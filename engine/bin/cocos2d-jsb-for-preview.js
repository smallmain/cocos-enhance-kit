(function outer(modules, cache, entry) {
  function newRequire(name, jumped) {
    var module = cache[name];
    if (!module) {
      var moduleData = modules[name];
      if (!moduleData) return;
      var exports = {};
      module = cache[name] = {
        exports: exports
      };
      moduleData[0]((function(x) {
        return newRequire(moduleData[1][x] || x);
      }), module, exports);
    }
    return module.exports;
  }
  for (var i = 0; i < entry.length; i++) newRequire(entry[i]);
  return newRequire;
})({
  1: [ (function(require, module, exports) {
    module.exports = {
      1001: "cocos2d: removeAction: Target not found",
      1002: "cc.ActionManager.removeActionByTag(): an invalid tag",
      1003: "cc.ActionManager.removeActionByTag(): target must be non-null",
      1004: "cc.ActionManager.getActionByTag(): an invalid tag",
      1005: "cocos2d : getActionByTag(tag = %s): Action not found",
      1006: "[Action step]. override me",
      1007: "[Action update]. override me",
      1008: "cocos2d: FiniteTimeAction#reverse: Implement me",
      1009: "cc.EaseElastic.reverse(): it should be overridden in subclass.",
      1010: "cc.IntervalAction: reverse not implemented.",
      1011: "cc.ActionInterval.setAmplitudeRate(): it should be overridden in subclass.",
      1012: "cc.ActionInterval.getAmplitudeRate(): it should be overridden in subclass.",
      1013: "The speed parameter error",
      1014: "The repeat parameter error",
      1015: "parameters should not be ending with null in Javascript",
      1016: "cc.RotateTo.reverse(): it should be overridden in subclass.",
      1019: "Failed to construct, Sequence construction needs two or more actions.",
      1020: "Failed to construct, Spawn construction needs two or more actions.",
      1021: "cc.Speed.initWithAction(): action must be non nil",
      1022: "cc.Follow.initWithAction(): followedNode must be non nil",
      1023: "cc.ActionEase.initWithAction(): action must be non nil",
      1024: "Invalid configuration. It must at least have one control point",
      1025: "cc.Sequence.initWithTwoActions(): arguments must all be non nil",
      1026: "cc.RepeatForever.initWithAction(): action must be non null",
      1027: "cc.Spawn.initWithTwoActions(): arguments must all be non null",
      1028: "cc.ReverseTime.initWithAction(): action must be non null",
      1029: "cc.ReverseTime.initWithAction(): the action was already passed in.",
      1030: "cc.Animate.initWithAnimation(): animation must be non-NULL",
      1031: "Illegal parameter get passed in cc.tween: %s.",
      1100: "Expected 'data' dict, but not found. Config file: %s",
      1101: "Please load the resource first : %s",
      1200: "cocos2d: Director: Error in gettimeofday",
      1201: "cocos2d: Director: unrecognized projection",
      1203: "cocos2d: Director: Error in gettimeofday",
      1204: "running scene should not null",
      1205: "the scene should not null",
      1206: "loadScene: The scene index to load (%s) is out of range.",
      1207: "loadScene: Unknown name type to load: '%s'",
      1208: "loadScene: Failed to load scene '%s' because '%s' is already being loaded.",
      1209: "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      1210: "Failed to preload '%s', %s",
      1211: "loadScene: The scene index to load (%s) is out of range.",
      1212: "loadScene: Unknown name type to load: '%s'",
      1213: "loadScene: Failed to load scene '%s' because '%s' is already loading",
      1214: "loadScene: Can not load the scene '%s' because it was not in the build settings before playing.",
      1215: "Failed to preload '%s', %s",
      1216: "Director.runSceneImmediate: scene is not valid",
      1300: "element type is wrong!",
      1400: "'%s' is deprecated, please use '%s' instead.",
      1404: "cc.spriteFrameCache is removed, please use cc.loader to load and cache sprite frames of atlas format.",
      1405: "The '%s' has been removed, please use '%s' instead.",
      1406: "'%s.%s' is removed",
      1408: "'%s' is not support in the '%s', please use '%s' instead.",
      1502: "cc.scheduler.scheduleCallbackForTarget(): target should be non-null.",
      1503: "cc.Scheduler.pauseTarget():target should be non-null",
      1504: "cc.Scheduler.resumeTarget():target should be non-null",
      1505: "cc.Scheduler.isTargetPaused():target should be non-null",
      1506: "warning: you CANNOT change update priority in scheduled function",
      1507: 'CCScheduler#scheduleSelector. Selector already scheduled. Updating interval from: %s to %s"',
      1508: "Argument callback must not be empty",
      1509: "Argument target must be non-nullptr",
      1510: "cc.Scheduler: Illegal target which doesn't have uuid or instanceId.",
      1511: "cc.Scheduler: pause state of the scheduled task doesn't match the element pause state in Scheduler, the given paused state will be ignored.",
      1513: "cc.Scheduler: scheduler stopped using `__instanceId` as id since v2.0, you should do scheduler.enableForTarget(target) before all scheduler API usage on target",
      1605: "child already added. It can't be added again",
      1606: "child must be non-null",
      1610: "cocos2d: removeChildByTag(tag = %s): child not found!",
      1612: "cc.Node.stopActionBy(): argument tag an invalid tag",
      1613: "cc.Node.getActionByTag(): argument tag is an invalid tag",
      1617: "child must be non-null",
      1618: "cc.Node.runAction(): action must be non-null",
      1619: "callback function must be non-null",
      1620: "interval must be positive",
      1623: "Set '%s' to normal node (not persist root node).",
      1624: "Replacing with the same sgNode",
      1625: "The replacement sgNode should not contain any child.",
      1626: "Should not set alpha via 'color', set 'opacity' please.",
      1627: "Not support for asynchronous creating node in SG",
      1632: "Node name can not include '/'.",
      1633: "Internal error, should not remove unknown node from parent.",
      1634: "addChild: The child to add must be instance of cc.Node, not %s.",
      1635: "reorderChild: this child is not in children list.",
      1636: "Node's zIndex value can't be greater than cc.macro.MAX_ZINDEX, setting to the maximum value",
      1637: "Node's zIndex value can't be smaller than cc.macro.MIN_ZINDEX, setting to the minimum value",
      1638: "Private node's zIndex can't be set, it will keep cc.macro.MIN_ZINDEX as its value",
      1639: "cc.Action is deprecated, please use cc.Tween instead",
      1800: "cc._EventListenerKeyboard.checkAvailable(): Invalid EventListenerKeyboard!",
      1801: "cc._EventListenerTouchOneByOne.checkAvailable(): Invalid EventListenerTouchOneByOne!",
      1802: "cc._EventListenerTouchAllAtOnce.checkAvailable(): Invalid EventListenerTouchAllAtOnce!",
      1803: "cc._EventListenerAcceleration.checkAvailable(): _onAccelerationEvent must be non-nil",
      1900: "Invalid parameter.",
      2e3: "Don't call this method if the event is for touch.",
      2200: "Design resolution not valid",
      2201: "should set resolutionPolicy",
      2300: "The touches is more than MAX_TOUCHES, nUnusedIndex = %s",
      2400: "WebGL error %s",
      2602: "cc.Sprite.setDisplayFrameWithAnimationName(): Frame not found",
      2603: "cc.Sprite.setDisplayFrameWithAnimationName(): Invalid frame index",
      2606: "cc.Sprite.initWithSpriteFrame(): spriteFrame should be non-null",
      2607: "cc.Sprite.initWithSpriteFrameName(): spriteFrameName should be non-null",
      2608: "%s is null, please check.",
      2609: "cc.Sprite.initWithFile(): filename should be non-null",
      2610: "cc.Sprite.setDisplayFrameWithAnimationName(): animationName must be non-null",
      2614: "cc.Sprite.addChild(): child should be non-null",
      2616: "cc.SpriteBatchNode.updateQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
      2617: "cc.SpriteBatchNode.insertQuadFromSprite(): cc.SpriteBatchNode only supports cc.Sprites as children",
      2618: "cc.SpriteBatchNode.addChild(): cc.SpriteBatchNode only supports cc.Sprites as children",
      2619: "cc.SpriteBatchNode.addChild(): cc.Sprite is not using the same texture",
      2623: "cc.SpriteBatchNode.updateQuadFromSprite(): sprite should be non-null",
      2625: "too many tiles, only 16384 tiles will be show",
      2626: "Unrecognized fill type in bar fill",
      2627: "Can not generate quad",
      2628: "%s does not exist",
      2712: "Invalid spriteFrameName",
      3005: "cocos2d: '%s' id=%s %s x %s",
      3006: "cocos2d: '%s' id= HTMLCanvasElement %s x %s",
      3007: "cocos2d: TextureCache dumpDebugInfo: %s textures, HTMLCanvasElement for %s KB (%s MB)",
      3103: "cc.Texture.addImage(): path should be non-null",
      3112: "cc.Texture.addImage(): path should be non-null",
      3113: "NSInternalInconsistencyException",
      3116: "WebGLRenderingContext.CLAMP_TO_EDGE should be used in NPOT textures",
      3117: "Mimpap texture only works in POT textures",
      3119: "Lazy init texture with image element failed due to image loading failure: %s",
      3120: "Loading texture with unsupported type: '%s'. Add '%s' into 'cc.macro.SUPPORT_TEXTURE_FORMATS' please.",
      3121: "Can't find a texture format supported by the current platform! Please add a fallback format in the editor.",
      3300: "Rect width exceeds maximum margin: %s",
      3400: "Rect height exceeds maximum margin: %s",
      3401: "Set texture with a url of image is not supported anymore. Please use cc.assetManager.loadRemote to load a texture first.",
      3500: "0 priority is forbidden for fixed priority since it's used for scene graph based priority.",
      3501: "Invalid listener type!",
      3502: "Can't set fixed priority with scene graph based listener.",
      3503: "Invalid parameters.",
      3504: "listener must be a cc.EventListener object when adding a fixed priority listener",
      3505: "The listener has been registered, please don't register it again.",
      3506: "Unsupported listener target.",
      3507: "Invalid scene graph priority!",
      3508: "If program goes here, there should be event in dispatch.",
      3509: "_inDispatch should be 1 here.",
      3510: "%s's scene graph node not contains in the parent's children",
      3511: "event is undefined",
      3600: "cc.Class will automatically call super constructor of %s, you should not call it manually.",
      3601: "The editor property 'playOnFocus' should be used with 'executeInEditMode' in class '%s'",
      3602: "Unknown editor property '%s' in class '%s'.",
      3603: "Use 'cc.Float' or 'cc.Integer' instead of 'cc.Number' please.",
      3604: "Can only indicate one type attribute for %s.",
      3605: "The default value of %s is not instance of %s.",
      3606: "No needs to indicate the '%s' attribute for %s, which its default value is type of %s.",
      3607: "The default value of %s must be an empty string.",
      3608: "The type of %s must be cc.String, not String.",
      3609: "The type of %s must be cc.Boolean, not Boolean.",
      3610: "The type of %s must be cc.Float or cc.Integer, not Number.",
      3611: "Can not indicate the '%s' attribute for %s, which its default value is type of %s.",
      3612: "%s Just set the default value to 'new %s()' and it will be handled properly.",
      3613: "'No need to use 'serializable: false' or 'editorOnly: true' for the getter of '%s.%s', every getter is actually non-serialized.",
      3614: "Should not define constructor for cc.Component %s.",
      3615: "Each script can have at most one Component.",
      3616: "Should not specify class name %s for Component which defines in project.",
      3617: "Can not instantiate CCClass '%s' with arguments.",
      3618: "ctor of '%s' can not be another CCClass",
      3619: "ctor of '%s' must be function type",
      3620: "this._super declared in '%s.%s' but no super method defined",
      3621: "Unknown type of %s.%s, maybe you want is '%s'.",
      3622: "Unknown type of %s.%s, property should be defined in 'properties' or 'ctor'",
      3623: "Can not use 'editor' attribute, '%s' not inherits from Components.",
      3624: "'%s' overrided '%s' but '%s' is defined as 'false' so the super method will not be called. You can set '%s' to null to disable this warning.",
      3625: "[isChildClassOf] superclass should be function type, not",
      3626: "Can't remove '%s' because '%s' depends on it.",
      3627: "Should not add renderer component (%s) to a Canvas node.",
      3628: "Should not add %s to a node which size is already used by its other component.",
      3633: "Properties function of '%s' should return an object!",
      3634: "Disallow to use '.' in property name",
      3635: "Default array must be empty, set default value of %s.%s to [], and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = [...];')",
      3636: "Do not set default value to non-empty object, unless the object defines its own 'clone' function. Set default value of %s.%s to null or {}, and initialize in 'onLoad' or 'ctor' please. (just like 'this.%s = {foo: bar};')",
      3637: "Can not declare %s.%s, it is already defined in the prototype of %s",
      3638: "'%s': the getter of '%s' is already defined!",
      3639: "Can not apply the specified attribute to the getter of '%s.%s', attribute index: %s",
      3640: "'%s': the setter of '%s' is already defined!",
      3641: "Can not construct %s because it contains object property.",
      3642: "Cannot define %s.%s because static member name can not be '%s'.",
      3643: "Can not define a member called 'constructor' in the class '%s', please use 'ctor' instead.",
      3644: "Please define 'type' parameter of %s.%s as the actual constructor.",
      3645: "Please define 'type' parameter of %s.%s as the constructor of %s.",
      3646: "Unknown 'type' parameter of %s.%s\uff1a%s",
      3647: "The length of range array must be equal or greater than 2",
      3648: "Can not declare %s.%s method, it is already defined in the properties of %s.",
      3649: "CCClass %s have conflict between its ctor and __ctor__.",
      3651: 'Can not call `_super` or `prototype.ctor` in ES6 Classes "%s", use `super` instead please.',
      3652: "Failed to `new %s()` under the hood, %s\nIt is used for getting default values declared in TypeScript in the first place.\nPlease ensure the constructor can be called during the script's initialization.",
      3653: 'Please do not specifiy "default" attribute in decorator of "%s" property in "%s" class.  \nDefault value must be initialized at their declaration:\n \n// Before:\n@property({\n  type: cc.SpriteFrame\n  default: null  // <--\n})\nmyProp;\n// After:\n@property({\n  type: cc.SpriteFrame\n})\nmyProp = null;   // <--',
      3654: 'Please specifiy a default value for "%s.%s" at its declaration:\n \n// Before:\n@property(...)\nmyProp;\n// After:\n@property(...)\nmyProp = 0;',
      3655: 'Can not specifiy "get" or "set"  attribute in decorator for "%s" property in "%s" class.  \nPlease use:\n \n@property(...)\nget %s () {\n    ...\n}\n@property\nset %s (value) {\n    ...\n}',
      3700: "internal error: _prefab is undefined",
      3701: "Failed to load prefab asset for node '%s'",
      3800: "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      3801: "The node can not be made persist because it's not under root node.",
      3802: "The node can not be made persist because it's not in current scene.",
      3803: "The target can not be made persist because it's not a cc.Node or it doesn't have _id property.",
      3804: "getComponent: Type must be non-nil",
      3805: "Can't add component '%s' because %s already contains the same component.",
      3806: "Can't add component '%s' to %s because it conflicts with the existing '%s' derived component.",
      3807: "addComponent: Failed to get class '%s'",
      3808: "addComponent: Should not add component ('%s') when the scripts are still loading.",
      3809: "addComponent: The component to add must be a constructor",
      3810: "addComponent: The component to add must be child class of cc.Component",
      3811: "_addComponentAt: The component to add must be a constructor",
      3812: "_addComponentAt: Index out of range",
      3813: "removeComponent: Component must be non-nil",
      3814: "Argument must be non-nil",
      3815: "Component not owned by this entity",
      3816: "Node '%s' is already activating",
      3817: "Sorry, the component of '%s' which with an index of %s is corrupted! It has been removed.",
      3818: "Failed to read or parse project.json",
      3819: "Warning: target element is not a DIV or CANVAS",
      3820: "The renderer doesn't support the renderMode %s",
      3821: "Cannot change hierarchy while activating or deactivating the parent.",
      3900: "Invalid clip to add",
      3901: "Invalid clip to remove",
      3902: "clip is defaultClip, set force to true to force remove clip and animation state",
      3903: "animation state is playing, set force to true to force stop and remove clip and animation state",
      3904: "motion path of target [%s] in prop [%s] frame [%s] is not valid",
      3905: "sprite frames must be an Array.",
      3906: "Can't find easing type [%s]",
      3907: "animator not added or already removed",
      3912: "already-playing",
      4003: "Label font size can't be shirnked less than 0!",
      4004: "force notify all fonts loaded!",
      4011: "Property spriteFrame of Font '%s' is invalid. Using system font instead.",
      4012: "The texture of Font '%s' must be already loaded on JSB. Using system font instead.",
      4013: "Sorry, lineHeight of system font not supported on JSB.",
      4200: "MaskType: IMAGE_STENCIL only support WebGL mode.",
      4201: "The alphaThreshold invalid in Canvas Mode.",
      4202: "The inverted invalid in Canvas Mode.",
      4300: "can not found the %s page.",
      4400: "Invalid RichText img tag! The sprite frame name can't be found in the ImageAtlas!",
      4600: "Script attached to '%s' is missing or invalid.",
      4700: "The dom control is not created!",
      4800: "unknown asset type",
      4901: "loadRes: should not specify the extname in %s %s",
      4902: "No need to release non-cached asset.",
      4914: "Resources url '%s' does not exist.",
      4915: "Pack indices and data do not match in size",
      4916: "Failed to download package for %s",
      4921: "Invalid pipe or invalid index provided!",
      4922: "The pipe to be inserted is already in the pipeline!",
      4923: "Uuid Loader: Parse asset [ %s ] failed : %s",
      4924: "JSON Loader: Input item doesn't contain string content",
      4925: "Uuid Loader: Deserialize asset [ %s ] failed : %s",
      4926: "Audio Downloader: no web audio context.",
      4927: "Audio Downloader: audio not supported on this browser!",
      4928: "Load %s failed!",
      4929: "Load Webp ( %s ) failed",
      4930: "Load image ( %s ) failed",
      4932: 'Since v1.10, for any atlas ("%s") in the "resources" directory, it is not possible to find the contained SpriteFrames via `loadRes`, `getRes` or `releaseRes`. Load the SpriteAtlas first and then use `spriteAtlas.getSpriteFrame(name)` instead please.',
      4933: "Download Font [ %s ] failed, using Arial or system default font instead",
      5e3: "object already destroyed",
      5001: "object not yet destroyed",
      5100: "Not a plist file!",
      5200: "Warning: localStorage isn't enabled. Please confirm browser cookie or privacy option",
      5201: "browser don't support web audio",
      5202: "This feature supports WebGL render mode only.",
      5300: "Type of target to deserialize not matched with data: target is %s, data is %s",
      5301: "Can not find script '%s'",
      5302: "Can not find class '%s'",
      5303: "Failed to deserialize %s, missing _deserialize function.",
      5304: "Unable to deserialize version %s data.",
      5402: "cc.js.addon called on non-object:",
      5403: "cc.js.mixin: arguments must be type object:",
      5404: "The base class to extend from must be non-nil",
      5405: "The class to extend must be non-nil",
      5406: "Class should be extended before assigning any prototype members.",
      5500: "'notify' can not be used in 'get/set' !",
      5501: "'notify' must be used with 'default' !",
      5507: "The 'default' attribute of '%s.%s' must be an array",
      5508: "Invalid type of %s.%s",
      5510: "The 'type' attribute of '%s.%s' can not be 'Number', use cc.Float or cc.Integer instead please.",
      5511: "The 'type' attribute of '%s.%s' is undefined when loading script",
      5512: "Can not serialize '%s.%s' because the specified type is anonymous, please provide a class name or set the 'serializable' attribute of '%s.%s' to 'false'.",
      5513: "The 'default' value of '%s.%s' should not be used with a 'get' function.",
      5514: "The 'default' value of '%s.%s' should not be used with a 'set' function.",
      5515: "The 'default' value of '%s.%s' can not be an constructor. Set default to null please.",
      5516: "Property '%s.%s' must define at least one of 'default', 'get' or 'set'.",
      5517: "'%s.%s' hides inherited property '%s.%s'. To make the current property override that implementation, add the `override: true` attribute please.",
      5601: "Can not get current scene.",
      5602: "Scene is destroyed",
      5603: "reference node is destroyed",
      5700: "no %s or %s on %s",
      5800: "%s.lerp not yet implemented.",
      5801: "%s.clone not yet implemented.",
      5802: "%s.equals not yet implemented.",
      5900: "MotionStreak only support WebGL mode.",
      5901: "cc.MotionStreak.getOpacity has not been supported.",
      5902: "cc.MotionStreak.setOpacity has not been supported.",
      6e3: "Custom should not be false if file is not specified.",
      6001: "The new %s must not be NaN",
      6017: "Incomplete or corrupt PNG file",
      6018: "Invalid filter algorithm: %s",
      6019: "Invalid byte order value.",
      6020: "You forgot your towel!",
      6021: "Unknown Field Tag: %s",
      6022: "Too many bits requested",
      6023: "No bits requested",
      6024: "Cannot recover from missing StripByteCounts",
      6025: "Cannot handle sub-byte bits per sample",
      6026: "Cannot handle sub-byte bits per pixel",
      6027: "Palette image missing color map",
      6028: "Unknown Photometric Interpretation: %s",
      6029: "Unkown error",
      6030: "cc.ParticleSystem: error decoding or ungzipping textureImageData in plist '%s'",
      6031: "cc.ParticleSystem: unknown image format with Data in plist %s",
      6032: "cc.ParticleSystem.initWithDictionary() : error loading the texture in plist '%s'",
      6400: "asset.url is not usable in core process",
      6402: "AssetLibrary has already been initialized!",
      6500: "Widget target must be one of the parent nodes of it",
      6600: "collider not added or already removed",
      6601: "Can't find testFunc for (%s, $s).",
      6700: "Can't init canvas '%s' because it conflicts with the existing '%s', the scene should only have one active canvas at the same time.",
      6800: "Callback of event must be non-nil",
      6801: "The message must be provided",
      6900: "The thing you want to instantiate must be an object",
      6901: "The thing you want to instantiate is nil",
      6902: "The thing you want to instantiate is destroyed",
      6903: "The instantiate method for given asset do not implemented",
      6904: "Can not instantiate array",
      6905: "Can not instantiate DOM element",
      7100: "%s already defined in Enum.",
      7101: "Sorry, 'cc.Enum' not available on this platform, please report this error here: https://github.com/cocos-creator/engine/issues/new",
      7200: "Method 'initWithTMXFile' is no effect now, please set property 'tmxAsset' instead.",
      7201: "Method 'initWithXML' is no effect now, please set property 'tmxAsset' instead.",
      7202: "Add component TiledLayer into node failed.",
      7203: "Property 'mapLoaded' is unused now. Please write the logic to the callback 'start'.",
      7210: "TMX Hexa zOrder not supported",
      7211: "TMX invalid value",
      7215: "cocos2d: Warning: TMX Layer %s has no tiles",
      7216: "cocos2d: TMXFormat: Unsupported TMX version: %s",
      7217: "cocos2d: TMXFomat: Unsupported orientation: %s",
      7218: "cc.TMXMapInfo.parseXMLFile(): unsupported compression method",
      7219: "cc.TMXMapInfo.parseXMLFile(): Only base64 and/or gzip/zlib maps are supported",
      7221: "cc.TMXMapInfo.parseXMLFile(): Texture '%s' not found.",
      7222: "Parse %s failed.",
      7236: "cc.TMXLayer.getTileAt(): TMXLayer: the tiles map has been released",
      7237: "cc.TMXLayer.getTileGIDAt(): TMXLayer: the tiles map has been released",
      7238: "cc.TMXLayer.setTileGID(): TMXLayer: the tiles map has been released",
      7239: "cc.TMXLayer.setTileGID(): invalid gid: %s",
      7240: "cc.TMXLayer.getTileFlagsAt(): TMXLayer: the tiles map has been released",
      7241: "cc.TiledMap.initWithXML(): Map not found. Please check the filename.",
      7401: "Failed to set _defaultArmatureIndex for '%s' because the index is out of range.",
      7402: "Failed to set _animationIndex for '%s' because the index is out of range.",
      7501: "Failed to set _defaultSkinIndex for '%s' because the index is out of range.",
      7502: "Failed to set _animationIndex for '%s' because its skeletonData is invalid.",
      7503: "Failed to set _animationIndex for '%s' because the index is out of range.",
      7504: "Can not render dynamic created SkeletonData",
      7506: "Failed to load spine atlas '$s'",
      7507: "Please re-import '%s' because its textures is not initialized! (This workflow will be improved in the future.)",
      7508: "The atlas asset of '%s' is not exists!",
      7509: "Spine: Animation not found: %s",
      7510: "Spine: Animation not found: %s",
      7600: "The context of RenderTexture is invalid.",
      7601: "cc.RenderTexture._initWithWidthAndHeightForWebGL() : only RGB and RGBA formats are valid for a render texture;",
      7602: "Could not attach texture to the framebuffer",
      7603: "clearDepth isn't supported on Cocos2d-Html5",
      7604: "saveToFile isn't supported on Cocos2d-Html5",
      7605: "newCCImage isn't supported on Cocos2d-Html5",
      7700: "On the web is always keep the aspect ratio",
      7701: "Can't know status",
      7702: "Video player's duration is not ready to get now!",
      7800: "Web does not support loading",
      7801: "Web does not support query history",
      7802: "Web does not support query history",
      7803: "The current browser does not support the GoBack",
      7804: "The current browser does not support the GoForward",
      7805: "Web does not support zoom",
      7900: "cc.math.Matrix3.assign(): current matrix equals matIn",
      7901: "cc.math.mat4Assign(): pOut equals pIn",
      7902: "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      7903: "cc.math.Matrix4 equal: pMat1 and pMat2 are same object.",
      7904: "cc.math.Matrix4.extractPlane: Invalid plane index",
      7905: "cc.math.mat4Assign(): pOut equals pIn",
      7906: "cc.mat.Matrix4.assignFrom(): mat4 equals current matrix",
      7907: "cc.math.Matrix4 equals: pMat1 and pMat2 are same object.",
      7908: "Invalid matrix mode specified",
      7909: "current quaternion is an invalid value",
      8e3: "Can't handle this field type or size",
      8001: "No bytes requested",
      8002: "Too many bytes requested",
      8003: "Missing StripByteCounts!",
      8103: "cc.GLProgram.link(): Cannot link invalid program",
      8104: "cocos2d: ERROR: Failed to link program: %s",
      8105: "cocos2d: cc.shaderCache._loadDefaultShader, error shader type",
      8106: "Please load the resource firset : %s",
      8107: "cc.GLProgram.getUniformLocationForName(): uniform name should be non-null",
      8108: "cc.GLProgram.getUniformLocationForName(): Invalid operation. Cannot get uniform location when program is not initialized",
      8109: "modelView matrix is undefined.",
      8200: "Please set node's active instead of rigidbody's enabled.",
      8300: "Should only one camera exists, please check your project.",
      8301: "Camera does not support Canvas Mode.",
      8400: "Wrong type arguments, 'filePath' must be a String.",
      8401: "Since 1.10, `%s` accept %s instance directly, not a URL string. Please directly reference the %s object in your script, or load %s by loader first. Don't use %s's URL anymore.",
      9e3: "Stencil manager does not support level bigger than %d in this device.",
      9001: "Stencil manager is already empty, cannot pop any mask.",
      9100: "LabelAtlas '%s' cannot be loaded, raw texture does not exist.",
      9101: "LabelAtlas '%s' cannot be loaded, fnt data does not exist.",
      9102: "Program not support highp precision, will change to mediump.",
      9103: "%s : Failed to set property [%s], property not found.",
      9104: "%s : Failed to define [%s], define not found.",
      9105: "%s : Failed to set property [%s], property length not correct.",
      9106: "%s : Set property [%s] warning : should transform object to ArrayBuffer.",
      9107: "%s : illegal property: [%s], myabe defined an unused property;",
      9200: "cc.view.enableAntiAlias is deprecated, please use cc.Texture2D.setFilters instead",
      "0100": "%s not yet implemented."
    };
  }), {} ],
  2: [ (function(require, module, exports) {
    "use strict";
    require("../core/platform/CCClass");
    var misc = require("../core/utils/misc");
    cc.Action = cc.Class({
      name: "cc.Action",
      ctor: function ctor() {
        this.originalTarget = null;
        this.target = null;
        this.tag = cc.Action.TAG_INVALID;
      },
      clone: function clone() {
        var action = new cc.Action();
        action.originalTarget = null;
        action.target = null;
        action.tag = this.tag;
        return action;
      },
      isDone: function isDone() {
        return true;
      },
      startWithTarget: function startWithTarget(target) {
        this.originalTarget = target;
        this.target = target;
      },
      stop: function stop() {
        this.target = null;
      },
      step: function step(dt) {
        cc.logID(1006);
      },
      update: function update(dt) {
        cc.logID(1007);
      },
      getTarget: function getTarget() {
        return this.target;
      },
      setTarget: function setTarget(target) {
        this.target = target;
      },
      getOriginalTarget: function getOriginalTarget() {
        return this.originalTarget;
      },
      setOriginalTarget: function setOriginalTarget(originalTarget) {
        this.originalTarget = originalTarget;
      },
      getTag: function getTag() {
        return this.tag;
      },
      setTag: function setTag(tag) {
        this.tag = tag;
      },
      retain: function retain() {},
      release: function release() {}
    });
    cc.Action.TAG_INVALID = -1;
    cc.FiniteTimeAction = cc.Class({
      name: "cc.FiniteTimeAction",
      extends: cc.Action,
      ctor: function ctor() {
        this._duration = 0;
      },
      getDuration: function getDuration() {
        return this._duration * (this._timesForRepeat || 1);
      },
      setDuration: function setDuration(duration) {
        this._duration = duration;
      },
      reverse: function reverse() {
        cc.logID(1008);
        return null;
      },
      clone: function clone() {
        return new cc.FiniteTimeAction();
      }
    });
    cc.Speed = cc.Class({
      name: "cc.Speed",
      extends: cc.Action,
      ctor: function ctor(action, speed) {
        this._speed = 0;
        this._innerAction = null;
        action && this.initWithAction(action, speed);
      },
      getSpeed: function getSpeed() {
        return this._speed;
      },
      setSpeed: function setSpeed(speed) {
        this._speed = speed;
      },
      initWithAction: function initWithAction(action, speed) {
        if (!action) {
          cc.errorID(1021);
          return false;
        }
        this._innerAction = action;
        this._speed = speed;
        return true;
      },
      clone: function clone() {
        var action = new cc.Speed();
        action.initWithAction(this._innerAction.clone(), this._speed);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.Action.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
      },
      stop: function stop() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
      },
      step: function step(dt) {
        this._innerAction.step(dt * this._speed);
      },
      isDone: function isDone() {
        return this._innerAction.isDone();
      },
      reverse: function reverse() {
        return new cc.Speed(this._innerAction.reverse(), this._speed);
      },
      setInnerAction: function setInnerAction(action) {
        this._innerAction !== action && (this._innerAction = action);
      },
      getInnerAction: function getInnerAction() {
        return this._innerAction;
      }
    });
    cc.speed = function(action, speed) {
      return new cc.Speed(action, speed);
    };
    cc.Follow = cc.Class({
      name: "cc.Follow",
      extends: cc.Action,
      ctor: function ctor(followedNode, rect) {
        this._followedNode = null;
        this._boundarySet = false;
        this._boundaryFullyCovered = false;
        this._halfScreenSize = null;
        this._fullScreenSize = null;
        this.leftBoundary = 0;
        this.rightBoundary = 0;
        this.topBoundary = 0;
        this.bottomBoundary = 0;
        this._worldRect = cc.rect(0, 0, 0, 0);
        followedNode && (rect ? this.initWithTarget(followedNode, rect) : this.initWithTarget(followedNode));
      },
      clone: function clone() {
        var action = new cc.Follow();
        var locRect = this._worldRect;
        var rect = new cc.Rect(locRect.x, locRect.y, locRect.width, locRect.height);
        action.initWithTarget(this._followedNode, rect);
        return action;
      },
      isBoundarySet: function isBoundarySet() {
        return this._boundarySet;
      },
      setBoundarySet: function setBoundarySet(value) {
        this._boundarySet = value;
      },
      setBoudarySet: function setBoudarySet(value) {
        this.setBoundarySet(value);
      },
      initWithTarget: function initWithTarget(followedNode, rect) {
        if (!followedNode) {
          cc.errorID(1022);
          return false;
        }
        var _this = this;
        rect = rect || cc.rect(0, 0, 0, 0);
        _this._followedNode = followedNode;
        _this._worldRect = rect;
        _this._boundarySet = !(0 === rect.width && 0 === rect.height);
        _this._boundaryFullyCovered = false;
        var winSize = cc.winSize;
        _this._fullScreenSize = cc.v2(winSize.width, winSize.height);
        _this._halfScreenSize = _this._fullScreenSize.mul(.5);
        if (_this._boundarySet) {
          _this.leftBoundary = -(rect.x + rect.width - _this._fullScreenSize.x);
          _this.rightBoundary = -rect.x;
          _this.topBoundary = -rect.y;
          _this.bottomBoundary = -(rect.y + rect.height - _this._fullScreenSize.y);
          _this.rightBoundary < _this.leftBoundary && (_this.rightBoundary = _this.leftBoundary = (_this.leftBoundary + _this.rightBoundary) / 2);
          _this.topBoundary < _this.bottomBoundary && (_this.topBoundary = _this.bottomBoundary = (_this.topBoundary + _this.bottomBoundary) / 2);
          _this.topBoundary === _this.bottomBoundary && _this.leftBoundary === _this.rightBoundary && (_this._boundaryFullyCovered = true);
        }
        return true;
      },
      step: function step(dt) {
        var targetWorldPos = this.target.convertToWorldSpaceAR(cc.Vec2.ZERO);
        var followedWorldPos = this._followedNode.convertToWorldSpaceAR(cc.Vec2.ZERO);
        var delta = targetWorldPos.sub(followedWorldPos);
        var tempPos = this.target.parent.convertToNodeSpaceAR(delta.add(this._halfScreenSize));
        if (this._boundarySet) {
          if (this._boundaryFullyCovered) return;
          this.target.setPosition(misc.clampf(tempPos.x, this.leftBoundary, this.rightBoundary), misc.clampf(tempPos.y, this.bottomBoundary, this.topBoundary));
        } else this.target.setPosition(tempPos.x, tempPos.y);
      },
      isDone: function isDone() {
        return !this._followedNode.activeInHierarchy;
      },
      stop: function stop() {
        this.target = null;
        cc.Action.prototype.stop.call(this);
      }
    });
    cc.follow = function(followedNode, rect) {
      return new cc.Follow(followedNode, rect);
    };
  }), {
    "../core/platform/CCClass": 272,
    "../core/utils/misc": 386
  } ],
  3: [ (function(require, module, exports) {
    "use strict";
    function cardinalSplineAt(p0, p1, p2, p3, tension, t) {
      var t2 = t * t;
      var t3 = t2 * t;
      var s = (1 - tension) / 2;
      var b1 = s * (2 * t2 - t3 - t);
      var b2 = s * (-t3 + t2) + (2 * t3 - 3 * t2 + 1);
      var b3 = s * (t3 - 2 * t2 + t) + (-2 * t3 + 3 * t2);
      var b4 = s * (t3 - t2);
      var x = p0.x * b1 + p1.x * b2 + p2.x * b3 + p3.x * b4;
      var y = p0.y * b1 + p1.y * b2 + p2.y * b3 + p3.y * b4;
      return cc.v2(x, y);
    }
    function getControlPointAt(controlPoints, pos) {
      var p = Math.min(controlPoints.length - 1, Math.max(pos, 0));
      return controlPoints[p];
    }
    function reverseControlPoints(controlPoints) {
      var newArray = [];
      for (var i = controlPoints.length - 1; i >= 0; i--) newArray.push(cc.v2(controlPoints[i].x, controlPoints[i].y));
      return newArray;
    }
    function cloneControlPoints(controlPoints) {
      var newArray = [];
      for (var i = 0; i < controlPoints.length; i++) newArray.push(cc.v2(controlPoints[i].x, controlPoints[i].y));
      return newArray;
    }
    cc.CardinalSplineTo = cc.Class({
      name: "cc.CardinalSplineTo",
      extends: cc.ActionInterval,
      ctor: function ctor(duration, points, tension) {
        this._points = [];
        this._deltaT = 0;
        this._tension = 0;
        this._previousPosition = null;
        this._accumulatedDiff = null;
        void 0 !== tension && cc.CardinalSplineTo.prototype.initWithDuration.call(this, duration, points, tension);
      },
      initWithDuration: function initWithDuration(duration, points, tension) {
        if (!points || 0 === points.length) {
          cc.errorID(1024);
          return false;
        }
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this.setPoints(points);
          this._tension = tension;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.CardinalSplineTo();
        action.initWithDuration(this._duration, cloneControlPoints(this._points), this._tension);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._deltaT = 1 / (this._points.length - 1);
        this._previousPosition = cc.v2(this.target.x, this.target.y);
        this._accumulatedDiff = cc.v2(0, 0);
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        var p, lt;
        var ps = this._points;
        if (1 === dt) {
          p = ps.length - 1;
          lt = 1;
        } else {
          var locDT = this._deltaT;
          p = 0 | dt / locDT;
          lt = (dt - locDT * p) / locDT;
        }
        var newPos = cardinalSplineAt(getControlPointAt(ps, p - 1), getControlPointAt(ps, p - 0), getControlPointAt(ps, p + 1), getControlPointAt(ps, p + 2), this._tension, lt);
        if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
          var tempX, tempY;
          tempX = this.target.x - this._previousPosition.x;
          tempY = this.target.y - this._previousPosition.y;
          if (0 !== tempX || 0 !== tempY) {
            var locAccDiff = this._accumulatedDiff;
            tempX = locAccDiff.x + tempX;
            tempY = locAccDiff.y + tempY;
            locAccDiff.x = tempX;
            locAccDiff.y = tempY;
            newPos.x += tempX;
            newPos.y += tempY;
          }
        }
        this.updatePosition(newPos);
      },
      reverse: function reverse() {
        var reversePoints = reverseControlPoints(this._points);
        return cc.cardinalSplineTo(this._duration, reversePoints, this._tension);
      },
      updatePosition: function updatePosition(newPos) {
        this.target.setPosition(newPos);
        this._previousPosition = newPos;
      },
      getPoints: function getPoints() {
        return this._points;
      },
      setPoints: function setPoints(points) {
        this._points = points;
      }
    });
    cc.cardinalSplineTo = function(duration, points, tension) {
      return new cc.CardinalSplineTo(duration, points, tension);
    };
    cc.CardinalSplineBy = cc.Class({
      name: "cc.CardinalSplineBy",
      extends: cc.CardinalSplineTo,
      ctor: function ctor(duration, points, tension) {
        this._startPosition = cc.v2(0, 0);
        void 0 !== tension && this.initWithDuration(duration, points, tension);
      },
      startWithTarget: function startWithTarget(target) {
        cc.CardinalSplineTo.prototype.startWithTarget.call(this, target);
        this._startPosition.x = target.x;
        this._startPosition.y = target.y;
      },
      reverse: function reverse() {
        var copyConfig = this._points.slice();
        var current;
        var p = copyConfig[0];
        for (var i = 1; i < copyConfig.length; ++i) {
          current = copyConfig[i];
          copyConfig[i] = current.sub(p);
          p = current;
        }
        var reverseArray = reverseControlPoints(copyConfig);
        p = reverseArray[reverseArray.length - 1];
        reverseArray.pop();
        p.x = -p.x;
        p.y = -p.y;
        reverseArray.unshift(p);
        for (var i = 1; i < reverseArray.length; ++i) {
          current = reverseArray[i];
          current.x = -current.x;
          current.y = -current.y;
          current.x += p.x;
          current.y += p.y;
          reverseArray[i] = current;
          p = current;
        }
        return cc.cardinalSplineBy(this._duration, reverseArray, this._tension);
      },
      updatePosition: function updatePosition(newPos) {
        var pos = this._startPosition;
        var posX = newPos.x + pos.x;
        var posY = newPos.y + pos.y;
        this._previousPosition.x = posX;
        this._previousPosition.y = posY;
        this.target.setPosition(posX, posY);
      },
      clone: function clone() {
        var a = new cc.CardinalSplineBy();
        a.initWithDuration(this._duration, cloneControlPoints(this._points), this._tension);
        return a;
      }
    });
    cc.cardinalSplineBy = function(duration, points, tension) {
      return new cc.CardinalSplineBy(duration, points, tension);
    };
    cc.CatmullRomTo = cc.Class({
      name: "cc.CatmullRomTo",
      extends: cc.CardinalSplineTo,
      ctor: function ctor(dt, points) {
        points && this.initWithDuration(dt, points);
      },
      initWithDuration: function initWithDuration(dt, points) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, .5);
      },
      clone: function clone() {
        var action = new cc.CatmullRomTo();
        action.initWithDuration(this._duration, cloneControlPoints(this._points));
        return action;
      }
    });
    cc.catmullRomTo = function(dt, points) {
      return new cc.CatmullRomTo(dt, points);
    };
    cc.CatmullRomBy = cc.Class({
      name: "cc.CatmullRomBy",
      extends: cc.CardinalSplineBy,
      ctor: function ctor(dt, points) {
        points && this.initWithDuration(dt, points);
      },
      initWithDuration: function initWithDuration(dt, points) {
        return cc.CardinalSplineTo.prototype.initWithDuration.call(this, dt, points, .5);
      },
      clone: function clone() {
        var action = new cc.CatmullRomBy();
        action.initWithDuration(this._duration, cloneControlPoints(this._points));
        return action;
      }
    });
    cc.catmullRomBy = function(dt, points) {
      return new cc.CatmullRomBy(dt, points);
    };
  }), {} ],
  4: [ (function(require, module, exports) {
    "use strict";
    cc.easeIn = function(rate) {
      return {
        _rate: rate,
        easing: function easing(dt) {
          return Math.pow(dt, this._rate);
        },
        reverse: function reverse() {
          return cc.easeIn(1 / this._rate);
        }
      };
    };
    cc.easeOut = function(rate) {
      return {
        _rate: rate,
        easing: function easing(dt) {
          return Math.pow(dt, 1 / this._rate);
        },
        reverse: function reverse() {
          return cc.easeOut(1 / this._rate);
        }
      };
    };
    cc.easeInOut = function(rate) {
      return {
        _rate: rate,
        easing: function easing(dt) {
          dt *= 2;
          return dt < 1 ? .5 * Math.pow(dt, this._rate) : 1 - .5 * Math.pow(2 - dt, this._rate);
        },
        reverse: function reverse() {
          return cc.easeInOut(this._rate);
        }
      };
    };
    var _easeExponentialInObj = {
      easing: function easing(dt) {
        return 0 === dt ? 0 : Math.pow(2, 10 * (dt - 1));
      },
      reverse: function reverse() {
        return _easeExponentialOutObj;
      }
    };
    cc.easeExponentialIn = function() {
      return _easeExponentialInObj;
    };
    var _easeExponentialOutObj = {
      easing: function easing(dt) {
        return 1 === dt ? 1 : 1 - Math.pow(2, -10 * dt);
      },
      reverse: function reverse() {
        return _easeExponentialInObj;
      }
    };
    cc.easeExponentialOut = function() {
      return _easeExponentialOutObj;
    };
    var _easeExponentialInOutObj = {
      easing: function easing(dt) {
        if (1 !== dt && 0 !== dt) {
          dt *= 2;
          return dt < 1 ? .5 * Math.pow(2, 10 * (dt - 1)) : .5 * (2 - Math.pow(2, -10 * (dt - 1)));
        }
        return dt;
      },
      reverse: function reverse() {
        return _easeExponentialInOutObj;
      }
    };
    cc.easeExponentialInOut = function() {
      return _easeExponentialInOutObj;
    };
    var _easeSineInObj = {
      easing: function easing(dt) {
        return 0 === dt || 1 === dt ? dt : -1 * Math.cos(dt * Math.PI / 2) + 1;
      },
      reverse: function reverse() {
        return _easeSineOutObj;
      }
    };
    cc.easeSineIn = function() {
      return _easeSineInObj;
    };
    var _easeSineOutObj = {
      easing: function easing(dt) {
        return 0 === dt || 1 === dt ? dt : Math.sin(dt * Math.PI / 2);
      },
      reverse: function reverse() {
        return _easeSineInObj;
      }
    };
    cc.easeSineOut = function() {
      return _easeSineOutObj;
    };
    var _easeSineInOutObj = {
      easing: function easing(dt) {
        return 0 === dt || 1 === dt ? dt : -.5 * (Math.cos(Math.PI * dt) - 1);
      },
      reverse: function reverse() {
        return _easeSineInOutObj;
      }
    };
    cc.easeSineInOut = function() {
      return _easeSineInOutObj;
    };
    var _easeElasticInObj = {
      easing: function easing(dt) {
        if (0 === dt || 1 === dt) return dt;
        dt -= 1;
        return -Math.pow(2, 10 * dt) * Math.sin((dt - .075) * Math.PI * 2 / .3);
      },
      reverse: function reverse() {
        return _easeElasticOutObj;
      }
    };
    cc.easeElasticIn = function(period) {
      if (period && .3 !== period) return {
        _period: period,
        easing: function easing(dt) {
          if (0 === dt || 1 === dt) return dt;
          dt -= 1;
          return -Math.pow(2, 10 * dt) * Math.sin((dt - this._period / 4) * Math.PI * 2 / this._period);
        },
        reverse: function reverse() {
          return cc.easeElasticOut(this._period);
        }
      };
      return _easeElasticInObj;
    };
    var _easeElasticOutObj = {
      easing: function easing(dt) {
        return 0 === dt || 1 === dt ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - .075) * Math.PI * 2 / .3) + 1;
      },
      reverse: function reverse() {
        return _easeElasticInObj;
      }
    };
    cc.easeElasticOut = function(period) {
      if (period && .3 !== period) return {
        _period: period,
        easing: function easing(dt) {
          return 0 === dt || 1 === dt ? dt : Math.pow(2, -10 * dt) * Math.sin((dt - this._period / 4) * Math.PI * 2 / this._period) + 1;
        },
        reverse: function reverse() {
          return cc.easeElasticIn(this._period);
        }
      };
      return _easeElasticOutObj;
    };
    cc.easeElasticInOut = function(period) {
      period = period || .3;
      return {
        _period: period,
        easing: function easing(dt) {
          var newT = 0;
          var locPeriod = this._period;
          if (0 === dt || 1 === dt) newT = dt; else {
            dt *= 2;
            locPeriod || (locPeriod = this._period = .3 * 1.5);
            var s = locPeriod / 4;
            dt -= 1;
            newT = dt < 0 ? -.5 * Math.pow(2, 10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) : Math.pow(2, -10 * dt) * Math.sin((dt - s) * Math.PI * 2 / locPeriod) * .5 + 1;
          }
          return newT;
        },
        reverse: function reverse() {
          return cc.easeElasticInOut(this._period);
        }
      };
    };
    function _bounceTime(time1) {
      if (time1 < 1 / 2.75) return 7.5625 * time1 * time1;
      if (time1 < 2 / 2.75) {
        time1 -= 1.5 / 2.75;
        return 7.5625 * time1 * time1 + .75;
      }
      if (time1 < 2.5 / 2.75) {
        time1 -= 2.25 / 2.75;
        return 7.5625 * time1 * time1 + .9375;
      }
      time1 -= 2.625 / 2.75;
      return 7.5625 * time1 * time1 + .984375;
    }
    var _easeBounceInObj = {
      easing: function easing(dt) {
        return 1 - _bounceTime(1 - dt);
      },
      reverse: function reverse() {
        return _easeBounceOutObj;
      }
    };
    cc.easeBounceIn = function() {
      return _easeBounceInObj;
    };
    var _easeBounceOutObj = {
      easing: function easing(dt) {
        return _bounceTime(dt);
      },
      reverse: function reverse() {
        return _easeBounceInObj;
      }
    };
    cc.easeBounceOut = function() {
      return _easeBounceOutObj;
    };
    var _easeBounceInOutObj = {
      easing: function easing(time1) {
        var newT;
        if (time1 < .5) {
          time1 *= 2;
          newT = .5 * (1 - _bounceTime(1 - time1));
        } else newT = .5 * _bounceTime(2 * time1 - 1) + .5;
        return newT;
      },
      reverse: function reverse() {
        return _easeBounceInOutObj;
      }
    };
    cc.easeBounceInOut = function() {
      return _easeBounceInOutObj;
    };
    var _easeBackInObj = {
      easing: function easing(time1) {
        var overshoot = 1.70158;
        return 0 === time1 || 1 === time1 ? time1 : time1 * time1 * ((overshoot + 1) * time1 - overshoot);
      },
      reverse: function reverse() {
        return _easeBackOutObj;
      }
    };
    cc.easeBackIn = function() {
      return _easeBackInObj;
    };
    var _easeBackOutObj = {
      easing: function easing(time1) {
        if (0 === time1) return 0;
        var overshoot = 1.70158;
        time1 -= 1;
        return time1 * time1 * ((overshoot + 1) * time1 + overshoot) + 1;
      },
      reverse: function reverse() {
        return _easeBackInObj;
      }
    };
    cc.easeBackOut = function() {
      return _easeBackOutObj;
    };
    var _easeBackInOutObj = {
      easing: function easing(time1) {
        var overshoot = 2.5949095;
        time1 *= 2;
        if (time1 < 1) return time1 * time1 * ((overshoot + 1) * time1 - overshoot) / 2;
        time1 -= 2;
        return time1 * time1 * ((overshoot + 1) * time1 + overshoot) / 2 + 1;
      },
      reverse: function reverse() {
        return _easeBackInOutObj;
      }
    };
    cc.easeBackInOut = function() {
      return _easeBackInOutObj;
    };
    cc.easeBezierAction = function(a, b, c, d) {
      return {
        easing: function easing(t) {
          return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d;
        },
        reverse: function reverse() {
          return cc.easeBezierAction(d, c, b, a);
        }
      };
    };
    var _easeQuadraticActionIn = {
      easing: function easing(time) {
        return Math.pow(time, 2);
      },
      reverse: function reverse() {
        return _easeQuadraticActionIn;
      }
    };
    cc.easeQuadraticActionIn = function() {
      return _easeQuadraticActionIn;
    };
    var _easeQuadraticActionOut = {
      easing: function easing(time) {
        return -time * (time - 2);
      },
      reverse: function reverse() {
        return _easeQuadraticActionOut;
      }
    };
    cc.easeQuadraticActionOut = function() {
      return _easeQuadraticActionOut;
    };
    var _easeQuadraticActionInOut = {
      easing: function easing(time) {
        var resultTime = time;
        time *= 2;
        if (time < 1) resultTime = time * time * .5; else {
          --time;
          resultTime = -.5 * (time * (time - 2) - 1);
        }
        return resultTime;
      },
      reverse: function reverse() {
        return _easeQuadraticActionInOut;
      }
    };
    cc.easeQuadraticActionInOut = function() {
      return _easeQuadraticActionInOut;
    };
    var _easeQuarticActionIn = {
      easing: function easing(time) {
        return time * time * time * time;
      },
      reverse: function reverse() {
        return _easeQuarticActionIn;
      }
    };
    cc.easeQuarticActionIn = function() {
      return _easeQuarticActionIn;
    };
    var _easeQuarticActionOut = {
      easing: function easing(time) {
        time -= 1;
        return -(time * time * time * time - 1);
      },
      reverse: function reverse() {
        return _easeQuarticActionOut;
      }
    };
    cc.easeQuarticActionOut = function() {
      return _easeQuarticActionOut;
    };
    var _easeQuarticActionInOut = {
      easing: function easing(time) {
        time *= 2;
        if (time < 1) return .5 * time * time * time * time;
        time -= 2;
        return -.5 * (time * time * time * time - 2);
      },
      reverse: function reverse() {
        return _easeQuarticActionInOut;
      }
    };
    cc.easeQuarticActionInOut = function() {
      return _easeQuarticActionInOut;
    };
    var _easeQuinticActionIn = {
      easing: function easing(time) {
        return time * time * time * time * time;
      },
      reverse: function reverse() {
        return _easeQuinticActionIn;
      }
    };
    cc.easeQuinticActionIn = function() {
      return _easeQuinticActionIn;
    };
    var _easeQuinticActionOut = {
      easing: function easing(time) {
        time -= 1;
        return time * time * time * time * time + 1;
      },
      reverse: function reverse() {
        return _easeQuinticActionOut;
      }
    };
    cc.easeQuinticActionOut = function() {
      return _easeQuinticActionOut;
    };
    var _easeQuinticActionInOut = {
      easing: function easing(time) {
        time *= 2;
        if (time < 1) return .5 * time * time * time * time * time;
        time -= 2;
        return .5 * (time * time * time * time * time + 2);
      },
      reverse: function reverse() {
        return _easeQuinticActionInOut;
      }
    };
    cc.easeQuinticActionInOut = function() {
      return _easeQuinticActionInOut;
    };
    var _easeCircleActionIn = {
      easing: function easing(time) {
        return -1 * (Math.sqrt(1 - time * time) - 1);
      },
      reverse: function reverse() {
        return _easeCircleActionIn;
      }
    };
    cc.easeCircleActionIn = function() {
      return _easeCircleActionIn;
    };
    var _easeCircleActionOut = {
      easing: function easing(time) {
        time -= 1;
        return Math.sqrt(1 - time * time);
      },
      reverse: function reverse() {
        return _easeCircleActionOut;
      }
    };
    cc.easeCircleActionOut = function() {
      return _easeCircleActionOut;
    };
    var _easeCircleActionInOut = {
      easing: function easing(time) {
        time *= 2;
        if (time < 1) return -.5 * (Math.sqrt(1 - time * time) - 1);
        time -= 2;
        return .5 * (Math.sqrt(1 - time * time) + 1);
      },
      reverse: function reverse() {
        return _easeCircleActionInOut;
      }
    };
    cc.easeCircleActionInOut = function() {
      return _easeCircleActionInOut;
    };
    var _easeCubicActionIn = {
      easing: function easing(time) {
        return time * time * time;
      },
      reverse: function reverse() {
        return _easeCubicActionIn;
      }
    };
    cc.easeCubicActionIn = function() {
      return _easeCubicActionIn;
    };
    var _easeCubicActionOut = {
      easing: function easing(time) {
        time -= 1;
        return time * time * time + 1;
      },
      reverse: function reverse() {
        return _easeCubicActionOut;
      }
    };
    cc.easeCubicActionOut = function() {
      return _easeCubicActionOut;
    };
    var _easeCubicActionInOut = {
      easing: function easing(time) {
        time *= 2;
        if (time < 1) return .5 * time * time * time;
        time -= 2;
        return .5 * (time * time * time + 2);
      },
      reverse: function reverse() {
        return _easeCubicActionInOut;
      }
    };
    cc.easeCubicActionInOut = function() {
      return _easeCubicActionInOut;
    };
  }), {} ],
  5: [ (function(require, module, exports) {
    "use strict";
    cc.ActionInstant = cc.Class({
      name: "cc.ActionInstant",
      extends: cc.FiniteTimeAction,
      isDone: function isDone() {
        return true;
      },
      step: function step(dt) {
        this.update(1);
      },
      update: function update(dt) {},
      reverse: function reverse() {
        return this.clone();
      },
      clone: function clone() {
        return new cc.ActionInstant();
      }
    });
    cc.Show = cc.Class({
      name: "cc.Show",
      extends: cc.ActionInstant,
      update: function update(dt) {
        var _renderComps = this.target.getComponentsInChildren(cc.RenderComponent);
        for (var i = 0; i < _renderComps.length; ++i) {
          var render = _renderComps[i];
          render.enabled = true;
        }
      },
      reverse: function reverse() {
        return new cc.Hide();
      },
      clone: function clone() {
        return new cc.Show();
      }
    });
    cc.show = function() {
      return new cc.Show();
    };
    cc.Hide = cc.Class({
      name: "cc.Hide",
      extends: cc.ActionInstant,
      update: function update(dt) {
        var _renderComps = this.target.getComponentsInChildren(cc.RenderComponent);
        for (var i = 0; i < _renderComps.length; ++i) {
          var render = _renderComps[i];
          render.enabled = false;
        }
      },
      reverse: function reverse() {
        return new cc.Show();
      },
      clone: function clone() {
        return new cc.Hide();
      }
    });
    cc.hide = function() {
      return new cc.Hide();
    };
    cc.ToggleVisibility = cc.Class({
      name: "cc.ToggleVisibility",
      extends: cc.ActionInstant,
      update: function update(dt) {
        var _renderComps = this.target.getComponentsInChildren(cc.RenderComponent);
        for (var i = 0; i < _renderComps.length; ++i) {
          var render = _renderComps[i];
          render.enabled = !render.enabled;
        }
      },
      reverse: function reverse() {
        return new cc.ToggleVisibility();
      },
      clone: function clone() {
        return new cc.ToggleVisibility();
      }
    });
    cc.toggleVisibility = function() {
      return new cc.ToggleVisibility();
    };
    cc.RemoveSelf = cc.Class({
      name: "cc.RemoveSelf",
      extends: cc.ActionInstant,
      ctor: function ctor(isNeedCleanUp) {
        this._isNeedCleanUp = true;
        void 0 !== isNeedCleanUp && this.init(isNeedCleanUp);
      },
      update: function update(dt) {
        this.target.removeFromParent(this._isNeedCleanUp);
      },
      init: function init(isNeedCleanUp) {
        this._isNeedCleanUp = isNeedCleanUp;
        return true;
      },
      reverse: function reverse() {
        return new cc.RemoveSelf(this._isNeedCleanUp);
      },
      clone: function clone() {
        return new cc.RemoveSelf(this._isNeedCleanUp);
      }
    });
    cc.removeSelf = function(isNeedCleanUp) {
      return new cc.RemoveSelf(isNeedCleanUp);
    };
    cc.DestroySelf = cc.Class({
      name: "cc.DestroySelf",
      extends: cc.ActionInstant,
      update: function update() {
        this.target.destroy();
      },
      reverse: function reverse() {
        return new cc.DestroySelf();
      },
      clone: function clone() {
        return new cc.DestroySelf();
      }
    });
    cc.destroySelf = function() {
      return new cc.DestroySelf();
    };
    cc.FlipX = cc.Class({
      name: "cc.FlipX",
      extends: cc.ActionInstant,
      ctor: function ctor(flip) {
        this._flippedX = false;
        void 0 !== flip && this.initWithFlipX(flip);
      },
      initWithFlipX: function initWithFlipX(flip) {
        this._flippedX = flip;
        return true;
      },
      update: function update(dt) {
        this.target.scaleX = Math.abs(this.target.scaleX) * (this._flippedX ? -1 : 1);
      },
      reverse: function reverse() {
        return new cc.FlipX(!this._flippedX);
      },
      clone: function clone() {
        var action = new cc.FlipX();
        action.initWithFlipX(this._flippedX);
        return action;
      }
    });
    cc.flipX = function(flip) {
      return new cc.FlipX(flip);
    };
    cc.FlipY = cc.Class({
      name: "cc.FlipY",
      extends: cc.ActionInstant,
      ctor: function ctor(flip) {
        this._flippedY = false;
        void 0 !== flip && this.initWithFlipY(flip);
      },
      initWithFlipY: function initWithFlipY(flip) {
        this._flippedY = flip;
        return true;
      },
      update: function update(dt) {
        this.target.scaleY = Math.abs(this.target.scaleY) * (this._flippedY ? -1 : 1);
      },
      reverse: function reverse() {
        return new cc.FlipY(!this._flippedY);
      },
      clone: function clone() {
        var action = new cc.FlipY();
        action.initWithFlipY(this._flippedY);
        return action;
      }
    });
    cc.flipY = function(flip) {
      return new cc.FlipY(flip);
    };
    cc.Place = cc.Class({
      name: "cc.Place",
      extends: cc.ActionInstant,
      ctor: function ctor(pos, y) {
        this._x = 0;
        this._y = 0;
        if (void 0 !== pos) {
          if (void 0 !== pos.x) {
            y = pos.y;
            pos = pos.x;
          }
          this.initWithPosition(pos, y);
        }
      },
      initWithPosition: function initWithPosition(x, y) {
        this._x = x;
        this._y = y;
        return true;
      },
      update: function update(dt) {
        this.target.setPosition(this._x, this._y);
      },
      clone: function clone() {
        var action = new cc.Place();
        action.initWithPosition(this._x, this._y);
        return action;
      }
    });
    cc.place = function(pos, y) {
      return new cc.Place(pos, y);
    };
    cc.CallFunc = cc.Class({
      name: "cc.CallFunc",
      extends: cc.ActionInstant,
      ctor: function ctor(selector, selectorTarget, data) {
        this._selectorTarget = null;
        this._function = null;
        this._data = null;
        this.initWithFunction(selector, selectorTarget, data);
      },
      initWithFunction: function initWithFunction(selector, selectorTarget, data) {
        selector && (this._function = selector);
        selectorTarget && (this._selectorTarget = selectorTarget);
        void 0 !== data && (this._data = data);
        return true;
      },
      execute: function execute() {
        this._function && this._function.call(this._selectorTarget, this.target, this._data);
      },
      update: function update(dt) {
        this.execute();
      },
      getTargetCallback: function getTargetCallback() {
        return this._selectorTarget;
      },
      setTargetCallback: function setTargetCallback(sel) {
        if (sel !== this._selectorTarget) {
          this._selectorTarget && (this._selectorTarget = null);
          this._selectorTarget = sel;
        }
      },
      clone: function clone() {
        var action = new cc.CallFunc();
        action.initWithFunction(this._function, this._selectorTarget, this._data);
        return action;
      }
    });
    cc.callFunc = function(selector, selectorTarget, data) {
      return new cc.CallFunc(selector, selectorTarget, data);
    };
  }), {} ],
  6: [ (function(require, module, exports) {
    "use strict";
    cc.ActionInterval = cc.Class({
      name: "cc.ActionInterval",
      extends: cc.FiniteTimeAction,
      ctor: function ctor(d) {
        this.MAX_VALUE = 2;
        this._elapsed = 0;
        this._firstTick = false;
        this._easeList = null;
        this._speed = 1;
        this._timesForRepeat = 1;
        this._repeatForever = false;
        this._repeatMethod = false;
        this._speedMethod = false;
        void 0 !== d && cc.ActionInterval.prototype.initWithDuration.call(this, d);
      },
      getElapsed: function getElapsed() {
        return this._elapsed;
      },
      initWithDuration: function initWithDuration(d) {
        this._duration = 0 === d ? cc.macro.FLT_EPSILON : d;
        this._elapsed = 0;
        this._firstTick = true;
        return true;
      },
      isDone: function isDone() {
        return this._elapsed >= this._duration;
      },
      _cloneDecoration: function _cloneDecoration(action) {
        action._repeatForever = this._repeatForever;
        action._speed = this._speed;
        action._timesForRepeat = this._timesForRepeat;
        action._easeList = this._easeList;
        action._speedMethod = this._speedMethod;
        action._repeatMethod = this._repeatMethod;
      },
      _reverseEaseList: function _reverseEaseList(action) {
        if (this._easeList) {
          action._easeList = [];
          for (var i = 0; i < this._easeList.length; i++) action._easeList.push(this._easeList[i].reverse());
        }
      },
      clone: function clone() {
        var action = new cc.ActionInterval(this._duration);
        this._cloneDecoration(action);
        return action;
      },
      easing: function easing(easeObj) {
        this._easeList ? this._easeList.length = 0 : this._easeList = [];
        for (var i = 0; i < arguments.length; i++) this._easeList.push(arguments[i]);
        return this;
      },
      _computeEaseTime: function _computeEaseTime(dt) {
        var locList = this._easeList;
        if (!locList || 0 === locList.length) return dt;
        for (var i = 0, n = locList.length; i < n; i++) dt = locList[i].easing(dt);
        return dt;
      },
      step: function step(dt) {
        if (this._firstTick) {
          this._firstTick = false;
          this._elapsed = 0;
        } else this._elapsed += dt;
        var t = this._elapsed / (this._duration > 1.192092896e-7 ? this._duration : 1.192092896e-7);
        t = 1 > t ? t : 1;
        this.update(t > 0 ? t : 0);
        if (this._repeatMethod && this._timesForRepeat > 1 && this.isDone()) {
          this._repeatForever || this._timesForRepeat--;
          this.startWithTarget(this.target);
          this.step(this._elapsed - this._duration);
        }
      },
      startWithTarget: function startWithTarget(target) {
        cc.Action.prototype.startWithTarget.call(this, target);
        this._elapsed = 0;
        this._firstTick = true;
      },
      reverse: function reverse() {
        cc.logID(1010);
        return null;
      },
      setAmplitudeRate: function setAmplitudeRate(amp) {
        cc.logID(1011);
      },
      getAmplitudeRate: function getAmplitudeRate() {
        cc.logID(1012);
        return 0;
      },
      speed: function speed(_speed) {
        if (_speed <= 0) {
          cc.logID(1013);
          return this;
        }
        this._speedMethod = true;
        this._speed *= _speed;
        return this;
      },
      getSpeed: function getSpeed() {
        return this._speed;
      },
      setSpeed: function setSpeed(speed) {
        this._speed = speed;
        return this;
      },
      repeat: function repeat(times) {
        times = Math.round(times);
        if (isNaN(times) || times < 1) {
          cc.logID(1014);
          return this;
        }
        this._repeatMethod = true;
        this._timesForRepeat *= times;
        return this;
      },
      repeatForever: function repeatForever() {
        this._repeatMethod = true;
        this._timesForRepeat = this.MAX_VALUE;
        this._repeatForever = true;
        return this;
      }
    });
    cc.actionInterval = function(d) {
      return new cc.ActionInterval(d);
    };
    cc.Sequence = cc.Class({
      name: "cc.Sequence",
      extends: cc.ActionInterval,
      ctor: function ctor(tempArray) {
        this._actions = [];
        this._split = null;
        this._last = 0;
        this._reversed = false;
        var paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (1 === paramArray.length) {
          cc.errorID(1019);
          return;
        }
        var last = paramArray.length - 1;
        last >= 0 && null == paramArray[last] && cc.logID(1015);
        if (last >= 0) {
          var prev = paramArray[0], action1;
          for (var i = 1; i < last; i++) if (paramArray[i]) {
            action1 = prev;
            prev = cc.Sequence._actionOneTwo(action1, paramArray[i]);
          }
          this.initWithTwoActions(prev, paramArray[last]);
        }
      },
      initWithTwoActions: function initWithTwoActions(actionOne, actionTwo) {
        if (!actionOne || !actionTwo) {
          cc.errorID(1025);
          return false;
        }
        var durationOne = actionOne._duration, durationTwo = actionTwo._duration;
        durationOne *= actionOne._repeatMethod ? actionOne._timesForRepeat : 1;
        durationTwo *= actionTwo._repeatMethod ? actionTwo._timesForRepeat : 1;
        var d = durationOne + durationTwo;
        this.initWithDuration(d);
        this._actions[0] = actionOne;
        this._actions[1] = actionTwo;
        return true;
      },
      clone: function clone() {
        var action = new cc.Sequence();
        this._cloneDecoration(action);
        action.initWithTwoActions(this._actions[0].clone(), this._actions[1].clone());
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._split = this._actions[0]._duration / this._duration;
        this._split *= this._actions[0]._repeatMethod ? this._actions[0]._timesForRepeat : 1;
        this._last = -1;
      },
      stop: function stop() {
        -1 !== this._last && this._actions[this._last].stop();
        cc.Action.prototype.stop.call(this);
      },
      update: function update(dt) {
        var new_t, found = 0;
        var locSplit = this._split, locActions = this._actions, locLast = this._last, actionFound;
        dt = this._computeEaseTime(dt);
        if (dt < locSplit) {
          new_t = 0 !== locSplit ? dt / locSplit : 1;
          if (0 === found && 1 === locLast && this._reversed) {
            locActions[1].update(0);
            locActions[1].stop();
          }
        } else {
          found = 1;
          new_t = 1 === locSplit ? 1 : (dt - locSplit) / (1 - locSplit);
          if (-1 === locLast) {
            locActions[0].startWithTarget(this.target);
            locActions[0].update(1);
            locActions[0].stop();
          }
          if (0 === locLast) {
            locActions[0].update(1);
            locActions[0].stop();
          }
        }
        actionFound = locActions[found];
        if (locLast === found && actionFound.isDone()) return;
        locLast !== found && actionFound.startWithTarget(this.target);
        new_t *= actionFound._timesForRepeat;
        actionFound.update(new_t > 1 ? new_t % 1 : new_t);
        this._last = found;
      },
      reverse: function reverse() {
        var action = cc.Sequence._actionOneTwo(this._actions[1].reverse(), this._actions[0].reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        action._reversed = true;
        return action;
      }
    });
    cc.sequence = function(tempArray) {
      var paramArray = tempArray instanceof Array ? tempArray : arguments;
      if (1 === paramArray.length) {
        cc.errorID(1019);
        return null;
      }
      var last = paramArray.length - 1;
      last >= 0 && null == paramArray[last] && cc.logID(1015);
      var result = null;
      if (last >= 0) {
        result = paramArray[0];
        for (var i = 1; i <= last; i++) paramArray[i] && (result = cc.Sequence._actionOneTwo(result, paramArray[i]));
      }
      return result;
    };
    cc.Sequence._actionOneTwo = function(actionOne, actionTwo) {
      var sequence = new cc.Sequence();
      sequence.initWithTwoActions(actionOne, actionTwo);
      return sequence;
    };
    cc.Repeat = cc.Class({
      name: "cc.Repeat",
      extends: cc.ActionInterval,
      ctor: function ctor(action, times) {
        this._times = 0;
        this._total = 0;
        this._nextDt = 0;
        this._actionInstant = false;
        this._innerAction = null;
        void 0 !== times && this.initWithAction(action, times);
      },
      initWithAction: function initWithAction(action, times) {
        var duration = action._duration * times;
        if (this.initWithDuration(duration)) {
          this._times = times;
          this._innerAction = action;
          if (action instanceof cc.ActionInstant) {
            this._actionInstant = true;
            this._times -= 1;
          }
          this._total = 0;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.Repeat();
        this._cloneDecoration(action);
        action.initWithAction(this._innerAction.clone(), this._times);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        this._total = 0;
        this._nextDt = this._innerAction._duration / this._duration;
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
      },
      stop: function stop() {
        this._innerAction.stop();
        cc.Action.prototype.stop.call(this);
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        var locInnerAction = this._innerAction;
        var locDuration = this._duration;
        var locTimes = this._times;
        var locNextDt = this._nextDt;
        if (dt >= locNextDt) {
          while (dt > locNextDt && this._total < locTimes) {
            locInnerAction.update(1);
            this._total++;
            locInnerAction.stop();
            locInnerAction.startWithTarget(this.target);
            locNextDt += locInnerAction._duration / locDuration;
            this._nextDt = locNextDt > 1 ? 1 : locNextDt;
          }
          if (dt >= 1 && this._total < locTimes) {
            locInnerAction.update(1);
            this._total++;
          }
          this._actionInstant || (this._total === locTimes ? locInnerAction.stop() : locInnerAction.update(dt - (locNextDt - locInnerAction._duration / locDuration)));
        } else locInnerAction.update(dt * locTimes % 1);
      },
      isDone: function isDone() {
        return this._total === this._times;
      },
      reverse: function reverse() {
        var action = new cc.Repeat(this._innerAction.reverse(), this._times);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      setInnerAction: function setInnerAction(action) {
        this._innerAction !== action && (this._innerAction = action);
      },
      getInnerAction: function getInnerAction() {
        return this._innerAction;
      }
    });
    cc.repeat = function(action, times) {
      return new cc.Repeat(action, times);
    };
    cc.repeatForever = function(action) {
      return new cc.RepeatForever(action);
    };
    cc.RepeatForever = cc.Class({
      name: "cc.RepeatForever",
      extends: cc.ActionInterval,
      ctor: function ctor(action) {
        this._innerAction = null;
        action && this.initWithAction(action);
      },
      initWithAction: function initWithAction(action) {
        if (!action) {
          cc.errorID(1026);
          return false;
        }
        this._innerAction = action;
        return true;
      },
      clone: function clone() {
        var action = new cc.RepeatForever();
        this._cloneDecoration(action);
        action.initWithAction(this._innerAction.clone());
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._innerAction.startWithTarget(target);
      },
      step: function step(dt) {
        var locInnerAction = this._innerAction;
        locInnerAction.step(dt);
        if (locInnerAction.isDone()) {
          locInnerAction.startWithTarget(this.target);
          locInnerAction.step(locInnerAction.getElapsed() - locInnerAction._duration);
        }
      },
      isDone: function isDone() {
        return false;
      },
      reverse: function reverse() {
        var action = new cc.RepeatForever(this._innerAction.reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      setInnerAction: function setInnerAction(action) {
        this._innerAction !== action && (this._innerAction = action);
      },
      getInnerAction: function getInnerAction() {
        return this._innerAction;
      }
    });
    cc.repeatForever = function(action) {
      return new cc.RepeatForever(action);
    };
    cc.Spawn = cc.Class({
      name: "cc.Spawn",
      extends: cc.ActionInterval,
      ctor: function ctor(tempArray) {
        this._one = null;
        this._two = null;
        var paramArray = tempArray instanceof Array ? tempArray : arguments;
        if (1 === paramArray.length) {
          cc.errorID(1020);
          return;
        }
        var last = paramArray.length - 1;
        last >= 0 && null == paramArray[last] && cc.logID(1015);
        if (last >= 0) {
          var prev = paramArray[0], action1;
          for (var i = 1; i < last; i++) if (paramArray[i]) {
            action1 = prev;
            prev = cc.Spawn._actionOneTwo(action1, paramArray[i]);
          }
          this.initWithTwoActions(prev, paramArray[last]);
        }
      },
      initWithTwoActions: function initWithTwoActions(action1, action2) {
        if (!action1 || !action2) {
          cc.errorID(1027);
          return false;
        }
        var ret = false;
        var d1 = action1._duration;
        var d2 = action2._duration;
        if (this.initWithDuration(Math.max(d1, d2))) {
          this._one = action1;
          this._two = action2;
          d1 > d2 ? this._two = cc.Sequence._actionOneTwo(action2, cc.delayTime(d1 - d2)) : d1 < d2 && (this._one = cc.Sequence._actionOneTwo(action1, cc.delayTime(d2 - d1)));
          ret = true;
        }
        return ret;
      },
      clone: function clone() {
        var action = new cc.Spawn();
        this._cloneDecoration(action);
        action.initWithTwoActions(this._one.clone(), this._two.clone());
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._one.startWithTarget(target);
        this._two.startWithTarget(target);
      },
      stop: function stop() {
        this._one.stop();
        this._two.stop();
        cc.Action.prototype.stop.call(this);
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        this._one && this._one.update(dt);
        this._two && this._two.update(dt);
      },
      reverse: function reverse() {
        var action = cc.Spawn._actionOneTwo(this._one.reverse(), this._two.reverse());
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.spawn = function(tempArray) {
      var paramArray = tempArray instanceof Array ? tempArray : arguments;
      if (1 === paramArray.length) {
        cc.errorID(1020);
        return null;
      }
      paramArray.length > 0 && null == paramArray[paramArray.length - 1] && cc.logID(1015);
      var prev = paramArray[0];
      for (var i = 1; i < paramArray.length; i++) null != paramArray[i] && (prev = cc.Spawn._actionOneTwo(prev, paramArray[i]));
      return prev;
    };
    cc.Spawn._actionOneTwo = function(action1, action2) {
      var pSpawn = new cc.Spawn();
      pSpawn.initWithTwoActions(action1, action2);
      return pSpawn;
    };
    cc.RotateTo = cc.Class({
      name: "cc.RotateTo",
      extends: cc.ActionInterval,
      statics: {
        _reverse: false
      },
      ctor: function ctor(duration, dstAngle) {
        this._startAngle = 0;
        this._dstAngle = 0;
        this._angle = 0;
        void 0 !== dstAngle && this.initWithDuration(duration, dstAngle);
      },
      initWithDuration: function initWithDuration(duration, dstAngle) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._dstAngle = dstAngle;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.RotateTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._dstAngle);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var startAngle = target.angle % 360;
        var angle = cc.RotateTo._reverse ? this._dstAngle - startAngle : this._dstAngle + startAngle;
        angle > 180 && (angle -= 360);
        angle < -180 && (angle += 360);
        this._startAngle = startAngle;
        this._angle = cc.RotateTo._reverse ? angle : -angle;
      },
      reverse: function reverse() {
        cc.logID(1016);
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        this.target && (this.target.angle = this._startAngle + this._angle * dt);
      }
    });
    cc.rotateTo = function(duration, dstAngle) {
      return new cc.RotateTo(duration, dstAngle);
    };
    cc.RotateBy = cc.Class({
      name: "cc.RotateBy",
      extends: cc.ActionInterval,
      statics: {
        _reverse: false
      },
      ctor: function ctor(duration, deltaAngle) {
        deltaAngle *= cc.RotateBy._reverse ? 1 : -1;
        this._deltaAngle = 0;
        this._startAngle = 0;
        void 0 !== deltaAngle && this.initWithDuration(duration, deltaAngle);
      },
      initWithDuration: function initWithDuration(duration, deltaAngle) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._deltaAngle = deltaAngle;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.RotateBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._deltaAngle);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startAngle = target.angle;
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        this.target && (this.target.angle = this._startAngle + this._deltaAngle * dt);
      },
      reverse: function reverse() {
        var action = new cc.RotateBy();
        action.initWithDuration(this._duration, -this._deltaAngle);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.rotateBy = function(duration, deltaAngle) {
      return new cc.RotateBy(duration, deltaAngle);
    };
    cc.MoveBy = cc.Class({
      name: "cc.MoveBy",
      extends: cc.ActionInterval,
      ctor: function ctor(duration, deltaPos, deltaY) {
        this._positionDelta = cc.v2(0, 0);
        this._startPosition = cc.v2(0, 0);
        this._previousPosition = cc.v2(0, 0);
        void 0 !== deltaPos && cc.MoveBy.prototype.initWithDuration.call(this, duration, deltaPos, deltaY);
      },
      initWithDuration: function initWithDuration(duration, position, y) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          if (void 0 !== position.x) {
            y = position.y;
            position = position.x;
          }
          this._positionDelta.x = position;
          this._positionDelta.y = y;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.MoveBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._positionDelta);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.x;
        var locPosY = target.y;
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          var x = this._positionDelta.x * dt;
          var y = this._positionDelta.y * dt;
          var locStartPosition = this._startPosition;
          if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
            var targetX = this.target.x;
            var targetY = this.target.y;
            var locPreviousPosition = this._previousPosition;
            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
            x += locStartPosition.x;
            y += locStartPosition.y;
            locPreviousPosition.x = x;
            locPreviousPosition.y = y;
            this.target.setPosition(x, y);
          } else this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
        }
      },
      reverse: function reverse() {
        var action = new cc.MoveBy(this._duration, cc.v2(-this._positionDelta.x, -this._positionDelta.y));
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.moveBy = function(duration, deltaPos, deltaY) {
      return new cc.MoveBy(duration, deltaPos, deltaY);
    };
    cc.MoveTo = cc.Class({
      name: "cc.MoveTo",
      extends: cc.MoveBy,
      ctor: function ctor(duration, position, y) {
        this._endPosition = cc.v2(0, 0);
        void 0 !== position && this.initWithDuration(duration, position, y);
      },
      initWithDuration: function initWithDuration(duration, position, y) {
        if (cc.MoveBy.prototype.initWithDuration.call(this, duration, position, y)) {
          if (void 0 !== position.x) {
            y = position.y;
            position = position.x;
          }
          this._endPosition.x = position;
          this._endPosition.y = y;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.MoveTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endPosition);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.MoveBy.prototype.startWithTarget.call(this, target);
        this._positionDelta.x = this._endPosition.x - target.x;
        this._positionDelta.y = this._endPosition.y - target.y;
      }
    });
    cc.moveTo = function(duration, position, y) {
      return new cc.MoveTo(duration, position, y);
    };
    cc.SkewTo = cc.Class({
      name: "cc.SkewTo",
      extends: cc.ActionInterval,
      ctor: function ctor(t, sx, sy) {
        this._skewX = 0;
        this._skewY = 0;
        this._startSkewX = 0;
        this._startSkewY = 0;
        this._endSkewX = 0;
        this._endSkewY = 0;
        this._deltaX = 0;
        this._deltaY = 0;
        void 0 !== sy && cc.SkewTo.prototype.initWithDuration.call(this, t, sx, sy);
      },
      initWithDuration: function initWithDuration(t, sx, sy) {
        var ret = false;
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
          this._endSkewX = sx;
          this._endSkewY = sy;
          ret = true;
        }
        return ret;
      },
      clone: function clone() {
        var action = new cc.SkewTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endSkewX, this._endSkewY);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startSkewX = target.skewX % 180;
        this._deltaX = this._endSkewX - this._startSkewX;
        this._deltaX > 180 && (this._deltaX -= 360);
        this._deltaX < -180 && (this._deltaX += 360);
        this._startSkewY = target.skewY % 360;
        this._deltaY = this._endSkewY - this._startSkewY;
        this._deltaY > 180 && (this._deltaY -= 360);
        this._deltaY < -180 && (this._deltaY += 360);
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        this.target.skewX = this._startSkewX + this._deltaX * dt;
        this.target.skewY = this._startSkewY + this._deltaY * dt;
      }
    });
    cc.skewTo = function(t, sx, sy) {
      return new cc.SkewTo(t, sx, sy);
    };
    cc.SkewBy = cc.Class({
      name: "cc.SkewBy",
      extends: cc.SkewTo,
      ctor: function ctor(t, sx, sy) {
        void 0 !== sy && this.initWithDuration(t, sx, sy);
      },
      initWithDuration: function initWithDuration(t, deltaSkewX, deltaSkewY) {
        var ret = false;
        if (cc.SkewTo.prototype.initWithDuration.call(this, t, deltaSkewX, deltaSkewY)) {
          this._skewX = deltaSkewX;
          this._skewY = deltaSkewY;
          ret = true;
        }
        return ret;
      },
      clone: function clone() {
        var action = new cc.SkewBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._skewX, this._skewY);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.SkewTo.prototype.startWithTarget.call(this, target);
        this._deltaX = this._skewX;
        this._deltaY = this._skewY;
        this._endSkewX = this._startSkewX + this._deltaX;
        this._endSkewY = this._startSkewY + this._deltaY;
      },
      reverse: function reverse() {
        var action = new cc.SkewBy(this._duration, -this._skewX, -this._skewY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.skewBy = function(t, sx, sy) {
      return new cc.SkewBy(t, sx, sy);
    };
    cc.JumpBy = cc.Class({
      name: "cc.JumpBy",
      extends: cc.ActionInterval,
      ctor: function ctor(duration, position, y, height, jumps) {
        this._startPosition = cc.v2(0, 0);
        this._previousPosition = cc.v2(0, 0);
        this._delta = cc.v2(0, 0);
        this._height = 0;
        this._jumps = 0;
        void 0 !== height && cc.JumpBy.prototype.initWithDuration.call(this, duration, position, y, height, jumps);
      },
      initWithDuration: function initWithDuration(duration, position, y, height, jumps) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          if (void 0 === jumps) {
            jumps = height;
            height = y;
            y = position.y;
            position = position.x;
          }
          this._delta.x = position;
          this._delta.y = y;
          this._height = height;
          this._jumps = jumps;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.JumpBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._delta, this._height, this._jumps);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.x;
        var locPosY = target.y;
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          var frac = dt * this._jumps % 1;
          var y = 4 * this._height * frac * (1 - frac);
          y += this._delta.y * dt;
          var x = this._delta.x * dt;
          var locStartPosition = this._startPosition;
          if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
            var targetX = this.target.x;
            var targetY = this.target.y;
            var locPreviousPosition = this._previousPosition;
            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
            x += locStartPosition.x;
            y += locStartPosition.y;
            locPreviousPosition.x = x;
            locPreviousPosition.y = y;
            this.target.setPosition(x, y);
          } else this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
        }
      },
      reverse: function reverse() {
        var action = new cc.JumpBy(this._duration, cc.v2(-this._delta.x, -this._delta.y), this._height, this._jumps);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.jumpBy = function(duration, position, y, height, jumps) {
      return new cc.JumpBy(duration, position, y, height, jumps);
    };
    cc.JumpTo = cc.Class({
      name: "cc.JumpTo",
      extends: cc.JumpBy,
      ctor: function ctor(duration, position, y, height, jumps) {
        this._endPosition = cc.v2(0, 0);
        void 0 !== height && this.initWithDuration(duration, position, y, height, jumps);
      },
      initWithDuration: function initWithDuration(duration, position, y, height, jumps) {
        if (cc.JumpBy.prototype.initWithDuration.call(this, duration, position, y, height, jumps)) {
          if (void 0 === jumps) {
            y = position.y;
            position = position.x;
          }
          this._endPosition.x = position;
          this._endPosition.y = y;
          return true;
        }
        return false;
      },
      startWithTarget: function startWithTarget(target) {
        cc.JumpBy.prototype.startWithTarget.call(this, target);
        this._delta.x = this._endPosition.x - this._startPosition.x;
        this._delta.y = this._endPosition.y - this._startPosition.y;
      },
      clone: function clone() {
        var action = new cc.JumpTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endPosition, this._height, this._jumps);
        return action;
      }
    });
    cc.jumpTo = function(duration, position, y, height, jumps) {
      return new cc.JumpTo(duration, position, y, height, jumps);
    };
    function bezierAt(a, b, c, d, t) {
      return Math.pow(1 - t, 3) * a + 3 * t * Math.pow(1 - t, 2) * b + 3 * Math.pow(t, 2) * (1 - t) * c + Math.pow(t, 3) * d;
    }
    cc.BezierBy = cc.Class({
      name: "cc.BezierBy",
      extends: cc.ActionInterval,
      ctor: function ctor(t, c) {
        this._config = [];
        this._startPosition = cc.v2(0, 0);
        this._previousPosition = cc.v2(0, 0);
        c && cc.BezierBy.prototype.initWithDuration.call(this, t, c);
      },
      initWithDuration: function initWithDuration(t, c) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
          this._config = c;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.BezierBy();
        this._cloneDecoration(action);
        var newConfigs = [];
        for (var i = 0; i < this._config.length; i++) {
          var selConf = this._config[i];
          newConfigs.push(cc.v2(selConf.x, selConf.y));
        }
        action.initWithDuration(this._duration, newConfigs);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var locPosX = target.x;
        var locPosY = target.y;
        this._previousPosition.x = locPosX;
        this._previousPosition.y = locPosY;
        this._startPosition.x = locPosX;
        this._startPosition.y = locPosY;
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          var locConfig = this._config;
          var xa = 0;
          var xb = locConfig[0].x;
          var xc = locConfig[1].x;
          var xd = locConfig[2].x;
          var ya = 0;
          var yb = locConfig[0].y;
          var yc = locConfig[1].y;
          var yd = locConfig[2].y;
          var x = bezierAt(xa, xb, xc, xd, dt);
          var y = bezierAt(ya, yb, yc, yd, dt);
          var locStartPosition = this._startPosition;
          if (cc.macro.ENABLE_STACKABLE_ACTIONS) {
            var targetX = this.target.x;
            var targetY = this.target.y;
            var locPreviousPosition = this._previousPosition;
            locStartPosition.x = locStartPosition.x + targetX - locPreviousPosition.x;
            locStartPosition.y = locStartPosition.y + targetY - locPreviousPosition.y;
            x += locStartPosition.x;
            y += locStartPosition.y;
            locPreviousPosition.x = x;
            locPreviousPosition.y = y;
            this.target.setPosition(x, y);
          } else this.target.setPosition(locStartPosition.x + x, locStartPosition.y + y);
        }
      },
      reverse: function reverse() {
        var locConfig = this._config;
        var x0 = locConfig[0].x, y0 = locConfig[0].y;
        var x1 = locConfig[1].x, y1 = locConfig[1].y;
        var x2 = locConfig[2].x, y2 = locConfig[2].y;
        var r = [ cc.v2(x1 - x2, y1 - y2), cc.v2(x0 - x2, y0 - y2), cc.v2(-x2, -y2) ];
        var action = new cc.BezierBy(this._duration, r);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.bezierBy = function(t, c) {
      return new cc.BezierBy(t, c);
    };
    cc.BezierTo = cc.Class({
      name: "cc.BezierTo",
      extends: cc.BezierBy,
      ctor: function ctor(t, c) {
        this._toConfig = [];
        c && this.initWithDuration(t, c);
      },
      initWithDuration: function initWithDuration(t, c) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, t)) {
          this._toConfig = c;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.BezierTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toConfig);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.BezierBy.prototype.startWithTarget.call(this, target);
        var locStartPos = this._startPosition;
        var locToConfig = this._toConfig;
        var locConfig = this._config;
        locConfig[0] = locToConfig[0].sub(locStartPos);
        locConfig[1] = locToConfig[1].sub(locStartPos);
        locConfig[2] = locToConfig[2].sub(locStartPos);
      }
    });
    cc.bezierTo = function(t, c) {
      return new cc.BezierTo(t, c);
    };
    cc.ScaleTo = cc.Class({
      name: "cc.ScaleTo",
      extends: cc.ActionInterval,
      ctor: function ctor(duration, sx, sy) {
        this._scaleX = 1;
        this._scaleY = 1;
        this._startScaleX = 1;
        this._startScaleY = 1;
        this._endScaleX = 0;
        this._endScaleY = 0;
        this._deltaX = 0;
        this._deltaY = 0;
        void 0 !== sx && cc.ScaleTo.prototype.initWithDuration.call(this, duration, sx, sy);
      },
      initWithDuration: function initWithDuration(duration, sx, sy) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._endScaleX = sx;
          this._endScaleY = null != sy ? sy : sx;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.ScaleTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startScaleX = target.scaleX;
        this._startScaleY = target.scaleY;
        this._deltaX = this._endScaleX - this._startScaleX;
        this._deltaY = this._endScaleY - this._startScaleY;
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          this.target.scaleX = this._startScaleX + this._deltaX * dt;
          this.target.scaleY = this._startScaleY + this._deltaY * dt;
        }
      }
    });
    cc.scaleTo = function(duration, sx, sy) {
      return new cc.ScaleTo(duration, sx, sy);
    };
    cc.ScaleBy = cc.Class({
      name: "cc.ScaleBy",
      extends: cc.ScaleTo,
      startWithTarget: function startWithTarget(target) {
        cc.ScaleTo.prototype.startWithTarget.call(this, target);
        this._deltaX = this._startScaleX * this._endScaleX - this._startScaleX;
        this._deltaY = this._startScaleY * this._endScaleY - this._startScaleY;
      },
      reverse: function reverse() {
        var action = new cc.ScaleBy(this._duration, 1 / this._endScaleX, 1 / this._endScaleY);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      clone: function clone() {
        var action = new cc.ScaleBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._endScaleX, this._endScaleY);
        return action;
      }
    });
    cc.scaleBy = function(duration, sx, sy) {
      return new cc.ScaleBy(duration, sx, sy);
    };
    cc.Blink = cc.Class({
      name: "cc.Blink",
      extends: cc.ActionInterval,
      ctor: function ctor(duration, blinks) {
        this._times = 0;
        this._originalState = false;
        void 0 !== blinks && this.initWithDuration(duration, blinks);
      },
      initWithDuration: function initWithDuration(duration, blinks) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._times = blinks;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.Blink();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._times);
        return action;
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target && !this.isDone()) {
          var slice = 1 / this._times;
          var m = dt % slice;
          this.target.opacity = m > slice / 2 ? 255 : 0;
        }
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._originalState = target.opacity;
      },
      stop: function stop() {
        this.target.opacity = this._originalState;
        cc.ActionInterval.prototype.stop.call(this);
      },
      reverse: function reverse() {
        var action = new cc.Blink(this._duration, this._times);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.blink = function(duration, blinks) {
      return new cc.Blink(duration, blinks);
    };
    cc.FadeTo = cc.Class({
      name: "cc.FadeTo",
      extends: cc.ActionInterval,
      ctor: function ctor(duration, opacity) {
        this._toOpacity = 0;
        this._fromOpacity = 0;
        void 0 !== opacity && cc.FadeTo.prototype.initWithDuration.call(this, duration, opacity);
      },
      initWithDuration: function initWithDuration(duration, opacity) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._toOpacity = opacity;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.FadeTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
      },
      update: function update(time) {
        time = this._computeEaseTime(time);
        var fromOpacity = void 0 !== this._fromOpacity ? this._fromOpacity : 255;
        this.target.opacity = fromOpacity + (this._toOpacity - fromOpacity) * time;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._fromOpacity = target.opacity;
      }
    });
    cc.fadeTo = function(duration, opacity) {
      return new cc.FadeTo(duration, opacity);
    };
    cc.FadeIn = cc.Class({
      name: "cc.FadeIn",
      extends: cc.FadeTo,
      ctor: function ctor(duration) {
        null == duration && (duration = 0);
        this._reverseAction = null;
        this.initWithDuration(duration, 255);
      },
      reverse: function reverse() {
        var action = new cc.FadeOut();
        action.initWithDuration(this._duration, 0);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      clone: function clone() {
        var action = new cc.FadeIn();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        this._reverseAction && (this._toOpacity = this._reverseAction._fromOpacity);
        cc.FadeTo.prototype.startWithTarget.call(this, target);
      }
    });
    cc.fadeIn = function(duration) {
      return new cc.FadeIn(duration);
    };
    cc.FadeOut = cc.Class({
      name: "cc.FadeOut",
      extends: cc.FadeTo,
      ctor: function ctor(duration) {
        null == duration && (duration = 0);
        this._reverseAction = null;
        this.initWithDuration(duration, 0);
      },
      reverse: function reverse() {
        var action = new cc.FadeIn();
        action._reverseAction = this;
        action.initWithDuration(this._duration, 255);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      clone: function clone() {
        var action = new cc.FadeOut();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._toOpacity);
        return action;
      }
    });
    cc.fadeOut = function(d) {
      return new cc.FadeOut(d);
    };
    cc.TintTo = cc.Class({
      name: "cc.TintTo",
      extends: cc.ActionInterval,
      ctor: function ctor(duration, red, green, blue) {
        this._to = cc.color(0, 0, 0);
        this._from = cc.color(0, 0, 0);
        if (red instanceof cc.Color) {
          blue = red.b;
          green = red.g;
          red = red.r;
        }
        void 0 !== blue && this.initWithDuration(duration, red, green, blue);
      },
      initWithDuration: function initWithDuration(duration, red, green, blue) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._to = cc.color(red, green, blue);
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.TintTo();
        this._cloneDecoration(action);
        var locTo = this._to;
        action.initWithDuration(this._duration, locTo.r, locTo.g, locTo.b);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._from = this.target.color;
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        var locFrom = this._from, locTo = this._to;
        locFrom && (this.target.color = cc.color(locFrom.r + (locTo.r - locFrom.r) * dt, locFrom.g + (locTo.g - locFrom.g) * dt, locFrom.b + (locTo.b - locFrom.b) * dt));
      }
    });
    cc.tintTo = function(duration, red, green, blue) {
      return new cc.TintTo(duration, red, green, blue);
    };
    cc.TintBy = cc.Class({
      name: "cc.TintBy",
      extends: cc.ActionInterval,
      ctor: function ctor(duration, deltaRed, deltaGreen, deltaBlue) {
        this._deltaR = 0;
        this._deltaG = 0;
        this._deltaB = 0;
        this._fromR = 0;
        this._fromG = 0;
        this._fromB = 0;
        void 0 !== deltaBlue && this.initWithDuration(duration, deltaRed, deltaGreen, deltaBlue);
      },
      initWithDuration: function initWithDuration(duration, deltaRed, deltaGreen, deltaBlue) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          this._deltaR = deltaRed;
          this._deltaG = deltaGreen;
          this._deltaB = deltaBlue;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.TintBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._deltaR, this._deltaG, this._deltaB);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var color = target.color;
        this._fromR = color.r;
        this._fromG = color.g;
        this._fromB = color.b;
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        this.target.color = cc.color(this._fromR + this._deltaR * dt, this._fromG + this._deltaG * dt, this._fromB + this._deltaB * dt);
      },
      reverse: function reverse() {
        var action = new cc.TintBy(this._duration, -this._deltaR, -this._deltaG, -this._deltaB);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.tintBy = function(duration, deltaRed, deltaGreen, deltaBlue) {
      return new cc.TintBy(duration, deltaRed, deltaGreen, deltaBlue);
    };
    cc.DelayTime = cc.Class({
      name: "cc.DelayTime",
      extends: cc.ActionInterval,
      update: function update(dt) {},
      reverse: function reverse() {
        var action = new cc.DelayTime(this._duration);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      },
      clone: function clone() {
        var action = new cc.DelayTime();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration);
        return action;
      }
    });
    cc.delayTime = function(d) {
      return new cc.DelayTime(d);
    };
    cc.ReverseTime = cc.Class({
      name: "cc.ReverseTime",
      extends: cc.ActionInterval,
      ctor: function ctor(action) {
        this._other = null;
        action && this.initWithAction(action);
      },
      initWithAction: function initWithAction(action) {
        if (!action) {
          cc.errorID(1028);
          return false;
        }
        if (action === this._other) {
          cc.errorID(1029);
          return false;
        }
        if (cc.ActionInterval.prototype.initWithDuration.call(this, action._duration)) {
          this._other = action;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.ReverseTime();
        this._cloneDecoration(action);
        action.initWithAction(this._other.clone());
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._other.startWithTarget(target);
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        this._other && this._other.update(1 - dt);
      },
      reverse: function reverse() {
        return this._other.clone();
      },
      stop: function stop() {
        this._other.stop();
        cc.Action.prototype.stop.call(this);
      }
    });
    cc.reverseTime = function(action) {
      return new cc.ReverseTime(action);
    };
    cc.TargetedAction = cc.Class({
      name: "cc.TargetedAction",
      extends: cc.ActionInterval,
      ctor: function ctor(target, action) {
        this._action = null;
        this._forcedTarget = null;
        action && this.initWithTarget(target, action);
      },
      initWithTarget: function initWithTarget(target, action) {
        if (this.initWithDuration(action._duration)) {
          this._forcedTarget = target;
          this._action = action;
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.TargetedAction();
        this._cloneDecoration(action);
        action.initWithTarget(this._forcedTarget, this._action.clone());
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._action.startWithTarget(this._forcedTarget);
      },
      stop: function stop() {
        this._action.stop();
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        this._action.update(dt);
      },
      getForcedTarget: function getForcedTarget() {
        return this._forcedTarget;
      },
      setForcedTarget: function setForcedTarget(forcedTarget) {
        this._forcedTarget !== forcedTarget && (this._forcedTarget = forcedTarget);
      }
    });
    cc.targetedAction = function(target, action) {
      return new cc.TargetedAction(target, action);
    };
  }), {} ],
  7: [ (function(require, module, exports) {
    "use strict";
    require("../core/platform/CCClass");
    var js = require("../core/platform/js");
    var HashElement = function HashElement() {
      this.actions = [];
      this.target = null;
      this.actionIndex = 0;
      this.currentAction = null;
      this.paused = false;
      this.lock = false;
    };
    cc.ActionManager = function() {
      this._hashTargets = js.createMap(true);
      this._arrayTargets = [];
      this._currentTarget = null;
      cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
    };
    cc.ActionManager.prototype = {
      constructor: cc.ActionManager,
      _elementPool: [],
      _searchElementByTarget: function _searchElementByTarget(arr, target) {
        for (var k = 0; k < arr.length; k++) if (target === arr[k].target) return arr[k];
        return null;
      },
      _getElement: function _getElement(target, paused) {
        var element = this._elementPool.pop();
        element || (element = new HashElement());
        element.target = target;
        element.paused = !!paused;
        return element;
      },
      _putElement: function _putElement(element) {
        element.actions.length = 0;
        element.actionIndex = 0;
        element.currentAction = null;
        element.paused = false;
        element.target = null;
        element.lock = false;
        this._elementPool.push(element);
      },
      addAction: function addAction(action, target, paused) {
        if (!action || !target) {
          cc.errorID(1e3);
          return;
        }
        var element = this._hashTargets[target._id];
        if (element) element.actions || (element.actions = []); else {
          element = this._getElement(target, paused);
          this._hashTargets[target._id] = element;
          this._arrayTargets.push(element);
        }
        element.actions.push(action);
        action.startWithTarget(target);
      },
      removeAllActions: function removeAllActions() {
        var locTargets = this._arrayTargets;
        for (var i = 0; i < locTargets.length; i++) {
          var element = locTargets[i];
          element && this._putElement(element);
        }
        this._arrayTargets.length = 0;
        this._hashTargets = js.createMap(true);
      },
      removeAllActionsFromTarget: function removeAllActionsFromTarget(target, forceDelete) {
        if (null == target) return;
        var element = this._hashTargets[target._id];
        if (element) {
          element.actions.length = 0;
          this._deleteHashElement(element);
        }
      },
      removeAction: function removeAction(action) {
        if (!action) return;
        var target = action.getOriginalTarget();
        var element = this._hashTargets[target._id];
        if (!element) return;
        for (var i = 0; i < element.actions.length; i++) if (element.actions[i] === action) {
          element.actions.splice(i, 1);
          element.actionIndex >= i && element.actionIndex--;
          break;
        }
      },
      _removeActionByTag: function _removeActionByTag(tag, element, target) {
        for (var i = 0, l = element.actions.length; i < l; ++i) {
          var action = element.actions[i];
          if (action && action.getTag() === tag) {
            if (target && action.getOriginalTarget() !== target) continue;
            this._removeActionAtIndex(i, element);
            break;
          }
        }
      },
      _removeAllActionsByTag: function _removeAllActionsByTag(tag, element, target) {
        for (var i = element.actions.length - 1; i >= 0; --i) {
          var action = element.actions[i];
          if (action && action.getTag() === tag) {
            if (target && action.getOriginalTarget() !== target) continue;
            this._removeActionAtIndex(i, element);
          }
        }
      },
      removeActionByTag: function removeActionByTag(tag, target) {
        tag === cc.Action.TAG_INVALID && cc.logID(1002);
        var hashTargets = this._hashTargets;
        if (target) {
          var element = hashTargets[target._id];
          element && this._removeActionByTag(tag, element, target);
        } else for (var name in hashTargets) {
          var _element = hashTargets[name];
          this._removeActionByTag(tag, _element);
        }
      },
      removeAllActionsByTag: function removeAllActionsByTag(tag, target) {
        tag === cc.Action.TAG_INVALID && cc.logID(1002);
        var hashTargets = this._hashTargets;
        if (target) {
          var element = hashTargets[target._id];
          element && this._removeAllActionsByTag(tag, element, target);
        } else for (var name in hashTargets) {
          var _element2 = hashTargets[name];
          this._removeAllActionsByTag(tag, _element2);
        }
      },
      getActionByTag: function getActionByTag(tag, target) {
        tag === cc.Action.TAG_INVALID && cc.logID(1004);
        var element = this._hashTargets[target._id];
        if (element) {
          if (null != element.actions) for (var i = 0; i < element.actions.length; ++i) {
            var action = element.actions[i];
            if (action && action.getTag() === tag) return action;
          }
          cc.logID(1005, tag);
        }
        return null;
      },
      getNumberOfRunningActionsInTarget: function getNumberOfRunningActionsInTarget(target) {
        var element = this._hashTargets[target._id];
        if (element) return element.actions ? element.actions.length : 0;
        return 0;
      },
      pauseTarget: function pauseTarget(target) {
        var element = this._hashTargets[target._id];
        element && (element.paused = true);
      },
      resumeTarget: function resumeTarget(target) {
        var element = this._hashTargets[target._id];
        element && (element.paused = false);
      },
      pauseAllRunningActions: function pauseAllRunningActions() {
        var idsWithActions = [];
        var locTargets = this._arrayTargets;
        for (var i = 0; i < locTargets.length; i++) {
          var element = locTargets[i];
          if (element && !element.paused) {
            element.paused = true;
            idsWithActions.push(element.target);
          }
        }
        return idsWithActions;
      },
      resumeTargets: function resumeTargets(targetsToResume) {
        if (!targetsToResume) return;
        for (var i = 0; i < targetsToResume.length; i++) targetsToResume[i] && this.resumeTarget(targetsToResume[i]);
      },
      pauseTargets: function pauseTargets(targetsToPause) {
        if (!targetsToPause) return;
        for (var i = 0; i < targetsToPause.length; i++) targetsToPause[i] && this.pauseTarget(targetsToPause[i]);
      },
      purgeSharedManager: function purgeSharedManager() {
        cc.director.getScheduler().unscheduleUpdate(this);
      },
      _removeActionAtIndex: function _removeActionAtIndex(index, element) {
        var action = element.actions[index];
        element.actions.splice(index, 1);
        element.actionIndex >= index && element.actionIndex--;
        0 === element.actions.length && this._deleteHashElement(element);
      },
      _deleteHashElement: function _deleteHashElement(element) {
        var ret = false;
        if (element && !element.lock && this._hashTargets[element.target._id]) {
          delete this._hashTargets[element.target._id];
          var targets = this._arrayTargets;
          for (var i = 0, l = targets.length; i < l; i++) if (targets[i] === element) {
            targets.splice(i, 1);
            break;
          }
          this._putElement(element);
          ret = true;
        }
        return ret;
      },
      update: function update(dt) {
        var locTargets = this._arrayTargets, locCurrTarget;
        for (var elt = 0; elt < locTargets.length; elt++) {
          this._currentTarget = locTargets[elt];
          locCurrTarget = this._currentTarget;
          if (!locCurrTarget.paused && locCurrTarget.actions) {
            locCurrTarget.lock = true;
            for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) {
              locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
              if (!locCurrTarget.currentAction) continue;
              locCurrTarget.currentAction.step(dt * (locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1));
              if (locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                locCurrTarget.currentAction.stop();
                var action = locCurrTarget.currentAction;
                locCurrTarget.currentAction = null;
                this.removeAction(action);
              }
              locCurrTarget.currentAction = null;
            }
            locCurrTarget.lock = false;
          }
          0 === locCurrTarget.actions.length && this._deleteHashElement(locCurrTarget) && elt--;
        }
      }
    };
    false;
  }), {
    "../core/platform/CCClass": 272,
    "../core/platform/js": 294
  } ],
  8: [ (function(require, module, exports) {
    "use strict";
    require("./CCActionManager");
    require("./CCAction");
    require("./CCActionInterval");
    require("./CCActionInstant");
    require("./CCActionEase");
    require("./CCActionCatmullRom");
    require("./tween");
  }), {
    "./CCAction": 2,
    "./CCActionCatmullRom": 3,
    "./CCActionEase": 4,
    "./CCActionInstant": 5,
    "./CCActionInterval": 6,
    "./CCActionManager": 7,
    "./tween": 9
  } ],
  9: [ (function(require, module, exports) {
    "use strict";
    var _bezier = require("../animation/bezier");
    var _tweenID = 0;
    var TweenAction = cc.Class({
      name: "cc.TweenAction",
      extends: cc.ActionInterval,
      ctor: function ctor(duration, props, opts) {
        this._opts = opts = opts || Object.create(null);
        this._props = Object.create(null);
        opts.progress = opts.progress || this.progress;
        if (opts.easing && "string" === typeof opts.easing) {
          var easingName = opts.easing;
          opts.easing = cc.easing[easingName];
          !opts.easing && cc.warnID(1031, easingName);
        }
        var relative = this._opts.relative;
        for (var name in props) {
          var value = props[name];
          var easing = void 0, progress = void 0;
          if (void 0 !== value.value && (value.easing || value.progress)) {
            if ("string" === typeof value.easing) {
              easing = cc.easing[value.easing];
              !easing && cc.warnID(1031, value.easing);
            } else easing = value.easing;
            progress = value.progress;
            value = value.value;
          }
          var isNumber = "number" === typeof value;
          if (!isNumber && (!value.lerp || relative && !value.add && !value.mul || !value.clone)) {
            cc.warn("Can not animate " + name + " property, because it do not have [lerp, (add|mul), clone] function.");
            continue;
          }
          var prop = Object.create(null);
          prop.value = value;
          prop.easing = easing;
          prop.progress = progress;
          this._props[name] = prop;
        }
        this._originProps = props;
        this.initWithDuration(duration);
      },
      clone: function clone() {
        var action = new TweenAction(this._duration, this._originProps, this._opts);
        this._cloneDecoration(action);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var relative = !!this._opts.relative;
        var props = this._props;
        for (var name in props) {
          var value = target[name];
          var prop = props[name];
          if ("number" === typeof value) {
            prop.start = value;
            prop.current = value;
            prop.end = relative ? value + prop.value : prop.value;
          } else {
            prop.start = value.clone();
            prop.current = value.clone();
            prop.end = relative ? (value.add || value.mul).call(value, prop.value) : prop.value;
          }
        }
      },
      update: function update(t) {
        var opts = this._opts;
        var easingTime = t;
        opts.easing && (easingTime = opts.easing(t));
        var target = this.target;
        if (!target) return;
        var props = this._props;
        var progress = opts.progress;
        for (var name in props) {
          var prop = props[name];
          var time = prop.easing ? prop.easing(t) : easingTime;
          var current = prop.current = (prop.progress || progress)(prop.start, prop.end, prop.current, time);
          target[name] = current;
        }
        var onUpdate = opts.onUpdate;
        onUpdate && onUpdate(target, t);
      },
      progress: function progress(start, end, current, t) {
        "number" === typeof start ? current = start + (end - start) * t : start.lerp(end, t, current);
        return current;
      }
    });
    var SetAction = cc.Class({
      name: "cc.SetAction",
      extends: cc.ActionInstant,
      ctor: function ctor(props) {
        this._props = {};
        void 0 !== props && this.init(props);
      },
      init: function init(props) {
        for (var name in props) this._props[name] = props[name];
        return true;
      },
      update: function update() {
        var props = this._props;
        var target = this.target;
        for (var name in props) target[name] = props[name];
      },
      clone: function clone() {
        var action = new SetAction();
        action.init(this._props);
        return action;
      }
    });
    function Tween(target) {
      this._actions = [];
      this._finalAction = null;
      this._target = target;
      this._tag = cc.Action.TAG_INVALID;
    }
    Tween.stopAll = function() {
      cc.director.getActionManager().removeAllActions();
    };
    Tween.stopAllByTag = function(tag) {
      cc.director.getActionManager().removeAllActionsByTag(tag);
    };
    Tween.stopAllByTarget = function(target) {
      cc.director.getActionManager().removeAllActionsFromTarget(target);
    };
    Tween.prototype.then = function(other) {
      other instanceof cc.Action ? this._actions.push(other.clone()) : this._actions.push(other._union());
      return this;
    };
    Tween.prototype.target = function(target) {
      this._target = target;
      return this;
    };
    Tween.prototype.start = function() {
      var target = this._target;
      if (!target) {
        cc.warn("Please set target to tween first");
        return this;
      }
      if (target instanceof cc.Object && !target.isValid) return;
      this._finalAction && cc.director.getActionManager().removeAction(this._finalAction);
      this._finalAction = this._union();
      void 0 === target._id && (target._id = ++_tweenID);
      this._finalAction.setTag(this._tag);
      cc.director.getActionManager().addAction(this._finalAction, target, false);
      return this;
    };
    Tween.prototype.stop = function() {
      this._finalAction && cc.director.getActionManager().removeAction(this._finalAction);
      return this;
    };
    Tween.prototype.tag = function(tag) {
      this._tag = tag;
      return this;
    };
    Tween.prototype.clone = function(target) {
      var action = this._union();
      return cc.tween(target).then(action.clone());
    };
    Tween.prototype.union = function() {
      var action = this._union();
      this._actions.length = 0;
      this._actions.push(action);
      return this;
    };
    Tween.prototype._union = function() {
      var actions = this._actions;
      actions = 1 === actions.length ? actions[0] : cc.sequence(actions);
      return actions;
    };
    Object.assign(Tween.prototype, {
      bezierTo: function bezierTo(duration, c1, c2, to, opts) {
        var c0x = c1.x, c0y = c1.y, c1x = c2.x, c1y = c2.y;
        opts = opts || Object.create(null);
        opts.progress = function(start, end, current, t) {
          current.x = (0, _bezier.bezier)(start.x, c0x, c1x, end.x, t);
          current.y = (0, _bezier.bezier)(start.y, c0y, c1y, end.y, t);
          return current;
        };
        return this.to(duration, {
          position: to
        }, opts);
      },
      bezierBy: function bezierBy(duration, c1, c2, to, opts) {
        var c0x = c1.x, c0y = c1.y, c1x = c2.x, c1y = c2.y;
        opts = opts || Object.create(null);
        opts.progress = function(start, end, current, t) {
          var sx = start.x, sy = start.y;
          current.x = (0, _bezier.bezier)(sx, c0x + sx, c1x + sx, end.x, t);
          current.y = (0, _bezier.bezier)(sy, c0y + sy, c1y + sy, end.y, t);
          return current;
        };
        return this.by(duration, {
          position: to
        }, opts);
      },
      flipX: function flipX() {
        var _this = this;
        return this.call((function() {
          _this._target.scaleX *= -1;
        }), this);
      },
      flipY: function flipY() {
        var _this2 = this;
        return this.call((function() {
          _this2._target.scaleY *= -1;
        }), this);
      },
      blink: function blink(duration, times, opts) {
        var slice = 1 / times;
        opts = opts || Object.create(null);
        opts.progress = function(start, end, current, t) {
          if (t >= 1) return start;
          var m = t % slice;
          return m > slice / 2 ? 255 : 0;
        };
        return this.to(duration, {
          opacity: 1
        }, opts);
      }
    });
    var tmp_args = [];
    function wrapAction(action) {
      return function() {
        tmp_args.length = 0;
        for (var l = arguments.length, i = 0; i < l; i++) {
          var arg = tmp_args[i] = arguments[i];
          arg instanceof Tween && (tmp_args[i] = arg._union());
        }
        return action.apply(this, tmp_args);
      };
    }
    var actions = {
      to: function to(duration, props, opts) {
        opts = opts || Object.create(null);
        opts.relative = false;
        return new TweenAction(duration, props, opts);
      },
      by: function by(duration, props, opts) {
        opts = opts || Object.create(null);
        opts.relative = true;
        return new TweenAction(duration, props, opts);
      },
      set: function set(props) {
        return new SetAction(props);
      },
      delay: cc.delayTime,
      call: cc.callFunc,
      hide: cc.hide,
      show: cc.show,
      removeSelf: cc.removeSelf,
      sequence: wrapAction(cc.sequence),
      parallel: wrapAction(cc.spawn)
    };
    var previousAsInputActions = {
      repeat: cc.repeat,
      repeatForever: cc.repeatForever,
      reverseTime: cc.reverseTime
    };
    var keys = Object.keys(actions);
    var _loop = function _loop(i) {
      var key = keys[i];
      Tween.prototype[key] = function() {
        var action = actions[key].apply(this, arguments);
        this._actions.push(action);
        return this;
      };
    };
    for (var i = 0; i < keys.length; i++) _loop(i);
    keys = Object.keys(previousAsInputActions);
    var _loop2 = function _loop2(_i) {
      var key = keys[_i];
      Tween.prototype[key] = function() {
        var actions = this._actions;
        var action = arguments[arguments.length - 1];
        var length = arguments.length - 1;
        if (action instanceof cc.Tween) action = action._union(); else if (!(action instanceof cc.Action)) {
          action = actions[actions.length - 1];
          actions.length -= 1;
          length += 1;
        }
        var args = [ action ];
        for (var _i2 = 0; _i2 < length; _i2++) args.push(arguments[_i2]);
        action = previousAsInputActions[key].apply(this, args);
        actions.push(action);
        return this;
      };
    };
    for (var _i = 0; _i < keys.length; _i++) _loop2(_i);
    cc.tween = function(target) {
      return new Tween(target);
    };
    cc.Tween = Tween;
  }), {
    "../animation/bezier": 15
  } ],
  10: [ (function(require, module, exports) {
    "use strict";
    var js = cc.js;
    var Playable = require("./playable");
    var _require = require("./animation-curves"), EventAnimCurve = _require.EventAnimCurve, EventInfo = _require.EventInfo;
    var WrapModeMask = require("./types").WrapModeMask;
    var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
    function AnimationAnimator(target, animation) {
      Playable.call(this);
      this.target = target;
      this.animation = animation;
      this._anims = new js.array.MutableForwardIterator([]);
    }
    js.extend(AnimationAnimator, Playable);
    var p = AnimationAnimator.prototype;
    p.playState = function(state, startTime) {
      if (!state.clip) return;
      state.curveLoaded || initClipData(this.target, state);
      state.animator = this;
      state.play();
      "number" === typeof startTime && state.setTime(startTime);
      this.play();
    };
    p.stopStatesExcept = function(state) {
      var iterator = this._anims;
      var array = iterator.array;
      for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var anim = array[iterator.i];
        if (anim === state) continue;
        this.stopState(anim);
      }
    };
    p.addAnimation = function(anim) {
      var index = this._anims.array.indexOf(anim);
      -1 === index && this._anims.push(anim);
      anim._setEventTarget(this.animation);
    };
    p.removeAnimation = function(anim) {
      var index = this._anims.array.indexOf(anim);
      if (index >= 0) {
        this._anims.fastRemoveAt(index);
        0 === this._anims.array.length && this.stop();
      } else cc.errorID(3907);
      anim.animator = null;
    };
    p.sample = function() {
      var iterator = this._anims;
      var array = iterator.array;
      for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var anim = array[iterator.i];
        anim.sample();
      }
    };
    p.stopState = function(state) {
      state && state.stop();
    };
    p.pauseState = function(state) {
      state && state.pause();
    };
    p.resumeState = function(state) {
      state && state.resume();
      this.isPaused && this.resume();
    };
    p.setStateTime = function(state, time) {
      if (void 0 !== time) {
        if (state) {
          state.setTime(time);
          state.sample();
        }
      } else {
        time = state;
        var array = this._anims.array;
        for (var i = 0; i < array.length; ++i) {
          var anim = array[i];
          anim.setTime(time);
          anim.sample();
        }
      }
    };
    p.onStop = function() {
      var iterator = this._anims;
      var array = iterator.array;
      for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
        var anim = array[iterator.i];
        anim.stop();
      }
    };
    p.onPause = function() {
      var array = this._anims.array;
      for (var i = 0; i < array.length; ++i) {
        var anim = array[i];
        anim.pause();
        anim.animator = null;
      }
    };
    p.onResume = function() {
      var array = this._anims.array;
      for (var i = 0; i < array.length; ++i) {
        var anim = array[i];
        anim.animator = this;
        anim.resume();
      }
    };
    p._reloadClip = function(state) {
      initClipData(this.target, state);
    };
    function createBatchedProperty(propPath, firstDotIndex, mainValue, animValue) {
      mainValue = mainValue.clone();
      var nextValue = mainValue;
      var leftIndex = firstDotIndex + 1;
      var rightIndex = propPath.indexOf(".", leftIndex);
      while (-1 !== rightIndex) {
        var nextName = propPath.slice(leftIndex, rightIndex);
        nextValue = nextValue[nextName];
        leftIndex = rightIndex + 1;
        rightIndex = propPath.indexOf(".", leftIndex);
      }
      var lastPropName = propPath.slice(leftIndex);
      nextValue[lastPropName] = animValue;
      return mainValue;
    }
    false;
    function initClipData(root, state) {
      var clip = state.clip;
      state.duration = clip.duration;
      state.speed = clip.speed;
      state.wrapMode = clip.wrapMode;
      state.frameRate = clip.sample;
      (state.wrapMode & WrapModeMask.Loop) === WrapModeMask.Loop ? state.repeatCount = Infinity : state.repeatCount = 1;
      var curves = state.curves = clip.createCurves(state, root);
      var events = clip.events;
      if (true, events) {
        var curve;
        for (var i = 0, l = events.length; i < l; i++) {
          if (!curve) {
            curve = new EventAnimCurve();
            curve.target = root;
            curves.push(curve);
          }
          var eventData = events[i];
          var ratio = eventData.frame / state.duration;
          var eventInfo = void 0;
          var index = binarySearch(curve.ratios, ratio);
          if (index >= 0) eventInfo = curve.events[index]; else {
            eventInfo = new EventInfo();
            curve.ratios.push(ratio);
            curve.events.push(eventInfo);
          }
          eventInfo.add(eventData.func, eventData.params);
        }
      }
    }
    false;
    module.exports = AnimationAnimator;
  }), {
    "../core/utils/binary-search": 379,
    "./animation-curves": 12,
    "./playable": 19,
    "./types": 20
  } ],
  11: [ (function(require, module, exports) {
    "use strict";
    var WrapMode = require("./types").WrapMode;
    var _require = require("./animation-curves"), DynamicAnimCurve = _require.DynamicAnimCurve, quickFindIndex = _require.quickFindIndex;
    var sampleMotionPaths = require("./motion-path-helper").sampleMotionPaths;
    var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
    var AnimationClip = cc.Class({
      name: "cc.AnimationClip",
      extends: cc.Asset,
      properties: {
        _duration: {
          default: 0,
          type: cc.Float
        },
        duration: {
          get: function get() {
            return this._duration;
          }
        },
        sample: {
          default: 60
        },
        speed: {
          default: 1
        },
        wrapMode: {
          default: WrapMode.Normal
        },
        curveData: {
          default: {},
          visible: false
        },
        events: {
          default: [],
          visible: false
        }
      },
      statics: {
        createWithSpriteFrames: function createWithSpriteFrames(spriteFrames, sample) {
          if (!Array.isArray(spriteFrames)) {
            cc.errorID(3905);
            return null;
          }
          var clip = new AnimationClip();
          clip.sample = sample || clip.sample;
          clip._duration = spriteFrames.length / clip.sample;
          var frames = [];
          var step = 1 / clip.sample;
          for (var i = 0, l = spriteFrames.length; i < l; i++) frames[i] = {
            frame: i * step,
            value: spriteFrames[i]
          };
          clip.curveData = {
            comps: {
              "cc.Sprite": {
                spriteFrame: frames
              }
            }
          };
          return clip;
        }
      },
      onLoad: function onLoad() {
        this._duration = Number.parseFloat(this.duration);
        this.speed = Number.parseFloat(this.speed);
        this.wrapMode = Number.parseInt(this.wrapMode);
        this.frameRate = Number.parseFloat(this.sample);
      },
      createPropCurve: function createPropCurve(target, propPath, keyframes) {
        var motionPaths = [];
        var isMotionPathProp = target instanceof cc.Node && "position" === propPath;
        var curve = new DynamicAnimCurve();
        curve.target = target;
        curve.prop = propPath;
        for (var i = 0, l = keyframes.length; i < l; i++) {
          var keyframe = keyframes[i];
          var ratio = keyframe.frame / this.duration;
          curve.ratios.push(ratio);
          isMotionPathProp && motionPaths.push(keyframe.motionPath);
          var curveValue = keyframe.value;
          curve.values.push(curveValue);
          var curveTypes = keyframe.curve;
          if (curveTypes) {
            if ("string" === typeof curveTypes) {
              curve.types.push(curveTypes);
              continue;
            }
            if (Array.isArray(curveTypes)) {
              curveTypes[0] === curveTypes[1] && curveTypes[2] === curveTypes[3] ? curve.types.push(DynamicAnimCurve.Linear) : curve.types.push(DynamicAnimCurve.Bezier(curveTypes));
              continue;
            }
          }
          curve.types.push(DynamicAnimCurve.Linear);
        }
        isMotionPathProp && sampleMotionPaths(motionPaths, curve, this.duration, this.sample, target);
        var ratios = curve.ratios;
        var currRatioDif, lastRatioDif;
        var canOptimize = true;
        var EPSILON = 1e-6;
        for (var _i = 1, _l = ratios.length; _i < _l; _i++) {
          currRatioDif = ratios[_i] - ratios[_i - 1];
          if (1 === _i) lastRatioDif = currRatioDif; else if (Math.abs(currRatioDif - lastRatioDif) > EPSILON) {
            canOptimize = false;
            break;
          }
        }
        curve._findFrameIndex = canOptimize ? quickFindIndex : binarySearch;
        var firstValue = curve.values[0];
        void 0 === firstValue || null === firstValue || curve._lerp || ("number" === typeof firstValue ? curve._lerp = DynamicAnimCurve.prototype._lerpNumber : firstValue instanceof cc.Quat ? curve._lerp = DynamicAnimCurve.prototype._lerpQuat : firstValue instanceof cc.Vec2 ? curve._lerp = DynamicAnimCurve.prototype._lerpVector2 : firstValue instanceof cc.Vec3 ? curve._lerp = DynamicAnimCurve.prototype._lerpVector3 : firstValue.lerp && (curve._lerp = DynamicAnimCurve.prototype._lerpObject));
        return curve;
      },
      createTargetCurves: function createTargetCurves(target, curveData, curves) {
        var propsData = curveData.props;
        var compsData = curveData.comps;
        if (propsData) for (var propPath in propsData) {
          var data = propsData[propPath];
          var curve = this.createPropCurve(target, propPath, data);
          curves.push(curve);
        }
        if (compsData) for (var compName in compsData) {
          var comp = target.getComponent(compName);
          if (!comp) continue;
          var compData = compsData[compName];
          for (var _propPath in compData) {
            var _data = compData[_propPath];
            var _curve = this.createPropCurve(comp, _propPath, _data);
            curves.push(_curve);
          }
        }
      },
      createCurves: function createCurves(state, root) {
        var curveData = this.curveData;
        var childrenCurveDatas = curveData.paths;
        var curves = [];
        this.createTargetCurves(root, curveData, curves);
        for (var namePath in childrenCurveDatas) {
          var target = cc.find(namePath, root);
          if (!target) continue;
          var childCurveDatas = childrenCurveDatas[namePath];
          this.createTargetCurves(target, childCurveDatas, curves);
        }
        return curves;
      }
    });
    cc.AnimationClip = module.exports = AnimationClip;
  }), {
    "../core/utils/binary-search": 379,
    "./animation-curves": 12,
    "./motion-path-helper": 18,
    "./types": 20
  } ],
  12: [ (function(require, module, exports) {
    "use strict";
    var bezierByTime = require("./bezier").bezierByTime;
    var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
    var WrapModeMask = require("./types").WrapModeMask;
    var WrappedInfo = require("./types").WrappedInfo;
    function computeRatioByType(ratio, type) {
      if ("string" === typeof type) {
        var func = cc.easing[type];
        func ? ratio = func(ratio) : cc.errorID(3906, type);
      } else Array.isArray(type) && (ratio = bezierByTime(type, ratio));
      return ratio;
    }
    var AnimCurve = cc.Class({
      name: "cc.AnimCurve",
      sample: function sample(time, ratio, state) {},
      onTimeChangedManually: void 0
    });
    function quickFindIndex(ratios, ratio) {
      var length = ratios.length - 1;
      if (0 === length) return 0;
      var start = ratios[0];
      if (ratio < start) return 0;
      var end = ratios[length];
      if (ratio > end) return ~ratios.length;
      ratio = (ratio - start) / (end - start);
      var eachLength = 1 / length;
      var index = ratio / eachLength;
      var floorIndex = 0 | index;
      var EPSILON = 1e-6;
      if (index - floorIndex < EPSILON) return floorIndex;
      if (floorIndex + 1 - index < EPSILON) return floorIndex + 1;
      return ~(floorIndex + 1);
    }
    var DynamicAnimCurve = cc.Class({
      name: "cc.DynamicAnimCurve",
      extends: AnimCurve,
      ctor: function ctor() {
        this._cachedIndex = 0;
      },
      properties: {
        target: null,
        prop: "",
        values: [],
        ratios: [],
        types: []
      },
      _findFrameIndex: binarySearch,
      _lerp: void 0,
      _lerpNumber: function _lerpNumber(from, to, t) {
        return from + (to - from) * t;
      },
      _lerpObject: function _lerpObject(from, to, t) {
        return from.lerp(to, t);
      },
      _lerpQuat: (function() {
        var out = cc.quat();
        return function(from, to, t) {
          return from.lerp(to, t, out);
        };
      })(),
      _lerpVector2: (function() {
        var out = cc.v2();
        return function(from, to, t) {
          return from.lerp(to, t, out);
        };
      })(),
      _lerpVector3: (function() {
        var out = cc.v3();
        return function(from, to, t) {
          return from.lerp(to, t, out);
        };
      })(),
      sample: function sample(time, ratio, state) {
        var values = this.values;
        var ratios = this.ratios;
        var frameCount = ratios.length;
        if (0 === frameCount) return;
        var shoudRefind = true;
        var cachedIndex = this._cachedIndex;
        if (cachedIndex < 0) {
          cachedIndex = ~cachedIndex;
          if (cachedIndex > 0 && cachedIndex < ratios.length) {
            var _fromRatio = ratios[cachedIndex - 1];
            var _toRatio = ratios[cachedIndex];
            ratio > _fromRatio && ratio < _toRatio && (shoudRefind = false);
          }
        }
        shoudRefind && (this._cachedIndex = this._findFrameIndex(ratios, ratio));
        var value;
        var index = this._cachedIndex;
        if (index < 0) {
          index = ~index;
          if (index <= 0) value = values[0]; else if (index >= frameCount) value = values[frameCount - 1]; else {
            var fromVal = values[index - 1];
            if (this._lerp) {
              var fromRatio = ratios[index - 1];
              var toRatio = ratios[index];
              var type = this.types[index - 1];
              var ratioBetweenFrames = (ratio - fromRatio) / (toRatio - fromRatio);
              type && (ratioBetweenFrames = computeRatioByType(ratioBetweenFrames, type));
              var toVal = values[index];
              value = this._lerp(fromVal, toVal, ratioBetweenFrames);
            } else value = fromVal;
          }
        } else value = values[index];
        this.target[this.prop] = value;
      }
    });
    DynamicAnimCurve.Linear = null;
    DynamicAnimCurve.Bezier = function(controlPoints) {
      return controlPoints;
    };
    var EventInfo = function EventInfo() {
      this.events = [];
    };
    EventInfo.prototype.add = function(func, params) {
      this.events.push({
        func: func || "",
        params: params || []
      });
    };
    var EventAnimCurve = cc.Class({
      name: "cc.EventAnimCurve",
      extends: AnimCurve,
      properties: {
        target: null,
        ratios: [],
        events: [],
        _wrappedInfo: {
          default: function _default() {
            return new WrappedInfo();
          }
        },
        _lastWrappedInfo: null,
        _ignoreIndex: NaN
      },
      _wrapIterations: function _wrapIterations(iterations) {
        iterations - (0 | iterations) === 0 && (iterations -= 1);
        return 0 | iterations;
      },
      sample: function sample(time, ratio, state) {
        var length = this.ratios.length;
        var currentWrappedInfo = state.getWrappedInfo(state.time, this._wrappedInfo);
        var direction = currentWrappedInfo.direction;
        var currentIndex = binarySearch(this.ratios, currentWrappedInfo.ratio);
        if (currentIndex < 0) {
          currentIndex = ~currentIndex - 1;
          direction < 0 && (currentIndex += 1);
        }
        this._ignoreIndex !== currentIndex && (this._ignoreIndex = NaN);
        currentWrappedInfo.frameIndex = currentIndex;
        if (!this._lastWrappedInfo) {
          this._fireEvent(currentIndex);
          this._lastWrappedInfo = new WrappedInfo(currentWrappedInfo);
          return;
        }
        var wrapMode = state.wrapMode;
        var currentIterations = this._wrapIterations(currentWrappedInfo.iterations);
        var lastWrappedInfo = this._lastWrappedInfo;
        var lastIterations = this._wrapIterations(lastWrappedInfo.iterations);
        var lastIndex = lastWrappedInfo.frameIndex;
        var lastDirection = lastWrappedInfo.direction;
        var interationsChanged = -1 !== lastIterations && currentIterations !== lastIterations;
        if (lastIndex === currentIndex && interationsChanged && 1 === length) this._fireEvent(0); else if (lastIndex !== currentIndex || interationsChanged) {
          direction = lastDirection;
          do {
            if (lastIndex !== currentIndex) {
              if (-1 === direction && 0 === lastIndex && currentIndex > 0) {
                (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = length;
                lastIterations++;
              } else if (1 === direction && lastIndex === length - 1 && currentIndex < length - 1) {
                (wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong ? direction *= -1 : lastIndex = -1;
                lastIterations++;
              }
              if (lastIndex === currentIndex) break;
              if (lastIterations > currentIterations) break;
            }
            lastIndex += direction;
            cc.director.getAnimationManager().pushDelayEvent(this, "_fireEvent", [ lastIndex ]);
          } while (lastIndex !== currentIndex && lastIndex > -1 && lastIndex < length);
        }
        this._lastWrappedInfo.set(currentWrappedInfo);
      },
      _fireEvent: function _fireEvent(index) {
        if (index < 0 || index >= this.events.length || this._ignoreIndex === index) return;
        var eventInfo = this.events[index];
        var events = eventInfo.events;
        if (!this.target.isValid) return;
        var components = this.target._components;
        for (var i = 0; i < events.length; i++) {
          var event = events[i];
          var funcName = event.func;
          for (var j = 0; j < components.length; j++) {
            var component = components[j];
            var func = component[funcName];
            func && func.apply(component, event.params);
          }
        }
      },
      onTimeChangedManually: function onTimeChangedManually(time, state) {
        this._lastWrappedInfo = null;
        this._ignoreIndex = NaN;
        var info = state.getWrappedInfo(time, this._wrappedInfo);
        var direction = info.direction;
        var frameIndex = binarySearch(this.ratios, info.ratio);
        if (frameIndex < 0) {
          frameIndex = ~frameIndex - 1;
          direction < 0 && (frameIndex += 1);
          this._ignoreIndex = frameIndex;
        }
      }
    });
    false;
    module.exports = {
      AnimCurve: AnimCurve,
      DynamicAnimCurve: DynamicAnimCurve,
      EventAnimCurve: EventAnimCurve,
      EventInfo: EventInfo,
      computeRatioByType: computeRatioByType,
      quickFindIndex: quickFindIndex
    };
  }), {
    "../core/utils/binary-search": 379,
    "./bezier": 15,
    "./types": 20
  } ],
  13: [ (function(require, module, exports) {
    "use strict";
    var js = cc.js;
    var AnimationManager = cc.Class({
      ctor: function ctor() {
        this._anims = new js.array.MutableForwardIterator([]);
        this._delayEvents = [];
        cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
      },
      update: function update(dt) {
        var iterator = this._anims;
        var array = iterator.array;
        for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
          var anim = array[iterator.i];
          anim._isPlaying && !anim._isPaused && anim.update(dt);
        }
        var events = this._delayEvents;
        for (var i = 0; i < events.length; i++) {
          var event = events[i];
          event.target[event.func].apply(event.target, event.args);
        }
        events.length = 0;
      },
      destruct: function destruct() {},
      addAnimation: function addAnimation(anim) {
        var index = this._anims.array.indexOf(anim);
        -1 === index && this._anims.push(anim);
      },
      removeAnimation: function removeAnimation(anim) {
        var index = this._anims.array.indexOf(anim);
        index >= 0 ? this._anims.fastRemoveAt(index) : cc.errorID(3907);
      },
      pushDelayEvent: function pushDelayEvent(target, func, args) {
        this._delayEvents.push({
          target: target,
          func: func,
          args: args
        });
      }
    });
    cc.AnimationManager = module.exports = AnimationManager;
  }), {} ],
  14: [ (function(require, module, exports) {
    "use strict";
    var js = cc.js;
    var Playable = require("./playable");
    var Types = require("./types");
    var WrappedInfo = Types.WrappedInfo;
    var WrapMode = Types.WrapMode;
    var WrapModeMask = Types.WrapModeMask;
    function AnimationState(clip, name) {
      Playable.call(this);
      this._currentFramePlayed = false;
      this._delay = 0;
      this._delayTime = 0;
      this._wrappedInfo = new WrappedInfo();
      this._lastWrappedInfo = null;
      this._process = process;
      this._clip = clip;
      this._name = name || clip && clip.name;
      this.animator = null;
      this.curves = [];
      this.delay = 0;
      this.repeatCount = 1;
      this.duration = 1;
      this.speed = 1;
      this.wrapMode = WrapMode.Normal;
      this.time = 0;
      this._target = null;
      this._lastframeEventOn = false;
      this.emit = function() {
        var args = new Array(arguments.length);
        for (var i = 0, l = args.length; i < l; i++) args[i] = arguments[i];
        cc.director.getAnimationManager().pushDelayEvent(this, "_emit", args);
      };
    }
    js.extend(AnimationState, Playable);
    var proto = AnimationState.prototype;
    proto._emit = function(type, state) {
      this._target && this._target.isValid && this._target.emit(type, type, state);
    };
    proto.on = function(type, callback, target) {
      if (this._target && this._target.isValid) {
        "lastframe" === type && (this._lastframeEventOn = true);
        return this._target.on(type, callback, target);
      }
      return null;
    };
    proto.once = function(type, callback, target) {
      if (this._target && this._target.isValid) {
        "lastframe" === type && (this._lastframeEventOn = true);
        var self = this;
        return this._target.once(type, (function(event) {
          callback.call(target, event);
          self._lastframeEventOn = false;
        }));
      }
      return null;
    };
    proto.off = function(type, callback, target) {
      if (this._target && this._target.isValid) {
        "lastframe" === type && (this._target.hasEventListener(type) || (this._lastframeEventOn = false));
        this._target.off(type, callback, target);
      }
    };
    proto._setEventTarget = function(target) {
      this._target = target;
    };
    proto.onPlay = function() {
      this.setTime(0);
      this._delayTime = this._delay;
      cc.director.getAnimationManager().addAnimation(this);
      this.animator && this.animator.addAnimation(this);
      this.emit("play", this);
    };
    proto.onStop = function() {
      this.isPaused || cc.director.getAnimationManager().removeAnimation(this);
      this.animator && this.animator.removeAnimation(this);
      this.emit("stop", this);
    };
    proto.onResume = function() {
      cc.director.getAnimationManager().addAnimation(this);
      this.emit("resume", this);
    };
    proto.onPause = function() {
      cc.director.getAnimationManager().removeAnimation(this);
      this.emit("pause", this);
    };
    proto.setTime = function(time) {
      this._currentFramePlayed = false;
      this.time = time || 0;
      var curves = this.curves;
      for (var i = 0, l = curves.length; i < l; i++) {
        var curve = curves[i];
        curve.onTimeChangedManually && curve.onTimeChangedManually(time, this);
      }
    };
    function process() {
      var info = this.sample();
      if (this._lastframeEventOn) {
        var lastInfo;
        lastInfo = this._lastWrappedInfo ? this._lastWrappedInfo : this._lastWrappedInfo = new WrappedInfo(info);
        this.repeatCount > 1 && (0 | info.iterations) > (0 | lastInfo.iterations) && this.emit("lastframe", this);
        lastInfo.set(info);
      }
      if (info.stopped) {
        this.stop();
        this.emit("finished", this);
      }
    }
    function simpleProcess() {
      var time = this.time;
      var duration = this.duration;
      if (time > duration) {
        time %= duration;
        0 === time && (time = duration);
      } else if (time < 0) {
        time %= duration;
        0 !== time && (time += duration);
      }
      var ratio = time / duration;
      var curves = this.curves;
      for (var i = 0, len = curves.length; i < len; i++) {
        var curve = curves[i];
        curve.sample(time, ratio, this);
      }
      if (this._lastframeEventOn) {
        void 0 === this._lastIterations && (this._lastIterations = ratio);
        (this.time > 0 && this._lastIterations > ratio || this.time < 0 && this._lastIterations < ratio) && this.emit("lastframe", this);
        this._lastIterations = ratio;
      }
    }
    proto.update = function(delta) {
      if (this._delayTime > 0) {
        this._delayTime -= delta;
        if (this._delayTime > 0) return;
      }
      this._currentFramePlayed ? this.time += delta * this.speed : this._currentFramePlayed = true;
      this._process();
    };
    proto._needRevers = function(currentIterations) {
      var wrapMode = this.wrapMode;
      var needRevers = false;
      if ((wrapMode & WrapModeMask.PingPong) === WrapModeMask.PingPong) {
        var isEnd = currentIterations - (0 | currentIterations) === 0;
        isEnd && currentIterations > 0 && (currentIterations -= 1);
        var isOddIteration = 1 & currentIterations;
        isOddIteration && (needRevers = !needRevers);
      }
      (wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse && (needRevers = !needRevers);
      return needRevers;
    };
    proto.getWrappedInfo = function(time, info) {
      info = info || new WrappedInfo();
      var stopped = false;
      var duration = this.duration;
      var repeatCount = this.repeatCount;
      var currentIterations = time > 0 ? time / duration : -time / duration;
      if (currentIterations >= repeatCount) {
        currentIterations = repeatCount;
        stopped = true;
        var tempRatio = repeatCount - (0 | repeatCount);
        0 === tempRatio && (tempRatio = 1);
        time = tempRatio * duration * (time > 0 ? 1 : -1);
      }
      if (time > duration) {
        var tempTime = time % duration;
        time = 0 === tempTime ? duration : tempTime;
      } else if (time < 0) {
        time %= duration;
        0 !== time && (time += duration);
      }
      var needRevers = false;
      var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
      shouldWrap && (needRevers = this._needRevers(currentIterations));
      var direction = needRevers ? -1 : 1;
      this.speed < 0 && (direction *= -1);
      shouldWrap && needRevers && (time = duration - time);
      info.ratio = time / duration;
      info.time = time;
      info.direction = direction;
      info.stopped = stopped;
      info.iterations = currentIterations;
      return info;
    };
    proto.sample = function() {
      var info = this.getWrappedInfo(this.time, this._wrappedInfo);
      var curves = this.curves;
      for (var i = 0, len = curves.length; i < len; i++) {
        var curve = curves[i];
        curve.sample(info.time, info.ratio, this);
      }
      return info;
    };
    js.get(proto, "clip", (function() {
      return this._clip;
    }));
    js.get(proto, "name", (function() {
      return this._name;
    }));
    js.obsolete(proto, "AnimationState.length", "duration");
    js.getset(proto, "curveLoaded", (function() {
      return this.curves.length > 0;
    }), (function() {
      this.curves.length = 0;
    }));
    js.getset(proto, "wrapMode", (function() {
      return this._wrapMode;
    }), (function(value) {
      this._wrapMode = value;
      false;
      this.time = 0;
      value & WrapModeMask.Loop ? this.repeatCount = Infinity : this.repeatCount = 1;
    }));
    js.getset(proto, "repeatCount", (function() {
      return this._repeatCount;
    }), (function(value) {
      this._repeatCount = value;
      var shouldWrap = this._wrapMode & WrapModeMask.ShouldWrap;
      var reverse = (this.wrapMode & WrapModeMask.Reverse) === WrapModeMask.Reverse;
      this._process = Infinity !== value || shouldWrap || reverse ? process : simpleProcess;
    }));
    js.getset(proto, "delay", (function() {
      return this._delay;
    }), (function(value) {
      this._delayTime = this._delay = value;
    }));
    cc.AnimationState = module.exports = AnimationState;
  }), {
    "./playable": 19,
    "./types": 20
  } ],
  15: [ (function(require, module, exports) {
    "use strict";
    function bezier(C1, C2, C3, C4, t) {
      var t1 = 1 - t;
      return t1 * (t1 * (C1 + (3 * C2 - C1) * t) + 3 * C3 * t * t) + C4 * t * t * t;
    }
    var cos = Math.cos, acos = Math.acos, max = Math.max, pi = Math.PI, tau = 2 * pi, sqrt = Math.sqrt;
    function crt(v) {
      return v < 0 ? -Math.pow(-v, 1 / 3) : Math.pow(v, 1 / 3);
    }
    function cardano(curve, x) {
      var pa = x - 0;
      var pb = x - curve[0];
      var pc = x - curve[2];
      var pd = x - 1;
      var pa3 = 3 * pa;
      var pb3 = 3 * pb;
      var pc3 = 3 * pc;
      var d = -pa + pb3 - pc3 + pd, rd = 1 / d, r3 = 1 / 3, a = (pa3 - 6 * pb + pc3) * rd, a3 = a * r3, b = (-pa3 + pb3) * rd, c = pa * rd, p = (3 * b - a * a) * r3, p3 = p * r3, q = (2 * a * a * a - 9 * a * b + 27 * c) / 27, q2 = q / 2, discriminant = q2 * q2 + p3 * p3 * p3, u1, v1, x1, x2, x3;
      if (discriminant < 0) {
        var mp3 = -p * r3, mp33 = mp3 * mp3 * mp3, r = sqrt(mp33), t = -q / (2 * r), cosphi = t < -1 ? -1 : t > 1 ? 1 : t, phi = acos(cosphi), crtr = crt(r), t1 = 2 * crtr;
        x1 = t1 * cos(phi * r3) - a3;
        x2 = t1 * cos((phi + tau) * r3) - a3;
        x3 = t1 * cos((phi + 2 * tau) * r3) - a3;
        return 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max(x1, x2, x3) : max(x1, x2) : 0 <= x3 && x3 <= 1 ? max(x1, x3) : x1 : 0 <= x2 && x2 <= 1 ? 0 <= x3 && x3 <= 1 ? max(x2, x3) : x2 : x3;
      }
      if (0 === discriminant) {
        u1 = q2 < 0 ? crt(-q2) : -crt(q2);
        x1 = 2 * u1 - a3;
        x2 = -u1 - a3;
        return 0 <= x1 && x1 <= 1 ? 0 <= x2 && x2 <= 1 ? max(x1, x2) : x1 : x2;
      }
      var sd = sqrt(discriminant);
      u1 = crt(-q2 + sd);
      v1 = crt(q2 + sd);
      x1 = u1 - v1 - a3;
      return x1;
    }
    function bezierByTime(controlPoints, x) {
      var percent = cardano(controlPoints, x);
      var p1y = controlPoints[1];
      var p2y = controlPoints[3];
      return ((1 - percent) * (p1y + (p2y - p1y) * percent) * 3 + percent * percent) * percent;
    }
    false;
    module.exports = {
      bezier: bezier,
      bezierByTime: bezierByTime
    };
  }), {} ],
  16: [ (function(require, module, exports) {
    "use strict";
    var easing = {
      constant: function constant() {
        return 0;
      },
      linear: function linear(k) {
        return k;
      },
      quadIn: function quadIn(k) {
        return k * k;
      },
      quadOut: function quadOut(k) {
        return k * (2 - k);
      },
      quadInOut: function quadInOut(k) {
        if ((k *= 2) < 1) return .5 * k * k;
        return -.5 * (--k * (k - 2) - 1);
      },
      cubicIn: function cubicIn(k) {
        return k * k * k;
      },
      cubicOut: function cubicOut(k) {
        return --k * k * k + 1;
      },
      cubicInOut: function cubicInOut(k) {
        if ((k *= 2) < 1) return .5 * k * k * k;
        return .5 * ((k -= 2) * k * k + 2);
      },
      quartIn: function quartIn(k) {
        return k * k * k * k;
      },
      quartOut: function quartOut(k) {
        return 1 - --k * k * k * k;
      },
      quartInOut: function quartInOut(k) {
        if ((k *= 2) < 1) return .5 * k * k * k * k;
        return -.5 * ((k -= 2) * k * k * k - 2);
      },
      quintIn: function quintIn(k) {
        return k * k * k * k * k;
      },
      quintOut: function quintOut(k) {
        return --k * k * k * k * k + 1;
      },
      quintInOut: function quintInOut(k) {
        if ((k *= 2) < 1) return .5 * k * k * k * k * k;
        return .5 * ((k -= 2) * k * k * k * k + 2);
      },
      sineIn: function sineIn(k) {
        return 1 - Math.cos(k * Math.PI / 2);
      },
      sineOut: function sineOut(k) {
        return Math.sin(k * Math.PI / 2);
      },
      sineInOut: function sineInOut(k) {
        return .5 * (1 - Math.cos(Math.PI * k));
      },
      expoIn: function expoIn(k) {
        return 0 === k ? 0 : Math.pow(1024, k - 1);
      },
      expoOut: function expoOut(k) {
        return 1 === k ? 1 : 1 - Math.pow(2, -10 * k);
      },
      expoInOut: function expoInOut(k) {
        if (0 === k) return 0;
        if (1 === k) return 1;
        if ((k *= 2) < 1) return .5 * Math.pow(1024, k - 1);
        return .5 * (2 - Math.pow(2, -10 * (k - 1)));
      },
      circIn: function circIn(k) {
        return 1 - Math.sqrt(1 - k * k);
      },
      circOut: function circOut(k) {
        return Math.sqrt(1 - --k * k);
      },
      circInOut: function circInOut(k) {
        if ((k *= 2) < 1) return -.5 * (Math.sqrt(1 - k * k) - 1);
        return .5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
      },
      elasticIn: function elasticIn(k) {
        var s, a = .1, p = .4;
        if (0 === k) return 0;
        if (1 === k) return 1;
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else s = p * Math.asin(1 / a) / (2 * Math.PI);
        return -a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p);
      },
      elasticOut: function elasticOut(k) {
        var s, a = .1, p = .4;
        if (0 === k) return 0;
        if (1 === k) return 1;
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else s = p * Math.asin(1 / a) / (2 * Math.PI);
        return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
      },
      elasticInOut: function elasticInOut(k) {
        var s, a = .1, p = .4;
        if (0 === k) return 0;
        if (1 === k) return 1;
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else s = p * Math.asin(1 / a) / (2 * Math.PI);
        if ((k *= 2) < 1) return a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * -.5;
        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * .5 + 1;
      },
      backIn: function backIn(k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
      },
      backOut: function backOut(k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      },
      backInOut: function backInOut(k) {
        var s = 2.5949095;
        if ((k *= 2) < 1) return k * k * ((s + 1) * k - s) * .5;
        return .5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
      },
      bounceIn: function bounceIn(k) {
        return 1 - easing.bounceOut(1 - k);
      },
      bounceOut: function bounceOut(k) {
        return k < 1 / 2.75 ? 7.5625 * k * k : k < 2 / 2.75 ? 7.5625 * (k -= 1.5 / 2.75) * k + .75 : k < 2.5 / 2.75 ? 7.5625 * (k -= 2.25 / 2.75) * k + .9375 : 7.5625 * (k -= 2.625 / 2.75) * k + .984375;
      },
      bounceInOut: function bounceInOut(k) {
        if (k < .5) return .5 * easing.bounceIn(2 * k);
        return .5 * easing.bounceOut(2 * k - 1) + .5;
      },
      smooth: function smooth(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        return t * t * (3 - 2 * t);
      },
      fade: function fade(t) {
        if (t <= 0) return 0;
        if (t >= 1) return 1;
        return t * t * t * (t * (6 * t - 15) + 10);
      }
    };
    function _makeOutIn(fnIn, fnOut) {
      return function(k) {
        if (k < .5) return fnOut(2 * k) / 2;
        return fnIn(2 * k - 1) / 2 + .5;
      };
    }
    easing.quadOutIn = _makeOutIn(easing.quadIn, easing.quadOut);
    easing.cubicOutIn = _makeOutIn(easing.cubicIn, easing.cubicOut);
    easing.quartOutIn = _makeOutIn(easing.quartIn, easing.quartOut);
    easing.quintOutIn = _makeOutIn(easing.quintIn, easing.quintOut);
    easing.sineOutIn = _makeOutIn(easing.sineIn, easing.sineOut);
    easing.expoOutIn = _makeOutIn(easing.expoIn, easing.expoOut);
    easing.circOutIn = _makeOutIn(easing.circIn, easing.circOut);
    easing.backOutIn = _makeOutIn(easing.backIn, easing.backOut);
    easing.bounceIn = function(k) {
      return 1 - easing.bounceOut(1 - k);
    };
    easing.bounceInOut = function(k) {
      if (k < .5) return .5 * easing.bounceIn(2 * k);
      return .5 * easing.bounceOut(2 * k - 1) + .5;
    };
    easing.bounceOutIn = _makeOutIn(easing.bounceIn, easing.bounceOut);
    cc.easing = module.exports = easing;
  }), {} ],
  17: [ (function(require, module, exports) {
    "use strict";
    require("./bezier");
    require("./easing");
    require("./types");
    require("./motion-path-helper");
    require("./animation-curves");
    require("./animation-clip");
    require("./animation-manager");
    require("./animation-state");
    require("./animation-animator");
  }), {
    "./animation-animator": 10,
    "./animation-clip": 11,
    "./animation-curves": 12,
    "./animation-manager": 13,
    "./animation-state": 14,
    "./bezier": 15,
    "./easing": 16,
    "./motion-path-helper": 18,
    "./types": 20
  } ],
  18: [ (function(require, module, exports) {
    "use strict";
    var DynamicAnimCurve = require("./animation-curves").DynamicAnimCurve;
    var computeRatioByType = require("./animation-curves").computeRatioByType;
    var bezier = require("./bezier").bezier;
    var binarySearch = require("../core/utils/binary-search").binarySearchEpsilon;
    var v2 = cc.v2;
    function Curve(points) {
      this.points = points || [];
      this.beziers = [];
      this.ratios = [];
      this.progresses = [];
      this.length = 0;
      this.computeBeziers();
    }
    Curve.prototype.computeBeziers = function() {
      this.beziers.length = 0;
      this.ratios.length = 0;
      this.progresses.length = 0;
      this.length = 0;
      var bezier;
      for (var i = 1; i < this.points.length; i++) {
        var startPoint = this.points[i - 1];
        var endPoint = this.points[i];
        bezier = new Bezier();
        bezier.start = startPoint.pos;
        bezier.startCtrlPoint = startPoint.out;
        bezier.end = endPoint.pos;
        bezier.endCtrlPoint = endPoint["in"];
        this.beziers.push(bezier);
        this.length += bezier.getLength();
      }
      var current = 0;
      for (var i = 0; i < this.beziers.length; i++) {
        bezier = this.beziers[i];
        this.ratios[i] = bezier.getLength() / this.length;
        this.progresses[i] = current += this.ratios[i];
      }
      return this.beziers;
    };
    function Bezier() {
      this.start = v2();
      this.end = v2();
      this.startCtrlPoint = v2();
      this.endCtrlPoint = v2();
    }
    Bezier.prototype.getPointAt = function(u) {
      var t = this.getUtoTmapping(u);
      return this.getPoint(t);
    };
    Bezier.prototype.getPoint = function(t) {
      var x = bezier(this.start.x, this.startCtrlPoint.x, this.endCtrlPoint.x, this.end.x, t);
      var y = bezier(this.start.y, this.startCtrlPoint.y, this.endCtrlPoint.y, this.end.y, t);
      return new v2(x, y);
    };
    Bezier.prototype.getLength = function() {
      var lengths = this.getLengths();
      return lengths[lengths.length - 1];
    };
    Bezier.prototype.getLengths = function(divisions) {
      divisions || (divisions = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
      if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1) return this.cacheArcLengths;
      var cache = [];
      var current, last = this.getPoint(0), vector = v2();
      var p, sum = 0;
      cache.push(0);
      for (p = 1; p <= divisions; p++) {
        current = this.getPoint(p / divisions);
        vector.x = last.x - current.x;
        vector.y = last.y - current.y;
        sum += vector.mag();
        cache.push(sum);
        last = current;
      }
      this.cacheArcLengths = cache;
      return cache;
    };
    Bezier.prototype.getUtoTmapping = function(u, distance) {
      var arcLengths = this.getLengths();
      var i = 0, il = arcLengths.length;
      var targetArcLength;
      targetArcLength = distance || u * arcLengths[il - 1];
      var low = 0, high = il - 1, comparison;
      while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
          low = i + 1;
          continue;
        }
        if (comparison > 0) {
          high = i - 1;
          continue;
        }
        high = i;
        break;
      }
      i = high;
      if (arcLengths[i] === targetArcLength) {
        var t = i / (il - 1);
        return t;
      }
      var lengthBefore = arcLengths[i];
      var lengthAfter = arcLengths[i + 1];
      var segmentLength = lengthAfter - lengthBefore;
      var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      var t = (i + segmentFraction) / (il - 1);
      return t;
    };
    function checkMotionPath(motionPath) {
      if (!Array.isArray(motionPath)) return false;
      for (var i = 0, l = motionPath.length; i < l; i++) {
        var controls = motionPath[i];
        if (!Array.isArray(controls) || 6 !== controls.length) return false;
      }
      return true;
    }
    function sampleMotionPaths(motionPaths, data, duration, fps, target) {
      function createControlPoints(array) {
        if (array instanceof cc.Vec2) return {
          in: array,
          pos: array,
          out: array
        };
        if (Array.isArray(array) && 6 === array.length) return {
          in: v2(array[2], array[3]),
          pos: v2(array[0], array[1]),
          out: v2(array[4], array[5])
        };
        return {
          in: cc.Vec2.ZERO,
          pos: cc.Vec2.ZERO,
          out: cc.Vec2.ZERO
        };
      }
      var values = data.values = data.values.map((function(value) {
        Array.isArray(value) && (value = 2 === value.length ? cc.v2(value[0], value[1]) : cc.v3(value[0], value[1], value[2]));
        return value;
      }));
      if (0 === motionPaths.length || 0 === values.length) return;
      var motionPathValid = false;
      for (var _i = 0; _i < motionPaths.length; _i++) {
        var _motionPath = motionPaths[_i];
        if (_motionPath && !checkMotionPath(_motionPath)) {
          cc.errorID(3904, target ? target.name : "", "position", _i);
          _motionPath = null;
        }
        if (_motionPath && _motionPath.length > 0) {
          motionPathValid = true;
          break;
        }
      }
      if (!motionPathValid) return;
      if (1 === values.length) return;
      var types = data.types;
      var ratios = data.ratios;
      var newValues = data.values = [];
      var newTypes = data.types = [];
      var newRatios = data.ratios = [];
      function addNewDatas(value, type, ratio) {
        newValues.push(value);
        newTypes.push(type);
        newRatios.push(ratio);
      }
      var startRatioOffset = 0;
      var EPSILON = 1e-6;
      var newType = DynamicAnimCurve.Linear;
      for (var i = 0, l = motionPaths.length; i < l - 1; i++) {
        var motionPath = motionPaths[i];
        var ratio = ratios[i];
        var nextRatio = ratios[i + 1];
        var betweenRatio = nextRatio - ratio;
        var value = values[i];
        var nextValue = values[i + 1];
        var type = types[i];
        var results = [];
        var progress = startRatioOffset / betweenRatio;
        var speed = 1 / (betweenRatio * duration * fps);
        var finalProgress;
        if (motionPath && motionPath.length > 0) {
          var points = [];
          points.push(createControlPoints(value));
          for (var j = 0, l2 = motionPath.length; j < l2; j++) {
            var controlPoints = createControlPoints(motionPath[j]);
            points.push(controlPoints);
          }
          points.push(createControlPoints(nextValue));
          var curve = new Curve(points);
          curve.computeBeziers();
          var progresses = curve.progresses;
          while (1 - progress > EPSILON) {
            finalProgress = progress;
            finalProgress = computeRatioByType(finalProgress, type);
            var pos, bezier, normal, length;
            if (finalProgress < 0) {
              bezier = curve.beziers[0];
              length = (0 - finalProgress) * bezier.getLength();
              normal = bezier.start.sub(bezier.endCtrlPoint).normalize();
              pos = bezier.start.add(normal.mul(length));
            } else if (finalProgress > 1) {
              bezier = curve.beziers[curve.beziers.length - 1];
              length = (finalProgress - 1) * bezier.getLength();
              normal = bezier.end.sub(bezier.startCtrlPoint).normalize();
              pos = bezier.end.add(normal.mul(length));
            } else {
              var bezierIndex = binarySearch(progresses, finalProgress);
              bezierIndex < 0 && (bezierIndex = ~bezierIndex);
              finalProgress -= bezierIndex > 0 ? progresses[bezierIndex - 1] : 0;
              finalProgress /= curve.ratios[bezierIndex];
              pos = curve.beziers[bezierIndex].getPointAt(finalProgress);
            }
            results.push(pos);
            progress += speed;
          }
        } else while (1 - progress > EPSILON) {
          finalProgress = progress;
          finalProgress = computeRatioByType(finalProgress, type);
          results.push(value.lerp(nextValue, finalProgress));
          progress += speed;
        }
        newType = "constant" === type ? type : DynamicAnimCurve.Linear;
        for (var j = 0, l2 = results.length; j < l2; j++) {
          var newRatio = ratio + startRatioOffset + speed * j * betweenRatio;
          addNewDatas(results[j], newType, newRatio);
        }
        startRatioOffset = Math.abs(progress - 1) > EPSILON ? (progress - 1) * betweenRatio : 0;
      }
      ratios[ratios.length - 1] !== newRatios[newRatios.length - 1] && addNewDatas(values[values.length - 1], newType, ratios[ratios.length - 1]);
    }
    false;
    module.exports = {
      sampleMotionPaths: sampleMotionPaths,
      Curve: Curve,
      Bezier: Bezier
    };
  }), {
    "../core/utils/binary-search": 379,
    "./animation-curves": 12,
    "./bezier": 15
  } ],
  19: [ (function(require, module, exports) {
    "use strict";
    var js = cc.js;
    var debug = require("../core/CCDebug");
    function Playable() {
      this._isPlaying = false;
      this._isPaused = false;
      this._stepOnce = false;
    }
    var prototype = Playable.prototype;
    js.get(prototype, "isPlaying", (function() {
      return this._isPlaying;
    }), true);
    js.get(prototype, "isPaused", (function() {
      return this._isPaused;
    }), true);
    var virtual = function virtual() {};
    prototype.onPlay = virtual;
    prototype.onPause = virtual;
    prototype.onResume = virtual;
    prototype.onStop = virtual;
    prototype.onError = virtual;
    prototype.play = function() {
      if (this._isPlaying) if (this._isPaused) {
        this._isPaused = false;
        this.onResume();
      } else this.onError(debug.getError(3912)); else {
        this._isPlaying = true;
        this.onPlay();
      }
    };
    prototype.stop = function() {
      if (this._isPlaying) {
        this._isPlaying = false;
        this.onStop();
        this._isPaused = false;
      }
    };
    prototype.pause = function() {
      if (this._isPlaying && !this._isPaused) {
        this._isPaused = true;
        this.onPause();
      }
    };
    prototype.resume = function() {
      if (this._isPlaying && this._isPaused) {
        this._isPaused = false;
        this.onResume();
      }
    };
    prototype.step = function() {
      this.pause();
      this._stepOnce = true;
      this._isPlaying || this.play();
    };
    module.exports = Playable;
  }), {
    "../core/CCDebug": 101
  } ],
  20: [ (function(require, module, exports) {
    "use strict";
    var WrapModeMask = {
      Loop: 2,
      ShouldWrap: 4,
      PingPong: 22,
      Reverse: 36
    };
    var WrapMode = cc.Enum({
      Default: 0,
      Normal: 1,
      Reverse: WrapModeMask.Reverse,
      Loop: WrapModeMask.Loop,
      LoopReverse: WrapModeMask.Loop | WrapModeMask.Reverse,
      PingPong: WrapModeMask.PingPong,
      PingPongReverse: WrapModeMask.PingPong | WrapModeMask.Reverse
    });
    cc.WrapMode = WrapMode;
    function WrappedInfo(info) {
      if (info) {
        this.set(info);
        return;
      }
      this.ratio = 0;
      this.time = 0;
      this.direction = 1;
      this.stopped = true;
      this.iterations = 0;
      this.frameIndex = void 0;
    }
    WrappedInfo.prototype.set = function(info) {
      this.ratio = info.ratio;
      this.time = info.time;
      this.direction = info.direction;
      this.stopped = info.stopped;
      this.iterations = info.iterations;
      this.frameIndex = info.frameIndex;
    };
    module.exports = {
      WrapModeMask: WrapModeMask,
      WrapMode: WrapMode,
      WrappedInfo: WrappedInfo
    };
  }), {} ],
  21: [ (function(require, module, exports) {
    "use strict";
    var EventTarget = require("../core/event/event-target");
    var sys = require("../core/platform/CCSys");
    var LoadMode = require("../core/assets/CCAudioClip").LoadMode;
    var touchBinded = false;
    var touchPlayList = [];
    var Audio = function Audio(src) {
      EventTarget.call(this);
      this._shouldRecycleOnEnded = false;
      this._src = src;
      this._element = null;
      this.id = 0;
      this._state = Audio.State.INITIALZING;
      var self = this;
      this._onended = function() {
        self._state = Audio.State.STOPPED;
        self.emit("ended");
      };
      this._onendedSecond = function() {
        self._unbindEnded(self._onendedSecond);
        self._bindEnded();
      };
    };
    cc.js.extend(Audio, EventTarget);
    Audio.State = {
      ERROR: -1,
      INITIALZING: 0,
      PLAYING: 1,
      PAUSED: 2,
      STOPPED: 3
    };
    (function(proto) {
      proto._bindEnded = function(callback) {
        callback = callback || this._onended;
        if (callback._binded) return;
        callback._binded = true;
        var elem = this._element;
        this._src && elem instanceof HTMLAudioElement ? elem.addEventListener("ended", callback) : elem.onended = callback;
      };
      proto._unbindEnded = function(callback) {
        callback = callback || this._onended;
        if (!callback._binded) return;
        callback._binded = false;
        var elem = this._element;
        elem instanceof HTMLAudioElement ? elem.removeEventListener("ended", callback) : elem && (elem.onended = null);
      };
      proto._onLoaded = function() {
        this._createElement();
        this._state = Audio.State.INITIALZING;
        this.setVolume(1);
        this.setLoop(false);
      };
      proto._createElement = function() {
        var elem = this._src._nativeAsset;
        if (elem instanceof HTMLAudioElement) {
          this._element || (this._element = document.createElement("audio"));
          this._element.src = elem.src;
        } else this._element = new WebAudioElement(elem, this);
      };
      proto.play = function() {
        var self = this;
        this._src && this._src._ensureLoaded((function() {
          self._state = Audio.State.PLAYING;
          self._bindEnded();
          var playPromise = self._element.play();
          window.Promise && playPromise instanceof Promise && playPromise["catch"]((function(err) {}));
          self._touchToPlay();
        }));
      };
      proto._touchToPlay = function() {
        this._src && this._src.loadMode === LoadMode.DOM_AUDIO && this._element.paused && touchPlayList.push({
          instance: this,
          offset: 0,
          audio: this._element
        });
        if (touchBinded) return;
        touchBinded = true;
        var touchEventName = "ontouchend" in window ? "touchend" : "mousedown";
        cc.game.canvas.addEventListener(touchEventName, (function() {
          var item;
          while (item = touchPlayList.pop()) item.audio.play(item.offset);
        }));
      };
      proto.destroy = function() {
        this._element = null;
      };
      proto.pause = function() {
        if (this.getState() !== Audio.State.PLAYING) return;
        var self = this;
        this._src && this._src._ensureLoaded((function() {
          self._unbindEnded();
          self._element.pause();
          self._state = Audio.State.PAUSED;
        }));
      };
      proto.resume = function() {
        if (this.getState() !== Audio.State.PAUSED) return;
        var self = this;
        this._src && this._src._ensureLoaded((function() {
          self._bindEnded();
          self._element.play();
          self._state = Audio.State.PLAYING;
        }));
      };
      proto.stop = function() {
        var self = this;
        this._src && this._src._ensureLoaded((function() {
          self._element.pause();
          self._element.currentTime = 0;
          for (var i = 0; i < touchPlayList.length; i++) if (touchPlayList[i].instance === self) {
            touchPlayList.splice(i, 1);
            break;
          }
          self._unbindEnded();
          self.emit("stop");
          self._state = Audio.State.STOPPED;
        }));
      };
      proto.setLoop = function(loop) {
        var self = this;
        this._src && this._src._ensureLoaded((function() {
          self._element.loop = loop;
        }));
      };
      proto.getLoop = function() {
        return !!this._element && this._element.loop;
      };
      proto.setVolume = function(num) {
        var self = this;
        this._src && this._src._ensureLoaded((function() {
          self._element.volume = num;
        }));
      };
      proto.getVolume = function() {
        return this._element ? this._element.volume : 1;
      };
      proto.setCurrentTime = function(num) {
        var self = this;
        this._src && this._src._ensureLoaded((function() {
          self._unbindEnded();
          self._bindEnded(self._onendedSecond);
          self._element.currentTime = num;
        }));
      };
      proto.getCurrentTime = function() {
        return this._element ? this._element.currentTime : 0;
      };
      proto.getDuration = function() {
        return this._src ? this._src.duration : 0;
      };
      proto.getState = function(forceUpdating) {
        void 0 === forceUpdating && (forceUpdating = true);
        forceUpdating && this._forceUpdatingState();
        return this._state;
      };
      proto._forceUpdatingState = function() {
        var elem = this._element;
        elem && (Audio.State.PLAYING === this._state && elem.paused ? this._state = Audio.State.STOPPED : Audio.State.STOPPED !== this._state || elem.paused || (this._state = Audio.State.PLAYING));
      };
      Object.defineProperty(proto, "src", {
        get: function get() {
          return this._src;
        },
        set: function set(clip) {
          this._unbindEnded();
          if (clip && clip.isValid) {
            if (clip !== this._src) {
              this._src = clip;
              if (clip.loaded) this._onLoaded(); else {
                var self = this;
                clip.once("load", (function() {
                  clip === self._src && self._onLoaded();
                }));
              }
            }
          } else {
            this._src = null;
            this._element instanceof WebAudioElement ? this._element = null : this._element && (this._element.src = "");
            this._state = Audio.State.INITIALZING;
          }
          return clip;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(proto, "paused", {
        get: function get() {
          return !this._element || this._element.paused;
        },
        enumerable: true,
        configurable: true
      });
    })(Audio.prototype);
    var TIME_CONSTANT;
    TIME_CONSTANT = cc.sys.browserType === cc.sys.BROWSER_TYPE_EDGE || cc.sys.browserType === cc.sys.BROWSER_TYPE_BAIDU || cc.sys.browserType === cc.sys.BROWSER_TYPE_UC ? .01 : 0;
    var WebAudioElement = function WebAudioElement(buffer, audio) {
      this._audio = audio;
      this._context = sys.__audioSupport.context;
      this._buffer = buffer;
      this._gainObj = this._context["createGain"]();
      this.volume = 1;
      this._gainObj["connect"](this._context["destination"]);
      this._loop = false;
      this._startTime = -1;
      this._currentSource = null;
      this.playedLength = 0;
      this._currentTimer = null;
      this._endCallback = function() {
        this.onended && this.onended(this);
      }.bind(this);
    };
    (function(proto) {
      proto.play = function(offset) {
        if (this._currentSource && !this.paused) {
          this._currentSource.onended = null;
          this._currentSource.stop(0);
          this.playedLength = 0;
        }
        var audio = this._context["createBufferSource"]();
        audio.buffer = this._buffer;
        audio["connect"](this._gainObj);
        audio.loop = this._loop;
        this._startTime = this._context.currentTime;
        offset = offset || this.playedLength;
        offset && (this._startTime -= offset);
        var duration = this._buffer.duration;
        var startTime = offset;
        var endTime;
        if (this._loop) audio.start ? audio.start(0, startTime) : audio["notoGrainOn"] ? audio["noteGrainOn"](0, startTime) : audio["noteOn"](0, startTime); else {
          endTime = duration - offset;
          audio.start ? audio.start(0, startTime, endTime) : audio["noteGrainOn"] ? audio["noteGrainOn"](0, startTime, endTime) : audio["noteOn"](0, startTime, endTime);
        }
        this._currentSource = audio;
        audio.onended = this._endCallback;
        if ((!audio.context.state || "suspended" === audio.context.state) && 0 === this._context.currentTime) {
          var self = this;
          clearTimeout(this._currentTimer);
          this._currentTimer = setTimeout((function() {
            0 === self._context.currentTime && touchPlayList.push({
              instance: self._audio,
              offset: offset,
              audio: self
            });
          }), 10);
        }
        var sys = cc.sys;
        sys.os === sys.OS_IOS && sys.isBrowser && sys.isMobile && ("suspended" === audio.context.state && 0 !== this._context.currentTime || "interrupted" === audio.context.state) && audio.context.resume();
      };
      proto.pause = function() {
        clearTimeout(this._currentTimer);
        if (this.paused) return;
        this.playedLength = this._context.currentTime - this._startTime;
        this.playedLength %= this._buffer.duration;
        var audio = this._currentSource;
        if (audio) {
          if (audio.onended) {
            audio.onended._binded = false;
            audio.onended = null;
          }
          audio.stop(0);
        }
        this._currentSource = null;
        this._startTime = -1;
      };
      Object.defineProperty(proto, "paused", {
        get: function get() {
          if (this._currentSource && this._currentSource.loop) return false;
          if (-1 === this._startTime) return true;
          return this._context.currentTime - this._startTime > this._buffer.duration;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(proto, "loop", {
        get: function get() {
          return this._loop;
        },
        set: function set(bool) {
          this._currentSource && (this._currentSource.loop = bool);
          return this._loop = bool;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(proto, "volume", {
        get: function get() {
          return this._volume;
        },
        set: function set(num) {
          this._volume = num;
          if (this._gainObj.gain.setTargetAtTime) try {
            this._gainObj.gain.setTargetAtTime(num, this._context.currentTime, TIME_CONSTANT);
          } catch (e) {
            this._gainObj.gain.setTargetAtTime(num, this._context.currentTime, .01);
          } else this._gainObj.gain.value = num;
          if (sys.os === sys.OS_IOS && !this.paused && this._currentSource) {
            this._currentSource.onended = null;
            this.pause();
            this.play();
          }
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(proto, "currentTime", {
        get: function get() {
          if (this.paused) return this.playedLength;
          this.playedLength = this._context.currentTime - this._startTime;
          this.playedLength %= this._buffer.duration;
          return this.playedLength;
        },
        set: function set(num) {
          if (this.paused) this.playedLength = num; else {
            this.pause();
            this.playedLength = num;
            this.play();
          }
          return num;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(proto, "duration", {
        get: function get() {
          return this._buffer.duration;
        },
        enumerable: true,
        configurable: true
      });
    })(WebAudioElement.prototype);
    module.exports = cc._Audio = Audio;
  }), {
    "../core/assets/CCAudioClip": 138,
    "../core/event/event-target": 219,
    "../core/platform/CCSys": 281
  } ],
  22: [ (function(require, module, exports) {
    "use strict";
    var Audio = require("./CCAudio");
    var AudioClip = require("../core/assets/CCAudioClip");
    var js = cc.js;
    var _instanceId = 0;
    var _id2audio = js.createMap(true);
    var _url2id = {};
    var _audioPool = [];
    var recycleAudio = function recycleAudio(audio) {
      if (!audio._shouldRecycleOnEnded) return;
      audio._finishCallback = null;
      audio.off("ended");
      audio.off("stop");
      audio.src = null;
      _audioPool.includes(audio) || (_audioPool.length < audioEngine._maxPoolSize ? _audioPool.push(audio) : audio.destroy());
      audio._shouldRecycleOnEnded = false;
    };
    var getAudioFromPath = function getAudioFromPath(path) {
      var id = ++_instanceId;
      var list = _url2id[path];
      list || (list = _url2id[path] = []);
      if (audioEngine._maxAudioInstance <= list.length) {
        var oldId = list.shift();
        var oldAudio = getAudioFromId(oldId);
        oldAudio.stop();
      }
      var audio = _audioPool.pop() || new Audio();
      var callback = function callback() {
        var audioInList = getAudioFromId(this.id);
        if (audioInList) {
          delete _id2audio[this.id];
          var index = list.indexOf(this.id);
          cc.js.array.fastRemoveAt(list, index);
        }
        recycleAudio(this);
      };
      audio.on("ended", (function() {
        this._finishCallback && this._finishCallback();
        this.getLoop() || callback.call(this);
      }), audio);
      audio.on("stop", callback, audio);
      audio.id = id;
      _id2audio[id] = audio;
      list.push(id);
      return audio;
    };
    var getAudioFromId = function getAudioFromId(id) {
      return _id2audio[id];
    };
    var handleVolume = function handleVolume(volume) {
      void 0 === volume ? volume = 1 : "string" === typeof volume && (volume = Number.parseFloat(volume));
      return volume;
    };
    var audioEngine = {
      AudioState: Audio.State,
      _maxAudioInstance: 24,
      _maxPoolSize: 32,
      _id2audio: _id2audio,
      play: function play(clip, loop, volume) {
        false;
        if (!(clip instanceof AudioClip)) return cc.error("Wrong type of AudioClip.");
        var path = clip.nativeUrl;
        var audio = getAudioFromPath(path);
        audio.src = clip;
        clip._ensureLoaded();
        audio._shouldRecycleOnEnded = true;
        audio.setLoop(loop || false);
        volume = handleVolume(volume);
        audio.setVolume(volume);
        audio.play();
        return audio.id;
      },
      setLoop: function setLoop(audioID, loop) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.setLoop) return;
        audio.setLoop(loop);
      },
      isLoop: function isLoop(audioID) {
        var audio = getAudioFromId(audioID);
        if (!audio || !audio.getLoop) return false;
        return audio.getLoop();
      },
      setVolume: function setVolume(audioID, volume) {
        var audio = getAudioFromId(audioID);
        audio && audio.setVolume(volume);
      },
      getVolume: function getVolume(audioID) {
        var audio = getAudioFromId(audioID);
        return audio ? audio.getVolume() : 1;
      },
      setCurrentTime: function setCurrentTime(audioID, sec) {
        var audio = getAudioFromId(audioID);
        if (audio) {
          audio.setCurrentTime(sec);
          return true;
        }
        return false;
      },
      getCurrentTime: function getCurrentTime(audioID) {
        var audio = getAudioFromId(audioID);
        return audio ? audio.getCurrentTime() : 0;
      },
      getDuration: function getDuration(audioID) {
        var audio = getAudioFromId(audioID);
        return audio ? audio.getDuration() : 0;
      },
      getState: function getState(audioID) {
        var audio = getAudioFromId(audioID);
        return audio ? audio.getState() : this.AudioState.ERROR;
      },
      isPlaying: function isPlaying(audioID) {
        return this.getState(audioID) === this.AudioState.PLAYING;
      },
      setFinishCallback: function setFinishCallback(audioID, callback) {
        var audio = getAudioFromId(audioID);
        if (!audio) return;
        audio._finishCallback = callback;
      },
      pause: function pause(audioID) {
        var audio = getAudioFromId(audioID);
        if (audio) {
          audio.pause();
          return true;
        }
        return false;
      },
      _pauseIDCache: [],
      pauseAll: function pauseAll() {
        for (var id in _id2audio) {
          var audio = _id2audio[id];
          var state = audio.getState();
          if (state === Audio.State.PLAYING) {
            this._pauseIDCache.push(id);
            audio.pause();
          }
        }
      },
      resume: function resume(audioID) {
        var audio = getAudioFromId(audioID);
        audio && audio.resume();
      },
      resumeAll: function resumeAll() {
        for (var i = 0; i < this._pauseIDCache.length; ++i) {
          var id = this._pauseIDCache[i];
          var audio = getAudioFromId(id);
          audio && audio.resume();
        }
        this._pauseIDCache.length = 0;
      },
      stop: function stop(audioID) {
        var audio = getAudioFromId(audioID);
        if (audio) {
          audio.stop();
          return true;
        }
        return false;
      },
      stopAll: function stopAll() {
        for (var id in _id2audio) {
          var audio = _id2audio[id];
          audio && audio.stop();
        }
      },
      setMaxAudioInstance: function setMaxAudioInstance(num) {
        true;
        cc.warn("Since v2.4.0, maxAudioInstance has become a read only property.\naudioEngine.setMaxAudioInstance() method will be removed in the future");
      },
      getMaxAudioInstance: function getMaxAudioInstance() {
        return this._maxAudioInstance;
      },
      uncache: function uncache(clip) {
        var filePath = clip;
        if ("string" === typeof clip) {
          cc.warnID(8401, "cc.audioEngine", "cc.AudioClip", "AudioClip", "cc.AudioClip", "audio");
          filePath = clip;
        } else {
          if (!clip) return;
          filePath = clip.nativeUrl;
        }
        var list = _url2id[filePath];
        if (!list) return;
        while (list.length > 0) {
          var id = list.pop();
          var audio = _id2audio[id];
          if (audio) {
            audio.stop();
            delete _id2audio[id];
          }
        }
      },
      uncacheAll: function uncacheAll() {
        this.stopAll();
        var audio;
        for (var id in _id2audio) {
          audio = _id2audio[id];
          audio && audio.destroy();
        }
        while (audio = _audioPool.pop()) audio.destroy();
        _id2audio = js.createMap(true);
        _url2id = {};
      },
      _breakCache: null,
      _break: function _break() {
        this._breakCache = [];
        for (var id in _id2audio) {
          var audio = _id2audio[id];
          var state = audio.getState();
          if (state === Audio.State.PLAYING) {
            this._breakCache.push(id);
            audio.pause();
          }
        }
      },
      _restore: function _restore() {
        if (!this._breakCache) return;
        while (this._breakCache.length > 0) {
          var id = this._breakCache.pop();
          var audio = getAudioFromId(id);
          audio && audio.resume && audio.resume();
        }
        this._breakCache = null;
      },
      _music: {
        id: -1,
        loop: false,
        volume: 1
      },
      _effect: {
        volume: 1,
        pauseCache: []
      },
      playMusic: function playMusic(clip, loop) {
        var music = this._music;
        this.stop(music.id);
        music.id = this.play(clip, loop, music.volume);
        music.loop = loop;
        return music.id;
      },
      stopMusic: function stopMusic() {
        this.stop(this._music.id);
      },
      pauseMusic: function pauseMusic() {
        this.pause(this._music.id);
        return this._music.id;
      },
      resumeMusic: function resumeMusic() {
        this.resume(this._music.id);
        return this._music.id;
      },
      getMusicVolume: function getMusicVolume() {
        return this._music.volume;
      },
      setMusicVolume: function setMusicVolume(volume) {
        volume = handleVolume(volume);
        var music = this._music;
        music.volume = volume;
        this.setVolume(music.id, music.volume);
        return music.volume;
      },
      isMusicPlaying: function isMusicPlaying() {
        return this.getState(this._music.id) === this.AudioState.PLAYING;
      },
      playEffect: function playEffect(clip, loop) {
        return this.play(clip, loop || false, this._effect.volume);
      },
      setEffectsVolume: function setEffectsVolume(volume) {
        volume = handleVolume(volume);
        var musicId = this._music.id;
        this._effect.volume = volume;
        for (var id in _id2audio) {
          var audio = _id2audio[id];
          if (!audio || audio.id === musicId) continue;
          audioEngine.setVolume(id, volume);
        }
      },
      getEffectsVolume: function getEffectsVolume() {
        return this._effect.volume;
      },
      pauseEffect: function pauseEffect(audioID) {
        return this.pause(audioID);
      },
      pauseAllEffects: function pauseAllEffects() {
        var musicId = this._music.id;
        var effect = this._effect;
        effect.pauseCache.length = 0;
        for (var id in _id2audio) {
          var audio = _id2audio[id];
          if (!audio || audio.id === musicId) continue;
          var state = audio.getState();
          if (state === this.AudioState.PLAYING) {
            effect.pauseCache.push(id);
            audio.pause();
          }
        }
      },
      resumeEffect: function resumeEffect(id) {
        this.resume(id);
      },
      resumeAllEffects: function resumeAllEffects() {
        var pauseIDCache = this._effect.pauseCache;
        for (var i = 0; i < pauseIDCache.length; ++i) {
          var id = pauseIDCache[i];
          var audio = _id2audio[id];
          audio && audio.resume();
        }
      },
      stopEffect: function stopEffect(audioID) {
        return this.stop(audioID);
      },
      stopAllEffects: function stopAllEffects() {
        var musicId = this._music.id;
        for (var id in _id2audio) {
          var audio = _id2audio[id];
          if (!audio || audio.id === musicId) continue;
          var state = audio.getState();
          state === audioEngine.AudioState.PLAYING && audio.stop();
        }
      }
    };
    module.exports = cc.audioEngine = audioEngine;
  }), {
    "../core/assets/CCAudioClip": 138,
    "./CCAudio": 21
  } ],
  23: [ (function(require, module, exports) {
    "use strict";
    var codec = {
      name: "Jacob__Codec"
    };
    codec.Base64 = require("./base64");
    codec.GZip = require("./gzip");
    codec.unzip = function() {
      return codec.GZip.gunzip.apply(codec.GZip, arguments);
    };
    codec.unzipBase64 = function() {
      var buffer = codec.Base64.decode.apply(codec.Base64, arguments);
      try {
        return codec.GZip.gunzip.call(codec.GZip, buffer);
      } catch (e) {
        return buffer.slice(7);
      }
    };
    codec.unzipBase64AsArray = function(input, bytes) {
      bytes = bytes || 1;
      var dec = this.unzipBase64(input), ar = [], i, j, len;
      for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
      }
      return ar;
    };
    codec.unzipAsArray = function(input, bytes) {
      bytes = bytes || 1;
      var dec = this.unzip(input), ar = [], i, j, len;
      for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
      }
      return ar;
    };
    cc.codec = module.exports = codec;
  }), {
    "./base64": 24,
    "./gzip": 25
  } ],
  24: [ (function(require, module, exports) {
    "use strict";
    var misc = require("../core/utils/misc");
    var strValue = misc.BASE64_VALUES;
    var Base64 = {
      name: "Jacob__Codec__Base64"
    };
    Base64.decode = function Jacob__Codec__Base64__decode(input) {
      var output = [], chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      while (i < input.length) {
        enc1 = strValue[input.charCodeAt(i++)];
        enc2 = strValue[input.charCodeAt(i++)];
        enc3 = strValue[input.charCodeAt(i++)];
        enc4 = strValue[input.charCodeAt(i++)];
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (15 & enc2) << 4 | enc3 >> 2;
        chr3 = (3 & enc3) << 6 | enc4;
        output.push(String.fromCharCode(chr1));
        64 !== enc3 && output.push(String.fromCharCode(chr2));
        64 !== enc4 && output.push(String.fromCharCode(chr3));
      }
      output = output.join("");
      return output;
    };
    Base64.decodeAsArray = function Jacob__Codec__Base64___decodeAsArray(input, bytes) {
      var dec = this.decode(input), ar = [], i, j, len;
      for (i = 0, len = dec.length / bytes; i < len; i++) {
        ar[i] = 0;
        for (j = bytes - 1; j >= 0; --j) ar[i] += dec.charCodeAt(i * bytes + j) << 8 * j;
      }
      return ar;
    };
    module.exports = Base64;
  }), {
    "../core/utils/misc": 386
  } ],
  25: [ (function(require, module, exports) {
    "use strict";
    var GZip = function Jacob__GZip(data) {
      this.data = data;
      this.debug = false;
      this.gpflags = void 0;
      this.files = 0;
      this.unzipped = [];
      this.buf32k = new Array(32768);
      this.bIdx = 0;
      this.modeZIP = false;
      this.bytepos = 0;
      this.bb = 1;
      this.bits = 0;
      this.nameBuf = [];
      this.fileout = void 0;
      this.literalTree = new Array(GZip.LITERALS);
      this.distanceTree = new Array(32);
      this.treepos = 0;
      this.Places = null;
      this.len = 0;
      this.fpos = new Array(17);
      this.fpos[0] = 0;
      this.flens = void 0;
      this.fmax = void 0;
    };
    GZip.gunzip = function(string) {
      string.constructor === Array || string.constructor === String;
      var gzip = new GZip(string);
      return gzip.gunzip()[0][0];
    };
    GZip.HufNode = function() {
      this.b0 = 0;
      this.b1 = 0;
      this.jump = null;
      this.jumppos = -1;
    };
    GZip.LITERALS = 288;
    GZip.NAMEMAX = 256;
    GZip.bitReverse = [ 0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255 ];
    GZip.cplens = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];
    GZip.cplext = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 ];
    GZip.cpdist = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];
    GZip.cpdext = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
    GZip.border = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
    GZip.prototype.gunzip = function() {
      this.outputArr = [];
      this.nextFile();
      return this.unzipped;
    };
    GZip.prototype.readByte = function() {
      this.bits += 8;
      return this.bytepos < this.data.length ? this.data.charCodeAt(this.bytepos++) : -1;
    };
    GZip.prototype.byteAlign = function() {
      this.bb = 1;
    };
    GZip.prototype.readBit = function() {
      var carry;
      this.bits++;
      carry = 1 & this.bb;
      this.bb >>= 1;
      if (0 === this.bb) {
        this.bb = this.readByte();
        carry = 1 & this.bb;
        this.bb = this.bb >> 1 | 128;
      }
      return carry;
    };
    GZip.prototype.readBits = function(a) {
      var res = 0, i = a;
      while (i--) res = res << 1 | this.readBit();
      a && (res = GZip.bitReverse[res] >> 8 - a);
      return res;
    };
    GZip.prototype.flushBuffer = function() {
      this.bIdx = 0;
    };
    GZip.prototype.addBuffer = function(a) {
      this.buf32k[this.bIdx++] = a;
      this.outputArr.push(String.fromCharCode(a));
      32768 === this.bIdx && (this.bIdx = 0);
    };
    GZip.prototype.IsPat = function() {
      while (1) {
        if (this.fpos[this.len] >= this.fmax) return -1;
        if (this.flens[this.fpos[this.len]] === this.len) return this.fpos[this.len]++;
        this.fpos[this.len]++;
      }
    };
    GZip.prototype.Rec = function() {
      var curplace = this.Places[this.treepos];
      var tmp;
      if (17 === this.len) return -1;
      this.treepos++;
      this.len++;
      tmp = this.IsPat();
      if (tmp >= 0) curplace.b0 = tmp; else {
        curplace.b0 = 32768;
        if (this.Rec()) return -1;
      }
      tmp = this.IsPat();
      if (tmp >= 0) {
        curplace.b1 = tmp;
        curplace.jump = null;
      } else {
        curplace.b1 = 32768;
        curplace.jump = this.Places[this.treepos];
        curplace.jumppos = this.treepos;
        if (this.Rec()) return -1;
      }
      this.len--;
      return 0;
    };
    GZip.prototype.CreateTree = function(currentTree, numval, lengths, show) {
      var i;
      this.Places = currentTree;
      this.treepos = 0;
      this.flens = lengths;
      this.fmax = numval;
      for (i = 0; i < 17; i++) this.fpos[i] = 0;
      this.len = 0;
      if (this.Rec()) return -1;
      return 0;
    };
    GZip.prototype.DecodeValue = function(currentTree) {
      var len, i, xtreepos = 0, X = currentTree[xtreepos], b;
      while (1) {
        b = this.readBit();
        if (b) {
          if (!(32768 & X.b1)) return X.b1;
          X = X.jump;
          len = currentTree.length;
          for (i = 0; i < len; i++) if (currentTree[i] === X) {
            xtreepos = i;
            break;
          }
        } else {
          if (!(32768 & X.b0)) return X.b0;
          xtreepos++;
          X = currentTree[xtreepos];
        }
      }
      return -1;
    };
    GZip.prototype.DeflateLoop = function() {
      var last, c, type, i, len;
      do {
        last = this.readBit();
        type = this.readBits(2);
        if (0 === type) {
          var blockLen, cSum;
          this.byteAlign();
          blockLen = this.readByte();
          blockLen |= this.readByte() << 8;
          cSum = this.readByte();
          cSum |= this.readByte() << 8;
          65535 & (blockLen ^ ~cSum) && document.write("BlockLen checksum mismatch\n");
          while (blockLen--) {
            c = this.readByte();
            this.addBuffer(c);
          }
        } else if (1 === type) {
          var j;
          while (1) {
            j = GZip.bitReverse[this.readBits(7)] >> 1;
            if (j > 23) {
              j = j << 1 | this.readBit();
              if (j > 199) {
                j -= 128;
                j = j << 1 | this.readBit();
              } else {
                j -= 48;
                j > 143 && (j += 136);
              }
            } else j += 256;
            if (j < 256) this.addBuffer(j); else {
              if (256 === j) break;
              var len, dist;
              j -= 257;
              len = this.readBits(GZip.cplext[j]) + GZip.cplens[j];
              j = GZip.bitReverse[this.readBits(5)] >> 3;
              if (GZip.cpdext[j] > 8) {
                dist = this.readBits(8);
                dist |= this.readBits(GZip.cpdext[j] - 8) << 8;
              } else dist = this.readBits(GZip.cpdext[j]);
              dist += GZip.cpdist[j];
              for (j = 0; j < len; j++) {
                var c = this.buf32k[this.bIdx - dist & 32767];
                this.addBuffer(c);
              }
            }
          }
        } else if (2 === type) {
          var j, n, literalCodes, distCodes, lenCodes;
          var ll = new Array(320);
          literalCodes = 257 + this.readBits(5);
          distCodes = 1 + this.readBits(5);
          lenCodes = 4 + this.readBits(4);
          for (j = 0; j < 19; j++) ll[j] = 0;
          for (j = 0; j < lenCodes; j++) ll[GZip.border[j]] = this.readBits(3);
          len = this.distanceTree.length;
          for (i = 0; i < len; i++) this.distanceTree[i] = new GZip.HufNode();
          if (this.CreateTree(this.distanceTree, 19, ll, 0)) {
            this.flushBuffer();
            return 1;
          }
          n = literalCodes + distCodes;
          i = 0;
          var z = -1;
          while (i < n) {
            z++;
            j = this.DecodeValue(this.distanceTree);
            if (j < 16) ll[i++] = j; else if (16 === j) {
              var l;
              j = 3 + this.readBits(2);
              if (i + j > n) {
                this.flushBuffer();
                return 1;
              }
              l = i ? ll[i - 1] : 0;
              while (j--) ll[i++] = l;
            } else {
              j = 17 === j ? 3 + this.readBits(3) : 11 + this.readBits(7);
              if (i + j > n) {
                this.flushBuffer();
                return 1;
              }
              while (j--) ll[i++] = 0;
            }
          }
          len = this.literalTree.length;
          for (i = 0; i < len; i++) this.literalTree[i] = new GZip.HufNode();
          if (this.CreateTree(this.literalTree, literalCodes, ll, 0)) {
            this.flushBuffer();
            return 1;
          }
          len = this.literalTree.length;
          for (i = 0; i < len; i++) this.distanceTree[i] = new GZip.HufNode();
          var ll2 = new Array();
          for (i = literalCodes; i < ll.length; i++) ll2[i - literalCodes] = ll[i];
          if (this.CreateTree(this.distanceTree, distCodes, ll2, 0)) {
            this.flushBuffer();
            return 1;
          }
          while (1) {
            j = this.DecodeValue(this.literalTree);
            if (j >= 256) {
              var len, dist;
              j -= 256;
              if (0 === j) break;
              j--;
              len = this.readBits(GZip.cplext[j]) + GZip.cplens[j];
              j = this.DecodeValue(this.distanceTree);
              if (GZip.cpdext[j] > 8) {
                dist = this.readBits(8);
                dist |= this.readBits(GZip.cpdext[j] - 8) << 8;
              } else dist = this.readBits(GZip.cpdext[j]);
              dist += GZip.cpdist[j];
              while (len--) {
                var c = this.buf32k[this.bIdx - dist & 32767];
                this.addBuffer(c);
              }
            } else this.addBuffer(j);
          }
        }
      } while (!last);
      this.flushBuffer();
      this.byteAlign();
      return 0;
    };
    GZip.prototype.unzipFile = function(name) {
      var i;
      this.gunzip();
      for (i = 0; i < this.unzipped.length; i++) if (this.unzipped[i][1] === name) return this.unzipped[i][0];
    };
    GZip.prototype.nextFile = function() {
      this.outputArr = [];
      this.modeZIP = false;
      var tmp = [];
      tmp[0] = this.readByte();
      tmp[1] = this.readByte();
      if (120 === tmp[0] && 218 === tmp[1]) {
        this.DeflateLoop();
        this.unzipped[this.files] = [ this.outputArr.join(""), "geonext.gxt" ];
        this.files++;
      }
      if (31 === tmp[0] && 139 === tmp[1]) {
        this.skipdir();
        this.unzipped[this.files] = [ this.outputArr.join(""), "file" ];
        this.files++;
      }
      if (80 === tmp[0] && 75 === tmp[1]) {
        this.modeZIP = true;
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();
        if (3 === tmp[2] && 4 === tmp[3]) {
          tmp[0] = this.readByte();
          tmp[1] = this.readByte();
          this.gpflags = this.readByte();
          this.gpflags |= this.readByte() << 8;
          var method = this.readByte();
          method |= this.readByte() << 8;
          this.readByte();
          this.readByte();
          this.readByte();
          this.readByte();
          var compSize = this.readByte();
          compSize |= this.readByte() << 8;
          compSize |= this.readByte() << 16;
          compSize |= this.readByte() << 24;
          var size = this.readByte();
          size |= this.readByte() << 8;
          size |= this.readByte() << 16;
          size |= this.readByte() << 24;
          var filelen = this.readByte();
          filelen |= this.readByte() << 8;
          var extralen = this.readByte();
          extralen |= this.readByte() << 8;
          i = 0;
          this.nameBuf = [];
          while (filelen--) {
            var c = this.readByte();
            "/" === c | ":" === c ? i = 0 : i < GZip.NAMEMAX - 1 && (this.nameBuf[i++] = String.fromCharCode(c));
          }
          this.fileout || (this.fileout = this.nameBuf);
          var i = 0;
          while (i < extralen) {
            c = this.readByte();
            i++;
          }
          if (8 === method) {
            this.DeflateLoop();
            this.unzipped[this.files] = [ this.outputArr.join(""), this.nameBuf.join("") ];
            this.files++;
          }
          this.skipdir();
        }
      }
    };
    GZip.prototype.skipdir = function() {
      var tmp = [];
      var compSize, size, os, i, c;
      if (8 & this.gpflags) {
        tmp[0] = this.readByte();
        tmp[1] = this.readByte();
        tmp[2] = this.readByte();
        tmp[3] = this.readByte();
        compSize = this.readByte();
        compSize |= this.readByte() << 8;
        compSize |= this.readByte() << 16;
        compSize |= this.readByte() << 24;
        size = this.readByte();
        size |= this.readByte() << 8;
        size |= this.readByte() << 16;
        size |= this.readByte() << 24;
      }
      this.modeZIP && this.nextFile();
      tmp[0] = this.readByte();
      if (8 !== tmp[0]) return 0;
      this.gpflags = this.readByte();
      this.readByte();
      this.readByte();
      this.readByte();
      this.readByte();
      this.readByte();
      os = this.readByte();
      if (4 & this.gpflags) {
        tmp[0] = this.readByte();
        tmp[2] = this.readByte();
        this.len = tmp[0] + 256 * tmp[1];
        for (i = 0; i < this.len; i++) this.readByte();
      }
      if (8 & this.gpflags) {
        i = 0;
        this.nameBuf = [];
        while (c = this.readByte()) {
          "7" !== c && ":" !== c || (i = 0);
          i < GZip.NAMEMAX - 1 && (this.nameBuf[i++] = c);
        }
      }
      if (16 & this.gpflags) while (c = this.readByte()) ;
      if (2 & this.gpflags) {
        this.readByte();
        this.readByte();
      }
      this.DeflateLoop();
      size = this.readByte();
      size |= this.readByte() << 8;
      size |= this.readByte() << 16;
      size |= this.readByte() << 24;
      this.modeZIP && this.nextFile();
    };
    module.exports = GZip;
  }), {} ],
  26: [ (function(require, module, exports) {
    "use strict";
    (function() {
      function i(a) {
        throw a;
      }
      var r = void 0, v = !0, aa = this;
      function y(a, c) {
        var b = a.split("."), e = aa;
        !(b[0] in e) && e.execScript && e.execScript("var " + b[0]);
        for (var f; b.length && (f = b.shift()); ) b.length || c === r ? e = e[f] ? e[f] : e[f] = {} : e[f] = c;
      }
      var H = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
      function ba(a) {
        if ("string" === typeof a) {
          var c = a.split(""), b, e;
          b = 0;
          for (e = c.length; b < e; b++) c[b] = (255 & c[b].charCodeAt(0)) >>> 0;
          a = c;
        }
        for (var f = 1, d = 0, g = a.length, h, m = 0; 0 < g; ) {
          h = 1024 < g ? 1024 : g;
          g -= h;
          do {
            f += a[m++], d += f;
          } while (--h);
          f %= 65521;
          d %= 65521;
        }
        return (d << 16 | f) >>> 0;
      }
      function J(a, c) {
        this.index = "number" === typeof c ? c : 0;
        this.i = 0;
        this.buffer = a instanceof (H ? Uint8Array : Array) ? a : new (H ? Uint8Array : Array)(32768);
        2 * this.buffer.length <= this.index && i(Error("invalid index"));
        this.buffer.length <= this.index && this.f();
      }
      J.prototype.f = function() {
        var a = this.buffer, c, b = a.length, e = new (H ? Uint8Array : Array)(b << 1);
        if (H) e.set(a); else for (c = 0; c < b; ++c) e[c] = a[c];
        return this.buffer = e;
      };
      J.prototype.d = function(a, c, b) {
        var e = this.buffer, f = this.index, d = this.i, g = e[f], h;
        b && 1 < c && (a = 8 < c ? (N[255 & a] << 24 | N[a >>> 8 & 255] << 16 | N[a >>> 16 & 255] << 8 | N[a >>> 24 & 255]) >> 32 - c : N[a] >> 8 - c);
        if (8 > c + d) g = g << c | a, d += c; else for (h = 0; h < c; ++h) g = g << 1 | a >> c - h - 1 & 1, 
        8 === ++d && (d = 0, e[f++] = N[g], g = 0, f === e.length && (e = this.f()));
        e[f] = g;
        this.buffer = e;
        this.i = d;
        this.index = f;
      };
      J.prototype.finish = function() {
        var a = this.buffer, c = this.index, b;
        0 < this.i && (a[c] <<= 8 - this.i, a[c] = N[a[c]], c++);
        H ? b = a.subarray(0, c) : (a.length = c, b = a);
        return b;
      };
      var ca = new (H ? Uint8Array : Array)(256), ha;
      for (ha = 0; 256 > ha; ++ha) {
        for (var R = ha, ia = R, ja = 7, R = R >>> 1; R; R >>>= 1) ia <<= 1, ia |= 1 & R, 
        --ja;
        ca[ha] = (ia << ja & 255) >>> 0;
      }
      var N = ca;
      var ka = [ 0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117 ];
      H && new Uint32Array(ka);
      function la(a) {
        this.buffer = new (H ? Uint16Array : Array)(2 * a);
        this.length = 0;
      }
      la.prototype.getParent = function(a) {
        return 2 * ((a - 2) / 4 | 0);
      };
      la.prototype.push = function(a, c) {
        var b, e, f = this.buffer, d;
        b = this.length;
        f[this.length++] = c;
        for (f[this.length++] = a; 0 < b; ) {
          if (e = this.getParent(b), !(f[b] > f[e])) break;
          d = f[b], f[b] = f[e], f[e] = d, d = f[b + 1], f[b + 1] = f[e + 1], f[e + 1] = d, 
          b = e;
        }
        return this.length;
      };
      la.prototype.pop = function() {
        var a, c, b = this.buffer, e, f, d;
        c = b[0];
        a = b[1];
        this.length -= 2;
        b[0] = b[this.length];
        b[1] = b[this.length + 1];
        for (d = 0; ;) {
          f = 2 * d + 2;
          if (f >= this.length) break;
          f + 2 < this.length && b[f + 2] > b[f] && (f += 2);
          if (!(b[f] > b[d])) break;
          e = b[d], b[d] = b[f], b[f] = e, e = b[d + 1], b[d + 1] = b[f + 1], b[f + 1] = e;
          d = f;
        }
        return {
          index: a,
          value: c,
          length: this.length
        };
      };
      function S(a) {
        var c = a.length, b = 0, e = Number.POSITIVE_INFINITY, f, d, g, h, m, j, s, n, l;
        for (n = 0; n < c; ++n) a[n] > b && (b = a[n]), a[n] < e && (e = a[n]);
        f = 1 << b;
        d = new (H ? Uint32Array : Array)(f);
        g = 1;
        h = 0;
        for (m = 2; g <= b; ) {
          for (n = 0; n < c; ++n) if (a[n] === g) {
            j = 0;
            s = h;
            for (l = 0; l < g; ++l) j = j << 1 | 1 & s, s >>= 1;
            for (l = j; l < f; l += m) d[l] = g << 16 | n;
            ++h;
          }
          ++g;
          h <<= 1;
          m <<= 1;
        }
        return [ d, b, e ];
      }
      function ma(a, c) {
        this.h = pa;
        this.w = 0;
        this.input = a;
        this.b = 0;
        c && (c.lazy && (this.w = c.lazy), "number" === typeof c.compressionType && (this.h = c.compressionType), 
        c.outputBuffer && (this.a = H && c.outputBuffer instanceof Array ? new Uint8Array(c.outputBuffer) : c.outputBuffer), 
        "number" === typeof c.outputIndex && (this.b = c.outputIndex));
        this.a || (this.a = new (H ? Uint8Array : Array)(32768));
      }
      var pa = 2, qa = {
        NONE: 0,
        r: 1,
        j: pa,
        N: 3
      }, ra = [], T;
      for (T = 0; 288 > T; T++) switch (v) {
       case 143 >= T:
        ra.push([ T + 48, 8 ]);
        break;

       case 255 >= T:
        ra.push([ T - 144 + 400, 9 ]);
        break;

       case 279 >= T:
        ra.push([ T - 256 + 0, 7 ]);
        break;

       case 287 >= T:
        ra.push([ T - 280 + 192, 8 ]);
        break;

       default:
        i("invalid literal: " + T);
      }
      ma.prototype.n = function() {
        var a, c, b, e, f = this.input;
        switch (this.h) {
         case 0:
          b = 0;
          for (e = f.length; b < e; ) {
            c = H ? f.subarray(b, b + 65535) : f.slice(b, b + 65535);
            b += c.length;
            var d = c, g = b === e, h = r, m = r, j = r, s = r, n = r, l = this.a, q = this.b;
            if (H) {
              for (l = new Uint8Array(this.a.buffer); l.length <= q + d.length + 5; ) l = new Uint8Array(l.length << 1);
              l.set(this.a);
            }
            h = g ? 1 : 0;
            l[q++] = 0 | h;
            m = d.length;
            j = 65536 + ~m & 65535;
            l[q++] = 255 & m;
            l[q++] = m >>> 8 & 255;
            l[q++] = 255 & j;
            l[q++] = j >>> 8 & 255;
            if (H) l.set(d, q), q += d.length, l = l.subarray(0, q); else {
              s = 0;
              for (n = d.length; s < n; ++s) l[q++] = d[s];
              l.length = q;
            }
            this.b = q;
            this.a = l;
          }
          break;

         case 1:
          var E = new J(new Uint8Array(this.a.buffer), this.b);
          E.d(1, 1, v);
          E.d(1, 2, v);
          var t = sa(this, f), z, K, A;
          z = 0;
          for (K = t.length; z < K; z++) if (A = t[z], J.prototype.d.apply(E, ra[A]), 256 < A) E.d(t[++z], t[++z], v), 
          E.d(t[++z], 5), E.d(t[++z], t[++z], v); else if (256 === A) break;
          this.a = E.finish();
          this.b = this.a.length;
          break;

         case pa:
          var x = new J(new Uint8Array(this.a), this.b), B, k, p, D, C, da = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], W, Ma, ea, Na, na, va = Array(19), Oa, $, oa, F, Pa;
          B = pa;
          x.d(1, 1, v);
          x.d(B, 2, v);
          k = sa(this, f);
          W = ta(this.L, 15);
          Ma = ua(W);
          ea = ta(this.K, 7);
          Na = ua(ea);
          for (p = 286; 257 < p && 0 === W[p - 1]; p--) ;
          for (D = 30; 1 < D && 0 === ea[D - 1]; D--) ;
          var Qa = p, Ra = D, M = new (H ? Uint32Array : Array)(Qa + Ra), u, O, w, fa, L = new (H ? Uint32Array : Array)(316), I, G, P = new (H ? Uint8Array : Array)(19);
          for (u = O = 0; u < Qa; u++) M[O++] = W[u];
          for (u = 0; u < Ra; u++) M[O++] = ea[u];
          if (!H) {
            u = 0;
            for (fa = P.length; u < fa; ++u) P[u] = 0;
          }
          u = I = 0;
          for (fa = M.length; u < fa; u += O) {
            for (O = 1; u + O < fa && M[u + O] === M[u]; ++O) ;
            w = O;
            if (0 === M[u]) if (3 > w) for (;0 < w--; ) L[I++] = 0, P[0]++; else for (;0 < w; ) G = 138 > w ? w : 138, 
            G > w - 3 && G < w && (G = w - 3), 10 >= G ? (L[I++] = 17, L[I++] = G - 3, P[17]++) : (L[I++] = 18, 
            L[I++] = G - 11, P[18]++), w -= G; else if (L[I++] = M[u], P[M[u]]++, w--, 3 > w) for (;0 < w--; ) L[I++] = M[u], 
            P[M[u]]++; else for (;0 < w; ) G = 6 > w ? w : 6, G > w - 3 && G < w && (G = w - 3), 
            L[I++] = 16, L[I++] = G - 3, P[16]++, w -= G;
          }
          a = H ? L.subarray(0, I) : L.slice(0, I);
          na = ta(P, 7);
          for (F = 0; 19 > F; F++) va[F] = na[da[F]];
          for (C = 19; 4 < C && 0 === va[C - 1]; C--) ;
          Oa = ua(na);
          x.d(p - 257, 5, v);
          x.d(D - 1, 5, v);
          x.d(C - 4, 4, v);
          for (F = 0; F < C; F++) x.d(va[F], 3, v);
          F = 0;
          for (Pa = a.length; F < Pa; F++) if ($ = a[F], x.d(Oa[$], na[$], v), 16 <= $) {
            F++;
            switch ($) {
             case 16:
              oa = 2;
              break;

             case 17:
              oa = 3;
              break;

             case 18:
              oa = 7;
              break;

             default:
              i("invalid code: " + $);
            }
            x.d(a[F], oa, v);
          }
          var Sa = [ Ma, W ], Ta = [ Na, ea ], Q, Ua, ga, ya, Va, Wa, Xa, Ya;
          Va = Sa[0];
          Wa = Sa[1];
          Xa = Ta[0];
          Ya = Ta[1];
          Q = 0;
          for (Ua = k.length; Q < Ua; ++Q) if (ga = k[Q], x.d(Va[ga], Wa[ga], v), 256 < ga) x.d(k[++Q], k[++Q], v), 
          ya = k[++Q], x.d(Xa[ya], Ya[ya], v), x.d(k[++Q], k[++Q], v); else if (256 === ga) break;
          this.a = x.finish();
          this.b = this.a.length;
          break;

         default:
          i("invalid compression type");
        }
        return this.a;
      };
      function wa(a, c) {
        this.length = a;
        this.G = c;
      }
      function xa() {
        var a = za;
        switch (v) {
         case 3 === a:
          return [ 257, a - 3, 0 ];

         case 4 === a:
          return [ 258, a - 4, 0 ];

         case 5 === a:
          return [ 259, a - 5, 0 ];

         case 6 === a:
          return [ 260, a - 6, 0 ];

         case 7 === a:
          return [ 261, a - 7, 0 ];

         case 8 === a:
          return [ 262, a - 8, 0 ];

         case 9 === a:
          return [ 263, a - 9, 0 ];

         case 10 === a:
          return [ 264, a - 10, 0 ];

         case 12 >= a:
          return [ 265, a - 11, 1 ];

         case 14 >= a:
          return [ 266, a - 13, 1 ];

         case 16 >= a:
          return [ 267, a - 15, 1 ];

         case 18 >= a:
          return [ 268, a - 17, 1 ];

         case 22 >= a:
          return [ 269, a - 19, 2 ];

         case 26 >= a:
          return [ 270, a - 23, 2 ];

         case 30 >= a:
          return [ 271, a - 27, 2 ];

         case 34 >= a:
          return [ 272, a - 31, 2 ];

         case 42 >= a:
          return [ 273, a - 35, 3 ];

         case 50 >= a:
          return [ 274, a - 43, 3 ];

         case 58 >= a:
          return [ 275, a - 51, 3 ];

         case 66 >= a:
          return [ 276, a - 59, 3 ];

         case 82 >= a:
          return [ 277, a - 67, 4 ];

         case 98 >= a:
          return [ 278, a - 83, 4 ];

         case 114 >= a:
          return [ 279, a - 99, 4 ];

         case 130 >= a:
          return [ 280, a - 115, 4 ];

         case 162 >= a:
          return [ 281, a - 131, 5 ];

         case 194 >= a:
          return [ 282, a - 163, 5 ];

         case 226 >= a:
          return [ 283, a - 195, 5 ];

         case 257 >= a:
          return [ 284, a - 227, 5 ];

         case 258 === a:
          return [ 285, a - 258, 0 ];

         default:
          i("invalid length: " + a);
        }
      }
      var Aa = [], za, Ba;
      for (za = 3; 258 >= za; za++) Ba = xa(), Aa[za] = Ba[2] << 24 | Ba[1] << 16 | Ba[0];
      var Ca = H ? new Uint32Array(Aa) : Aa;
      function sa(a, c) {
        function b(a, c) {
          var b = a.G, d = [], e = 0, f;
          f = Ca[a.length];
          d[e++] = 65535 & f;
          d[e++] = f >> 16 & 255;
          d[e++] = f >> 24;
          var g;
          switch (v) {
           case 1 === b:
            g = [ 0, b - 1, 0 ];
            break;

           case 2 === b:
            g = [ 1, b - 2, 0 ];
            break;

           case 3 === b:
            g = [ 2, b - 3, 0 ];
            break;

           case 4 === b:
            g = [ 3, b - 4, 0 ];
            break;

           case 6 >= b:
            g = [ 4, b - 5, 1 ];
            break;

           case 8 >= b:
            g = [ 5, b - 7, 1 ];
            break;

           case 12 >= b:
            g = [ 6, b - 9, 2 ];
            break;

           case 16 >= b:
            g = [ 7, b - 13, 2 ];
            break;

           case 24 >= b:
            g = [ 8, b - 17, 3 ];
            break;

           case 32 >= b:
            g = [ 9, b - 25, 3 ];
            break;

           case 48 >= b:
            g = [ 10, b - 33, 4 ];
            break;

           case 64 >= b:
            g = [ 11, b - 49, 4 ];
            break;

           case 96 >= b:
            g = [ 12, b - 65, 5 ];
            break;

           case 128 >= b:
            g = [ 13, b - 97, 5 ];
            break;

           case 192 >= b:
            g = [ 14, b - 129, 6 ];
            break;

           case 256 >= b:
            g = [ 15, b - 193, 6 ];
            break;

           case 384 >= b:
            g = [ 16, b - 257, 7 ];
            break;

           case 512 >= b:
            g = [ 17, b - 385, 7 ];
            break;

           case 768 >= b:
            g = [ 18, b - 513, 8 ];
            break;

           case 1024 >= b:
            g = [ 19, b - 769, 8 ];
            break;

           case 1536 >= b:
            g = [ 20, b - 1025, 9 ];
            break;

           case 2048 >= b:
            g = [ 21, b - 1537, 9 ];
            break;

           case 3072 >= b:
            g = [ 22, b - 2049, 10 ];
            break;

           case 4096 >= b:
            g = [ 23, b - 3073, 10 ];
            break;

           case 6144 >= b:
            g = [ 24, b - 4097, 11 ];
            break;

           case 8192 >= b:
            g = [ 25, b - 6145, 11 ];
            break;

           case 12288 >= b:
            g = [ 26, b - 8193, 12 ];
            break;

           case 16384 >= b:
            g = [ 27, b - 12289, 12 ];
            break;

           case 24576 >= b:
            g = [ 28, b - 16385, 13 ];
            break;

           case 32768 >= b:
            g = [ 29, b - 24577, 13 ];
            break;

           default:
            i("invalid distance");
          }
          f = g;
          d[e++] = f[0];
          d[e++] = f[1];
          d[e++] = f[2];
          var h, j;
          h = 0;
          for (j = d.length; h < j; ++h) l[q++] = d[h];
          t[d[0]]++;
          z[d[3]]++;
          E = a.length + c - 1;
          n = null;
        }
        var e, f, d, g, h, m = {}, j, s, n, l = H ? new Uint16Array(2 * c.length) : [], q = 0, E = 0, t = new (H ? Uint32Array : Array)(286), z = new (H ? Uint32Array : Array)(30), K = a.w, A;
        if (!H) {
          for (d = 0; 285 >= d; ) t[d++] = 0;
          for (d = 0; 29 >= d; ) z[d++] = 0;
        }
        t[256] = 1;
        e = 0;
        for (f = c.length; e < f; ++e) {
          d = h = 0;
          for (g = 3; d < g && e + d !== f; ++d) h = h << 8 | c[e + d];
          m[h] === r && (m[h] = []);
          j = m[h];
          if (!(0 < E--)) {
            for (;0 < j.length && 32768 < e - j[0]; ) j.shift();
            if (e + 3 >= f) {
              n && b(n, -1);
              d = 0;
              for (g = f - e; d < g; ++d) A = c[e + d], l[q++] = A, ++t[A];
              break;
            }
            if (0 < j.length) {
              var x = r, B = r, k = 0, p = r, D = r, C = r, da = r, W = c.length, D = 0, da = j.length;
              a: for (;D < da; D++) {
                x = j[da - D - 1];
                p = 3;
                if (3 < k) {
                  for (C = k; 3 < C; C--) if (c[x + C - 1] !== c[e + C - 1]) continue a;
                  p = k;
                }
                for (;258 > p && e + p < W && c[x + p] === c[e + p]; ) ++p;
                p > k && (B = x, k = p);
                if (258 === p) break;
              }
              s = new wa(k, e - B);
              n ? n.length < s.length ? (A = c[e - 1], l[q++] = A, ++t[A], b(s, 0)) : b(n, -1) : s.length < K ? n = s : b(s, 0);
            } else n ? b(n, -1) : (A = c[e], l[q++] = A, ++t[A]);
          }
          j.push(e);
        }
        l[q++] = 256;
        t[256]++;
        a.L = t;
        a.K = z;
        return H ? l.subarray(0, q) : l;
      }
      function ta(a, c) {
        function b(a) {
          var c = z[a][K[a]];
          c === n ? (b(a + 1), b(a + 1)) : --E[c];
          ++K[a];
        }
        var e = a.length, f = new la(572), d = new (H ? Uint8Array : Array)(e), g, h, m, j, s;
        if (!H) for (j = 0; j < e; j++) d[j] = 0;
        for (j = 0; j < e; ++j) 0 < a[j] && f.push(j, a[j]);
        g = Array(f.length / 2);
        h = new (H ? Uint32Array : Array)(f.length / 2);
        if (1 === g.length) return d[f.pop().index] = 1, d;
        j = 0;
        for (s = f.length / 2; j < s; ++j) g[j] = f.pop(), h[j] = g[j].value;
        var n = h.length, l = new (H ? Uint16Array : Array)(c), q = new (H ? Uint8Array : Array)(c), E = new (H ? Uint8Array : Array)(n), t = Array(c), z = Array(c), K = Array(c), A = (1 << c) - n, x = 1 << c - 1, B, k, p, D, C;
        l[c - 1] = n;
        for (k = 0; k < c; ++k) A < x ? q[k] = 0 : (q[k] = 1, A -= x), A <<= 1, l[c - 2 - k] = (l[c - 1 - k] / 2 | 0) + n;
        l[0] = q[0];
        t[0] = Array(l[0]);
        z[0] = Array(l[0]);
        for (k = 1; k < c; ++k) l[k] > 2 * l[k - 1] + q[k] && (l[k] = 2 * l[k - 1] + q[k]), 
        t[k] = Array(l[k]), z[k] = Array(l[k]);
        for (B = 0; B < n; ++B) E[B] = c;
        for (p = 0; p < l[c - 1]; ++p) t[c - 1][p] = h[p], z[c - 1][p] = p;
        for (B = 0; B < c; ++B) K[B] = 0;
        1 === q[c - 1] && (--E[0], ++K[c - 1]);
        for (k = c - 2; 0 <= k; --k) {
          D = B = 0;
          C = K[k + 1];
          for (p = 0; p < l[k]; p++) D = t[k + 1][C] + t[k + 1][C + 1], D > h[B] ? (t[k][p] = D, 
          z[k][p] = n, C += 2) : (t[k][p] = h[B], z[k][p] = B, ++B);
          K[k] = 0;
          1 === q[k] && b(k);
        }
        m = E;
        j = 0;
        for (s = g.length; j < s; ++j) d[g[j].index] = m[j];
        return d;
      }
      function ua(a) {
        var c = new (H ? Uint16Array : Array)(a.length), b = [], e = [], f = 0, d, g, h, m;
        d = 0;
        for (g = a.length; d < g; d++) b[a[d]] = 1 + (0 | b[a[d]]);
        d = 1;
        for (g = 16; d <= g; d++) e[d] = f, f += 0 | b[d], f > 1 << d && i("overcommitted"), 
        f <<= 1;
        65536 > f && i("undercommitted");
        d = 0;
        for (g = a.length; d < g; d++) {
          f = e[a[d]];
          e[a[d]] += 1;
          h = c[d] = 0;
          for (m = a[d]; h < m; h++) c[d] = c[d] << 1 | 1 & f, f >>>= 1;
        }
        return c;
      }
      function Da(a, c) {
        this.input = a;
        this.a = new (H ? Uint8Array : Array)(32768);
        this.h = U.j;
        var b = {}, e;
        !c && (c = {}) || "number" !== typeof c.compressionType || (this.h = c.compressionType);
        for (e in c) b[e] = c[e];
        b.outputBuffer = this.a;
        this.z = new ma(this.input, b);
      }
      var U = qa;
      Da.prototype.n = function() {
        var a, c, b, e, f, d, g, h = 0;
        g = this.a;
        a = Ea;
        switch (a) {
         case Ea:
          c = Math.LOG2E * Math.log(32768) - 8;
          break;

         default:
          i(Error("invalid compression method"));
        }
        b = c << 4 | a;
        g[h++] = b;
        switch (a) {
         case Ea:
          switch (this.h) {
           case U.NONE:
            f = 0;
            break;

           case U.r:
            f = 1;
            break;

           case U.j:
            f = 2;
            break;

           default:
            i(Error("unsupported compression type"));
          }
          break;

         default:
          i(Error("invalid compression method"));
        }
        e = f << 6 | 0;
        g[h++] = e | 31 - (256 * b + e) % 31;
        d = ba(this.input);
        this.z.b = h;
        g = this.z.n();
        h = g.length;
        H && (g = new Uint8Array(g.buffer), g.length <= h + 4 && (this.a = new Uint8Array(g.length + 4), 
        this.a.set(g), g = this.a), g = g.subarray(0, h + 4));
        g[h++] = d >> 24 & 255;
        g[h++] = d >> 16 & 255;
        g[h++] = d >> 8 & 255;
        g[h++] = 255 & d;
        return g;
      };
      y("Zlib.Deflate", Da);
      y("Zlib.Deflate.compress", (function(a, c) {
        return new Da(a, c).n();
      }));
      y("Zlib.Deflate.CompressionType", U);
      y("Zlib.Deflate.CompressionType.NONE", U.NONE);
      y("Zlib.Deflate.CompressionType.FIXED", U.r);
      y("Zlib.Deflate.CompressionType.DYNAMIC", U.j);
      function V(a, c) {
        this.k = [];
        this.l = 32768;
        this.e = this.g = this.c = this.q = 0;
        this.input = H ? new Uint8Array(a) : a;
        this.s = !1;
        this.m = Fa;
        this.B = !1;
        !c && (c = {}) || (c.index && (this.c = c.index), c.bufferSize && (this.l = c.bufferSize), 
        c.bufferType && (this.m = c.bufferType), c.resize && (this.B = c.resize));
        switch (this.m) {
         case Ga:
          this.b = 32768;
          this.a = new (H ? Uint8Array : Array)(32768 + this.l + 258);
          break;

         case Fa:
          this.b = 0;
          this.a = new (H ? Uint8Array : Array)(this.l);
          this.f = this.J;
          this.t = this.H;
          this.o = this.I;
          break;

         default:
          i(Error("invalid inflate mode"));
        }
      }
      var Ga = 0, Fa = 1, Ha = {
        D: Ga,
        C: Fa
      };
      V.prototype.p = function() {
        for (;!this.s; ) {
          var a = X(this, 3);
          1 & a && (this.s = v);
          a >>>= 1;
          switch (a) {
           case 0:
            var c = this.input, b = this.c, e = this.a, f = this.b, d = r, g = r, h = r, m = e.length, j = r;
            this.e = this.g = 0;
            d = c[b++];
            d === r && i(Error("invalid uncompressed block header: LEN (first byte)"));
            g = d;
            d = c[b++];
            d === r && i(Error("invalid uncompressed block header: LEN (second byte)"));
            g |= d << 8;
            d = c[b++];
            d === r && i(Error("invalid uncompressed block header: NLEN (first byte)"));
            h = d;
            d = c[b++];
            d === r && i(Error("invalid uncompressed block header: NLEN (second byte)"));
            h |= d << 8;
            g === ~h && i(Error("invalid uncompressed block header: length verify"));
            b + g > c.length && i(Error("input buffer is broken"));
            switch (this.m) {
             case Ga:
              for (;f + g > e.length; ) {
                j = m - f;
                g -= j;
                if (H) e.set(c.subarray(b, b + j), f), f += j, b += j; else for (;j--; ) e[f++] = c[b++];
                this.b = f;
                e = this.f();
                f = this.b;
              }
              break;

             case Fa:
              for (;f + g > e.length; ) e = this.f({
                v: 2
              });
              break;

             default:
              i(Error("invalid inflate mode"));
            }
            if (H) e.set(c.subarray(b, b + g), f), f += g, b += g; else for (;g--; ) e[f++] = c[b++];
            this.c = b;
            this.b = f;
            this.a = e;
            break;

           case 1:
            this.o(Ia, Ja);
            break;

           case 2:
            Ka(this);
            break;

           default:
            i(Error("unknown BTYPE: " + a));
          }
        }
        return this.t();
      };
      var La = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], Za = H ? new Uint16Array(La) : La, $a = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258 ], ab = H ? new Uint16Array($a) : $a, bb = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 ], cb = H ? new Uint8Array(bb) : bb, db = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ], eb = H ? new Uint16Array(db) : db, fb = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ], gb = H ? new Uint8Array(fb) : fb, hb = new (H ? Uint8Array : Array)(288), Y, ib;
      Y = 0;
      for (ib = hb.length; Y < ib; ++Y) hb[Y] = 143 >= Y ? 8 : 255 >= Y ? 9 : 279 >= Y ? 7 : 8;
      var Ia = S(hb), jb = new (H ? Uint8Array : Array)(30), kb, lb;
      kb = 0;
      for (lb = jb.length; kb < lb; ++kb) jb[kb] = 5;
      var Ja = S(jb);
      function X(a, c) {
        for (var b = a.g, e = a.e, f = a.input, d = a.c, g; e < c; ) g = f[d++], g === r && i(Error("input buffer is broken")), 
        b |= g << e, e += 8;
        g = b & (1 << c) - 1;
        a.g = b >>> c;
        a.e = e - c;
        a.c = d;
        return g;
      }
      function mb(a, c) {
        for (var b = a.g, e = a.e, f = a.input, d = a.c, g = c[0], h = c[1], m, j, s; e < h; ) m = f[d++], 
        m === r && i(Error("input buffer is broken")), b |= m << e, e += 8;
        j = g[b & (1 << h) - 1];
        s = j >>> 16;
        a.g = b >> s;
        a.e = e - s;
        a.c = d;
        return 65535 & j;
      }
      function Ka(a) {
        function c(a, b, c) {
          var d, e, f, g;
          for (g = 0; g < a; ) switch (d = mb(this, b), d) {
           case 16:
            for (f = 3 + X(this, 2); f--; ) c[g++] = e;
            break;

           case 17:
            for (f = 3 + X(this, 3); f--; ) c[g++] = 0;
            e = 0;
            break;

           case 18:
            for (f = 11 + X(this, 7); f--; ) c[g++] = 0;
            e = 0;
            break;

           default:
            e = c[g++] = d;
          }
          return c;
        }
        var b = X(a, 5) + 257, e = X(a, 5) + 1, f = X(a, 4) + 4, d = new (H ? Uint8Array : Array)(Za.length), g, h, m, j;
        for (j = 0; j < f; ++j) d[Za[j]] = X(a, 3);
        g = S(d);
        h = new (H ? Uint8Array : Array)(b);
        m = new (H ? Uint8Array : Array)(e);
        a.o(S(c.call(a, b, g, h)), S(c.call(a, e, g, m)));
      }
      V.prototype.o = function(a, c) {
        var b = this.a, e = this.b;
        this.u = a;
        for (var f = b.length - 258, d, g, h, m; 256 !== (d = mb(this, a)); ) if (256 > d) e >= f && (this.b = e, 
        b = this.f(), e = this.b), b[e++] = d; else {
          g = d - 257;
          m = ab[g];
          0 < cb[g] && (m += X(this, cb[g]));
          d = mb(this, c);
          h = eb[d];
          0 < gb[d] && (h += X(this, gb[d]));
          e >= f && (this.b = e, b = this.f(), e = this.b);
          for (;m--; ) b[e] = b[e++ - h];
        }
        for (;8 <= this.e; ) this.e -= 8, this.c--;
        this.b = e;
      };
      V.prototype.I = function(a, c) {
        var b = this.a, e = this.b;
        this.u = a;
        for (var f = b.length, d, g, h, m; 256 !== (d = mb(this, a)); ) if (256 > d) e >= f && (b = this.f(), 
        f = b.length), b[e++] = d; else {
          g = d - 257;
          m = ab[g];
          0 < cb[g] && (m += X(this, cb[g]));
          d = mb(this, c);
          h = eb[d];
          0 < gb[d] && (h += X(this, gb[d]));
          e + m > f && (b = this.f(), f = b.length);
          for (;m--; ) b[e] = b[e++ - h];
        }
        for (;8 <= this.e; ) this.e -= 8, this.c--;
        this.b = e;
      };
      V.prototype.f = function() {
        var a = new (H ? Uint8Array : Array)(this.b - 32768), c = this.b - 32768, b, e, f = this.a;
        if (H) a.set(f.subarray(32768, a.length)); else {
          b = 0;
          for (e = a.length; b < e; ++b) a[b] = f[b + 32768];
        }
        this.k.push(a);
        this.q += a.length;
        if (H) f.set(f.subarray(c, c + 32768)); else for (b = 0; 32768 > b; ++b) f[b] = f[c + b];
        this.b = 32768;
        return f;
      };
      V.prototype.J = function(a) {
        var c, b = this.input.length / this.c + 1 | 0, e, f, d, g = this.input, h = this.a;
        a && ("number" === typeof a.v && (b = a.v), "number" === typeof a.F && (b += a.F));
        2 > b ? (e = (g.length - this.c) / this.u[2], d = e / 2 * 258 | 0, f = d < h.length ? h.length + d : h.length << 1) : f = h.length * b;
        H ? (c = new Uint8Array(f), c.set(h)) : c = h;
        return this.a = c;
      };
      V.prototype.t = function() {
        var a = 0, c = this.a, b = this.k, e, f = new (H ? Uint8Array : Array)(this.q + (this.b - 32768)), d, g, h, m;
        if (0 === b.length) return H ? this.a.subarray(32768, this.b) : this.a.slice(32768, this.b);
        d = 0;
        for (g = b.length; d < g; ++d) {
          e = b[d];
          h = 0;
          for (m = e.length; h < m; ++h) f[a++] = e[h];
        }
        d = 32768;
        for (g = this.b; d < g; ++d) f[a++] = c[d];
        this.k = [];
        return this.buffer = f;
      };
      V.prototype.H = function() {
        var a, c = this.b;
        H ? this.B ? (a = new Uint8Array(c), a.set(this.a.subarray(0, c))) : a = this.a.subarray(0, c) : (this.a.length > c && (this.a.length = c), 
        a = this.a);
        return this.buffer = a;
      };
      function nb(a, c) {
        var b, e;
        this.input = a;
        this.c = 0;
        !c && (c = {}) || (c.index && (this.c = c.index), c.verify && (this.M = c.verify));
        b = a[this.c++];
        e = a[this.c++];
        switch (15 & b) {
         case Ea:
          this.method = Ea;
          break;

         default:
          i(Error("unsupported compression method"));
        }
        0 !== ((b << 8) + e) % 31 && i(Error("invalid fcheck flag:" + ((b << 8) + e) % 31));
        32 & e && i(Error("fdict flag is not supported"));
        this.A = new V(a, {
          index: this.c,
          bufferSize: c.bufferSize,
          bufferType: c.bufferType,
          resize: c.resize
        });
      }
      nb.prototype.p = function() {
        var a = this.input, c, b;
        c = this.A.p();
        this.c = this.A.c;
        this.M && (b = (a[this.c++] << 24 | a[this.c++] << 16 | a[this.c++] << 8 | a[this.c++]) >>> 0, 
        b !== ba(c) && i(Error("invalid adler-32 checksum")));
        return c;
      };
      y("Zlib.Inflate", nb);
      y("Zlib.Inflate.BufferType", Ha);
      Ha.ADAPTIVE = Ha.C;
      Ha.BLOCK = Ha.D;
      y("Zlib.Inflate.prototype.decompress", nb.prototype.p);
      var ob = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
      H && new Uint16Array(ob);
      var pb = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258 ];
      H && new Uint16Array(pb);
      var qb = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0 ];
      H && new Uint8Array(qb);
      var rb = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];
      H && new Uint16Array(rb);
      var sb = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];
      H && new Uint8Array(sb);
      var tb = new (H ? Uint8Array : Array)(288), Z, ub;
      Z = 0;
      for (ub = tb.length; Z < ub; ++Z) tb[Z] = 143 >= Z ? 8 : 255 >= Z ? 9 : 279 >= Z ? 7 : 8;
      S(tb);
      var vb = new (H ? Uint8Array : Array)(30), wb, xb;
      wb = 0;
      for (xb = vb.length; wb < xb; ++wb) vb[wb] = 5;
      S(vb);
      var Ea = 8;
    }).call(window);
    var _p = window.Zlib;
    _p.Deflate = _p["Deflate"];
    _p.Deflate.compress = _p.Deflate["compress"];
    _p.Inflate = _p["Inflate"];
    _p.Inflate.BufferType = _p.Inflate["BufferType"];
    _p.Inflate.prototype.decompress = _p.Inflate.prototype["decompress"];
    module.exports = _p;
  }), {} ],
  27: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _enums = _interopRequireDefault(require("../../renderer/enums"));
    var _color = _interopRequireDefault(require("../value-types/color"));
    var _valueTypes = require("../value-types");
    var _index = _interopRequireDefault(require("../renderer/index"));
    var _CCEnum = _interopRequireDefault(require("../platform/CCEnum"));
    var _CCComponent2 = _interopRequireDefault(require("../components/CCComponent"));
    var _CCClassDecorator = require("../platform/CCClassDecorator");
    var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _class3;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _assertThisInitialized(self) {
      if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var RendererLight = null;
    true, true;
    RendererLight = window.renderer.Light;
    var LightType = (0, _CCEnum["default"])({
      DIRECTIONAL: 0,
      POINT: 1,
      SPOT: 2,
      AMBIENT: 3
    });
    var LightShadowType = (0, _CCEnum["default"])({
      NONE: 0,
      HARD: 2,
      SOFT_PCF3X3: 3,
      SOFT_PCF5X5: 4
    });
    var Light = (_dec = (0, _CCClassDecorator.ccclass)("cc.Light"), _dec2 = (0, _CCClassDecorator.menu)("i18n:MAIN_MENU.component.renderers/Light"), 
    _dec3 = (0, _CCClassDecorator.inspector)("packages://inspector/inspectors/comps/light.js"), 
    _dec4 = (0, _CCClassDecorator.property)({
      type: LightType
    }), _dec5 = (0, _CCClassDecorator.property)({
      type: LightShadowType
    }), _dec(_class = _dec2(_class = (0, _CCClassDecorator.executeInEditMode)(_class = _dec3(_class = (_class2 = (_class3 = (function(_CCComponent) {
      _inheritsLoose(Light, _CCComponent);
      function Light() {
        var _this;
        _this = _CCComponent.call(this) || this;
        _initializerDefineProperty(_this, "_type", _descriptor, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_color", _descriptor2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_intensity", _descriptor3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_range", _descriptor4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_spotAngle", _descriptor5, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_spotExp", _descriptor6, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_shadowType", _descriptor7, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_shadowResolution", _descriptor8, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_shadowDarkness", _descriptor9, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_shadowMinDepth", _descriptor10, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_shadowMaxDepth", _descriptor11, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_shadowFrustumSize", _descriptor12, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_shadowBias", _descriptor13, _assertThisInitialized(_this));
        _this._light = new RendererLight();
        return _this;
      }
      var _proto = Light.prototype;
      _proto.onLoad = function onLoad() {
        this._light.setNode(this.node);
        this.type = this._type;
        this.color = this._color;
        this.intensity = this._intensity;
        this.range = this._range;
        this.spotAngle = this._spotAngle;
        this.spotExp = this._spotExp;
        this.shadowType = this._shadowType;
        this.shadowResolution = this._shadowResolution;
        this.shadowDarkness = this._shadowDarkness;
        this.shadowMaxDepth = this._shadowMaxDepth;
        this.shadowFrustumSize = this._shadowFrustumSize;
        this.shadowBias = this._shadowBias;
      };
      _proto.onEnable = function onEnable() {
        _index["default"].scene.addLight(this._light);
      };
      _proto.onDisable = function onDisable() {
        _index["default"].scene.removeLight(this._light);
      };
      _createClass(Light, [ {
        key: "type",
        get: function get() {
          return this._type;
        },
        set: function set(val) {
          this._type = val;
          var type = _enums["default"].LIGHT_DIRECTIONAL;
          val === LightType.POINT ? type = _enums["default"].LIGHT_POINT : val === LightType.SPOT ? type = _enums["default"].LIGHT_SPOT : val === LightType.AMBIENT && (type = _enums["default"].LIGHT_AMBIENT);
          this._light.setType(type);
        }
      }, {
        key: "color",
        get: function get() {
          return this._color;
        },
        set: function set(val) {
          this._color.equals(val) || this._color.set(val);
          this._light.setColor(val.r / 255, val.g / 255, val.b / 255);
        }
      }, {
        key: "intensity",
        get: function get() {
          return this._intensity;
        },
        set: function set(val) {
          this._intensity = val;
          this._light.setIntensity(val);
        }
      }, {
        key: "range",
        get: function get() {
          return this._range;
        },
        set: function set(val) {
          this._range = val;
          this._light.setRange(val);
        }
      }, {
        key: "spotAngle",
        get: function get() {
          return this._spotAngle;
        },
        set: function set(val) {
          this._spotAngle = val;
          this._light.setSpotAngle((0, _valueTypes.toRadian)(val));
        }
      }, {
        key: "spotExp",
        get: function get() {
          return this._spotExp;
        },
        set: function set(val) {
          this._spotExp = val;
          this._light.setSpotExp(val);
        }
      }, {
        key: "shadowType",
        get: function get() {
          return this._shadowType;
        },
        set: function set(val) {
          this._shadowType = val;
          this._light.setShadowType(val);
        }
      }, {
        key: "shadowResolution",
        get: function get() {
          return this._shadowResolution;
        },
        set: function set(val) {
          this._shadowResolution = val;
          this._light.setShadowResolution(val);
        }
      }, {
        key: "shadowDarkness",
        get: function get() {
          return this._shadowDarkness;
        },
        set: function set(val) {
          this._shadowDarkness = val;
          this._light.setShadowDarkness(val);
        }
      }, {
        key: "shadowMinDepth",
        get: function get() {
          return this._shadowMinDepth;
        },
        set: function set(val) {
          this._shadowMinDepth = val;
          this._light.setShadowMinDepth(val);
        }
      }, {
        key: "shadowMaxDepth",
        get: function get() {
          return this._shadowMaxDepth;
        },
        set: function set(val) {
          this._shadowMaxDepth = val;
          this._light.setShadowMaxDepth(val);
        }
      }, {
        key: "shadowFrustumSize",
        get: function get() {
          return this._shadowFrustumSize;
        },
        set: function set(val) {
          this._shadowFrustumSize = val;
          this._light.setShadowFrustumSize(val);
        }
      } ]);
      return Light;
    })(_CCComponent2["default"]), _class3.Type = LightType, _class3.ShadowType = LightShadowType, 
    _class3), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_type", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return LightType.DIRECTIONAL;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_color", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _color["default"].WHITE;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_intensity", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_range", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1e3;
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_spotAngle", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 60;
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "_spotExp", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "_shadowType", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return LightShadowType.NONE;
      }
    }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "_shadowResolution", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1024;
      }
    }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "_shadowDarkness", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return .5;
      }
    }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "_shadowMinDepth", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "_shadowMaxDepth", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 4096;
      }
    }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "_shadowFrustumSize", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1024;
      }
    }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "_shadowBias", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 5e-4;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "type", [ _dec4 ], Object.getOwnPropertyDescriptor(_class2.prototype, "type"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "color", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "color"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "intensity", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "intensity"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "range", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "range"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "spotAngle", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "spotAngle"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "spotExp", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "spotExp"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "shadowType", [ _dec5 ], Object.getOwnPropertyDescriptor(_class2.prototype, "shadowType"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "shadowResolution", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "shadowResolution"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "shadowDarkness", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "shadowDarkness"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "shadowMinDepth", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "shadowMinDepth"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "shadowMaxDepth", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "shadowMaxDepth"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "shadowFrustumSize", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "shadowFrustumSize"), _class2.prototype), 
    _class2)) || _class) || _class) || _class) || _class);
    exports["default"] = Light;
    cc.Light = Light;
    module.exports = exports["default"];
  }), {
    "../../renderer/enums": 426,
    "../../renderer/scene/light": void 0,
    "../components/CCComponent": 181,
    "../platform/CCClassDecorator": 273,
    "../platform/CCEnum": 274,
    "../renderer/index": 322,
    "../value-types": 401,
    "../value-types/color": 400
  } ],
  28: [ (function(require, module, exports) {
    "use strict";
    var Model = cc.Class({
      name: "cc.Model",
      extends: cc.Asset,
      ctor: function ctor() {
        this._rootNode = null;
        this.loaded = false;
      },
      properties: {
        _nodes: {
          default: []
        },
        _precomputeJointMatrix: false,
        nodes: {
          get: function get() {
            return this._nodes;
          }
        },
        rootNode: {
          get: function get() {
            return this._rootNode;
          }
        },
        precomputeJointMatrix: {
          get: function get() {
            return this._precomputeJointMatrix;
          }
        }
      },
      onLoad: function onLoad() {
        var nodes = this._nodes;
        this._rootNode = nodes[0];
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          node.position = cc.v3.apply(this, node.position);
          node.scale = cc.v3.apply(this, node.scale);
          node.quat = cc.quat.apply(this, node.quat);
          node.uniqueBindPose && (node.uniqueBindPose = cc.mat4.apply(this, node.uniqueBindPose));
          var pose = node.bindpose;
          if (pose) for (var _i in pose) pose[_i] = cc.mat4.apply(this, pose[_i]);
          var children = node.children;
          if (children) for (var _i2 = 0; _i2 < children.length; _i2++) children[_i2] = nodes[children[_i2]];
        }
      }
    });
    cc.Model = module.exports = Model;
  }), {} ],
  29: [ (function(require, module, exports) {
    "use strict";
    var _quat = _interopRequireDefault(require("../value-types/quat"));
    var _vec = _interopRequireDefault(require("../value-types/vec3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _quat_tmp = cc.quat();
    var _vec3_tmp = cc.v3();
    cc.Rotate3DTo = cc.Class({
      name: "cc.Rotate3DTo",
      extends: cc.ActionInterval,
      ctor: function ctor(duration, dstAngleX, dstAngleY, dstAngleZ) {
        this._startQuat = cc.quat();
        this._dstQuat = cc.quat();
        void 0 !== dstAngleX && this.initWithDuration(duration, dstAngleX, dstAngleY, dstAngleZ);
      },
      initWithDuration: function initWithDuration(duration, dstAngleX, dstAngleY, dstAngleZ) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          var dstQuat = this._dstQuat;
          if (dstAngleX instanceof cc.Quat) dstQuat.set(dstAngleX); else {
            if (dstAngleX instanceof cc.Vec3) {
              dstAngleY = dstAngleX.y;
              dstAngleZ = dstAngleX.z;
              dstAngleX = dstAngleX.x;
            } else {
              dstAngleY = dstAngleY || 0;
              dstAngleZ = dstAngleZ || 0;
            }
            _quat["default"].fromEuler(dstQuat, dstAngleX, dstAngleY, dstAngleZ);
          }
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.Rotate3DTo();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._dstQuat);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        this._startQuat.set(target.quat);
      },
      reverse: function reverse() {
        cc.logID(1016);
      },
      update: function update(dt) {
        dt = this._computeEaseTime(dt);
        if (this.target) {
          _quat["default"].slerp(_quat_tmp, this._startQuat, this._dstQuat, dt);
          this.target.setRotation(_quat_tmp);
        }
      }
    });
    cc.rotate3DTo = function(duration, dstAngleX, dstAngleY, dstAngleZ) {
      return new cc.Rotate3DTo(duration, dstAngleX, dstAngleY, dstAngleZ);
    };
    cc.Rotate3DBy = cc.Class({
      name: "cc.Rotate3DBy",
      extends: cc.ActionInterval,
      ctor: function ctor(duration, deltaAngleX, deltaAngleY, deltaAngleZ) {
        this._startQuat = cc.quat();
        this._dstQuat = cc.quat();
        this._deltaAngle = cc.v3();
        void 0 !== deltaAngleX && this.initWithDuration(duration, deltaAngleX, deltaAngleY, deltaAngleZ);
      },
      initWithDuration: function initWithDuration(duration, deltaAngleX, deltaAngleY, deltaAngleZ) {
        if (cc.ActionInterval.prototype.initWithDuration.call(this, duration)) {
          if (deltaAngleX instanceof cc.Vec3) {
            deltaAngleY = deltaAngleX.y;
            deltaAngleZ = deltaAngleX.z;
            deltaAngleX = deltaAngleX.x;
          } else {
            deltaAngleY = deltaAngleY || 0;
            deltaAngleZ = deltaAngleZ || 0;
          }
          _vec["default"].set(this._deltaAngle, deltaAngleX, deltaAngleY, deltaAngleZ);
          return true;
        }
        return false;
      },
      clone: function clone() {
        var action = new cc.Rotate3DBy();
        this._cloneDecoration(action);
        action.initWithDuration(this._duration, this._angle);
        return action;
      },
      startWithTarget: function startWithTarget(target) {
        cc.ActionInterval.prototype.startWithTarget.call(this, target);
        var startAngle = target.eulerAngles;
        var deltaAngle = this._deltaAngle;
        _quat["default"].fromEuler(this._dstQuat, startAngle.x + deltaAngle.x, startAngle.y + deltaAngle.y, startAngle.z + deltaAngle.z);
        this._startQuat.set(target.quat);
      },
      update: (function() {
        var RAD = Math.PI / 180;
        return function(dt) {
          dt = this._computeEaseTime(dt);
          if (this.target) {
            _quat["default"].slerp(_quat_tmp, this._startQuat, this._dstQuat, dt);
            this.target.setRotation(_quat_tmp);
          }
        };
      })(),
      reverse: function reverse() {
        var angle = this._angle;
        _vec3_tmp.x = -angle.x;
        _vec3_tmp.y = -angle.y;
        _vec3_tmp.z = -angle.z;
        var action = new cc.Rotate3DBy(this._duration, _vec3_tmp);
        this._cloneDecoration(action);
        this._reverseEaseList(action);
        return action;
      }
    });
    cc.rotate3DBy = function(duration, deltaAngleX, deltaAngleY, deltaAngleZ) {
      return new cc.Rotate3DBy(duration, deltaAngleX, deltaAngleY, deltaAngleZ);
    };
  }), {
    "../value-types/quat": 404,
    "../value-types/vec3": 411
  } ],
  30: [ (function(require, module, exports) {
    "use strict";
    true, true;
    require("./primitive");
    require("./physics/exports/physics-builtin");
    require("./physics/exports/physics-cannon");
    require("./physics/exports/physics-framework");
    require("./CCModel");
    require("./skeleton/CCSkeleton");
    require("./skeleton/CCSkeletonAnimationClip");
    require("./actions");
    require("./physics/framework/assets/physics-material");
    true;
    require("./skeleton/CCSkeletonAnimation");
    require("./skeleton/CCSkinnedMeshRenderer");
    require("./skeleton/skinned-mesh-renderer");
    require("./CCLightComponent");
    require("./particle/particle-system-3d");
    require("./particle/renderer/particle-system-3d-renderer");
  }), {
    "./CCLightComponent": 27,
    "./CCModel": 28,
    "./actions": 29,
    "./particle/particle-system-3d": 46,
    "./particle/renderer/particle-system-3d-renderer": 49,
    "./physics/exports/physics-builtin": 67,
    "./physics/exports/physics-cannon": 68,
    "./physics/exports/physics-framework": 69,
    "./physics/framework/assets/physics-material": 70,
    "./primitive": 87,
    "./skeleton/CCSkeleton": 96,
    "./skeleton/CCSkeletonAnimation": 97,
    "./skeleton/CCSkeletonAnimationClip": 98,
    "./skeleton/CCSkinnedMeshRenderer": 99,
    "./skeleton/skinned-mesh-renderer": 100
  } ],
  31: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _CCClassDecorator = require("../../../platform/CCClassDecorator");
    var _valueTypes = require("../../../value-types");
    var _gradientRange = _interopRequireDefault(require("./gradient-range"));
    var _dec, _dec2, _class, _class2, _descriptor, _descriptor2;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var COLOR_OVERTIME_RAND_OFFSET = 91041;
    var ColorOvertimeModule = (_dec = (0, _CCClassDecorator.ccclass)("cc.ColorOvertimeModule"), 
    _dec2 = (0, _CCClassDecorator.property)({
      type: _gradientRange["default"]
    }), _dec(_class = (_class2 = (function() {
      function ColorOvertimeModule() {
        _initializerDefineProperty(this, "enable", _descriptor, this);
        _initializerDefineProperty(this, "color", _descriptor2, this);
      }
      var _proto = ColorOvertimeModule.prototype;
      _proto.animate = function animate(particle) {
        if (this.enable) {
          particle.color.set(particle.startColor);
          particle.color.multiply(this.color.evaluate(1 - particle.remainingLifetime / particle.startLifetime, (0, 
          _valueTypes.pseudoRandom)(particle.randomSeed + COLOR_OVERTIME_RAND_OFFSET)));
        }
      };
      return ColorOvertimeModule;
    })(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "enable", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "color", [ _dec2 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _gradientRange["default"]();
      }
    }), _class2)) || _class);
    exports["default"] = ColorOvertimeModule;
    module.exports = exports["default"];
  }), {
    "../../../platform/CCClassDecorator": 273,
    "../../../value-types": 401,
    "./gradient-range": 34
  } ],
  32: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = exports.Mode = void 0;
    var _CCClassDecorator = require("../../../platform/CCClassDecorator");
    var _CCEnum = _interopRequireDefault(require("../../../platform/CCEnum"));
    var _valueTypes = require("../../../value-types");
    var _curve = require("../curve");
    var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _class3;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var SerializableTable = false;
    var Mode = (0, _CCEnum["default"])({
      Constant: 0,
      Curve: 1,
      TwoCurves: 2,
      TwoConstants: 3
    });
    exports.Mode = Mode;
    var CurveRange = (_dec = (0, _CCClassDecorator.ccclass)("cc.CurveRange"), _dec2 = (0, 
    _CCClassDecorator.property)({
      type: Mode
    }), _dec3 = (0, _CCClassDecorator.property)({
      type: _curve.AnimationCurve
    }), _dec4 = (0, _CCClassDecorator.property)({
      type: _curve.AnimationCurve
    }), _dec5 = (0, _CCClassDecorator.property)({
      type: _curve.AnimationCurve
    }), _dec(_class = (_class2 = (_class3 = (function() {
      function CurveRange() {
        _initializerDefineProperty(this, "mode", _descriptor, this);
        _initializerDefineProperty(this, "curve", _descriptor2, this);
        _initializerDefineProperty(this, "curveMin", _descriptor3, this);
        _initializerDefineProperty(this, "curveMax", _descriptor4, this);
        _initializerDefineProperty(this, "constant", _descriptor5, this);
        _initializerDefineProperty(this, "constantMin", _descriptor6, this);
        _initializerDefineProperty(this, "constantMax", _descriptor7, this);
        _initializerDefineProperty(this, "multiplier", _descriptor8, this);
      }
      var _proto = CurveRange.prototype;
      _proto.evaluate = function evaluate(time, rndRatio) {
        switch (this.mode) {
         case Mode.Constant:
          return this.constant;

         case Mode.Curve:
          return this.curve.evaluate(time) * this.multiplier;

         case Mode.TwoCurves:
          return (0, _valueTypes.lerp)(this.curveMin.evaluate(time), this.curveMax.evaluate(time), rndRatio) * this.multiplier;

         case Mode.TwoConstants:
          return (0, _valueTypes.lerp)(this.constantMin, this.constantMax, rndRatio);
        }
      };
      _proto.getMax = function getMax() {
        switch (this.mode) {
         case Mode.Constant:
          return this.constant;

         case Mode.Curve:
          return this.multiplier;

         case Mode.TwoConstants:
          return this.constantMax;

         case Mode.TwoCurves:
          return this.multiplier;
        }
        return 0;
      };
      return CurveRange;
    })(), _class3.Mode = Mode, _class3), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "mode", [ _dec2 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return Mode.Constant;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "curve", [ _dec3 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curve.AnimationCurve();
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "curveMin", [ _dec4 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curve.AnimationCurve();
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "curveMax", [ _dec5 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curve.AnimationCurve();
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "constant", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "constantMin", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "constantMax", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "multiplier", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _class2)) || _class);
    exports["default"] = CurveRange;
    false;
    cc.CurveRange = CurveRange;
  }), {
    "../../../platform/CCClassDecorator": 273,
    "../../../platform/CCEnum": 274,
    "../../../value-types": 401,
    "../curve": 42
  } ],
  33: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _CCClassDecorator = require("../../../platform/CCClassDecorator");
    var _valueTypes = require("../../../value-types");
    var _enum = require("../enum");
    var _particleGeneralFunction = require("../particle-general-function");
    var _curveRange = _interopRequireDefault(require("./curve-range"));
    var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var FORCE_OVERTIME_RAND_OFFSET = 212165;
    var _temp_v3 = cc.v3();
    var ForceOvertimeModule = (_dec = (0, _CCClassDecorator.ccclass)("cc.ForceOvertimeModule"), 
    _dec2 = (0, _CCClassDecorator.property)({
      type: _enum.Space
    }), _dec3 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ]
    }), _dec4 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ]
    }), _dec5 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ],
      displayOrder: 4
    }), _dec(_class = (_class2 = (function() {
      function ForceOvertimeModule() {
        _initializerDefineProperty(this, "enable", _descriptor, this);
        _initializerDefineProperty(this, "space", _descriptor2, this);
        _initializerDefineProperty(this, "x", _descriptor3, this);
        _initializerDefineProperty(this, "y", _descriptor4, this);
        _initializerDefineProperty(this, "z", _descriptor5, this);
        this.randomized = false;
        this.rotation = null;
        this.needTransform = false;
        this.rotation = new _valueTypes.Quat();
        this.needTransform = false;
      }
      var _proto = ForceOvertimeModule.prototype;
      _proto.update = function update(space, worldTransform) {
        this.needTransform = (0, _particleGeneralFunction.calculateTransform)(space, this.space, worldTransform, this.rotation);
      };
      _proto.animate = function animate(p, dt) {
        var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
        var force = _valueTypes.Vec3.set(_temp_v3, this.x.evaluate(normalizedTime, (0, _valueTypes.pseudoRandom)(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET)), this.y.evaluate(normalizedTime, (0, 
        _valueTypes.pseudoRandom)(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET)), this.z.evaluate(normalizedTime, (0, 
        _valueTypes.pseudoRandom)(p.randomSeed + FORCE_OVERTIME_RAND_OFFSET)));
        this.needTransform && _valueTypes.Vec3.transformQuat(force, force, this.rotation);
        _valueTypes.Vec3.scaleAndAdd(p.velocity, p.velocity, force, dt);
      };
      return ForceOvertimeModule;
    })(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "enable", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "space", [ _dec2 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _enum.Space.Local;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "x", [ _dec3 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "y", [ _dec4 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "z", [ _dec5 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _class2)) || _class);
    exports["default"] = ForceOvertimeModule;
    module.exports = exports["default"];
  }), {
    "../../../platform/CCClassDecorator": 273,
    "../../../value-types": 401,
    "../enum": 44,
    "../particle-general-function": 45,
    "./curve-range": 32
  } ],
  34: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _CCClassDecorator = require("../../../platform/CCClassDecorator");
    var _CCEnum = _interopRequireDefault(require("../../../platform/CCEnum"));
    var _gradient = require("./gradient");
    var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _class3;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var GRADIENT_MODE_FIX = 0;
    var GRADIENT_MODE_BLEND = 1;
    var GRADIENT_RANGE_MODE_COLOR = 0;
    var GRADIENT_RANGE_MODE_TWO_COLOR = 1;
    var GRADIENT_RANGE_MODE_RANDOM_COLOR = 2;
    var GRADIENT_RANGE_MODE_GRADIENT = 3;
    var GRADIENT_RANGE_MODE_TWO_GRADIENT = 4;
    var SerializableTable = false;
    var Mode = (0, _CCEnum["default"])({
      Color: 0,
      Gradient: 1,
      TwoColors: 2,
      TwoGradients: 3,
      RandomColor: 4
    });
    var GradientRange = (_dec = (0, _CCClassDecorator.ccclass)("cc.GradientRange"), 
    _dec2 = (0, _CCClassDecorator.property)({
      type: Mode
    }), _dec3 = (0, _CCClassDecorator.property)({
      type: _gradient.Gradient
    }), _dec4 = (0, _CCClassDecorator.property)({
      type: _gradient.Gradient
    }), _dec5 = (0, _CCClassDecorator.property)({
      type: _gradient.Gradient
    }), _dec(_class = (_class2 = (_class3 = (function() {
      function GradientRange() {
        _initializerDefineProperty(this, "_mode", _descriptor, this);
        _initializerDefineProperty(this, "_color", _descriptor2, this);
        _initializerDefineProperty(this, "color", _descriptor3, this);
        _initializerDefineProperty(this, "colorMin", _descriptor4, this);
        _initializerDefineProperty(this, "colorMax", _descriptor5, this);
        _initializerDefineProperty(this, "gradient", _descriptor6, this);
        _initializerDefineProperty(this, "gradientMin", _descriptor7, this);
        _initializerDefineProperty(this, "gradientMax", _descriptor8, this);
      }
      var _proto = GradientRange.prototype;
      _proto.evaluate = function evaluate(time, rndRatio) {
        switch (this._mode) {
         case Mode.Color:
          return this.color;

         case Mode.TwoColors:
          this.colorMin.lerp(this.colorMax, rndRatio, this._color);
          return this._color;

         case Mode.RandomColor:
          return this.gradient.randomColor();

         case Mode.Gradient:
          return this.gradient.evaluate(time);

         case Mode.TwoGradients:
          this.gradientMin.evaluate(time).lerp(this.gradientMax.evaluate(time), rndRatio, this._color);
          return this._color;

         default:
          return this.color;
        }
      };
      _createClass(GradientRange, [ {
        key: "mode",
        get: function get() {
          return this._mode;
        },
        set: function set(m) {
          false;
          this._mode = m;
        }
      } ]);
      return GradientRange;
    })(), _class3.Mode = Mode, _class3), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_mode", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return Mode.Color;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "mode", [ _dec2 ], Object.getOwnPropertyDescriptor(_class2.prototype, "mode"), _class2.prototype), 
    _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_color", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return cc.Color.WHITE.clone();
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "color", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return cc.Color.WHITE.clone();
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "colorMin", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return cc.Color.WHITE.clone();
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "colorMax", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return cc.Color.WHITE.clone();
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "gradient", [ _dec3 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _gradient.Gradient();
      }
    }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "gradientMin", [ _dec4 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _gradient.Gradient();
      }
    }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "gradientMax", [ _dec5 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _gradient.Gradient();
      }
    }), _class2)) || _class);
    exports["default"] = GradientRange;
    false;
    cc.GradientRange = GradientRange;
    module.exports = exports["default"];
  }), {
    "../../../platform/CCClassDecorator": 273,
    "../../../platform/CCEnum": 274,
    "./gradient": 35
  } ],
  35: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.Gradient = exports.ColorKey = exports.AlphaKey = void 0;
    var _CCClassDecorator = require("../../../platform/CCClassDecorator");
    var _CCEnum = _interopRequireDefault(require("../../../platform/CCEnum"));
    var _valueTypes = require("../../../value-types");
    var _dec, _class, _class2, _descriptor, _descriptor2, _dec2, _class4, _class5, _descriptor3, _descriptor4, _dec3, _dec4, _dec5, _dec6, _class7, _class8, _descriptor5, _descriptor6, _descriptor7, _class9;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var Mode = (0, _CCEnum["default"])({
      Blend: 0,
      Fixed: 1
    });
    var ColorKey = (_dec = (0, _CCClassDecorator.ccclass)("cc.ColorKey"), _dec(_class = (_class2 = function ColorKey() {
      _initializerDefineProperty(this, "color", _descriptor, this);
      _initializerDefineProperty(this, "time", _descriptor2, this);
    }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "color", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return cc.Color.WHITE.clone();
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "time", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _class2)) || _class);
    exports.ColorKey = ColorKey;
    var AlphaKey = (_dec2 = (0, _CCClassDecorator.ccclass)("cc.AlphaKey"), _dec2(_class4 = (_class5 = function AlphaKey() {
      _initializerDefineProperty(this, "alpha", _descriptor3, this);
      _initializerDefineProperty(this, "time", _descriptor4, this);
    }, _descriptor3 = _applyDecoratedDescriptor(_class5.prototype, "alpha", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class5.prototype, "time", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _class5)) || _class4);
    exports.AlphaKey = AlphaKey;
    var Gradient = (_dec3 = (0, _CCClassDecorator.ccclass)("cc.Gradient"), _dec4 = (0, 
    _CCClassDecorator.property)({
      type: [ ColorKey ]
    }), _dec5 = (0, _CCClassDecorator.property)({
      type: [ AlphaKey ]
    }), _dec6 = (0, _CCClassDecorator.property)({
      type: Mode
    }), _dec3(_class7 = (_class8 = (_class9 = (function() {
      function Gradient() {
        _initializerDefineProperty(this, "colorKeys", _descriptor5, this);
        _initializerDefineProperty(this, "alphaKeys", _descriptor6, this);
        _initializerDefineProperty(this, "mode", _descriptor7, this);
        this._color = null;
        this._color = cc.Color.WHITE.clone();
      }
      var _proto = Gradient.prototype;
      _proto.setKeys = function setKeys(colorKeys, alphaKeys) {
        this.colorKeys = colorKeys;
        this.alphaKeys = alphaKeys;
      };
      _proto.sortKeys = function sortKeys() {
        this.colorKeys.length > 1 && this.colorKeys.sort((function(a, b) {
          return a.time - b.time;
        }));
        this.alphaKeys.length > 1 && this.alphaKeys.sort((function(a, b) {
          return a.time - b.time;
        }));
      };
      _proto.evaluate = function evaluate(time) {
        this.getRGB(time);
        this._color._fastSetA(this.getAlpha(time));
        return this._color;
      };
      _proto.randomColor = function randomColor() {
        var c = this.colorKeys[Math.trunc(Math.random() * this.colorKeys.length)];
        var a = this.alphaKeys[Math.trunc(Math.random() * this.alphaKeys.length)];
        this._color.set(c.color);
        this._color._fastSetA(a.alpha);
        return this._color;
      };
      _proto.getRGB = function getRGB(time) {
        if (!(this.colorKeys.length > 1)) {
          if (1 === this.colorKeys.length) {
            this._color.set(this.colorKeys[0].color);
            return this._color;
          }
          this._color.set(cc.Color.WHITE);
          return this._color;
        }
        time = (0, _valueTypes.repeat)(time, 1);
        for (var i = 1; i < this.colorKeys.length; ++i) {
          var preTime = this.colorKeys[i - 1].time;
          var curTime = this.colorKeys[i].time;
          if (time >= preTime && time < curTime) {
            if (this.mode === Mode.Fixed) return this.colorKeys[i].color;
            var factor = (time - preTime) / (curTime - preTime);
            this.colorKeys[i - 1].color.lerp(this.colorKeys[i].color, factor, this._color);
            return this._color;
          }
        }
        var lastIndex = this.colorKeys.length - 1;
        time < this.colorKeys[0].time ? cc.Color.BLACK.lerp(this.colorKeys[0].color, time / this.colorKeys[0].time, this._color) : time > this.colorKeys[lastIndex].time && this.colorKeys[lastIndex].color.lerp(cc.Color.BLACK, (time - this.colorKeys[lastIndex].time) / (1 - this.colorKeys[lastIndex].time), this._color);
      };
      _proto.getAlpha = function getAlpha(time) {
        if (!(this.alphaKeys.length > 1)) return 1 === this.alphaKeys.length ? this.alphaKeys[0].alpha : 255;
        time = (0, _valueTypes.repeat)(time, 1);
        for (var i = 1; i < this.alphaKeys.length; ++i) {
          var preTime = this.alphaKeys[i - 1].time;
          var curTime = this.alphaKeys[i].time;
          if (time >= preTime && time < curTime) {
            if (this.mode === Mode.Fixed) return this.alphaKeys[i].alpha;
            var factor = (time - preTime) / (curTime - preTime);
            return (0, _valueTypes.lerp)(this.alphaKeys[i - 1].alpha, this.alphaKeys[i].alpha, factor);
          }
        }
        var lastIndex = this.alphaKeys.length - 1;
        if (time < this.alphaKeys[0].time) return (0, _valueTypes.lerp)(255, this.alphaKeys[0].alpha, time / this.alphaKeys[0].time);
        if (time > this.alphaKeys[lastIndex].time) return (0, _valueTypes.lerp)(this.alphaKeys[lastIndex].alpha, 255, (time - this.alphaKeys[lastIndex].time) / (1 - this.alphaKeys[lastIndex].time));
      };
      return Gradient;
    })(), _class9.Mode = Mode, _class9), _descriptor5 = _applyDecoratedDescriptor(_class8.prototype, "colorKeys", [ _dec4 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new Array();
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class8.prototype, "alphaKeys", [ _dec5 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new Array();
      }
    }), _descriptor7 = _applyDecoratedDescriptor(_class8.prototype, "mode", [ _dec6 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return Mode.Blend;
      }
    }), _class8)) || _class7);
    exports.Gradient = Gradient;
    cc.ColorKey = ColorKey;
    cc.AlphaKey = AlphaKey;
    cc.Gradient = Gradient;
  }), {
    "../../../platform/CCClassDecorator": 273,
    "../../../platform/CCEnum": 274,
    "../../../value-types": 401
  } ],
  36: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _CCClassDecorator = require("../../../platform/CCClassDecorator");
    var _valueTypes = require("../../../value-types");
    var _enum = require("../enum");
    var _curveRange = _interopRequireDefault(require("./curve-range"));
    var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var LIMIT_VELOCITY_RAND_OFFSET = 23541;
    var _temp_v3 = cc.v3();
    var _temp_v3_1 = cc.v3();
    function dampenBeyondLimit(vel, limit, dampen) {
      var sgn = Math.sign(vel);
      var abs = Math.abs(vel);
      abs > limit && (abs = (0, _valueTypes.lerp)(abs, limit, dampen));
      return abs * sgn;
    }
    var LimitVelocityOvertimeModule = (_dec = (0, _CCClassDecorator.ccclass)("cc.LimitVelocityOvertimeModule"), 
    _dec2 = (0, _CCClassDecorator.property)({
      type: _enum.Space
    }), _dec3 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ],
      visible: function visible() {
        return !this.separateAxes;
      }
    }), _dec4 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ],
      visible: function visible() {
        return this.separateAxes;
      }
    }), _dec5 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ],
      visible: function visible() {
        return this.separateAxes;
      }
    }), _dec6 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ],
      visible: function visible() {
        return this.separateAxes;
      }
    }), _dec(_class = (_class2 = (function() {
      function LimitVelocityOvertimeModule() {
        _initializerDefineProperty(this, "enable", _descriptor, this);
        _initializerDefineProperty(this, "space", _descriptor2, this);
        _initializerDefineProperty(this, "separateAxes", _descriptor3, this);
        _initializerDefineProperty(this, "limit", _descriptor4, this);
        _initializerDefineProperty(this, "limitX", _descriptor5, this);
        _initializerDefineProperty(this, "limitY", _descriptor6, this);
        _initializerDefineProperty(this, "limitZ", _descriptor7, this);
        _initializerDefineProperty(this, "dampen", _descriptor8, this);
        this.drag = null;
        this.multiplyDragByParticleSize = false;
        this.multiplyDragByParticleVelocity = false;
        this.rotation = null;
        this.needTransform = false;
        this.rotation = new _valueTypes.Quat();
        this.needTransform = false;
      }
      var _proto = LimitVelocityOvertimeModule.prototype;
      _proto.update = function update(space, worldTransform) {
        this.needTransform = calculateTransform(space, this.space, worldTransform, this.rotation);
      };
      _proto.animate = function animate(p) {
        var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
        var dampedVel = _temp_v3;
        if (this.separateAxes) {
          _valueTypes.Vec3.set(_temp_v3_1, this.limitX.evaluate(normalizedTime, (0, _valueTypes.pseudoRandom)(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)), this.limitY.evaluate(normalizedTime, (0, 
          _valueTypes.pseudoRandom)(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)), this.limitZ.evaluate(normalizedTime, (0, 
          _valueTypes.pseudoRandom)(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)));
          this.needTransform && _valueTypes.Vec3.transformQuat(_temp_v3_1, _temp_v3_1, this.rotation);
          _valueTypes.Vec3.set(dampedVel, dampenBeyondLimit(p.ultimateVelocity.x, _temp_v3_1.x, this.dampen), dampenBeyondLimit(p.ultimateVelocity.y, _temp_v3_1.y, this.dampen), dampenBeyondLimit(p.ultimateVelocity.z, _temp_v3_1.z, this.dampen));
        } else {
          _valueTypes.Vec3.normalize(dampedVel, p.ultimateVelocity);
          _valueTypes.Vec3.scale(dampedVel, dampedVel, dampenBeyondLimit(p.ultimateVelocity.len(), this.limit.evaluate(normalizedTime, (0, 
          _valueTypes.pseudoRandom)(p.randomSeed + LIMIT_VELOCITY_RAND_OFFSET)), this.dampen));
        }
        _valueTypes.Vec3.copy(p.ultimateVelocity, dampedVel);
      };
      return LimitVelocityOvertimeModule;
    })(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "enable", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "space", [ _dec2 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _enum.Space.Local;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "separateAxes", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "limit", [ _dec3 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "limitX", [ _dec4 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "limitY", [ _dec5 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "limitZ", [ _dec6 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "dampen", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 3;
      }
    }), _class2)) || _class);
    exports["default"] = LimitVelocityOvertimeModule;
    module.exports = exports["default"];
  }), {
    "../../../platform/CCClassDecorator": 273,
    "../../../value-types": 401,
    "../enum": 44,
    "./curve-range": 32
  } ],
  37: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _CCClassDecorator = require("../../../platform/CCClassDecorator");
    var _valueTypes = require("../../../value-types");
    var _curveRange = _interopRequireDefault(require("./curve-range"));
    var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var ROTATION_OVERTIME_RAND_OFFSET = 125292;
    var RotationOvertimeModule = (_dec = (0, _CCClassDecorator.ccclass)("cc.RotationOvertimeModule"), 
    _dec2 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ],
      radian: true,
      visible: function visible() {
        return this._separateAxes;
      }
    }), _dec3 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ],
      radian: true,
      visible: function visible() {
        return this._separateAxes;
      }
    }), _dec4 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ],
      radian: true
    }), _dec(_class = (_class2 = (function() {
      function RotationOvertimeModule() {
        _initializerDefineProperty(this, "enable", _descriptor, this);
        _initializerDefineProperty(this, "_separateAxes", _descriptor2, this);
        _initializerDefineProperty(this, "x", _descriptor3, this);
        _initializerDefineProperty(this, "y", _descriptor4, this);
        _initializerDefineProperty(this, "z", _descriptor5, this);
      }
      var _proto = RotationOvertimeModule.prototype;
      _proto.animate = function animate(p, dt) {
        var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
        if (this._separateAxes) {
          var rotationRand = (0, _valueTypes.pseudoRandom)(p.randomSeed + ROTATION_OVERTIME_RAND_OFFSET);
          p.rotation.x += this.x.evaluate(normalizedTime, rotationRand) * dt;
          p.rotation.y += this.y.evaluate(normalizedTime, rotationRand) * dt;
          p.rotation.z += this.z.evaluate(normalizedTime, rotationRand) * dt;
        } else p.rotation.x += this.z.evaluate(normalizedTime, (0, _valueTypes.pseudoRandom)(p.randomSeed + ROTATION_OVERTIME_RAND_OFFSET)) * dt;
      };
      _createClass(RotationOvertimeModule, [ {
        key: "separateAxes",
        get: function get() {
          return this._separateAxes;
        },
        set: function set(val) {
          this._separateAxes = val;
        }
      } ]);
      return RotationOvertimeModule;
    })(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "enable", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_separateAxes", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "separateAxes", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "separateAxes"), _class2.prototype), 
    _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "x", [ _dec2 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "y", [ _dec3 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "z", [ _dec4 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _class2)) || _class);
    exports["default"] = RotationOvertimeModule;
    module.exports = exports["default"];
  }), {
    "../../../platform/CCClassDecorator": 273,
    "../../../value-types": 401,
    "./curve-range": 32
  } ],
  38: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _CCClassDecorator = require("../../../platform/CCClassDecorator");
    var _valueTypes = require("../../../value-types");
    var _curveRange = _interopRequireDefault(require("./curve-range"));
    var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var SIZE_OVERTIME_RAND_OFFSET = 39825;
    var SizeOvertimeModule = (_dec = (0, _CCClassDecorator.ccclass)("cc.SizeOvertimeModule"), 
    _dec2 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      visible: function visible() {
        return !this.separateAxes;
      }
    }), _dec3 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      visible: function visible() {
        return this.separateAxes;
      }
    }), _dec4 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      visible: function visible() {
        return this.separateAxes;
      }
    }), _dec5 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      visible: function visible() {
        return this.separateAxes;
      }
    }), _dec(_class = (_class2 = (function() {
      function SizeOvertimeModule() {
        _initializerDefineProperty(this, "enable", _descriptor, this);
        _initializerDefineProperty(this, "separateAxes", _descriptor2, this);
        _initializerDefineProperty(this, "size", _descriptor3, this);
        _initializerDefineProperty(this, "x", _descriptor4, this);
        _initializerDefineProperty(this, "y", _descriptor5, this);
        _initializerDefineProperty(this, "z", _descriptor6, this);
      }
      var _proto = SizeOvertimeModule.prototype;
      _proto.animate = function animate(particle) {
        if (this.separateAxes) {
          var currLifetime = 1 - particle.remainingLifetime / particle.startLifetime;
          var sizeRand = (0, _valueTypes.pseudoRandom)(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET);
          particle.size.x = particle.startSize.x * this.x.evaluate(currLifetime, sizeRand);
          particle.size.y = particle.startSize.y * this.y.evaluate(currLifetime, sizeRand);
          particle.size.z = particle.startSize.z * this.z.evaluate(currLifetime, sizeRand);
        } else _valueTypes.Vec3.scale(particle.size, particle.startSize, this.size.evaluate(1 - particle.remainingLifetime / particle.startLifetime, (0, 
        _valueTypes.pseudoRandom)(particle.randomSeed + SIZE_OVERTIME_RAND_OFFSET)));
      };
      return SizeOvertimeModule;
    })(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "enable", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "separateAxes", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "size", [ _dec2 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "x", [ _dec3 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "y", [ _dec4 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "z", [ _dec5 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _class2)) || _class);
    exports["default"] = SizeOvertimeModule;
    module.exports = exports["default"];
  }), {
    "../../../platform/CCClassDecorator": 273,
    "../../../value-types": 401,
    "./curve-range": 32
  } ],
  39: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _CCClassDecorator = require("../../../platform/CCClassDecorator");
    var _CCEnum = _interopRequireDefault(require("../../../platform/CCEnum"));
    var _valueTypes = require("../../../value-types");
    var _curveRange = _interopRequireDefault(require("./curve-range"));
    var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var TEXTURE_ANIMATION_RAND_OFFSET = 90794;
    var Mode = (0, _CCEnum["default"])({
      Grid: 0
    });
    var Animation = (0, _CCEnum["default"])({
      WholeSheet: 0,
      SingleRow: 1
    });
    var TextureAnimationModule = (_dec = (0, _CCClassDecorator.ccclass)("cc.TextureAnimationModule"), 
    _dec2 = (0, _CCClassDecorator.property)({
      type: Mode
    }), _dec3 = (0, _CCClassDecorator.property)({
      type: Animation
    }), _dec4 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"]
    }), _dec5 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"]
    }), _dec(_class = (_class2 = (function() {
      function TextureAnimationModule() {
        _initializerDefineProperty(this, "_enable", _descriptor, this);
        _initializerDefineProperty(this, "_mode", _descriptor2, this);
        _initializerDefineProperty(this, "_numTilesX", _descriptor3, this);
        _initializerDefineProperty(this, "_numTilesY", _descriptor4, this);
        _initializerDefineProperty(this, "animation", _descriptor5, this);
        _initializerDefineProperty(this, "randomRow", _descriptor6, this);
        _initializerDefineProperty(this, "rowIndex", _descriptor7, this);
        _initializerDefineProperty(this, "frameOverTime", _descriptor8, this);
        _initializerDefineProperty(this, "startFrame", _descriptor9, this);
        _initializerDefineProperty(this, "cycleCount", _descriptor10, this);
        this._flipU = 0;
        this._flipV = 0;
        this._uvChannelMask = -1;
        this.ps = null;
      }
      var _proto = TextureAnimationModule.prototype;
      _proto.onInit = function onInit(ps) {
        this.ps = ps;
      };
      _proto.init = function init(p) {
        p.startRow = Math.floor(Math.random() * this.numTilesY);
      };
      _proto.animate = function animate(p) {
        var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
        var startFrame = this.startFrame.evaluate(normalizedTime, (0, _valueTypes.pseudoRandom)(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) / (this.numTilesX * this.numTilesY);
        if (this.animation === Animation.WholeSheet) p.frameIndex = (0, _valueTypes.repeat)(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, (0, 
        _valueTypes.pseudoRandom)(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) + startFrame), 1); else if (this.animation === Animation.SingleRow) {
          var rowLength = 1 / this.numTilesY;
          if (this.randomRow) {
            var f = (0, _valueTypes.repeat)(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, (0, 
            _valueTypes.pseudoRandom)(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) + startFrame), 1);
            var from = p.startRow * rowLength;
            var to = from + rowLength;
            p.frameIndex = (0, _valueTypes.lerp)(from, to, f);
          } else {
            var _from = this.rowIndex * rowLength;
            var _to = _from + rowLength;
            p.frameIndex = (0, _valueTypes.lerp)(_from, _to, (0, _valueTypes.repeat)(this.cycleCount * (this.frameOverTime.evaluate(normalizedTime, (0, 
            _valueTypes.pseudoRandom)(p.randomSeed + TEXTURE_ANIMATION_RAND_OFFSET)) + startFrame), 1));
          }
        }
      };
      _createClass(TextureAnimationModule, [ {
        key: "enable",
        get: function get() {
          return this._enable;
        },
        set: function set(val) {
          this._enable = val;
          this.ps._assembler._updateMaterialParams();
        }
      }, {
        key: "mode",
        get: function get() {
          return this._mode;
        },
        set: function set(val) {
          if (val !== Mode.Grid) {
            console.error("particle texture animation's sprites is not supported!");
            return;
          }
        }
      }, {
        key: "numTilesX",
        get: function get() {
          return this._numTilesX;
        },
        set: function set(val) {
          if (this._numTilesX === val) return;
          this._numTilesX = val;
          this.ps && this.ps._assembler && this.ps._assembler._updateMaterialParams();
        }
      }, {
        key: "numTilesY",
        get: function get() {
          return this._numTilesY;
        },
        set: function set(val) {
          if (this._numTilesY === val) return;
          this._numTilesY = val;
          this.ps && this.ps._assembler && this.ps._assembler._updateMaterialParams();
        }
      }, {
        key: "flipU",
        get: function get() {
          return this._flipU;
        },
        set: function set(val) {
          console.error("particle texture animation's flipU is not supported!");
        }
      }, {
        key: "flipV",
        get: function get() {
          return this._flipV;
        },
        set: function set(val) {
          console.error("particle texture animation's flipV is not supported!");
        }
      }, {
        key: "uvChannelMask",
        get: function get() {
          return this._uvChannelMask;
        },
        set: function set(val) {
          console.error("particle texture animation's uvChannelMask is not supported!");
        }
      } ]);
      return TextureAnimationModule;
    })(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_enable", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "enable", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "enable"), _class2.prototype), 
    _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_mode", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return Mode.Grid;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "mode", [ _dec2 ], Object.getOwnPropertyDescriptor(_class2.prototype, "mode"), _class2.prototype), 
    _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_numTilesX", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "numTilesX", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "numTilesX"), _class2.prototype), 
    _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_numTilesY", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "numTilesY", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "numTilesY"), _class2.prototype), 
    _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "animation", [ _dec3 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return Animation.WholeSheet;
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "randomRow", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "rowIndex", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "frameOverTime", [ _dec4 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "startFrame", [ _dec5 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "cycleCount", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "flipU", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "flipU"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "flipV", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "flipV"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "uvChannelMask", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "uvChannelMask"), _class2.prototype), 
    _class2)) || _class);
    exports["default"] = TextureAnimationModule;
    module.exports = exports["default"];
  }), {
    "../../../platform/CCClassDecorator": 273,
    "../../../platform/CCEnum": 274,
    "../../../value-types": 401,
    "./curve-range": 32
  } ],
  40: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _CCClassDecorator = require("../../../platform/CCClassDecorator");
    var _valueTypes = require("../../../value-types");
    var _enum = require("../enum");
    var _particleGeneralFunction = require("../particle-general-function");
    var _curveRange = _interopRequireDefault(require("./curve-range"));
    var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var VELOCITY_OVERTIME_RAND_OFFSET = 197866;
    var _temp_v3 = cc.v3();
    var VelocityOvertimeModule = (_dec = (0, _CCClassDecorator.ccclass)("cc.VelocityOvertimeModule"), 
    _dec2 = (0, _CCClassDecorator.property)({
      type: _enum.Space
    }), _dec3 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ]
    }), _dec4 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ]
    }), _dec5 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ]
    }), _dec6 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"],
      range: [ -1, 1 ]
    }), _dec(_class = (_class2 = (function() {
      function VelocityOvertimeModule() {
        _initializerDefineProperty(this, "enable", _descriptor, this);
        _initializerDefineProperty(this, "space", _descriptor2, this);
        _initializerDefineProperty(this, "x", _descriptor3, this);
        _initializerDefineProperty(this, "y", _descriptor4, this);
        _initializerDefineProperty(this, "z", _descriptor5, this);
        _initializerDefineProperty(this, "speedModifier", _descriptor6, this);
        this.rotation = null;
        this.needTransform = false;
        this.rotation = new _valueTypes.Quat();
        this.speedModifier.constant = 1;
        this.needTransform = false;
      }
      var _proto = VelocityOvertimeModule.prototype;
      _proto.update = function update(space, worldTransform) {
        this.needTransform = (0, _particleGeneralFunction.calculateTransform)(space, this.space, worldTransform, this.rotation);
      };
      _proto.animate = function animate(p) {
        var normalizedTime = 1 - p.remainingLifetime / p.startLifetime;
        var vel = _valueTypes.Vec3.set(_temp_v3, this.x.evaluate(normalizedTime, (0, _valueTypes.pseudoRandom)(p.randomSeed + VELOCITY_OVERTIME_RAND_OFFSET)), this.y.evaluate(normalizedTime, (0, 
        _valueTypes.pseudoRandom)(p.randomSeed + VELOCITY_OVERTIME_RAND_OFFSET)), this.z.evaluate(normalizedTime, (0, 
        _valueTypes.pseudoRandom)(p.randomSeed + VELOCITY_OVERTIME_RAND_OFFSET)));
        this.needTransform && _valueTypes.Vec3.transformQuat(vel, vel, this.rotation);
        _valueTypes.Vec3.add(p.animatedVelocity, p.animatedVelocity, vel);
        _valueTypes.Vec3.add(p.ultimateVelocity, p.velocity, p.animatedVelocity);
        _valueTypes.Vec3.scale(p.ultimateVelocity, p.ultimateVelocity, this.speedModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, (0, 
        _valueTypes.pseudoRandom)(p.randomSeed + VELOCITY_OVERTIME_RAND_OFFSET)));
      };
      return VelocityOvertimeModule;
    })(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "enable", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "space", [ _dec2 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _enum.Space.Local;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "x", [ _dec3 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "y", [ _dec4 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "z", [ _dec5 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "speedModifier", [ _dec6 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _class2)) || _class);
    exports["default"] = VelocityOvertimeModule;
    module.exports = exports["default"];
  }), {
    "../../../platform/CCClassDecorator": 273,
    "../../../value-types": 401,
    "../enum": 44,
    "../particle-general-function": 45,
    "./curve-range": 32
  } ],
  41: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _CCClassDecorator = require("../../platform/CCClassDecorator");
    var _valueTypes = require("../../value-types");
    var _curveRange = _interopRequireDefault(require("./animator/curve-range"));
    var _dec, _dec2, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var Burst = (_dec = (0, _CCClassDecorator.ccclass)("cc.Burst"), _dec2 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"]
    }), _dec(_class = (_class2 = (function() {
      function Burst() {
        _initializerDefineProperty(this, "_time", _descriptor, this);
        _initializerDefineProperty(this, "minCount", _descriptor2, this);
        _initializerDefineProperty(this, "maxCount", _descriptor3, this);
        _initializerDefineProperty(this, "_repeatCount", _descriptor4, this);
        _initializerDefineProperty(this, "repeatInterval", _descriptor5, this);
        _initializerDefineProperty(this, "count", _descriptor6, this);
        this._remainingCount = 0;
        this._curTime = 0;
        this._remainingCount = 0;
        this._curTime = 0;
      }
      var _proto = Burst.prototype;
      _proto.update = function update(psys, dt) {
        if (0 === this._remainingCount) {
          this._remainingCount = this._repeatCount;
          this._curTime = this._time;
        }
        if (this._remainingCount > 0) {
          var preFrameTime = (0, _valueTypes.repeat)(psys._time - psys.startDelay.evaluate(0, 1), psys.duration) - dt;
          preFrameTime = preFrameTime > 0 ? preFrameTime : 0;
          var curFrameTime = (0, _valueTypes.repeat)(psys.time - psys.startDelay.evaluate(0, 1), psys.duration);
          if (this._curTime >= preFrameTime && this._curTime < curFrameTime) {
            psys.emit(this.count.evaluate(this._curTime / psys.duration, 1), dt - (curFrameTime - this._curTime));
            this._curTime += this.repeatInterval;
            --this._remainingCount;
          }
        }
      };
      _proto.getMaxCount = function getMaxCount(psys) {
        return this.count.getMax() * Math.min(Math.ceil(psys.duration / this.repeatInterval), this.repeatCount);
      };
      _createClass(Burst, [ {
        key: "time",
        get: function get() {
          return this._time;
        },
        set: function set(val) {
          this._time = val;
          this._curTime = val;
        }
      }, {
        key: "repeatCount",
        get: function get() {
          return this._repeatCount;
        },
        set: function set(val) {
          this._repeatCount = val;
          this._remainingCount = val;
        }
      } ]);
      return Burst;
    })(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_time", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "time", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "time"), _class2.prototype), 
    _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "minCount", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 30;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "maxCount", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 30;
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_repeatCount", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "repeatCount", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "repeatCount"), _class2.prototype), 
    _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "repeatInterval", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "count", [ _dec2 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _class2)) || _class);
    exports["default"] = Burst;
    module.exports = exports["default"];
  }), {
    "../../platform/CCClassDecorator": 273,
    "../../value-types": 401,
    "./animator/curve-range": 32
  } ],
  42: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.OptimizedKey = exports.Keyframe = exports.AnimationCurve = void 0;
    exports.evalOptCurve = evalOptCurve;
    var _CCEnum = _interopRequireDefault(require("../../platform/CCEnum"));
    var _valueTypes = require("../../value-types");
    var _CCClassDecorator = require("../../platform/CCClassDecorator");
    var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _dec2, _dec3, _dec4, _dec5, _class4, _class5, _descriptor5, _descriptor6, _descriptor7;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var LOOK_FORWARD = 3;
    var WrapMode = (0, _CCEnum["default"])({
      Default: 0,
      Once: 1,
      Loop: 2,
      PingPong: 3,
      ClampForever: 4
    });
    var Keyframe = (_dec = (0, _CCClassDecorator.ccclass)("cc.Keyframe"), _dec(_class = (_class2 = function Keyframe(time, value, inTangent, outTangent) {
      _initializerDefineProperty(this, "time", _descriptor, this);
      _initializerDefineProperty(this, "value", _descriptor2, this);
      _initializerDefineProperty(this, "inTangent", _descriptor3, this);
      _initializerDefineProperty(this, "outTangent", _descriptor4, this);
      this.time = time || 0;
      this.value = value || 0;
      this.inTangent = inTangent || 0;
      this.outTangent = outTangent || 0;
    }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "time", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "value", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "inTangent", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "outTangent", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _class2)) || _class);
    exports.Keyframe = Keyframe;
    var OptimizedKey = (function() {
      function OptimizedKey() {
        this.index = 0;
        this.time = 0;
        this.endTime = 0;
        this.coefficient = null;
        this.index = -1;
        this.time = 0;
        this.endTime = 0;
        this.coefficient = new Float32Array(4);
      }
      var _proto = OptimizedKey.prototype;
      _proto.evaluate = function evaluate(T) {
        var t = T - this.time;
        return evalOptCurve(t, this.coefficient);
      };
      return OptimizedKey;
    })();
    exports.OptimizedKey = OptimizedKey;
    function evalOptCurve(t, coefs) {
      return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
    }
    var defaultKFStart = new Keyframe(0, 1, 0, 0);
    var defaultKFEnd = new Keyframe(1, 1, 0, 0);
    var AnimationCurve = (_dec2 = (0, _CCClassDecorator.ccclass)("cc.AnimationCurve"), 
    _dec3 = (0, _CCClassDecorator.property)({
      type: [ Keyframe ]
    }), _dec4 = (0, _CCClassDecorator.property)({
      type: cc.Enum(WrapMode),
      visible: false
    }), _dec5 = (0, _CCClassDecorator.property)({
      type: cc.Enum(WrapMode),
      visible: false
    }), _dec2(_class4 = (_class5 = (function() {
      function AnimationCurve(keyFrames) {
        void 0 === keyFrames && (keyFrames = null);
        _initializerDefineProperty(this, "keyFrames", _descriptor5, this);
        _initializerDefineProperty(this, "preWrapMode", _descriptor6, this);
        _initializerDefineProperty(this, "postWrapMode", _descriptor7, this);
        this.cachedKey = null;
        if (keyFrames) this.keyFrames = keyFrames; else {
          this.keyFrames.push(defaultKFStart);
          this.keyFrames.push(defaultKFEnd);
        }
        this.cachedKey = new OptimizedKey();
      }
      var _proto2 = AnimationCurve.prototype;
      _proto2.addKey = function addKey(keyFrame) {
        null == this.keyFrames && (this.keyFrames = []);
        this.keyFrames.push(keyFrame);
      };
      _proto2.evaluate_slow = function evaluate_slow(time) {
        var wrappedTime = time;
        var wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode;
        var startTime = this.keyFrames[0].time;
        var endTime = this.keyFrames[this.keyFrames.length - 1].time;
        switch (wrapMode) {
         case WrapMode.Loop:
          wrappedTime = (0, _valueTypes.repeat)(time - startTime, endTime - startTime) + startTime;
          break;

         case WrapMode.PingPong:
          wrappedTime = (0, _valueTypes.pingPong)(time - startTime, endTime - startTime) + startTime;
          break;

         case WrapMode.ClampForever:
          wrappedTime = (0, _valueTypes.clamp)(time, startTime, endTime);
        }
        var preKFIndex = 0;
        if (wrappedTime > this.keyFrames[0].time) if (wrappedTime >= this.keyFrames[this.keyFrames.length - 1].time) preKFIndex = this.keyFrames.length - 2; else for (var i = 0; i < this.keyFrames.length - 1; i++) if (wrappedTime >= this.keyFrames[0].time && wrappedTime <= this.keyFrames[i + 1].time) {
          preKFIndex = i;
          break;
        }
        var keyframe0 = this.keyFrames[preKFIndex];
        var keyframe1 = this.keyFrames[preKFIndex + 1];
        var t = (0, _valueTypes.inverseLerp)(keyframe0.time, keyframe1.time, wrappedTime);
        var dt = keyframe1.time - keyframe0.time;
        var m0 = keyframe0.outTangent * dt;
        var m1 = keyframe1.inTangent * dt;
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2 * t3 - 3 * t2 + 1;
        var b = t3 - 2 * t2 + t;
        var c = t3 - t2;
        var d = -2 * t3 + 3 * t2;
        return a * keyframe0.value + b * m0 + c * m1 + d * keyframe1.value;
      };
      _proto2.evaluate = function evaluate(time) {
        var wrappedTime = time;
        var wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode;
        var startTime = this.keyFrames[0].time;
        var endTime = this.keyFrames[this.keyFrames.length - 1].time;
        switch (wrapMode) {
         case WrapMode.Loop:
          wrappedTime = (0, _valueTypes.repeat)(time - startTime, endTime - startTime) + startTime;
          break;

         case WrapMode.PingPong:
          wrappedTime = (0, _valueTypes.pingPong)(time - startTime, endTime - startTime) + startTime;
          break;

         case WrapMode.ClampForever:
          wrappedTime = (0, _valueTypes.clamp)(time, startTime, endTime);
        }
        true;
        if (wrappedTime >= this.cachedKey.time && wrappedTime < this.cachedKey.endTime) return this.cachedKey.evaluate(wrappedTime);
        var leftIndex = this.findIndex(this.cachedKey, wrappedTime);
        var rightIndex = Math.min(leftIndex + 1, this.keyFrames.length - 1);
        this.calcOptimizedKey(this.cachedKey, leftIndex, rightIndex);
        return this.cachedKey.evaluate(wrappedTime);
      };
      _proto2.calcOptimizedKey = function calcOptimizedKey(optKey, leftIndex, rightIndex) {
        var lhs = this.keyFrames[leftIndex];
        var rhs = this.keyFrames[rightIndex];
        optKey.index = leftIndex;
        optKey.time = lhs.time;
        optKey.endTime = rhs.time;
        var dx = rhs.time - lhs.time;
        var dy = rhs.value - lhs.value;
        var length = 1 / (dx * dx);
        var d1 = lhs.outTangent * dx;
        var d2 = rhs.inTangent * dx;
        optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx;
        optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length;
        optKey.coefficient[2] = lhs.outTangent;
        optKey.coefficient[3] = lhs.value;
      };
      _proto2.findIndex = function findIndex(optKey, t) {
        var cachedIndex = optKey.index;
        if (-1 !== cachedIndex) {
          var cachedTime = this.keyFrames[cachedIndex].time;
          if (t > cachedTime) for (var i = 0; i < LOOK_FORWARD; i++) {
            var currIndex = cachedIndex + i;
            if (currIndex + 1 < this.keyFrames.length && this.keyFrames[currIndex + 1].time > t) return currIndex;
          } else for (var _i = 0; _i < LOOK_FORWARD; _i++) {
            var _currIndex = cachedIndex - _i;
            if (_currIndex - 1 >= 0 && this.keyFrames[_currIndex - 1].time <= t) return _currIndex - 1;
          }
        }
        var left = 0;
        var right = this.keyFrames.length;
        var mid;
        while (right - left > 1) {
          mid = Math.floor((left + right) / 2);
          this.keyFrames[mid].time >= t ? right = mid : left = mid;
        }
        return left;
      };
      return AnimationCurve;
    })(), _descriptor5 = _applyDecoratedDescriptor(_class5.prototype, "keyFrames", [ _dec3 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new Array();
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class5.prototype, "preWrapMode", [ _dec4 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return WrapMode.ClampForever;
      }
    }), _descriptor7 = _applyDecoratedDescriptor(_class5.prototype, "postWrapMode", [ _dec5 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return WrapMode.ClampForever;
      }
    }), _class5)) || _class4);
    exports.AnimationCurve = AnimationCurve;
    cc.Keyframe = Keyframe;
    cc.AnimationCurve = AnimationCurve;
  }), {
    "../../platform/CCClassDecorator": 273,
    "../../platform/CCEnum": 274,
    "../../value-types": 401
  } ],
  43: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _CCClassDecorator = require("../../../platform/CCClassDecorator");
    var _valueTypes = require("../../../value-types");
    var _curveRange = _interopRequireDefault(require("../animator/curve-range"));
    var _particleGeneralFunction = require("../particle-general-function");
    var _enum = require("../enum");
    var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var _intermediVec = new _valueTypes.Vec3(0, 0, 0);
    var _intermediArr = new Array();
    var _unitBoxExtent = new _valueTypes.Vec3(.5, .5, .5);
    var ShapeModule = (_dec = (0, _CCClassDecorator.ccclass)("cc.ShapeModule"), _dec2 = (0, 
    _CCClassDecorator.property)({
      type: _enum.ShapeType
    }), _dec3 = (0, _CCClassDecorator.property)({
      type: _enum.EmitLocation
    }), _dec4 = (0, _CCClassDecorator.property)({
      type: _enum.ArcMode
    }), _dec5 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"]
    }), _dec(_class = (_class2 = (function() {
      function ShapeModule() {
        _initializerDefineProperty(this, "enable", _descriptor, this);
        _initializerDefineProperty(this, "_shapeType", _descriptor2, this);
        _initializerDefineProperty(this, "emitFrom", _descriptor3, this);
        _initializerDefineProperty(this, "radius", _descriptor4, this);
        _initializerDefineProperty(this, "radiusThickness", _descriptor5, this);
        _initializerDefineProperty(this, "_angle", _descriptor6, this);
        _initializerDefineProperty(this, "_arc", _descriptor7, this);
        _initializerDefineProperty(this, "arcMode", _descriptor8, this);
        _initializerDefineProperty(this, "arcSpread", _descriptor9, this);
        _initializerDefineProperty(this, "arcSpeed", _descriptor10, this);
        _initializerDefineProperty(this, "length", _descriptor11, this);
        _initializerDefineProperty(this, "boxThickness", _descriptor12, this);
        _initializerDefineProperty(this, "_position", _descriptor13, this);
        _initializerDefineProperty(this, "_rotation", _descriptor14, this);
        _initializerDefineProperty(this, "_scale", _descriptor15, this);
        _initializerDefineProperty(this, "alignToDirection", _descriptor16, this);
        _initializerDefineProperty(this, "randomDirectionAmount", _descriptor17, this);
        _initializerDefineProperty(this, "sphericalDirectionAmount", _descriptor18, this);
        _initializerDefineProperty(this, "randomPositionAmount", _descriptor19, this);
        this.mat = null;
        this.Quat = null;
        this.particleSystem = null;
        this.lastTime = null;
        this.totalAngle = null;
        this.mat = new _valueTypes.Mat4();
        this.quat = new _valueTypes.Quat();
        this.particleSystem = null;
        this.lastTime = 0;
        this.totalAngle = 0;
      }
      var _proto = ShapeModule.prototype;
      _proto.onInit = function onInit(ps) {
        this.particleSystem = ps;
        this.constructMat();
        this.lastTime = this.particleSystem._time;
      };
      _proto.constructMat = function constructMat() {
        _valueTypes.Quat.fromEuler(this.quat, this._rotation.x, this._rotation.y, this._rotation.z);
        _valueTypes.Mat4.fromRTS(this.mat, this.quat, this._position, this._scale);
      };
      _proto.emit = function emit(p) {
        switch (this.shapeType) {
         case _enum.ShapeType.Box:
          boxEmit(this.emitFrom, this.boxThickness, p.position, p.velocity);
          break;

         case _enum.ShapeType.Circle:
          circleEmit(this.radius, this.radiusThickness, this.generateArcAngle(), p.position, p.velocity);
          break;

         case _enum.ShapeType.Cone:
          coneEmit(this.emitFrom, this.radius, this.radiusThickness, this.generateArcAngle(), this._angle, this.length, p.position, p.velocity);
          break;

         case _enum.ShapeType.Sphere:
          sphereEmit(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
          break;

         case _enum.ShapeType.Hemisphere:
          hemisphereEmit(this.emitFrom, this.radius, this.radiusThickness, p.position, p.velocity);
          break;

         default:
          console.warn(this.shapeType + " shapeType is not supported by ShapeModule.");
        }
        if (this.randomPositionAmount > 0) {
          p.position.x += (0, _valueTypes.randomRange)(-this.randomPositionAmount, this.randomPositionAmount);
          p.position.y += (0, _valueTypes.randomRange)(-this.randomPositionAmount, this.randomPositionAmount);
          p.position.z += (0, _valueTypes.randomRange)(-this.randomPositionAmount, this.randomPositionAmount);
        }
        _valueTypes.Vec3.transformQuat(p.velocity, p.velocity, this.quat);
        _valueTypes.Vec3.transformMat4(p.position, p.position, this.mat);
        if (this.sphericalDirectionAmount > 0) {
          var sphericalVel = _valueTypes.Vec3.normalize(_intermediVec, p.position);
          _valueTypes.Vec3.lerp(p.velocity, p.velocity, sphericalVel, this.sphericalDirectionAmount);
        }
        this.lastTime = this.particleSystem._time;
      };
      _proto.generateArcAngle = function generateArcAngle() {
        if (this.arcMode === _enum.ArcMode.Random) return (0, _valueTypes.randomRange)(0, this._arc);
        var angle = this.totalAngle + 2 * Math.PI * this.arcSpeed.evaluate(this.particleSystem._time, 1) * (this.particleSystem._time - this.lastTime);
        this.totalAngle = angle;
        0 !== this.arcSpread && (angle = Math.floor(angle / (this._arc * this.arcSpread)) * this._arc * this.arcSpread);
        switch (this.arcMode) {
         case _enum.ArcMode.Loop:
          return (0, _valueTypes.repeat)(angle, this._arc);

         case _enum.ArcMode.PingPong:
          return (0, _valueTypes.pingPong)(angle, this._arc);
        }
      };
      _createClass(ShapeModule, [ {
        key: "shapeType",
        get: function get() {
          return this._shapeType;
        },
        set: function set(val) {
          this._shapeType = val;
          switch (this._shapeType) {
           case _enum.ShapeType.Box:
            this.emitFrom === _enum.EmitLocation.Base && (this.emitFrom = _enum.EmitLocation.Volume);
            break;

           case _enum.ShapeType.Cone:
            this.emitFrom === _enum.EmitLocation.Edge && (this.emitFrom = _enum.EmitLocation.Base);
            break;

           case _enum.ShapeType.Sphere:
           case _enum.ShapeType.Hemisphere:
            this.emitFrom !== _enum.EmitLocation.Base && this.emitFrom !== _enum.EmitLocation.Edge || (this.emitFrom = _enum.EmitLocation.Volume);
          }
        }
      }, {
        key: "angle",
        get: function get() {
          return Math.round(100 * (0, _valueTypes.toDegree)(this._angle)) / 100;
        },
        set: function set(val) {
          this._angle = (0, _valueTypes.toRadian)(val);
        }
      }, {
        key: "arc",
        get: function get() {
          return (0, _valueTypes.toDegree)(this._arc);
        },
        set: function set(val) {
          this._arc = (0, _valueTypes.toRadian)(val);
        }
      }, {
        key: "position",
        get: function get() {
          return this._position;
        },
        set: function set(val) {
          this._position = val;
          this.constructMat();
        }
      }, {
        key: "rotation",
        get: function get() {
          return this._rotation;
        },
        set: function set(val) {
          this._rotation = val;
          this.constructMat();
        }
      }, {
        key: "scale",
        get: function get() {
          return this._scale;
        },
        set: function set(val) {
          this._scale = val;
          this.constructMat();
        }
      } ]);
      return ShapeModule;
    })(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "enable", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_shapeType", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _enum.ShapeType.Cone;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "shapeType", [ _dec2 ], Object.getOwnPropertyDescriptor(_class2.prototype, "shapeType"), _class2.prototype), 
    _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "emitFrom", [ _dec3 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _enum.EmitLocation.Volume;
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "radius", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "radiusThickness", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "_angle", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return (0, _valueTypes.toRadian)(25);
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "angle", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "angle"), _class2.prototype), 
    _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "_arc", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return (0, _valueTypes.toRadian)(360);
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "arc", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "arc"), _class2.prototype), 
    _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "arcMode", [ _dec4 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _enum.ArcMode.Random;
      }
    }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "arcSpread", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "arcSpeed", [ _dec5 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "length", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 5;
      }
    }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "boxThickness", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _valueTypes.Vec3(0, 0, 0);
      }
    }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "_position", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _valueTypes.Vec3(0, 0, 0);
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "position", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "position"), _class2.prototype), 
    _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "_rotation", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _valueTypes.Vec3(0, 0, 0);
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "rotation", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "rotation"), _class2.prototype), 
    _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "_scale", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _valueTypes.Vec3(1, 1, 1);
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "scale", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "scale"), _class2.prototype), 
    _descriptor16 = _applyDecoratedDescriptor(_class2.prototype, "alignToDirection", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor17 = _applyDecoratedDescriptor(_class2.prototype, "randomDirectionAmount", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor18 = _applyDecoratedDescriptor(_class2.prototype, "sphericalDirectionAmount", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _descriptor19 = _applyDecoratedDescriptor(_class2.prototype, "randomPositionAmount", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 0;
      }
    }), _class2)) || _class);
    exports["default"] = ShapeModule;
    function sphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
      switch (emitFrom) {
       case _enum.EmitLocation.Volume:
        (0, _particleGeneralFunction.randomPointBetweenSphere)(pos, radius * (1 - radiusThickness), radius);
        _valueTypes.Vec3.copy(dir, pos);
        _valueTypes.Vec3.normalize(dir, dir);
        break;

       case _enum.EmitLocation.Shell:
        (0, _particleGeneralFunction.randomUnitVector)(pos);
        _valueTypes.Vec3.scale(pos, pos, radius);
        _valueTypes.Vec3.copy(dir, pos);
        break;

       default:
        console.warn(emitFrom + " is not supported for sphere emitter.");
      }
    }
    function hemisphereEmit(emitFrom, radius, radiusThickness, pos, dir) {
      switch (emitFrom) {
       case _enum.EmitLocation.Volume:
        (0, _particleGeneralFunction.randomPointBetweenSphere)(pos, radius * (1 - radiusThickness), radius);
        pos.z > 0 && (pos.z *= -1);
        _valueTypes.Vec3.copy(dir, pos);
        _valueTypes.Vec3.normalize(dir, dir);
        break;

       case _enum.EmitLocation.Shell:
        (0, _particleGeneralFunction.randomUnitVector)(pos);
        _valueTypes.Vec3.scale(pos, pos, radius);
        pos.z < 0 && (pos.z *= -1);
        _valueTypes.Vec3.copy(dir, pos);
        break;

       default:
        console.warn(emitFrom + " is not supported for hemisphere emitter.");
      }
    }
    function coneEmit(emitFrom, radius, radiusThickness, theta, angle, length, pos, dir) {
      switch (emitFrom) {
       case _enum.EmitLocation.Base:
        (0, _particleGeneralFunction.randomPointBetweenCircleAtFixedAngle)(pos, radius * (1 - radiusThickness), radius, theta);
        _valueTypes.Vec2.scale(dir, pos, Math.sin(angle));
        dir.z = -Math.cos(angle) * radius;
        _valueTypes.Vec3.normalize(dir, dir);
        pos.z = 0;
        break;

       case _enum.EmitLocation.Shell:
        (0, _particleGeneralFunction.fixedAngleUnitVector2)(pos, theta);
        _valueTypes.Vec2.scale(dir, pos, Math.sin(angle));
        dir.z = -Math.cos(angle);
        _valueTypes.Vec3.normalize(dir, dir);
        _valueTypes.Vec2.scale(pos, pos, radius);
        pos.z = 0;
        break;

       case _enum.EmitLocation.Volume:
        (0, _particleGeneralFunction.randomPointBetweenCircleAtFixedAngle)(pos, radius * (1 - radiusThickness), radius, theta);
        _valueTypes.Vec2.scale(dir, pos, Math.sin(angle));
        dir.z = -Math.cos(angle) * radius;
        _valueTypes.Vec3.normalize(dir, dir);
        pos.z = 0;
        _valueTypes.Vec3.add(pos, pos, _valueTypes.Vec3.scale(_intermediVec, dir, length * (0, 
        _valueTypes.random)() / -dir.z));
        break;

       default:
        console.warn(emitFrom + " is not supported for cone emitter.");
      }
    }
    function boxEmit(emitFrom, boxThickness, pos, dir) {
      switch (emitFrom) {
       case _enum.EmitLocation.Volume:
        (0, _particleGeneralFunction.randomPointInCube)(pos, _unitBoxExtent);
        break;

       case _enum.EmitLocation.Shell:
        _intermediArr.splice(0, _intermediArr.length);
        _intermediArr.push((0, _valueTypes.randomRange)(-.5, .5));
        _intermediArr.push((0, _valueTypes.randomRange)(-.5, .5));
        _intermediArr.push(.5 * (0, _particleGeneralFunction.randomSign)());
        (0, _particleGeneralFunction.randomSortArray)(_intermediArr);
        applyBoxThickness(_intermediArr, boxThickness);
        _valueTypes.Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
        break;

       case _enum.EmitLocation.Edge:
        _intermediArr.splice(0, _intermediArr.length);
        _intermediArr.push((0, _valueTypes.randomRange)(-.5, .5));
        _intermediArr.push(.5 * (0, _particleGeneralFunction.randomSign)());
        _intermediArr.push(.5 * (0, _particleGeneralFunction.randomSign)());
        (0, _particleGeneralFunction.randomSortArray)(_intermediArr);
        applyBoxThickness(_intermediArr, boxThickness);
        _valueTypes.Vec3.set(pos, _intermediArr[0], _intermediArr[1], _intermediArr[2]);
        break;

       default:
        console.warn(emitFrom + " is not supported for box emitter.");
      }
      _valueTypes.Vec3.copy(dir, _particleGeneralFunction.particleEmitZAxis);
    }
    function circleEmit(radius, radiusThickness, theta, pos, dir) {
      (0, _particleGeneralFunction.randomPointBetweenCircleAtFixedAngle)(pos, radius * (1 - radiusThickness), radius, theta);
      _valueTypes.Vec3.normalize(dir, pos);
    }
    function applyBoxThickness(pos, thickness) {
      if (thickness.x > 0) {
        pos[0] += .5 * (0, _valueTypes.randomRange)(-thickness.x, thickness.x);
        pos[0] = (0, _valueTypes.clamp)(pos[0], -.5, .5);
      }
      if (thickness.y > 0) {
        pos[1] += .5 * (0, _valueTypes.randomRange)(-thickness.y, thickness.y);
        pos[1] = (0, _valueTypes.clamp)(pos[1], -.5, .5);
      }
      if (thickness.z > 0) {
        pos[2] += .5 * (0, _valueTypes.randomRange)(-thickness.z, thickness.z);
        pos[2] = (0, _valueTypes.clamp)(pos[2], -.5, .5);
      }
    }
    module.exports = exports["default"];
  }), {
    "../../../platform/CCClassDecorator": 273,
    "../../../value-types": 401,
    "../animator/curve-range": 32,
    "../enum": 44,
    "../particle-general-function": 45
  } ],
  44: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.TrailMode = exports.TextureMode = exports.Space = exports.ShapeType = exports.RenderMode = exports.EmitLocation = exports.ArcMode = void 0;
    var _CCEnum = _interopRequireDefault(require("../../platform/CCEnum"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Space = (0, _CCEnum["default"])({
      World: 0,
      Local: 1,
      Custom: 2
    });
    exports.Space = Space;
    var RenderMode = (0, _CCEnum["default"])({
      Billboard: 0,
      StrecthedBillboard: 1,
      HorizontalBillboard: 2,
      VerticalBillboard: 3,
      Mesh: 4
    });
    exports.RenderMode = RenderMode;
    var ShapeType = (0, _CCEnum["default"])({
      Box: 0,
      Circle: 1,
      Cone: 2,
      Sphere: 3,
      Hemisphere: 4
    });
    exports.ShapeType = ShapeType;
    var EmitLocation = (0, _CCEnum["default"])({
      Base: 0,
      Edge: 1,
      Shell: 2,
      Volume: 3
    });
    exports.EmitLocation = EmitLocation;
    var ArcMode = (0, _CCEnum["default"])({
      Random: 0,
      Loop: 1,
      PingPong: 2
    });
    exports.ArcMode = ArcMode;
    var TrailMode = (0, _CCEnum["default"])({
      Particles: 0,
      Ribbon: 1
    });
    exports.TrailMode = TrailMode;
    var TextureMode = (0, _CCEnum["default"])({
      Stretch: 0,
      Repeat: 1
    });
    exports.TextureMode = TextureMode;
  }), {
    "../../platform/CCEnum": 274
  } ],
  45: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.calculateTransform = calculateTransform;
    exports.fixedAngleUnitVector2 = fixedAngleUnitVector2;
    exports.particleEmitZAxis = void 0;
    exports.randomPointBetweenCircle = randomPointBetweenCircle;
    exports.randomPointBetweenCircleAtFixedAngle = randomPointBetweenCircleAtFixedAngle;
    exports.randomPointBetweenCube = randomPointBetweenCube;
    exports.randomPointBetweenSphere = randomPointBetweenSphere;
    exports.randomPointInCube = randomPointInCube;
    exports.randomPointInUnitCircle = randomPointInUnitCircle;
    exports.randomPointInUnitSphere = randomPointInUnitSphere;
    exports.randomSign = randomSign;
    exports.randomSortArray = randomSortArray;
    exports.randomUnitVector = randomUnitVector;
    exports.randomUnitVector2 = randomUnitVector2;
    var _valueTypes = require("../../value-types");
    var _utils = require("../../value-types/utils");
    var _enum = require("./enum");
    var particleEmitZAxis = new _valueTypes.Vec3(0, 0, -1);
    exports.particleEmitZAxis = particleEmitZAxis;
    function calculateTransform(systemSpace, moduleSpace, worldTransform, outQuat) {
      if (moduleSpace !== systemSpace) {
        if (systemSpace === _enum.Space.World) _valueTypes.Mat4.getRotation(outQuat, worldTransform); else {
          _valueTypes.Mat4.invert(worldTransform, worldTransform);
          _valueTypes.Mat4.getRotation(outQuat, worldTransform);
        }
        return true;
      }
      _valueTypes.Quat.set(outQuat, 0, 0, 0, 1);
      return false;
    }
    function fixedAngleUnitVector2(out, theta) {
      _valueTypes.Vec2.set(out, Math.cos(theta), Math.sin(theta));
    }
    function randomUnitVector2(out) {
      var a = (0, _valueTypes.randomRange)(0, 2 * Math.PI);
      var x = Math.cos(a);
      var y = Math.sin(a);
      _valueTypes.Vec2.set(out, x, y);
    }
    function randomUnitVector(out) {
      var z = (0, _valueTypes.randomRange)(-1, 1);
      var a = (0, _valueTypes.randomRange)(0, 2 * Math.PI);
      var r = Math.sqrt(1 - z * z);
      var x = r * Math.cos(a);
      var y = r * Math.sin(a);
      _valueTypes.Vec3.set(out, x, y, z);
    }
    function randomPointInUnitSphere(out) {
      randomUnitVector(out);
      _valueTypes.Vec3.scale(out, out, (0, _valueTypes.random)());
    }
    function randomPointBetweenSphere(out, minRadius, maxRadius) {
      randomUnitVector(out);
      _valueTypes.Vec3.scale(out, out, minRadius + (maxRadius - minRadius) * (0, _valueTypes.random)());
    }
    function randomPointInUnitCircle(out) {
      randomUnitVector2(out);
      out.z = 0;
      _valueTypes.Vec3.scale(out, out, (0, _valueTypes.random)());
    }
    function randomPointBetweenCircle(out, minRadius, maxRadius) {
      randomUnitVector2(out);
      out.z = 0;
      _valueTypes.Vec3.scale(out, out, minRadius + (maxRadius - minRadius) * (0, _valueTypes.random)());
    }
    function randomPointBetweenCircleAtFixedAngle(out, minRadius, maxRadius, theta) {
      fixedAngleUnitVector2(out, theta);
      out.z = 0;
      _valueTypes.Vec3.scale(out, out, minRadius + (maxRadius - minRadius) * (0, _valueTypes.random)());
    }
    function randomPointInCube(out, extents) {
      _valueTypes.Vec3.set(out, (0, _valueTypes.randomRange)(-extents.x, extents.x), (0, 
      _valueTypes.randomRange)(-extents.y, extents.y), (0, _valueTypes.randomRange)(-extents.z, extents.z));
    }
    function randomPointBetweenCube(out, minBox, maxBox) {
      var subscript = [ "x", "y", "z" ];
      var edge = (0, _valueTypes.randomRangeInt)(0, 3);
      for (var i = 0; i < 3; i++) {
        if (i === edge) {
          out[subscript[i]] = (0, _valueTypes.randomRange)(-maxBox[subscript[i]], maxBox[subscript[i]]);
          continue;
        }
        var x = 2 * (0, _valueTypes.random)() - 1;
        out[subscript[i]] = x < 0 ? -minBox[subscript[i]] + x * (maxBox[subscript[i]] - minBox[subscript[i]]) : minBox[subscript[i]] + x * (maxBox[subscript[i]] - minBox[subscript[i]]);
      }
    }
    function randomSortArray(arr) {
      for (var i = 0; i < arr.length; i++) {
        var transpose = i + (0, _valueTypes.randomRangeInt)(0, arr.length - i);
        var val = arr[transpose];
        arr[transpose] = arr[i];
        arr[i] = val;
      }
    }
    function randomSign() {
      var sgn = (0, _valueTypes.randomRange)(-1, 1);
      0 === sgn ? sgn++ : sgn;
      return (0, _utils.sign)(sgn);
    }
  }), {
    "../../value-types": 401,
    "../../value-types/utils": 408,
    "./enum": 44
  } ],
  46: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueTypes = require("../../value-types");
    var _utils = require("../../value-types/utils");
    var _CCMaterial = _interopRequireDefault(require("../../assets/material/CCMaterial"));
    var _colorOvertime = _interopRequireDefault(require("./animator/color-overtime"));
    var _curveRange = _interopRequireWildcard(require("./animator/curve-range"));
    var _forceOvertime = _interopRequireDefault(require("./animator/force-overtime"));
    var _gradientRange = _interopRequireDefault(require("./animator/gradient-range"));
    var _limitVelocityOvertime = _interopRequireDefault(require("./animator/limit-velocity-overtime"));
    var _rotationOvertime = _interopRequireDefault(require("./animator/rotation-overtime"));
    var _sizeOvertime = _interopRequireDefault(require("./animator/size-overtime"));
    var _textureAnimation = _interopRequireDefault(require("./animator/texture-animation"));
    var _velocityOvertime = _interopRequireDefault(require("./animator/velocity-overtime"));
    var _burst = _interopRequireDefault(require("./burst"));
    var _shapeModule = _interopRequireDefault(require("./emitter/shape-module"));
    var _enum = require("./enum");
    var _particleGeneralFunction = require("./particle-general-function");
    var _trail = _interopRequireDefault(require("./renderer/trail"));
    var _CCMesh = _interopRequireDefault(require("../../mesh/CCMesh"));
    var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _descriptor21, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _descriptor26, _descriptor27, _descriptor28, _descriptor29, _descriptor30, _descriptor31;
    function _getRequireWildcardCache(nodeInterop) {
      if ("function" !== typeof WeakMap) return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) return obj;
      if (null === obj || "object" !== typeof obj && "function" !== typeof obj) return {
        default: obj
      };
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) return cache.get(obj);
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
      }
      newObj["default"] = obj;
      cache && cache.set(obj, newObj);
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = "undefined" !== typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" === typeof o.length) {
        it && (o = it);
        var i = 0;
        return function() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if ("string" === typeof o) return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      "Object" === n && o.constructor && (n = o.constructor.name);
      if ("Map" === n || "Set" === n) return Array.from(o);
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      (null == len || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _assertThisInitialized(self) {
      if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var _require = require("../../platform/CCClassDecorator"), ccclass = _require.ccclass, menu = _require.menu, property = _require.property, executeInEditMode = _require.executeInEditMode, executionOrder = _require.executionOrder;
    var RenderComponent = require("../../components/CCRenderComponent");
    var _world_mat = new _valueTypes.Mat4();
    var _module_props = false;
    var ParticleSystem3D = (_dec = ccclass("cc.ParticleSystem3D"), _dec2 = menu("i18n:MAIN_MENU.component.renderers/ParticleSystem3D"), 
    _dec3 = executionOrder(99), _dec4 = property({
      animatable: false
    }), _dec5 = property({
      animatable: false
    }), _dec6 = property({
      type: _enum.Space,
      animatable: false
    }), _dec7 = property({
      type: _curveRange["default"]
    }), _dec8 = property({
      type: _curveRange["default"]
    }), _dec9 = property({
      type: _gradientRange["default"]
    }), _dec10 = property({
      type: _enum.Space
    }), _dec11 = property({
      type: _curveRange["default"]
    }), _dec12 = property({
      type: _curveRange["default"],
      range: [ -1, 1 ]
    }), _dec13 = property({
      type: _curveRange["default"],
      range: [ -1, 1 ],
      radian: true
    }), _dec14 = property({
      type: _curveRange["default"],
      range: [ -1, 1 ]
    }), _dec15 = property({
      type: _curveRange["default"]
    }), _dec16 = property({
      type: _curveRange["default"]
    }), _dec17 = property({
      type: [ _burst["default"] ],
      animatable: false
    }), _dec18 = property({
      type: [ _CCMaterial["default"] ],
      displayName: "Materials",
      visible: false,
      override: true
    }), _dec19 = property({
      type: _shapeModule["default"],
      animatable: false
    }), _dec20 = property({
      type: _colorOvertime["default"],
      animatable: false
    }), _dec21 = property({
      type: _sizeOvertime["default"],
      animatable: false
    }), _dec22 = property({
      type: _velocityOvertime["default"],
      animatable: false
    }), _dec23 = property({
      type: _forceOvertime["default"],
      animatable: false
    }), _dec24 = property({
      type: _limitVelocityOvertime["default"],
      animatable: false
    }), _dec25 = property({
      type: _rotationOvertime["default"],
      animatable: false
    }), _dec26 = property({
      type: _textureAnimation["default"],
      animatable: false
    }), _dec27 = property({
      type: _trail["default"],
      animatable: false
    }), _dec28 = property({
      type: _enum.RenderMode,
      animatable: false
    }), _dec29 = property({
      animatable: false
    }), _dec30 = property({
      animatable: false
    }), _dec31 = property({
      type: _CCMesh["default"],
      animatable: false
    }), _dec32 = property({
      type: _CCMaterial["default"],
      animatable: false
    }), _dec33 = property({
      type: _CCMaterial["default"],
      animatable: false
    }), _dec(_class = _dec2(_class = _dec3(_class = executeInEditMode(_class = (_class2 = (function(_RenderComponent) {
      _inheritsLoose(ParticleSystem3D, _RenderComponent);
      function ParticleSystem3D() {
        var _this2;
        _this2 = _RenderComponent.call(this) || this;
        _initializerDefineProperty(_this2, "duration", _descriptor, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_capacity", _descriptor2, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "loop", _descriptor3, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "playOnAwake", _descriptor4, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_prewarm", _descriptor5, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_simulationSpace", _descriptor6, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "simulationSpeed", _descriptor7, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "startDelay", _descriptor8, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "startLifetime", _descriptor9, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "startColor", _descriptor10, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "scaleSpace", _descriptor11, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "startSize", _descriptor12, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "startSpeed", _descriptor13, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "startRotation", _descriptor14, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "gravityModifier", _descriptor15, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "rateOverTime", _descriptor16, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "rateOverDistance", _descriptor17, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "bursts", _descriptor18, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_shapeModule", _descriptor19, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_colorOverLifetimeModule", _descriptor20, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_sizeOvertimeModule", _descriptor21, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_velocityOvertimeModule", _descriptor22, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_forceOvertimeModule", _descriptor23, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_limitVelocityOvertimeModule", _descriptor24, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_rotationOvertimeModule", _descriptor25, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_textureAnimationModule", _descriptor26, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_trailModule", _descriptor27, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_renderMode", _descriptor28, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_velocityScale", _descriptor29, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_lengthScale", _descriptor30, _assertThisInitialized(_this2));
        _initializerDefineProperty(_this2, "_mesh", _descriptor31, _assertThisInitialized(_this2));
        _this2._isPlaying = void 0;
        _this2._isPaused = void 0;
        _this2._isStopped = void 0;
        _this2._isEmitting = void 0;
        _this2._time = void 0;
        _this2._emitRateTimeCounter = void 0;
        _this2._emitRateDistanceCounter = void 0;
        _this2._oldWPos = void 0;
        _this2._curWPos = void 0;
        _this2._customData1 = void 0;
        _this2._customData2 = void 0;
        _this2._subEmitters = void 0;
        _this2.rateOverTime.constant = 10;
        _this2.startLifetime.constant = 5;
        _this2.startSize.constant = 1;
        _this2.startSpeed.constant = 5;
        _this2._isPlaying = false;
        _this2._isPaused = false;
        _this2._isStopped = true;
        _this2._isEmitting = false;
        _this2._time = 0;
        _this2._emitRateTimeCounter = 0;
        _this2._emitRateDistanceCounter = 0;
        _this2._oldWPos = new _valueTypes.Vec3(0, 0, 0);
        _this2._curWPos = new _valueTypes.Vec3(0, 0, 0);
        _this2._customData1 = new _valueTypes.Vec2(0, 0);
        _this2._customData2 = new _valueTypes.Vec2(0, 0);
        _this2._subEmitters = [];
        return _this2;
      }
      var _proto = ParticleSystem3D.prototype;
      _proto.onLoad = function onLoad() {
        this._assembler.onInit(this);
        this.shapeModule.onInit(this);
        this.trailModule.onInit(this);
        this.textureAnimationModule.onInit(this);
        this._resetPosition();
      };
      _proto._onMaterialModified = function _onMaterialModified(index, material) {
        this._assembler && this._assembler._onMaterialModified(index, material);
      };
      _proto._onRebuildPSO = function _onRebuildPSO(index, material) {
        this._assembler && this._assembler._onRebuildPSO(index, material);
      };
      _proto.play = function play() {
        this._isPaused && (this._isPaused = false);
        this._isStopped && (this._isStopped = false);
        this._isPlaying = true;
        this._isEmitting = true;
        this._resetPosition();
        this._prewarm && this._prewarmSystem();
      };
      _proto.pause = function pause() {
        if (this._isStopped) {
          console.warn("pause(): particle system is already stopped.");
          return;
        }
        this._isPlaying && (this._isPlaying = false);
        this._isPaused = true;
      };
      _proto.stop = function stop() {
        (this._isPlaying || this._isPaused) && this.clear();
        this._isPlaying && (this._isPlaying = false);
        this._isPaused && (this._isPaused = false);
        this._time = 0;
        this._emitRateTimeCounter = 0;
        this._emitRateDistanceCounter = 0;
        this._isStopped = true;
      };
      _proto.clear = function clear() {
        if (this.enabledInHierarchy) {
          this._assembler && this._assembler.clear();
          this.trailModule.clear();
        }
      };
      _proto.getParticleCount = function getParticleCount() {
        return this._assembler ? this._assembler.getParticleCount() : 0;
      };
      _proto.setCustomData1 = function setCustomData1(x, y) {
        _valueTypes.Vec2.set(this._customData1, x, y);
      };
      _proto.setCustomData2 = function setCustomData2(x, y) {
        _valueTypes.Vec2.set(this._customData2, x, y);
      };
      _proto.onDestroy = function onDestroy() {
        this._assembler.onDestroy();
        this.trailModule.destroy();
      };
      _proto.onEnable = function onEnable() {
        _RenderComponent.prototype.onEnable.call(this);
        this.playOnAwake && this.play();
        this._assembler.onEnable();
        this.trailModule.onEnable();
      };
      _proto.onDisable = function onDisable() {
        _RenderComponent.prototype.onDisable.call(this);
        this._assembler.onDisable();
        this.trailModule.onDisable();
      };
      _proto.update = function update(dt) {
        var scaledDeltaTime = dt * this.simulationSpeed;
        if (this._isPlaying) {
          this._time += scaledDeltaTime;
          this._emit(scaledDeltaTime);
          0 !== this._assembler._updateParticles(scaledDeltaTime) || this._isEmitting || this.stop();
          this._assembler.updateParticleBuffer();
          this.trailModule.enable && this.trailModule.updateTrailBuffer();
        }
      };
      _proto.emit = function emit(count, dt) {
        if (!this._assembler) return;
        this._simulationSpace === _enum.Space.World && this.node.getWorldMatrix(_world_mat);
        for (var i = 0; i < count; ++i) {
          var particle = this._assembler._getFreeParticle();
          if (null === particle) return;
          var rand = (0, _valueTypes.pseudoRandom)((0, _valueTypes.randomRangeInt)(0, _utils.INT_MAX));
          if (this.shapeModule.enable) this.shapeModule.emit(particle); else {
            _valueTypes.Vec3.set(particle.position, 0, 0, 0);
            _valueTypes.Vec3.copy(particle.velocity, _particleGeneralFunction.particleEmitZAxis);
          }
          this.textureAnimationModule.enable && this.textureAnimationModule.init(particle);
          _valueTypes.Vec3.scale(particle.velocity, particle.velocity, this.startSpeed.evaluate(this._time / this.duration, rand));
          switch (this._simulationSpace) {
           case _enum.Space.Local:
            break;

           case _enum.Space.World:
            _valueTypes.Vec3.transformMat4(particle.position, particle.position, _world_mat);
            var worldRot = new _valueTypes.Quat();
            this.node.getWorldRotation(worldRot);
            _valueTypes.Vec3.transformQuat(particle.velocity, particle.velocity, worldRot);
            break;

           case _enum.Space.Custom:
          }
          _valueTypes.Vec3.copy(particle.ultimateVelocity, particle.velocity);
          _valueTypes.Vec3.set(particle.rotation, 0, 0, this.startRotation.evaluate(this._time / this.duration, rand));
          _valueTypes.Vec3.set(particle.startSize, this.startSize.evaluate(this._time / this.duration, rand), 1, 1);
          particle.startSize.y = particle.startSize.x;
          _valueTypes.Vec3.copy(particle.size, particle.startSize);
          particle.startColor.set(this.startColor.evaluate(this._time / this.duration, rand));
          particle.color.set(particle.startColor);
          particle.startLifetime = this.startLifetime.evaluate(this._time / this.duration, rand) + dt;
          particle.remainingLifetime = particle.startLifetime;
          particle.randomSeed = (0, _valueTypes.randomRangeInt)(0, 233280);
          this._assembler._setNewParticle(particle);
        }
      };
      _proto._prewarmSystem = function _prewarmSystem() {
        this.startDelay.mode = _curveRange.Mode.Constant;
        this.startDelay.constant = 0;
        var dt = 1;
        var cnt = this.duration / dt;
        for (var i = 0; i < cnt; ++i) {
          this._time += dt;
          this._emit(dt);
          this._assembler && this._assembler._updateParticles(dt);
        }
      };
      _proto._emit = function _emit(dt) {
        var startDelay = this.startDelay.evaluate(0, 1);
        if (this._time > startDelay) {
          if (this._time > this.duration + startDelay && !this.loop) {
            this._isEmitting = false;
            return;
          }
          this._emitRateTimeCounter += this.rateOverTime.evaluate(this._time / this.duration, 1) * dt;
          if (this._emitRateTimeCounter > 1 && this._isEmitting) {
            var emitNum = Math.floor(this._emitRateTimeCounter);
            this._emitRateTimeCounter -= emitNum;
            this.emit(emitNum, dt);
          }
          this.node.getWorldPosition(this._curWPos);
          var distance = _valueTypes.Vec3.distance(this._curWPos, this._oldWPos);
          _valueTypes.Vec3.copy(this._oldWPos, this._curWPos);
          this._emitRateDistanceCounter += distance * this.rateOverDistance.evaluate(this._time / this.duration, 1);
          if (this._emitRateDistanceCounter > 1 && this._isEmitting) {
            var _emitNum = Math.floor(this._emitRateDistanceCounter);
            this._emitRateDistanceCounter -= _emitNum;
            this.emit(_emitNum, dt);
          }
          for (var _iterator = _createForOfIteratorHelperLoose(this.bursts), _step; !(_step = _iterator()).done; ) {
            var burst = _step.value;
            burst.update(this, dt);
          }
        }
      };
      _proto._activateMaterial = function _activateMaterial() {};
      _proto._resetPosition = function _resetPosition() {
        this.node.getWorldPosition(this._oldWPos);
        _valueTypes.Vec3.copy(this._curWPos, this._oldWPos);
      };
      _proto.addSubEmitter = function addSubEmitter(subEmitter) {
        this._subEmitters.push(subEmitter);
      };
      _proto.removeSubEmitter = function removeSubEmitter(idx) {
        this._subEmitters.splice(this._subEmitters.indexOf(idx), 1);
      };
      _proto.addBurst = function addBurst(burst) {
        this.bursts.push(burst);
      };
      _proto.removeBurst = function removeBurst(idx) {
        this.bursts.splice(this.bursts.indexOf(idx), 1);
      };
      _proto._checkBacth = function _checkBacth() {};
      _createClass(ParticleSystem3D, [ {
        key: "capacity",
        get: function get() {
          return this._capacity;
        },
        set: function set(val) {
          this._capacity = val;
          this._assembler && this._assembler.setCapacity(this._capacity);
        }
      }, {
        key: "prewarm",
        get: function get() {
          return this._prewarm;
        },
        set: function set(val) {
          true === val && false === this.loop;
          this._prewarm = val;
        }
      }, {
        key: "simulationSpace",
        get: function get() {
          return this._simulationSpace;
        },
        set: function set(val) {
          if (val !== this._simulationSpace) {
            this._simulationSpace = val;
            if (this._assembler) {
              this._assembler._updateMaterialParams();
              this._assembler._updateTrailMaterial();
            }
          }
        }
      }, {
        key: "materials",
        get: function get() {
          return this._materials;
        },
        set: function set(val) {
          this._materials = val;
          this._activateMaterial();
        }
      }, {
        key: "shapeModule",
        get: function get() {
          return this._shapeModule;
        },
        set: function set(val) {
          this._shapeModule = val;
          this._shapeModule.onInit(this);
        }
      }, {
        key: "colorOverLifetimeModule",
        get: function get() {
          return this._colorOverLifetimeModule;
        },
        set: function set(val) {
          this._colorOverLifetimeModule = val;
        }
      }, {
        key: "sizeOvertimeModule",
        get: function get() {
          return this._sizeOvertimeModule;
        },
        set: function set(val) {
          this._sizeOvertimeModule = val;
        }
      }, {
        key: "velocityOvertimeModule",
        get: function get() {
          return this._velocityOvertimeModule;
        },
        set: function set(val) {
          this._velocityOvertimeModule = val;
        }
      }, {
        key: "forceOvertimeModule",
        get: function get() {
          return this._forceOvertimeModule;
        },
        set: function set(val) {
          this._forceOvertimeModule = val;
        }
      }, {
        key: "limitVelocityOvertimeModule",
        get: function get() {
          return this._limitVelocityOvertimeModule;
        },
        set: function set(val) {
          this._limitVelocityOvertimeModule = val;
        }
      }, {
        key: "rotationOvertimeModule",
        get: function get() {
          return this._rotationOvertimeModule;
        },
        set: function set(val) {
          this._rotationOvertimeModule = val;
        }
      }, {
        key: "textureAnimationModule",
        get: function get() {
          return this._textureAnimationModule;
        },
        set: function set(val) {
          this._textureAnimationModule = val;
          this._textureAnimationModule.onInit(this);
        }
      }, {
        key: "trailModule",
        get: function get() {
          return this._trailModule;
        },
        set: function set(val) {
          this._trailModule = val;
          this._trailModule.onInit(this);
        }
      }, {
        key: "renderMode",
        get: function get() {
          return this._renderMode;
        },
        set: function set(val) {
          if (this._renderMode === val) return;
          this._renderMode = val;
          if (this._assembler) {
            this._assembler._setVertexAttrib();
            this._assembler._updateModel();
            this._assembler._updateMaterialParams();
          }
        }
      }, {
        key: "velocityScale",
        get: function get() {
          return this._velocityScale;
        },
        set: function set(val) {
          this._velocityScale = val;
          this._assembler && this._assembler._updateMaterialParams();
        }
      }, {
        key: "lengthScale",
        get: function get() {
          return this._lengthScale;
        },
        set: function set(val) {
          this._lengthScale = val;
          this._assembler && this._assembler._updateMaterialParams();
        }
      }, {
        key: "mesh",
        get: function get() {
          return this._mesh;
        },
        set: function set(val) {
          this._mesh = val;
          this._assembler && this._assembler._updateModel();
        }
      }, {
        key: "particleMaterial",
        get: function get() {
          return this.getMaterial(0);
        },
        set: function set(val) {
          this.setMaterial(0, val);
          this._onMaterialModified(0, val);
        }
      }, {
        key: "trailMaterial",
        get: function get() {
          return this.getMaterial(1);
        },
        set: function set(val) {
          this.setMaterial(1, val);
          this._onMaterialModified(1, val);
        }
      }, {
        key: "isPlaying",
        get: function get() {
          return this._isPlaying;
        }
      }, {
        key: "isPaused",
        get: function get() {
          return this._isPaused;
        }
      }, {
        key: "isStopped",
        get: function get() {
          return this._isStopped;
        }
      }, {
        key: "isEmitting",
        get: function get() {
          return this._isEmitting;
        }
      }, {
        key: "time",
        get: function get() {
          return this._time;
        }
      } ]);
      return ParticleSystem3D;
    })(RenderComponent), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "duration", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 5;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_capacity", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 100;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "capacity", [ property ], Object.getOwnPropertyDescriptor(_class2.prototype, "capacity"), _class2.prototype), 
    _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "loop", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return true;
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "playOnAwake", [ _dec4 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return true;
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_prewarm", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "prewarm", [ _dec5 ], Object.getOwnPropertyDescriptor(_class2.prototype, "prewarm"), _class2.prototype), 
    _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "_simulationSpace", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _enum.Space.Local;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "simulationSpace", [ _dec6 ], Object.getOwnPropertyDescriptor(_class2.prototype, "simulationSpace"), _class2.prototype), 
    _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "simulationSpeed", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "startDelay", [ _dec7 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "startLifetime", [ _dec8 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "startColor", [ _dec9 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _gradientRange["default"]();
      }
    }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "scaleSpace", [ _dec10 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _enum.Space.Local;
      }
    }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "startSize", [ _dec11 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "startSpeed", [ _dec12 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "startRotation", [ _dec13 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "gravityModifier", [ _dec14 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor16 = _applyDecoratedDescriptor(_class2.prototype, "rateOverTime", [ _dec15 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor17 = _applyDecoratedDescriptor(_class2.prototype, "rateOverDistance", [ _dec16 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor18 = _applyDecoratedDescriptor(_class2.prototype, "bursts", [ _dec17 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new Array();
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "materials", [ _dec18 ], Object.getOwnPropertyDescriptor(_class2.prototype, "materials"), _class2.prototype), 
    _descriptor19 = _applyDecoratedDescriptor(_class2.prototype, "_shapeModule", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _shapeModule["default"]();
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "shapeModule", [ _dec19 ], Object.getOwnPropertyDescriptor(_class2.prototype, "shapeModule"), _class2.prototype), 
    _descriptor20 = _applyDecoratedDescriptor(_class2.prototype, "_colorOverLifetimeModule", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _colorOvertime["default"]();
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "colorOverLifetimeModule", [ _dec20 ], Object.getOwnPropertyDescriptor(_class2.prototype, "colorOverLifetimeModule"), _class2.prototype), 
    _descriptor21 = _applyDecoratedDescriptor(_class2.prototype, "_sizeOvertimeModule", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _sizeOvertime["default"]();
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "sizeOvertimeModule", [ _dec21 ], Object.getOwnPropertyDescriptor(_class2.prototype, "sizeOvertimeModule"), _class2.prototype), 
    _descriptor22 = _applyDecoratedDescriptor(_class2.prototype, "_velocityOvertimeModule", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _velocityOvertime["default"]();
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "velocityOvertimeModule", [ _dec22 ], Object.getOwnPropertyDescriptor(_class2.prototype, "velocityOvertimeModule"), _class2.prototype), 
    _descriptor23 = _applyDecoratedDescriptor(_class2.prototype, "_forceOvertimeModule", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _forceOvertime["default"]();
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "forceOvertimeModule", [ _dec23 ], Object.getOwnPropertyDescriptor(_class2.prototype, "forceOvertimeModule"), _class2.prototype), 
    _descriptor24 = _applyDecoratedDescriptor(_class2.prototype, "_limitVelocityOvertimeModule", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _limitVelocityOvertime["default"]();
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "limitVelocityOvertimeModule", [ _dec24 ], Object.getOwnPropertyDescriptor(_class2.prototype, "limitVelocityOvertimeModule"), _class2.prototype), 
    _descriptor25 = _applyDecoratedDescriptor(_class2.prototype, "_rotationOvertimeModule", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _rotationOvertime["default"]();
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "rotationOvertimeModule", [ _dec25 ], Object.getOwnPropertyDescriptor(_class2.prototype, "rotationOvertimeModule"), _class2.prototype), 
    _descriptor26 = _applyDecoratedDescriptor(_class2.prototype, "_textureAnimationModule", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _textureAnimation["default"]();
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "textureAnimationModule", [ _dec26 ], Object.getOwnPropertyDescriptor(_class2.prototype, "textureAnimationModule"), _class2.prototype), 
    _descriptor27 = _applyDecoratedDescriptor(_class2.prototype, "_trailModule", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _trail["default"]();
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "trailModule", [ _dec27 ], Object.getOwnPropertyDescriptor(_class2.prototype, "trailModule"), _class2.prototype), 
    _descriptor28 = _applyDecoratedDescriptor(_class2.prototype, "_renderMode", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _enum.RenderMode.Billboard;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "renderMode", [ _dec28 ], Object.getOwnPropertyDescriptor(_class2.prototype, "renderMode"), _class2.prototype), 
    _descriptor29 = _applyDecoratedDescriptor(_class2.prototype, "_velocityScale", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "velocityScale", [ _dec29 ], Object.getOwnPropertyDescriptor(_class2.prototype, "velocityScale"), _class2.prototype), 
    _descriptor30 = _applyDecoratedDescriptor(_class2.prototype, "_lengthScale", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "lengthScale", [ _dec30 ], Object.getOwnPropertyDescriptor(_class2.prototype, "lengthScale"), _class2.prototype), 
    _descriptor31 = _applyDecoratedDescriptor(_class2.prototype, "_mesh", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return null;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "mesh", [ _dec31 ], Object.getOwnPropertyDescriptor(_class2.prototype, "mesh"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "particleMaterial", [ _dec32 ], Object.getOwnPropertyDescriptor(_class2.prototype, "particleMaterial"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "trailMaterial", [ _dec33 ], Object.getOwnPropertyDescriptor(_class2.prototype, "trailMaterial"), _class2.prototype), 
    _class2)) || _class) || _class) || _class) || _class);
    exports["default"] = ParticleSystem3D;
    false;
    cc.ParticleSystem3D = ParticleSystem3D;
    module.exports = exports["default"];
  }), {
    "../../assets/material/CCMaterial": 156,
    "../../components/CCRenderComponent": 192,
    "../../mesh/CCMesh": 240,
    "../../platform/CCClassDecorator": 273,
    "../../value-types": 401,
    "../../value-types/utils": 408,
    "./animator/color-overtime": 31,
    "./animator/curve-range": 32,
    "./animator/force-overtime": 33,
    "./animator/gradient-range": 34,
    "./animator/limit-velocity-overtime": 36,
    "./animator/rotation-overtime": 37,
    "./animator/size-overtime": 38,
    "./animator/texture-animation": 39,
    "./animator/velocity-overtime": 40,
    "./burst": 41,
    "./emitter/shape-module": 43,
    "./enum": 44,
    "./particle-general-function": 45,
    "./renderer/trail": 50
  } ],
  47: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueTypes = require("../../value-types");
    var Particle = function Particle(particleSystem) {
      this.particleSystem = null;
      this.position = null;
      this.velocity = null;
      this.animatedVelocity = null;
      this.ultimateVelocity = null;
      this.angularVelocity = null;
      this.axisOfRotation = null;
      this.rotation = null;
      this.startSize = null;
      this.size = null;
      this.startColor = null;
      this.color = cc.Color.WHITE;
      this.randomSeed = null;
      this.remainingLifetime = null;
      this.startLifetime = null;
      this.emitAccumulator0 = null;
      this.emitAccumulator1 = null;
      this.frameIndex = null;
      this.particleSystem = particleSystem;
      this.position = new _valueTypes.Vec3(0, 0, 0);
      this.velocity = new _valueTypes.Vec3(0, 0, 0);
      this.animatedVelocity = new _valueTypes.Vec3(0, 0, 0);
      this.ultimateVelocity = new _valueTypes.Vec3(0, 0, 0);
      this.angularVelocity = new _valueTypes.Vec3(0, 0, 0);
      this.axisOfRotation = new _valueTypes.Vec3(0, 0, 0);
      this.rotation = new _valueTypes.Vec3(0, 0, 0);
      this.startSize = new _valueTypes.Vec3(0, 0, 0);
      this.size = new _valueTypes.Vec3(0, 0, 0);
      this.startColor = cc.Color.WHITE.clone();
      this.color = cc.Color.WHITE.clone();
      this.randomSeed = 0;
      this.remainingLifetime = 0;
      this.startLifetime = 0;
      this.emitAccumulator0 = 0;
      this.emitAccumulator1 = 0;
      this.frameIndex = 0;
    };
    exports["default"] = Particle;
    module.exports = exports["default"];
  }), {
    "../../value-types": 401
  } ],
  48: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _gfx = _interopRequireDefault(require("../../../../renderer/gfx"));
    var _inputAssembler = _interopRequireDefault(require("../../../../renderer/core/input-assembler"));
    var _meshData = require("../../../mesh/mesh-data");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var renderer = require("../../../renderer");
    var ParticleBatchModel = (function() {
      function ParticleBatchModel() {
        this._capacity = 0;
        this._vertFormat = null;
        this._vertAttrsFloatCount = 0;
        this._mesh = null;
        this._vertCount = 0;
        this._indexCount = 0;
        this._material = null;
        this._capacity = 0;
        this._vertFormat = null;
        this._vertAttrsFloatCount = 0;
        this._mesh = null;
        this._subDatas = [];
        this._subMeshes = [];
      }
      var _proto = ParticleBatchModel.prototype;
      _proto.setCapacity = function setCapacity(capacity) {
        var capChanged = this._capacity !== capacity;
        this._capacity = capacity;
        this._inited && capChanged && this._recreateBuffer();
      };
      _proto.setVertexAttributes = function setVertexAttributes(mesh, vfmt) {
        if (this._mesh === mesh && this._vertFormat === vfmt) return;
        this._mesh = mesh;
        this._vertFormat = vfmt;
        this._vertAttrsFloatCount = this._vertFormat._bytes / 4;
        this._createParticleData();
        this._inited = true;
      };
      _proto._recreateBuffer = function _recreateBuffer() {
        this._createParticleData();
      };
      _proto._createParticleData = function _createParticleData() {
        this.destroyIAData();
        this._vertCount = 4;
        this._indexCount = 6;
        var vbData = null;
        var ibData = null;
        var vertSize = this._vertFormat._bytes;
        if (this._mesh) {
          var subData = this._mesh._subDatas[0];
          this._vertCount = subData.vData.byteLength / subData.vfm._bytes;
          this._indexCount = subData.iData.byteLength / 2;
          vbData = new Float32Array(vertSize * this._capacity * this._vertCount / 4);
          ibData = new Uint16Array(this._capacity * this._indexCount);
          var posEle = this._vertFormat.element(_gfx["default"].ATTR_TEX_COORD3);
          var normalEle = this._vertFormat.element(_gfx["default"].ATTR_NORMAL);
          var uvEle = this._vertFormat.element(_gfx["default"].ATTR_TEX_COORD);
          var colorEle = this._vertFormat.element(_gfx["default"].ATTR_COLOR1);
          this._mesh.copyAttribute(0, _gfx["default"].ATTR_POSITION, vbData.buffer, vertSize, posEle.offset);
          this._mesh.copyAttribute(0, _gfx["default"].ATTR_NORMAL, vbData.buffer, vertSize, normalEle.offset);
          this._mesh.copyAttribute(0, _gfx["default"].ATTR_UV0, vbData.buffer, vertSize, uvEle.offset);
          if (!this._mesh.copyAttribute(0, _gfx["default"].ATTR_COLOR, vbData.buffer, vertSize, colorEle.offset)) {
            var vb = new Uint32Array(vbData.buffer);
            for (var i = 0; i < this._vertCount; ++i) vb[i * this._vertAttrsFloatCount + colorEle.offset / 4] = cc.Color.WHITE._val;
          }
          var vbFloatArray = new Float32Array(vbData.buffer);
          for (var i = 1; i < this._capacity; i++) vbFloatArray.copyWithin(i * vertSize * this._vertCount / 4, 0, vertSize * this._vertCount / 4);
          this._mesh.copyIndices(0, ibData);
          for (var i = 1; i < this._capacity; i++) for (var j = 0; j < this._indexCount; j++) ibData[i * this._indexCount + j] = ibData[j] + i * this._vertCount;
        } else {
          vbData = new Float32Array(vertSize * this._capacity * this._vertCount / 4);
          ibData = new Uint16Array(this._capacity * this._indexCount);
          var dst = 0;
          for (var i = 0; i < this._capacity; ++i) {
            var baseIdx = 4 * i;
            ibData[dst++] = baseIdx;
            ibData[dst++] = baseIdx + 1;
            ibData[dst++] = baseIdx + 2;
            ibData[dst++] = baseIdx + 3;
            ibData[dst++] = baseIdx + 2;
            ibData[dst++] = baseIdx + 1;
          }
        }
        var meshData = new _meshData.MeshData();
        meshData.vData = vbData;
        meshData.iData = ibData;
        meshData.vfm = this._vertFormat;
        meshData.vDirty = true;
        meshData.iDirty = true;
        meshData.enable = true;
        this._subDatas[0] = meshData;
        var _vb;
        var ib;
        true, true;
        meshData.vDirty = true;
      };
      _proto.createTrailData = function createTrailData(vfmt, num) {
        if (this._subDatas[1]) return;
        var vertSize = vfmt._bytes;
        var vBuffer = new ArrayBuffer(vertSize * (num + 1) * 2);
        var ibData = new Uint16Array(6 * num);
        var meshData = new _meshData.MeshData();
        meshData.vData = new Float32Array(vBuffer);
        meshData.iData = ibData;
        meshData.vfm = vfmt;
        meshData.vDirty = true;
        meshData.iDirty = true;
        meshData.enable = true;
        this._subDatas[1] = meshData;
        var vb;
        var ib;
        true, true;
        meshData.vDirty = true;
      };
      _proto.setModelMaterial = function setModelMaterial(mat) {
        this._material = mat;
      };
      _proto.addParticleVertexData = function addParticleVertexData(index, pvdata) {
        var subData = this._subDatas[0];
        var vData = subData.getVData();
        var uintVData = subData.getVData(Uint32Array);
        if (this._mesh) for (var i = 0; i < this._vertCount; i++) {
          var _offset = (index * this._vertCount + i) * this._vertAttrsFloatCount;
          vData[_offset++] = pvdata[0].x;
          vData[_offset++] = pvdata[0].y;
          vData[_offset++] = pvdata[0].z;
          _offset += 2;
          vData[_offset++] = pvdata[1].z;
          vData[_offset++] = pvdata[2].x;
          vData[_offset++] = pvdata[2].y;
          vData[_offset++] = pvdata[2].z;
          vData[_offset++] = pvdata[3].x;
          vData[_offset++] = pvdata[3].y;
          vData[_offset++] = pvdata[3].z;
          uintVData[_offset++] = pvdata[4];
        } else {
          var offset = index * this._vertAttrsFloatCount;
          vData[offset++] = pvdata[0].x;
          vData[offset++] = pvdata[0].y;
          vData[offset++] = pvdata[0].z;
          vData[offset++] = pvdata[1].x;
          vData[offset++] = pvdata[1].y;
          vData[offset++] = pvdata[1].z;
          vData[offset++] = pvdata[2].x;
          vData[offset++] = pvdata[2].y;
          vData[offset++] = pvdata[2].z;
          vData[offset++] = pvdata[3].x;
          vData[offset++] = pvdata[3].y;
          vData[offset++] = pvdata[3].z;
          uintVData[offset++] = pvdata[4];
          if (pvdata[5]) {
            vData[offset++] = pvdata[5].x;
            vData[offset++] = pvdata[5].y;
            vData[offset++] = pvdata[5].z;
          }
        }
      };
      _proto._uploadData = function _uploadData() {
        var subDatas = this._subDatas;
        var subMeshes = this._subMeshes;
        for (var i = 0, len = subDatas.length; i < len; i++) {
          var subData = subDatas[i];
          var subMesh = subMeshes[i];
          if (subData.vDirty) {
            var vBuffer = subMesh._vertexBuffer, vData = subData.vData;
            vBuffer.update(0, vData);
            subData.vDirty = false;
          }
          if (subData.iDirty) {
            var iBuffer = subMesh._indexBuffer, iData = subData.iData;
            iBuffer.update(0, iData);
            subData.iDirty = false;
          }
        }
      };
      _proto.updateIA = function updateIA(index, count, vDirty, iDirty) {
        true, true;
        return;
        var subData;
      };
      _proto.clear = function clear() {
        var subMesh = this._subMeshes[0];
        subMesh && (subMesh.indexCount = 0);
      };
      _proto.destroy = function destroy() {
        this._subDatas.length = 0;
        var subMeshes = this._subMeshes;
        for (var i = 0, len = subMeshes.length; i < len; i++) {
          var vb = subMeshes[i]._vertexBuffer;
          vb && vb.destroy();
          var ib = subMeshes[i]._indexBuffer;
          ib && ib.destroy();
        }
        subMeshes.length = 0;
      };
      _proto.destroyIAData = function destroyIAData() {
        if (this._subMeshes[0]) {
          this._subMeshes[0]._vertexBuffer.destroy();
          this._subMeshes[0]._indexBuffer.destroy();
          this._subMeshes[0] = null;
        }
        this._subDatas[0] = null;
      };
      return ParticleBatchModel;
    })();
    exports["default"] = ParticleBatchModel;
    module.exports = exports["default"];
  }), {
    "../../../../renderer/core/input-assembler": 423,
    "../../../../renderer/gfx": 427,
    "../../../mesh/mesh-data": 243,
    "../../../renderer": 322
  } ],
  49: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueTypes = require("../../../value-types");
    var _gfx = _interopRequireDefault(require("../../../../renderer/gfx"));
    var _particleBatchModel = _interopRequireDefault(require("./particle-batch-model"));
    var _materialVariant = _interopRequireDefault(require("../../../assets/material/material-variant"));
    var _recyclePool = _interopRequireDefault(require("../../../../renderer/memop/recycle-pool"));
    var _enum = require("../enum");
    var _particle = _interopRequireDefault(require("../particle"));
    var _assembler = _interopRequireDefault(require("../../../renderer/assembler"));
    var _particleSystem3d = _interopRequireDefault(require("../particle-system-3d"));
    var _dec, _class;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var _require = require("../../../platform/CCClassDecorator"), ccclass = _require.ccclass, property = _require.property;
    var _tempAttribUV = new _valueTypes.Vec3();
    var _tempAttribUV0 = new _valueTypes.Vec2();
    var _tempAttribColor = new _valueTypes.Vec4();
    var _tempWorldTrans = new _valueTypes.Mat4();
    var _uvs = [ 0, 0, 1, 0, 0, 1, 1, 1 ];
    var CC_USE_WORLD_SPACE = "CC_USE_WORLD_SPACE";
    var CC_USE_BILLBOARD = "CC_USE_BILLBOARD";
    var CC_USE_STRETCHED_BILLBOARD = "CC_USE_STRETCHED_BILLBOARD";
    var CC_USE_HORIZONTAL_BILLBOARD = "CC_USE_HORIZONTAL_BILLBOARD";
    var CC_USE_VERTICAL_BILLBOARD = "CC_USE_VERTICAL_BILLBOARD";
    var CC_USE_MESH = "CC_USE_MESH";
    var vfmtNormal = new _gfx["default"].VertexFormat([ {
      name: _gfx["default"].ATTR_POSITION,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_TEX_COORD,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_TEX_COORD1,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_TEX_COORD2,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_COLOR,
      type: _gfx["default"].ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    vfmtNormal.name = "vfmtNormal";
    var vfmtStretch = new _gfx["default"].VertexFormat([ {
      name: _gfx["default"].ATTR_POSITION,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_TEX_COORD,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_TEX_COORD1,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_TEX_COORD2,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_COLOR,
      type: _gfx["default"].ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    }, {
      name: _gfx["default"].ATTR_COLOR1,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    } ]);
    vfmtStretch.name = "vfmtStretch";
    var vfmtMesh = new _gfx["default"].VertexFormat([ {
      name: _gfx["default"].ATTR_POSITION,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_TEX_COORD,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_TEX_COORD1,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_TEX_COORD2,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_COLOR,
      type: _gfx["default"].ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    }, {
      name: _gfx["default"].ATTR_TEX_COORD3,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_NORMAL,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_COLOR1,
      type: _gfx["default"].ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    vfmtMesh.name = "vfmtMesh";
    var ParticleSystem3DAssembler = (_dec = ccclass("cc.ParticleSystem3DAssembler"), 
    _dec(_class = (function(_Assembler) {
      _inheritsLoose(ParticleSystem3DAssembler, _Assembler);
      function ParticleSystem3DAssembler() {
        var _this;
        _this = _Assembler.call(this) || this;
        _this._defines = null;
        _this._trailDefines = null;
        _this._model = null;
        _this.frameTile_velLenScale = null;
        _this.attrs = [];
        _this._vertFormat = [];
        _this._particleSystem = null;
        _this._particles = null;
        _this._defaultMat = null;
        _this._isAssetReady = false;
        _this._defaultTrailMat = null;
        _this._customProperties = null;
        _this._node_scale = null;
        _this._model = null;
        _this.frameTile_velLenScale = cc.v4(1, 1, 0, 0);
        _this._node_scale = cc.v4();
        _this.attrs = new Array(5);
        _this._trailDefines = {
          CC_USE_WORLD_SPACE: true
        };
        return _this;
      }
      var _proto = ParticleSystem3DAssembler.prototype;
      _proto.onInit = function onInit(ps) {
        var _this2 = this;
        this._particleSystem = ps;
        this._particles = new _recyclePool["default"](function() {
          return new _particle["default"](_this2);
        }, 16);
        this._setVertexAttrib();
        this.onEnable();
        this._updateModel();
        this._updateMaterialParams();
        this._updateTrailMaterial();
      };
      _proto.onEnable = function onEnable() {
        if (!this._particleSystem) return;
        null == this._model && (this._model = new _particleBatchModel["default"]());
        this._model.inited || this._model.setCapacity(this._particleSystem.capacity);
        this._model.enabled = this._particleSystem.enabledInHierarchy;
      };
      _proto.onDisable = function onDisable() {
        this._model && (this._model.enabled = this._particleSystem.enabledInHierarchy);
      };
      _proto.onDestroy = function onDestroy() {
        this._model = null;
      };
      _proto.clear = function clear() {
        this._particles.reset();
        this.updateParticleBuffer();
      };
      _proto._getFreeParticle = function _getFreeParticle() {
        if (this._particles.length >= this._particleSystem.capacity) return null;
        return this._particles.add();
      };
      _proto._setNewParticle = function _setNewParticle(p) {};
      _proto._updateParticles = function _updateParticles(dt) {
        this._particleSystem.node.getWorldMatrix(_tempWorldTrans);
        switch (this._particleSystem.scaleSpace) {
         case _enum.Space.Local:
          this._particleSystem.node.getScale(this._node_scale);
          break;

         case _enum.Space.World:
          this._particleSystem.node.getWorldScale(this._node_scale);
        }
        var material = this._particleSystem.materials[0];
        var mat = material ? this._particleSystem.particleMaterial : this._defaultMat;
        mat.setProperty("scale", this._node_scale);
        this._particleSystem.velocityOvertimeModule.enable && this._particleSystem.velocityOvertimeModule.update(this._particleSystem._simulationSpace, _tempWorldTrans);
        this._particleSystem.forceOvertimeModule.enable && this._particleSystem.forceOvertimeModule.update(this._particleSystem._simulationSpace, _tempWorldTrans);
        this._particleSystem.trailModule.enable && this._particleSystem.trailModule.update();
        for (var i = 0; i < this._particles.length; ++i) {
          var p = this._particles.data[i];
          p.remainingLifetime -= dt;
          _valueTypes.Vec3.set(p.animatedVelocity, 0, 0, 0);
          if (p.remainingLifetime < 0) {
            this._particleSystem.trailModule.enable && this._particleSystem.trailModule.removeParticle(p);
            this._particles.remove(i);
            --i;
            continue;
          }
          p.velocity.y -= 9.8 * this._particleSystem.gravityModifier.evaluate(1 - p.remainingLifetime / p.startLifetime, p.randomSeed) * dt;
          this._particleSystem.sizeOvertimeModule.enable && this._particleSystem.sizeOvertimeModule.animate(p);
          this._particleSystem.colorOverLifetimeModule.enable && this._particleSystem.colorOverLifetimeModule.animate(p);
          this._particleSystem.forceOvertimeModule.enable && this._particleSystem.forceOvertimeModule.animate(p, dt);
          this._particleSystem.velocityOvertimeModule.enable ? this._particleSystem.velocityOvertimeModule.animate(p) : _valueTypes.Vec3.copy(p.ultimateVelocity, p.velocity);
          this._particleSystem.limitVelocityOvertimeModule.enable && this._particleSystem.limitVelocityOvertimeModule.animate(p);
          this._particleSystem.rotationOvertimeModule.enable && this._particleSystem.rotationOvertimeModule.animate(p, dt);
          this._particleSystem.textureAnimationModule.enable && this._particleSystem.textureAnimationModule.animate(p);
          _valueTypes.Vec3.scaleAndAdd(p.position, p.position, p.ultimateVelocity, dt);
          this._particleSystem.trailModule.enable && this._particleSystem.trailModule.animate(p, dt);
        }
        return this._particles.length;
      };
      _proto.updateParticleBuffer = function updateParticleBuffer() {
        var idx = 0;
        var uploadVel = this._particleSystem.renderMode === _enum.RenderMode.StrecthedBillboard;
        for (var i = 0; i < this._particles.length; ++i) {
          var p = this._particles.data[i];
          var fi = 0;
          this._particleSystem.textureAnimationModule.enable && (fi = p.frameIndex);
          idx = 4 * i;
          var attrNum = 0;
          if (this._particleSystem.renderMode !== _enum.RenderMode.Mesh) for (var j = 0; j < 4; ++j) {
            attrNum = 0;
            this.attrs[attrNum++] = p.position;
            _tempAttribUV.x = _uvs[2 * j];
            _tempAttribUV.y = _uvs[2 * j + 1];
            _tempAttribUV.z = fi;
            this.attrs[attrNum++] = _tempAttribUV;
            this.attrs[attrNum++] = p.size;
            this.attrs[attrNum++] = p.rotation;
            this.attrs[attrNum++] = p.color._val;
            this.attrs[attrNum++] = uploadVel ? p.ultimateVelocity : null;
            this._model.addParticleVertexData(idx++, this.attrs);
          } else {
            attrNum = 0;
            this.attrs[attrNum++] = p.position;
            _tempAttribUV.z = fi;
            this.attrs[attrNum++] = _tempAttribUV;
            this.attrs[attrNum++] = p.size;
            this.attrs[attrNum++] = p.rotation;
            this.attrs[attrNum++] = p.color._val;
            this._model.addParticleVertexData(i, this.attrs);
          }
        }
        this.updateIA(0, this._particles.length * this._model._indexCount, true);
      };
      _proto.updateShaderUniform = function updateShaderUniform() {};
      _proto.updateIA = function updateIA(index, count, vDirty, iDirty) {
        if (!this._model) return;
        this._model.updateIA(index, count, vDirty, iDirty);
      };
      _proto.getParticleCount = function getParticleCount() {
        return this._particles.data.length;
      };
      _proto._onMaterialModified = function _onMaterialModified(index, material) {
        if (0 === index) {
          this._updateModel();
          this._updateMaterialParams();
        } else this._updateTrailMaterial();
      };
      _proto._onRebuildPSO = function _onRebuildPSO(index, material) {
        this._model && 0 === index && this._model.setModelMaterial(material);
        this._particleSystem.trailModule._trailModel && 1 === index && this._particleSystem.trailModule._trailModel.setModelMaterial(material);
      };
      _proto._ensureLoadMesh = function _ensureLoadMesh() {
        this._particleSystem.mesh && !this._particleSystem.mesh.loaded && cc.assetManager.postLoadNative(this._particleSystem.mesh);
      };
      _proto.setCapacity = function setCapacity(capacity) {
        if (!this._model) return;
        this._model.setCapacity(capacity);
      };
      _proto._setVertexAttrib = function _setVertexAttrib() {
        switch (this._particleSystem.renderMode) {
         case _enum.RenderMode.StrecthedBillboard:
          this._vertFormat = vfmtStretch;
          break;

         case _enum.RenderMode.Mesh:
          this._vertFormat = vfmtMesh;
          break;

         default:
          this._vertFormat = vfmtNormal;
        }
      };
      _proto._updateMaterialParams = function _updateMaterialParams() {
        if (!this._particleSystem) return;
        var mat = this._particleSystem.materials[0];
        mat = null == mat && null == this._defaultMat ? this._defaultMat = _materialVariant["default"].createWithBuiltin("3d-particle", this) : _materialVariant["default"].create(mat, this._particleSystem);
        mat = mat || this._defaultMat;
        this._particleSystem._simulationSpace === _enum.Space.World ? mat.define(CC_USE_WORLD_SPACE, true) : mat.define(CC_USE_WORLD_SPACE, false);
        if (this._particleSystem.renderMode === _enum.RenderMode.Billboard) {
          mat.define(CC_USE_BILLBOARD, true);
          mat.define(CC_USE_STRETCHED_BILLBOARD, false);
          mat.define(CC_USE_HORIZONTAL_BILLBOARD, false);
          mat.define(CC_USE_VERTICAL_BILLBOARD, false);
          mat.define(CC_USE_MESH, false);
        } else if (this._particleSystem.renderMode === _enum.RenderMode.StrecthedBillboard) {
          mat.define(CC_USE_BILLBOARD, false);
          mat.define(CC_USE_STRETCHED_BILLBOARD, true);
          mat.define(CC_USE_HORIZONTAL_BILLBOARD, false);
          mat.define(CC_USE_VERTICAL_BILLBOARD, false);
          mat.define(CC_USE_MESH, false);
          this.frameTile_velLenScale.z = this._particleSystem.velocityScale;
          this.frameTile_velLenScale.w = this._particleSystem.lengthScale;
        } else if (this._particleSystem.renderMode === _enum.RenderMode.HorizontalBillboard) {
          mat.define(CC_USE_BILLBOARD, false);
          mat.define(CC_USE_STRETCHED_BILLBOARD, false);
          mat.define(CC_USE_HORIZONTAL_BILLBOARD, true);
          mat.define(CC_USE_VERTICAL_BILLBOARD, false);
          mat.define(CC_USE_MESH, false);
        } else if (this._particleSystem.renderMode === _enum.RenderMode.VerticalBillboard) {
          mat.define(CC_USE_BILLBOARD, false);
          mat.define(CC_USE_STRETCHED_BILLBOARD, false);
          mat.define(CC_USE_HORIZONTAL_BILLBOARD, false);
          mat.define(CC_USE_VERTICAL_BILLBOARD, true);
          mat.define(CC_USE_MESH, false);
        } else if (this._particleSystem.renderMode === _enum.RenderMode.Mesh) {
          mat.define(CC_USE_BILLBOARD, false);
          mat.define(CC_USE_STRETCHED_BILLBOARD, false);
          mat.define(CC_USE_HORIZONTAL_BILLBOARD, false);
          mat.define(CC_USE_VERTICAL_BILLBOARD, false);
          mat.define(CC_USE_MESH, true);
        } else console.warn("particle system renderMode " + this._particleSystem.renderMode + " not support.");
        this._particleSystem.textureAnimationModule.enable && _valueTypes.Vec2.set(this.frameTile_velLenScale, this._particleSystem.textureAnimationModule.numTilesX, this._particleSystem.textureAnimationModule.numTilesY);
        mat.setProperty("frameTile_velLenScale", this.frameTile_velLenScale);
        this._particleSystem.setMaterial(0, mat);
      };
      _proto._updateTrailMaterial = function _updateTrailMaterial() {
        var mat = this._particleSystem.trailMaterial;
        if (this._particleSystem.trailModule.enable) {
          null === mat && null === this._defaultTrailMat && (this._defaultTrailMat = _materialVariant["default"].createWithBuiltin("3d-trail", this));
          if (null === mat) {
            mat = this._defaultTrailMat;
            this._particleSystem.trailMaterial = mat;
          }
          this._particleSystem._simulationSpace === _enum.Space.World || this._particleSystem.trailModule.space === _enum.Space.World ? mat.define(CC_USE_WORLD_SPACE, true) : mat.define(CC_USE_WORLD_SPACE, false);
          this._particleSystem.trailModule._updateMaterial();
        }
      };
      _proto._updateTrailEnable = function _updateTrailEnable(enable) {
        if (!this._model) return;
        var subData = this._model._subDatas[1];
        subData && (subData.enable = enable);
      };
      _proto._updateModel = function _updateModel() {
        if (!this._model) return;
        this._model.setVertexAttributes(this._particleSystem.renderMode === _enum.RenderMode.Mesh ? this._particleSystem.mesh : null, this._vertFormat);
      };
      _proto.setVertexAttributes = function setVertexAttributes(mesh, vfmt) {
        if (!this._model) return;
        this._model.setVertexAttributes(mesh, vfmt);
      };
      _proto.fillBuffers = function fillBuffers(comp, renderer) {
        if (!this._model) return;
        this._model._uploadData();
        var submeshes = this._model._subMeshes;
        var subDatas = this._model._subDatas;
        var materials = comp.materials;
        renderer._flush();
        for (var i = 0, len = submeshes.length; i < len; i++) {
          var ia = submeshes[i];
          var meshData = subDatas[i];
          var material = materials[i];
          if (meshData.enable) {
            renderer.material = material;
            renderer.cullingMask = comp.node._cullingMask;
            renderer.node = comp.node;
            renderer._flushIA(ia);
          }
        }
      };
      return ParticleSystem3DAssembler;
    })(_assembler["default"])) || _class);
    exports["default"] = ParticleSystem3DAssembler;
    Object.assign(ParticleSystem3DAssembler, {
      uv: _uvs
    });
    _assembler["default"].register(_particleSystem3d["default"], ParticleSystem3DAssembler);
    module.exports = exports["default"];
  }), {
    "../../../../renderer/gfx": 427,
    "../../../../renderer/memop/recycle-pool": 429,
    "../../../assets/material/material-variant": 163,
    "../../../platform/CCClassDecorator": 273,
    "../../../renderer/assembler": 302,
    "../../../value-types": 401,
    "../enum": 44,
    "../particle": 47,
    "../particle-system-3d": 46,
    "./particle-batch-model": 48
  } ],
  50: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _CCClassDecorator = require("../../../platform/CCClassDecorator");
    var _valueTypes = require("../../../value-types");
    var _gfx = _interopRequireDefault(require("../../../../renderer/gfx"));
    var _pool = _interopRequireDefault(require("../../../../renderer/memop/pool"));
    var _curveRange = _interopRequireDefault(require("../animator/curve-range"));
    var _gradientRange = _interopRequireDefault(require("../animator/gradient-range"));
    var _enum = require("../enum");
    var _utils = _interopRequireDefault(require("../utils"));
    var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = "undefined" !== typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" === typeof o.length) {
        it && (o = it);
        var i = 0;
        return function() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if ("string" === typeof o) return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      "Object" === n && o.constructor && (n = o.constructor.name);
      if ("Map" === n || "Set" === n) return Array.from(o);
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      (null == len || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var PRE_TRIANGLE_INDEX = 1;
    var NEXT_TRIANGLE_INDEX = 4;
    var DIRECTION_THRESHOLD = Math.cos((0, _valueTypes.toRadian)(100));
    var _temp_trailEle = {
      position: cc.v3(),
      velocity: cc.v3()
    };
    var _temp_quat = cc.quat();
    var _temp_xform = cc.mat4();
    var _temp_Vec3 = cc.v3();
    var _temp_Vec3_1 = cc.v3();
    var _temp_color = cc.color();
    var ITrailElement = function ITrailElement() {
      this.position = void 0;
      this.lifetime = void 0;
      this.width = void 0;
      this.velocity = void 0;
      this.color = void 0;
    };
    var TrailSegment = (function() {
      function TrailSegment(maxTrailElementNum) {
        this.start = void 0;
        this.end = void 0;
        this.trailElements = [];
        this.start = -1;
        this.end = -1;
        this.trailElements = [];
        while (maxTrailElementNum--) this.trailElements.push({
          position: cc.v3(),
          lifetime: 0,
          width: 0,
          velocity: cc.v3(),
          direction: 0,
          color: cc.color()
        });
      }
      var _proto = TrailSegment.prototype;
      _proto.getElement = function getElement(idx) {
        if (-1 === this.start) return null;
        idx < 0 && (idx = (idx + this.trailElements.length) % this.trailElements.length);
        idx >= this.trailElements.length && (idx %= this.trailElements.length);
        return this.trailElements[idx];
      };
      _proto.addElement = function addElement() {
        if (0 === this.trailElements.length) return null;
        if (-1 === this.start) {
          this.start = 0;
          this.end = 1;
          return this.trailElements[0];
        }
        if (this.start === this.end) {
          this.trailElements.splice(this.end, 0, {
            position: cc.v3(),
            lifetime: 0,
            width: 0,
            velocity: cc.v3(),
            direction: 0,
            color: cc.color()
          });
          this.start++;
          this.start %= this.trailElements.length;
        }
        var newEleLoc = this.end++;
        this.end %= this.trailElements.length;
        return this.trailElements[newEleLoc];
      };
      _proto.iterateElement = function iterateElement(target, f, p, dt) {
        var end = this.start >= this.end ? this.end + this.trailElements.length : this.end;
        for (var i = this.start; i < end; i++) if (f(target, this.trailElements[i % this.trailElements.length], p, dt)) {
          this.start++;
          this.start %= this.trailElements.length;
        }
        if (this.start === end) {
          this.start = -1;
          this.end = -1;
        }
      };
      _proto.count = function count() {
        return this.start < this.end ? this.end - this.start : this.trailElements.length + this.end - this.start;
      };
      _proto.clear = function clear() {
        this.start = -1;
        this.end = -1;
      };
      return TrailSegment;
    })();
    var TrailModule = (_dec = (0, _CCClassDecorator.ccclass)("cc.TrailModule"), _dec2 = (0, 
    _CCClassDecorator.property)({
      type: _enum.TrailMode
    }), _dec3 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"]
    }), _dec4 = (0, _CCClassDecorator.property)({
      type: _enum.Space
    }), _dec5 = (0, _CCClassDecorator.property)({
      type: _enum.TextureMode
    }), _dec6 = (0, _CCClassDecorator.property)({
      type: _curveRange["default"]
    }), _dec7 = (0, _CCClassDecorator.property)({
      type: _gradientRange["default"]
    }), _dec8 = (0, _CCClassDecorator.property)({
      type: _gradientRange["default"]
    }), _dec(_class = (_class2 = (function() {
      function TrailModule() {
        _initializerDefineProperty(this, "_enable", _descriptor, this);
        _initializerDefineProperty(this, "mode", _descriptor2, this);
        _initializerDefineProperty(this, "lifeTime", _descriptor3, this);
        _initializerDefineProperty(this, "_minParticleDistance", _descriptor4, this);
        _initializerDefineProperty(this, "_space", _descriptor5, this);
        _initializerDefineProperty(this, "existWithParticles", _descriptor6, this);
        _initializerDefineProperty(this, "textureMode", _descriptor7, this);
        _initializerDefineProperty(this, "widthFromParticle", _descriptor8, this);
        _initializerDefineProperty(this, "widthRatio", _descriptor9, this);
        _initializerDefineProperty(this, "colorFromParticle", _descriptor10, this);
        _initializerDefineProperty(this, "colorOverTrail", _descriptor11, this);
        _initializerDefineProperty(this, "colorOvertime", _descriptor12, this);
        this._particleSystem = null;
        this._minSquaredDistance = 0;
        this._vertSize = 0;
        this._trailNum = 0;
        this._trailLifetime = 0;
        this.vbOffset = 0;
        this.ibOffset = 0;
        this._trailSegments = null;
        this._particleTrail = null;
        this._ia = null;
        this._gfxVFmt = null;
        this._vbF32 = null;
        this._vbUint32 = null;
        this._iBuffer = null;
        this._needTransform = null;
        this._defaultMat = null;
        this._material = null;
        this._gfxVFmt = new _gfx["default"].VertexFormat([ {
          name: _gfx["default"].ATTR_POSITION,
          type: _gfx["default"].ATTR_TYPE_FLOAT32,
          num: 3
        }, {
          name: _gfx["default"].ATTR_TEX_COORD,
          type: _gfx["default"].ATTR_TYPE_FLOAT32,
          num: 4
        }, {
          name: _gfx["default"].ATTR_TEX_COORD1,
          type: _gfx["default"].ATTR_TYPE_FLOAT32,
          num: 3
        }, {
          name: _gfx["default"].ATTR_COLOR,
          type: _gfx["default"].ATTR_TYPE_UINT8,
          num: 4,
          normalize: true
        } ]);
        this._vertSize = this._gfxVFmt._bytes;
        this._particleTrail = new _utils["default"]();
      }
      var _proto2 = TrailModule.prototype;
      _proto2.onInit = function onInit(ps) {
        this._particleSystem = ps;
        this.minParticleDistance = this._minParticleDistance;
        var burstCount = 0;
        for (var _iterator = _createForOfIteratorHelperLoose(ps.bursts), _step; !(_step = _iterator()).done; ) {
          var b = _step.value;
          burstCount += b.getMaxCount(ps);
        }
        this.lifeTime.constant = 1;
        this._trailNum = Math.ceil(ps.startLifetime.getMax() * this.lifeTime.getMax() * 60 * (ps.rateOverTime.getMax() * ps.duration + burstCount));
        this._trailSegments = new _pool["default"](function() {
          return new TrailSegment(10);
        }, Math.ceil(ps.rateOverTime.getMax() * ps.duration));
        if (this._enable) {
          this.enable = this._enable;
          this._updateMaterial();
        }
      };
      _proto2.onEnable = function onEnable() {};
      _proto2.onDisable = function onDisable() {};
      _proto2.destroy = function destroy() {
        if (this._trailSegments) {
          this._trailSegments.clear((function(obj) {
            obj.trailElements.length = 0;
          }));
          this._trailSegments = null;
        }
      };
      _proto2.clear = function clear() {
        if (this.enable) {
          var trailIter = this._particleTrail.values();
          var trail = trailIter.next();
          while (!trail.done) {
            trail.value.clear();
            trail = trailIter.next();
          }
          this._particleTrail.clear();
          this.updateTrailBuffer();
        }
      };
      _proto2._createTrailData = function _createTrailData() {
        var model = this._particleSystem._assembler._model;
        if (model) {
          model.createTrailData(this._gfxVFmt, this._trailNum);
          var subData = model._subDatas[1];
          this._vbF32 = subData.getVData();
          this._vbUint32 = subData.getVData(Uint32Array);
          this._iBuffer = subData.iData;
        }
      };
      _proto2._updateMaterial = function _updateMaterial() {
        if (this._particleSystem) {
          var mat = this._particleSystem.trailMaterial;
          this._material = mat || this._particleSystem._assembler._defaultTrailMat;
        }
      };
      _proto2.update = function update() {
        this._trailLifetime = this.lifeTime.evaluate(this._particleSystem._time, 1);
        if (this.space === _enum.Space.World && this._particleSystem._simulationSpace === _enum.Space.Local) {
          this._needTransform = true;
          this._particleSystem.node.getWorldMatrix(_temp_xform);
          this._particleSystem.node.getWorldRotation(_temp_quat);
        } else this._needTransform = false;
      };
      _proto2.animate = function animate(p, scaledDt) {
        if (!this._trailSegments) return;
        var trail = this._particleTrail.get(p);
        if (!trail) {
          trail = this._trailSegments.alloc();
          this._particleTrail.set(p, trail);
          return;
        }
        var lastSeg = trail.getElement(trail.end - 1);
        this._needTransform ? _valueTypes.Vec3.transformMat4(_temp_Vec3, p.position, _temp_xform) : _valueTypes.Vec3.copy(_temp_Vec3, p.position);
        if (lastSeg) {
          trail.iterateElement(this, this._updateTrailElement, p, scaledDt);
          if (_valueTypes.Vec3.squaredDistance(lastSeg.position, _temp_Vec3) < this._minSquaredDistance) return;
        }
        lastSeg = trail.addElement();
        if (!lastSeg) return;
        _valueTypes.Vec3.copy(lastSeg.position, _temp_Vec3);
        lastSeg.lifetime = 0;
        this.widthFromParticle ? lastSeg.width = p.size.x * this.widthRatio.evaluate(0, 1) : lastSeg.width = this.widthRatio.evaluate(0, 1);
        var trailNum = trail.count();
        if (2 === trailNum) {
          var lastSecondTrail = trail.getElement(trail.end - 2);
          _valueTypes.Vec3.subtract(lastSecondTrail.velocity, lastSeg.position, lastSecondTrail.position);
        } else if (trailNum > 2) {
          var _lastSecondTrail = trail.getElement(trail.end - 2);
          var lastThirdTrail = trail.getElement(trail.end - 3);
          _valueTypes.Vec3.subtract(_temp_Vec3, lastThirdTrail.position, _lastSecondTrail.position);
          _valueTypes.Vec3.subtract(_temp_Vec3_1, lastSeg.position, _lastSecondTrail.position);
          _valueTypes.Vec3.subtract(_lastSecondTrail.velocity, _temp_Vec3_1, _temp_Vec3);
          _valueTypes.Vec3.equals(cc.Vec3.ZERO, _lastSecondTrail.velocity) && _valueTypes.Vec3.copy(_lastSecondTrail.velocity, _temp_Vec3);
        }
        this.colorFromParticle ? lastSeg.color.set(p.color) : lastSeg.color.set(this.colorOvertime.evaluate(0, 1));
      };
      _proto2._updateTrailElement = function _updateTrailElement(trail, trailEle, p, dt) {
        trailEle.lifetime += dt;
        if (trail.colorFromParticle) {
          trailEle.color.set(p.color);
          trailEle.color.multiply(trail.colorOvertime.evaluate(1 - p.remainingLifetime / p.startLifetime, 1));
        } else trailEle.color.set(trail.colorOvertime.evaluate(1 - p.remainingLifetime / p.startLifetime, 1));
        trail.widthFromParticle ? trailEle.width = p.size.x * trail.widthRatio.evaluate(trailEle.lifetime / trail._trailLifetime, 1) : trailEle.width = trail.widthRatio.evaluate(trailEle.lifetime / trail._trailLifetime, 1);
        return trailEle.lifetime > trail._trailLifetime;
      };
      _proto2.removeParticle = function removeParticle(p) {
        var trail = this._particleTrail.get(p);
        if (trail && this._trailSegments) {
          trail.clear();
          this._trailSegments.free(trail);
          this._particleTrail["delete"](p);
        }
      };
      _proto2.updateTrailBuffer = function updateTrailBuffer() {
        this.vbOffset = 0;
        this.ibOffset = 0;
        for (var _iterator2 = _createForOfIteratorHelperLoose(this._particleTrail.keys()), _step2; !(_step2 = _iterator2()).done; ) {
          var p = _step2.value;
          var trailSeg = this._particleTrail.get(p);
          if (-1 === trailSeg.start) continue;
          var indexOffset = 4 * this.vbOffset / this._vertSize;
          var end = trailSeg.start >= trailSeg.end ? trailSeg.end + trailSeg.trailElements.length : trailSeg.end;
          var trailNum = end - trailSeg.start;
          var textCoordSeg = 1 / trailNum;
          var startSegEle = trailSeg.trailElements[trailSeg.start];
          this._fillVertexBuffer(startSegEle, this.colorOverTrail.evaluate(1, 1), indexOffset, 1, 0, NEXT_TRIANGLE_INDEX);
          for (var i = trailSeg.start + 1; i < end; i++) {
            var segEle = trailSeg.trailElements[i % trailSeg.trailElements.length];
            var j = i - trailSeg.start;
            this._fillVertexBuffer(segEle, this.colorOverTrail.evaluate(1 - j / trailNum, 1), indexOffset, 1 - j * textCoordSeg, j, PRE_TRIANGLE_INDEX | NEXT_TRIANGLE_INDEX);
          }
          this._needTransform ? _valueTypes.Vec3.transformMat4(_temp_trailEle.position, p.position, _temp_xform) : _valueTypes.Vec3.copy(_temp_trailEle.position, p.position);
          if (1 === trailNum || 2 === trailNum) {
            var lastSecondTrail = trailSeg.getElement(trailSeg.end - 1);
            _valueTypes.Vec3.subtract(lastSecondTrail.velocity, _temp_trailEle.position, lastSecondTrail.position);
            this._vbF32[this.vbOffset - this._vertSize / 4 - 4] = lastSecondTrail.velocity.x;
            this._vbF32[this.vbOffset - this._vertSize / 4 - 3] = lastSecondTrail.velocity.y;
            this._vbF32[this.vbOffset - this._vertSize / 4 - 2] = lastSecondTrail.velocity.z;
            this._vbF32[this.vbOffset - 4] = lastSecondTrail.velocity.x;
            this._vbF32[this.vbOffset - 3] = lastSecondTrail.velocity.y;
            this._vbF32[this.vbOffset - 2] = lastSecondTrail.velocity.z;
            _valueTypes.Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, lastSecondTrail.position);
            this._checkDirectionReverse(_temp_trailEle, lastSecondTrail);
          } else if (trailNum > 2) {
            var _lastSecondTrail2 = trailSeg.getElement(trailSeg.end - 1);
            var lastThirdTrail = trailSeg.getElement(trailSeg.end - 2);
            _valueTypes.Vec3.subtract(_temp_Vec3, lastThirdTrail.position, _lastSecondTrail2.position);
            _valueTypes.Vec3.subtract(_temp_Vec3_1, _temp_trailEle.position, _lastSecondTrail2.position);
            _valueTypes.Vec3.normalize(_temp_Vec3, _temp_Vec3);
            _valueTypes.Vec3.normalize(_temp_Vec3_1, _temp_Vec3_1);
            _valueTypes.Vec3.subtract(_lastSecondTrail2.velocity, _temp_Vec3_1, _temp_Vec3);
            _valueTypes.Vec3.normalize(_lastSecondTrail2.velocity, _lastSecondTrail2.velocity);
            this._checkDirectionReverse(_lastSecondTrail2, lastThirdTrail);
            this.vbOffset -= this._vertSize / 4 * 2;
            this.ibOffset -= 6;
            this._fillVertexBuffer(_lastSecondTrail2, this.colorOverTrail.evaluate(textCoordSeg, 1), indexOffset, textCoordSeg, trailNum - 1, PRE_TRIANGLE_INDEX | NEXT_TRIANGLE_INDEX);
            _valueTypes.Vec3.subtract(_temp_trailEle.velocity, _temp_trailEle.position, _lastSecondTrail2.position);
            _valueTypes.Vec3.normalize(_temp_trailEle.velocity, _temp_trailEle.velocity);
            this._checkDirectionReverse(_temp_trailEle, _lastSecondTrail2);
          }
          this.widthFromParticle ? _temp_trailEle.width = p.size.x * this.widthRatio.evaluate(0, 1) : _temp_trailEle.width = this.widthRatio.evaluate(0, 1);
          _temp_trailEle.color = p.color;
          _valueTypes.Vec3.equals(_temp_trailEle.velocity, cc.Vec3.ZERO) ? this.ibOffset -= 3 : this._fillVertexBuffer(_temp_trailEle, this.colorOverTrail.evaluate(0, 1), indexOffset, 0, trailNum, PRE_TRIANGLE_INDEX);
        }
        this._updateIA(this.ibOffset);
      };
      _proto2._fillVertexBuffer = function _fillVertexBuffer(trailSeg, colorModifer, indexOffset, xTexCoord, trailEleIdx, indexSet) {
        this._vbF32[this.vbOffset++] = trailSeg.position.x;
        this._vbF32[this.vbOffset++] = trailSeg.position.y;
        this._vbF32[this.vbOffset++] = trailSeg.position.z;
        this._vbF32[this.vbOffset++] = 0;
        this._vbF32[this.vbOffset++] = trailSeg.width;
        this._vbF32[this.vbOffset++] = xTexCoord;
        this._vbF32[this.vbOffset++] = 0;
        this._vbF32[this.vbOffset++] = trailSeg.velocity.x;
        this._vbF32[this.vbOffset++] = trailSeg.velocity.y;
        this._vbF32[this.vbOffset++] = trailSeg.velocity.z;
        _temp_color.set(trailSeg.color);
        _temp_color.multiply(colorModifer);
        this._vbUint32[this.vbOffset++] = _temp_color._val;
        this._vbF32[this.vbOffset++] = trailSeg.position.x;
        this._vbF32[this.vbOffset++] = trailSeg.position.y;
        this._vbF32[this.vbOffset++] = trailSeg.position.z;
        this._vbF32[this.vbOffset++] = 1;
        this._vbF32[this.vbOffset++] = trailSeg.width;
        this._vbF32[this.vbOffset++] = xTexCoord;
        this._vbF32[this.vbOffset++] = 1;
        this._vbF32[this.vbOffset++] = trailSeg.velocity.x;
        this._vbF32[this.vbOffset++] = trailSeg.velocity.y;
        this._vbF32[this.vbOffset++] = trailSeg.velocity.z;
        this._vbUint32[this.vbOffset++] = _temp_color._val;
        if (indexSet & PRE_TRIANGLE_INDEX) {
          this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx;
          this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx - 1;
          this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1;
        }
        if (indexSet & NEXT_TRIANGLE_INDEX) {
          this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx;
          this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 1;
          this._iBuffer[this.ibOffset++] = indexOffset + 2 * trailEleIdx + 2;
        }
      };
      _proto2._updateIA = function _updateIA(count) {
        this._particleSystem && this._particleSystem._assembler && this._particleSystem._assembler.updateIA(1, count, true, true);
      };
      _proto2._checkDirectionReverse = function _checkDirectionReverse(currElement, prevElement) {
        _valueTypes.Vec3.dot(currElement.velocity, prevElement.velocity) < DIRECTION_THRESHOLD ? currElement.direction = 1 - prevElement.direction : currElement.direction = prevElement.direction;
      };
      _createClass(TrailModule, [ {
        key: "enable",
        get: function get() {
          return this._enable;
        },
        set: function set(val) {
          val && this._createTrailData();
          if (val && !this._enable) {
            this._enable = val;
            this._particleSystem._assembler._updateTrailMaterial();
          }
          this._enable = val;
          this._particleSystem._assembler._updateTrailEnable(this._enable);
        }
      }, {
        key: "minParticleDistance",
        get: function get() {
          return this._minParticleDistance;
        },
        set: function set(val) {
          this._minParticleDistance = val;
          this._minSquaredDistance = val * val;
        }
      }, {
        key: "space",
        get: function get() {
          return this._space;
        },
        set: function set(val) {
          this._space = val;
          this._particleSystem && this._particleSystem._assembler._updateTrailMaterial();
        }
      } ]);
      return TrailModule;
    })(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_enable", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "enable", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "enable"), _class2.prototype), 
    _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "mode", [ _dec2 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _enum.TrailMode.Particles;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "lifeTime", [ _dec3 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_minParticleDistance", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return .1;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "minParticleDistance", [ _CCClassDecorator.property ], Object.getOwnPropertyDescriptor(_class2.prototype, "minParticleDistance"), _class2.prototype), 
    _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_space", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _enum.Space.World;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "space", [ _dec4 ], Object.getOwnPropertyDescriptor(_class2.prototype, "space"), _class2.prototype), 
    _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "existWithParticles", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return true;
      }
    }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "textureMode", [ _dec5 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return _enum.TextureMode.Stretch;
      }
    }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "widthFromParticle", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return true;
      }
    }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "widthRatio", [ _dec6 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _curveRange["default"]();
      }
    }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "colorFromParticle", [ _CCClassDecorator.property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "colorOverTrail", [ _dec7 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _gradientRange["default"]();
      }
    }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "colorOvertime", [ _dec8 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new _gradientRange["default"]();
      }
    }), _class2)) || _class);
    exports["default"] = TrailModule;
    module.exports = exports["default"];
  }), {
    "../../../../renderer/gfx": 427,
    "../../../../renderer/memop/pool": 428,
    "../../../platform/CCClassDecorator": 273,
    "../../../value-types": 401,
    "../animator/curve-range": 32,
    "../animator/gradient-range": 34,
    "../enum": 44,
    "../utils": 51
  } ],
  51: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    Object.is || (Object.is = function(x, y) {
      return x === y ? 0 !== x || 1 / x === 1 / y : x !== x && y !== y;
    });
    var MapUtils = (function() {
      function MapUtils(data) {
        this.datas = [];
        !data && (data = []);
        this.datas = [];
        var that = this;
        data.forEach((function(item) {
          that.has(item[0]) || that.datas.push({
            key: item[0],
            value: item[1]
          });
        }));
      }
      var _proto = MapUtils.prototype;
      _proto.size = function size() {
        return this.datas.length;
      };
      _proto.set = function set(key, value) {
        this["delete"](key);
        this.datas.push({
          key: key,
          value: value
        });
      };
      _proto.get = function get(key) {
        var value = void 0;
        var datas = this.datas;
        for (var i = 0, len = datas.length; i < len; i++) if (Object.is(key, datas[i].key)) {
          value = datas[i].value;
          break;
        }
        return value;
      };
      _proto.has = function has(key) {
        var res = false;
        var datas = this.datas;
        for (var i = 0, len = datas.length; i < len; i++) if (Object.is(key, datas[i].key)) {
          res = true;
          break;
        }
        return res;
      };
      _proto.clear = function clear() {
        this.datas.length = 0;
      };
      _proto["delete"] = function _delete(key) {
        var res = false;
        var datas = this.datas;
        for (var i = 0, len = datas.length; i < len; i++) if (Object.is(key, datas[i].key)) {
          datas.splice(i, 1);
          res = true;
          break;
        }
        return res;
      };
      _proto.keys = function keys() {
        var datas = this.datas;
        var keys = [];
        for (var i = 0, len = datas.length; i < len; i++) keys.push(datas[i].key);
        return keys;
      };
      _proto.values = function values() {
        var index = 0;
        var datas = this.datas;
        return {
          next: function next() {
            if (0 === datas.length || void 0 === datas[index]) return {
              value: void 0,
              done: true
            };
            return {
              value: datas[index++].value,
              done: false
            };
          }
        };
      };
      return MapUtils;
    })();
    exports["default"] = MapUtils;
    module.exports = exports["default"];
  }), {} ],
  52: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.CannonRigidBody = void 0;
    var _cannon = _interopRequireDefault(require("../../../../../external/cannon/cannon"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var v3_cannon0 = new _cannon["default"].Vec3();
    var v3_cannon1 = new _cannon["default"].Vec3();
    var Vec3 = cc.Vec3;
    var CannonRigidBody = (function() {
      function CannonRigidBody() {
        this._rigidBody = void 0;
        this._sharedBody = void 0;
        this._isEnabled = false;
      }
      var _proto = CannonRigidBody.prototype;
      _proto.__preload = function __preload(com) {
        this._rigidBody = com;
        this._sharedBody = cc.director.getPhysics3DManager().physicsWorld.getSharedBody(this._rigidBody.node);
        this._sharedBody.reference = true;
        this._sharedBody.wrappedBody = this;
      };
      _proto.onLoad = function onLoad() {};
      _proto.onEnable = function onEnable() {
        this._isEnabled = true;
        this.mass = this._rigidBody.mass;
        this.allowSleep = this._rigidBody.allowSleep;
        this.linearDamping = this._rigidBody.linearDamping;
        this.angularDamping = this._rigidBody.angularDamping;
        this.useGravity = this._rigidBody.useGravity;
        this.isKinematic = this._rigidBody.isKinematic;
        this.fixedRotation = this._rigidBody.fixedRotation;
        this.linearFactor = this._rigidBody.linearFactor;
        this.angularFactor = this._rigidBody.angularFactor;
        this._sharedBody.enabled = true;
      };
      _proto.onDisable = function onDisable() {
        this._isEnabled = false;
        this._sharedBody.enabled = false;
      };
      _proto.onDestroy = function onDestroy() {
        this._sharedBody.reference = false;
        this._rigidBody = null;
        this._sharedBody = null;
      };
      _proto.wakeUp = function wakeUp() {
        return this._sharedBody.body.wakeUp();
      };
      _proto.sleep = function sleep() {
        return this._sharedBody.body.sleep();
      };
      _proto.getLinearVelocity = function getLinearVelocity(out) {
        Vec3.copy(out, this._sharedBody.body.velocity);
        return out;
      };
      _proto.setLinearVelocity = function setLinearVelocity(value) {
        var body = this._sharedBody.body;
        body.isSleeping() && body.wakeUp();
        Vec3.copy(body.velocity, value);
      };
      _proto.getAngularVelocity = function getAngularVelocity(out) {
        Vec3.copy(out, this._sharedBody.body.angularVelocity);
        return out;
      };
      _proto.setAngularVelocity = function setAngularVelocity(value) {
        var body = this._sharedBody.body;
        body.isSleeping() && body.wakeUp();
        Vec3.copy(body.angularVelocity, value);
      };
      _proto.applyForce = function applyForce(force, worldPoint) {
        null == worldPoint && (worldPoint = Vec3.ZERO);
        var body = this._sharedBody.body;
        body.isSleeping() && body.wakeUp();
        body.applyForce(Vec3.copy(v3_cannon0, force), Vec3.copy(v3_cannon1, worldPoint));
      };
      _proto.applyImpulse = function applyImpulse(impulse, worldPoint) {
        null == worldPoint && (worldPoint = Vec3.ZERO);
        var body = this._sharedBody.body;
        body.isSleeping() && body.wakeUp();
        body.applyImpulse(Vec3.copy(v3_cannon0, impulse), Vec3.copy(v3_cannon1, worldPoint));
      };
      _proto.applyLocalForce = function applyLocalForce(force, localPoint) {
        null == localPoint && (localPoint = Vec3.ZERO);
        var body = this._sharedBody.body;
        body.isSleeping() && body.wakeUp();
        body.applyLocalForce(Vec3.copy(v3_cannon0, force), Vec3.copy(v3_cannon1, localPoint));
      };
      _proto.applyLocalImpulse = function applyLocalImpulse(impulse, localPoint) {
        null == localPoint && (localPoint = Vec3.ZERO);
        var body = this._sharedBody.body;
        body.isSleeping() && body.wakeUp();
        body.applyLocalImpulse(Vec3.copy(v3_cannon0, impulse), Vec3.copy(v3_cannon1, localPoint));
      };
      _proto.applyTorque = function applyTorque(torque) {
        var body = this._sharedBody.body;
        body.isSleeping() && body.wakeUp();
        body.torque.x += torque.x;
        body.torque.y += torque.y;
        body.torque.z += torque.z;
      };
      _proto.applyLocalTorque = function applyLocalTorque(torque) {
        var body = this._sharedBody.body;
        body.isSleeping() && body.wakeUp();
        Vec3.copy(v3_cannon0, torque);
        body.vectorToWorldFrame(v3_cannon0, v3_cannon0);
        body.torque.x += v3_cannon0.x;
        body.torque.y += v3_cannon0.y;
        body.torque.z += v3_cannon0.z;
      };
      _createClass(CannonRigidBody, [ {
        key: "isAwake",
        get: function get() {
          return this._sharedBody.body.isAwake();
        }
      }, {
        key: "isSleepy",
        get: function get() {
          return this._sharedBody.body.isSleepy();
        }
      }, {
        key: "isSleeping",
        get: function get() {
          return this._sharedBody.body.isSleeping();
        }
      }, {
        key: "allowSleep",
        set: function set(v) {
          var body = this._sharedBody.body;
          body.isSleeping() && body.wakeUp();
          body.allowSleep = v;
        }
      }, {
        key: "mass",
        set: function set(value) {
          var body = this._sharedBody.body;
          body.mass = value;
          0 == body.mass ? body.type = _cannon["default"].Body.STATIC : body.type = this._rigidBody.isKinematic ? _cannon["default"].Body.KINEMATIC : _cannon["default"].Body.DYNAMIC;
          body.updateMassProperties();
          body.isSleeping() && body.wakeUp();
        }
      }, {
        key: "isKinematic",
        set: function set(value) {
          var body = this._sharedBody.body;
          0 == body.mass ? body.type = _cannon["default"].Body.STATIC : body.type = value ? _cannon["default"].Body.KINEMATIC : _cannon["default"].Body.DYNAMIC;
        }
      }, {
        key: "fixedRotation",
        set: function set(value) {
          var body = this._sharedBody.body;
          body.isSleeping() && body.wakeUp();
          body.fixedRotation = value;
          body.updateMassProperties();
        }
      }, {
        key: "linearDamping",
        set: function set(value) {
          this._sharedBody.body.linearDamping = value;
        }
      }, {
        key: "angularDamping",
        set: function set(value) {
          this._sharedBody.body.angularDamping = value;
        }
      }, {
        key: "useGravity",
        set: function set(value) {
          var body = this._sharedBody.body;
          body.isSleeping() && body.wakeUp();
          body.useGravity = value;
        }
      }, {
        key: "linearFactor",
        set: function set(value) {
          var body = this._sharedBody.body;
          body.isSleeping() && body.wakeUp();
          Vec3.copy(body.linearFactor, value);
        }
      }, {
        key: "angularFactor",
        set: function set(value) {
          var body = this._sharedBody.body;
          body.isSleeping() && body.wakeUp();
          Vec3.copy(body.angularFactor, value);
        }
      }, {
        key: "rigidBody",
        get: function get() {
          return this._rigidBody;
        }
      }, {
        key: "sharedBody",
        get: function get() {
          return this._sharedBody;
        }
      }, {
        key: "isEnabled",
        get: function get() {
          return this._isEnabled;
        }
      } ]);
      return CannonRigidBody;
    })();
    exports.CannonRigidBody = CannonRigidBody;
  }), {
    "../../../../../external/cannon/cannon": 463
  } ],
  53: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.CannonSharedBody = void 0;
    var _cannon = _interopRequireDefault(require("../../../../../external/cannon/cannon"));
    var _physicsEnum = require("../framework/physics-enum");
    var _util = require("../framework/util");
    var _cannonUtil = require("./cannon-util");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var LocalDirtyFlag = cc.Node._LocalDirtyFlag;
    var PHYSICS_SCALE = LocalDirtyFlag.PHYSICS_SCALE;
    var Quat = cc.Quat;
    var Vec3 = cc.Vec3;
    var fastRemoveAt = cc.js.array.fastRemoveAt;
    var v3_0 = new Vec3();
    var quat_0 = new Quat();
    var contactsPool = [];
    var CollisionEventObject = {
      type: "collision-enter",
      selfCollider: null,
      otherCollider: null,
      contacts: []
    };
    var CannonSharedBody = (function() {
      CannonSharedBody.getSharedBody = function getSharedBody(node, wrappedWorld) {
        var key = node._id;
        if (CannonSharedBody.sharedBodiesMap.has(key)) return CannonSharedBody.sharedBodiesMap.get(key);
        var newSB = new CannonSharedBody(node, wrappedWorld);
        CannonSharedBody.sharedBodiesMap.set(node._id, newSB);
        return newSB;
      };
      function CannonSharedBody(node, wrappedWorld) {
        this.node = void 0;
        this.wrappedWorld = void 0;
        this.body = new _cannon["default"].Body();
        this.shapes = [];
        this.wrappedBody = null;
        this.index = -1;
        this.ref = 0;
        this.onCollidedListener = this.onCollided.bind(this);
        this.wrappedWorld = wrappedWorld;
        this.node = node;
        this.body.material = this.wrappedWorld.world.defaultMaterial;
        this.body.addEventListener("cc-collide", this.onCollidedListener);
        this._updateGroup();
        this.node.on(cc.Node.EventType.GROUP_CHANGED, this._updateGroup, this);
      }
      var _proto = CannonSharedBody.prototype;
      _proto._updateGroup = function _updateGroup() {
        (0, _cannonUtil.groupIndexToBitMask)(this.node.groupIndex, this.body);
      };
      _proto.addShape = function addShape(v) {
        var index = this.shapes.indexOf(v);
        if (index < 0) {
          var _index = this.body.shapes.length;
          this.body.addShape(v.shape);
          this.shapes.push(v);
          v.setIndex(_index);
          var offset = this.body.shapeOffsets[_index];
          var orient = this.body.shapeOrientations[_index];
          v.setOffsetAndOrient(offset, orient);
        }
      };
      _proto.removeShape = function removeShape(v) {
        var index = this.shapes.indexOf(v);
        if (index >= 0) {
          fastRemoveAt(this.shapes, index);
          this.body.removeShape(v.shape);
          v.setIndex(-1);
        }
      };
      _proto.syncSceneToPhysics = function syncSceneToPhysics(force) {
        void 0 === force && (force = false);
        var node = this.node;
        var needUpdateTransform = (0, _util.worldDirty)(node);
        if (!force && !needUpdateTransform) return;
        this.body.aabbNeedsUpdate = true;
        node.getWorldPosition(v3_0);
        node.getWorldRotation(quat_0);
        Vec3.copy(this.body.position, v3_0);
        Quat.copy(this.body.quaternion, quat_0);
        if (node._localMatDirty & PHYSICS_SCALE) {
          var wscale = node.__wscale;
          for (var i = 0; i < this.shapes.length; i++) this.shapes[i].setScale(wscale);
          (0, _cannonUtil.commitShapeUpdates)(this.body);
        }
        this.body.isSleeping() && this.body.wakeUp();
      };
      _proto.syncPhysicsToScene = function syncPhysicsToScene() {
        if (this.body.type != _physicsEnum.ERigidBodyType.STATIC && !this.body.isSleeping()) {
          Vec3.copy(v3_0, this.body.position);
          Quat.copy(quat_0, this.body.quaternion);
          this.node.setWorldPosition(v3_0);
          this.node.setWorldRotation(quat_0);
        }
      };
      _proto.destroy = function destroy() {
        this.body.removeEventListener("cc-collide", this.onCollidedListener);
        this.node.off(cc.Node.EventType.GROUP_CHANGED, this._updateGroup, this);
        CannonSharedBody.sharedBodiesMap["delete"](this.node._id);
        delete _cannon["default"].World["idToBodyMap"][this.body.id];
        this.node = null;
        this.wrappedWorld = null;
        this.body = null;
        this.shapes = null;
        this.onCollidedListener = null;
      };
      _proto.onCollided = function onCollided(event) {
        CollisionEventObject.type = event.event;
        var self = (0, _util.getWrap)(event.selfShape);
        var other = (0, _util.getWrap)(event.otherShape);
        if (self) {
          CollisionEventObject.selfCollider = self.collider;
          CollisionEventObject.otherCollider = other ? other.collider : null;
          var i = 0;
          for (i = CollisionEventObject.contacts.length; i--; ) contactsPool.push(CollisionEventObject.contacts.pop());
          for (i = 0; i < event.contacts.length; i++) {
            var cq = event.contacts[i];
            if (contactsPool.length > 0) {
              var c = contactsPool.pop();
              Vec3.copy(c.contactA, cq.ri);
              Vec3.copy(c.contactB, cq.rj);
              Vec3.copy(c.normal, cq.ni);
              CollisionEventObject.contacts.push(c);
            } else {
              var _c = {
                contactA: Vec3.copy(new Vec3(), cq.ri),
                contactB: Vec3.copy(new Vec3(), cq.rj),
                normal: Vec3.copy(new Vec3(), cq.ni)
              };
              CollisionEventObject.contacts.push(_c);
            }
          }
          for (i = 0; i < this.shapes.length; i++) {
            var shape = this.shapes[i];
            CollisionEventObject.type = _cannonUtil.deprecatedEventMap[CollisionEventObject.type];
            shape.collider.emit(CollisionEventObject.type, CollisionEventObject);
            CollisionEventObject.type = event.event;
            shape.collider.emit(CollisionEventObject.type, CollisionEventObject);
          }
        }
      };
      _createClass(CannonSharedBody, [ {
        key: "enabled",
        set: function set(v) {
          if (v) {
            if (this.index < 0) {
              this.index = this.wrappedWorld.bodies.length;
              this.wrappedWorld.addSharedBody(this);
              var node = this.node;
              this.body.aabbNeedsUpdate = true;
              node.getWorldPosition(v3_0);
              node.getWorldRotation(quat_0);
              var pos = this.body.position;
              pos.x = parseFloat(v3_0.x.toFixed(3));
              pos.y = parseFloat(v3_0.y.toFixed(3));
              pos.z = parseFloat(v3_0.z.toFixed(3));
              var rot = this.body.quaternion;
              rot.x = parseFloat(quat_0.x.toFixed(12));
              rot.y = parseFloat(quat_0.y.toFixed(12));
              rot.z = parseFloat(quat_0.z.toFixed(12));
              rot.w = parseFloat(quat_0.w.toFixed(12));
              if (node._localMatDirty & PHYSICS_SCALE) {
                var wscale = node.__wscale;
                for (var i = 0; i < this.shapes.length; i++) this.shapes[i].setScale(wscale);
                (0, _cannonUtil.commitShapeUpdates)(this.body);
              }
              this.body.isSleeping() && this.body.wakeUp();
            }
          } else if (this.index >= 0) {
            var isRemove = 0 == this.shapes.length && null == this.wrappedBody || 0 == this.shapes.length && null != this.wrappedBody && !this.wrappedBody.rigidBody.enabledInHierarchy || 0 == this.shapes.length && null != this.wrappedBody && !this.wrappedBody.isEnabled;
            if (isRemove) {
              this.body.sleep();
              this.index = -1;
              this.wrappedWorld.removeSharedBody(this);
            }
          }
        }
      }, {
        key: "reference",
        set: function set(v) {
          v ? this.ref++ : this.ref--;
          0 == this.ref && this.destroy();
        }
      } ]);
      return CannonSharedBody;
    })();
    exports.CannonSharedBody = CannonSharedBody;
    CannonSharedBody.sharedBodiesMap = new Map();
  }), {
    "../../../../../external/cannon/cannon": 463,
    "../framework/physics-enum": 78,
    "../framework/util": 82,
    "./cannon-util": 54
  } ],
  54: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.commitShapeUpdates = commitShapeUpdates;
    exports.deprecatedEventMap = void 0;
    exports.fillRaycastResult = fillRaycastResult;
    exports.groupIndexToBitMask = groupIndexToBitMask;
    exports.toCannonRaycastOptions = toCannonRaycastOptions;
    var _util = require("../framework/util");
    var Vec3 = cc.Vec3;
    function groupIndexToBitMask(groupIndex, out) {
      var categoryBits = 1 << groupIndex;
      var maskBits = 0;
      var bits = cc.game.collisionMatrix[groupIndex];
      if (!bits) {
        cc.error("cannon-utils: group is not exist", groupIndex);
        return;
      }
      for (var i = 0; i < bits.length; i++) {
        if (!bits[i]) continue;
        maskBits |= 1 << i;
      }
      out.collisionFilterGroup = categoryBits;
      out.collisionFilterMask = maskBits;
    }
    function toCannonRaycastOptions(out, options) {
      out.checkCollisionResponse = !options.queryTrigger;
      groupIndexToBitMask(options.groupIndex, out);
      out.skipBackFaces = false;
    }
    function fillRaycastResult(result, cannonResult) {
      result._assign(Vec3.copy(new Vec3(), cannonResult.hitPointWorld), cannonResult.distance, (0, 
      _util.getWrap)(cannonResult.shape).collider);
    }
    function commitShapeUpdates(body) {
      body.aabbNeedsUpdate = true;
      body.updateMassProperties();
      body.updateBoundingRadius();
    }
    var deprecatedEventMap = {
      onCollisionEnter: "collision-enter",
      onCollisionStay: "collision-stay",
      onCollisionExit: "collision-exit",
      onTriggerEnter: "trigger-enter",
      onTriggerStay: "trigger-stay",
      onTriggerExit: "trigger-exit"
    };
    exports.deprecatedEventMap = deprecatedEventMap;
  }), {
    "../framework/util": 82
  } ],
  55: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.CannonWorld = void 0;
    var _cannon = _interopRequireDefault(require("../../../../../external/cannon/cannon"));
    var _cannonUtil = require("./cannon-util");
    var _cannonShape = require("./shapes/cannon-shape");
    var _cannonSharedBody = require("./cannon-shared-body");
    var _util = require("../framework/util");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var Vec3 = cc.Vec3;
    var fastRemoveAt = cc.js.array.fastRemoveAt;
    var CannonWorld = (function() {
      function CannonWorld() {
        this.bodies = [];
        this._world = void 0;
        this._raycastResult = new _cannon["default"].RaycastResult();
        this._world = new _cannon["default"].World();
        this._world.broadphase = new _cannon["default"].NaiveBroadphase();
        this._world.addEventListener("postStep", this.onPostStep.bind(this));
      }
      var _proto = CannonWorld.prototype;
      _proto.onPostStep = function onPostStep() {
        var p3dm = cc.director.getPhysics3DManager();
        if (p3dm.useFixedDigit) {
          var pd = p3dm.fixDigits.position;
          var rd = p3dm.fixDigits.rotation;
          var bodies = this._world.bodies;
          for (var i = 0; i < bodies.length; i++) {
            var bi = bodies[i];
            if (bi.type != _cannon["default"].Body.STATIC && !bi.isSleeping()) {
              var pos = bi.position;
              pos.x = parseFloat(pos.x.toFixed(pd));
              pos.y = parseFloat(pos.y.toFixed(pd));
              pos.z = parseFloat(pos.z.toFixed(pd));
              var rot = bi.quaternion;
              rot.x = parseFloat(rot.x.toFixed(rd));
              rot.y = parseFloat(rot.y.toFixed(rd));
              rot.z = parseFloat(rot.z.toFixed(rd));
              rot.w = parseFloat(rot.w.toFixed(rd));
              var vel = bi.velocity;
              vel.x = parseFloat(vel.x.toFixed(pd));
              vel.y = parseFloat(vel.y.toFixed(pd));
              vel.z = parseFloat(vel.z.toFixed(pd));
              var avel = bi.angularVelocity;
              avel.x = parseFloat(avel.x.toFixed(pd));
              avel.y = parseFloat(avel.y.toFixed(pd));
              avel.z = parseFloat(avel.z.toFixed(pd));
            }
          }
        }
      };
      _proto.step = function step(deltaTime, timeSinceLastCalled, maxSubStep) {
        this.syncSceneToPhysics();
        this._world.step(deltaTime, timeSinceLastCalled, maxSubStep);
        this.syncPhysicsToScene();
        this.emitEvents();
      };
      _proto.syncSceneToPhysics = function syncSceneToPhysics() {
        (0, _util.clearNodeTransformRecord)();
        for (var i = 0; i < this.bodies.length; i++) this.bodies[i].syncSceneToPhysics();
        (0, _util.clearNodeTransformDirtyFlag)();
      };
      _proto.syncPhysicsToScene = function syncPhysicsToScene() {
        for (var i = 0; i < this.bodies.length; i++) this.bodies[i].syncPhysicsToScene();
      };
      _proto.emitEvents = function emitEvents() {
        this._world.emitTriggeredEvents();
        this._world.emitCollisionEvents();
      };
      _proto.raycastClosest = function raycastClosest(worldRay, options, result) {
        setupFromAndTo(worldRay, options.maxDistance);
        (0, _cannonUtil.toCannonRaycastOptions)(raycastOpt, options);
        var hit = this._world.raycastClosest(from, to, raycastOpt, this._raycastResult);
        hit && (0, _cannonUtil.fillRaycastResult)(result, this._raycastResult);
        return hit;
      };
      _proto.raycast = function raycast(worldRay, options, pool, results) {
        setupFromAndTo(worldRay, options.maxDistance);
        (0, _cannonUtil.toCannonRaycastOptions)(raycastOpt, options);
        var hit = this._world.raycastAll(from, to, raycastOpt, (function(result) {
          var r = pool.add();
          (0, _cannonUtil.fillRaycastResult)(r, result);
          results.push(r);
        }));
        return hit;
      };
      _proto.getSharedBody = function getSharedBody(node) {
        return _cannonSharedBody.CannonSharedBody.getSharedBody(node, this);
      };
      _proto.addSharedBody = function addSharedBody(sharedBody) {
        var i = this.bodies.indexOf(sharedBody);
        if (i < 0) {
          this.bodies.push(sharedBody);
          this._world.addBody(sharedBody.body);
        }
      };
      _proto.removeSharedBody = function removeSharedBody(sharedBody) {
        var i = this.bodies.indexOf(sharedBody);
        if (i >= 0) {
          fastRemoveAt(this.bodies, i);
          this._world.remove(sharedBody.body);
        }
      };
      _createClass(CannonWorld, [ {
        key: "world",
        get: function get() {
          return this._world;
        }
      }, {
        key: "defaultMaterial",
        set: function set(mat) {
          this._world.defaultMaterial.friction = mat.friction;
          this._world.defaultMaterial.restitution = mat.restitution;
          null != _cannonShape.CannonShape.idToMaterial[mat._uuid] && (_cannonShape.CannonShape.idToMaterial[mat._uuid] = this._world.defaultMaterial);
        }
      }, {
        key: "allowSleep",
        set: function set(v) {
          this._world.allowSleep = v;
        }
      }, {
        key: "gravity",
        set: function set(gravity) {
          Vec3.copy(this._world.gravity, gravity);
        }
      } ]);
      return CannonWorld;
    })();
    exports.CannonWorld = CannonWorld;
    var from = new _cannon["default"].Vec3();
    var to = new _cannon["default"].Vec3();
    function setupFromAndTo(worldRay, distance) {
      Vec3.copy(from, worldRay.o);
      worldRay.computeHit(to, distance);
    }
    var raycastOpt = {
      checkCollisionResponse: false,
      collisionFilterGroup: -1,
      collisionFilterMask: -1,
      skipBackFaces: false
    };
  }), {
    "../../../../../external/cannon/cannon": 463,
    "../framework/util": 82,
    "./cannon-shared-body": 53,
    "./cannon-util": 54,
    "./shapes/cannon-shape": 58
  } ],
  56: [ (function(require, module, exports) {
    "use strict";
    var _physicsSelector = require("../framework/physics-selector");
    var _cannonRigidBody = require("./cannon-rigid-body");
    var _cannonWorld = require("./cannon-world");
    var _cannonBoxShape = require("./shapes/cannon-box-shape");
    var _cannonSphereShape = require("./shapes/cannon-sphere-shape");
    true;
    (0, _physicsSelector.instantiate)(_cannonBoxShape.CannonBoxShape, _cannonSphereShape.CannonSphereShape, _cannonRigidBody.CannonRigidBody, _cannonWorld.CannonWorld);
  }), {
    "../framework/physics-selector": 81,
    "./cannon-rigid-body": 52,
    "./cannon-world": 55,
    "./shapes/cannon-box-shape": 57,
    "./shapes/cannon-sphere-shape": 59
  } ],
  57: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.CannonBoxShape = void 0;
    var _cannon = _interopRequireDefault(require("../../../../../../external/cannon/cannon"));
    var _cannonUtil = require("../cannon-util");
    var _cannonShape = require("./cannon-shape");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Vec3 = cc.Vec3;
    var v3_0 = new Vec3();
    var CannonBoxShape = (function(_CannonShape) {
      _inheritsLoose(CannonBoxShape, _CannonShape);
      function CannonBoxShape(size) {
        var _this;
        _this = _CannonShape.call(this) || this;
        _this.halfExtent = new _cannon["default"].Vec3();
        Vec3.multiplyScalar(_this.halfExtent, size, .5);
        _this._shape = new _cannon["default"].Box(_this.halfExtent.clone());
        return _this;
      }
      var _proto = CannonBoxShape.prototype;
      _proto.onLoad = function onLoad() {
        _CannonShape.prototype.onLoad.call(this);
        this.size = this.boxCollider.size;
      };
      _proto.setScale = function setScale(scale) {
        _CannonShape.prototype.setScale.call(this, scale);
        this.size = this.boxCollider.size;
      };
      _createClass(CannonBoxShape, [ {
        key: "boxCollider",
        get: function get() {
          return this.collider;
        }
      }, {
        key: "box",
        get: function get() {
          return this._shape;
        }
      }, {
        key: "size",
        set: function set(v) {
          this.collider.node.getWorldScale(v3_0);
          v3_0.x = Math.abs(v3_0.x);
          v3_0.y = Math.abs(v3_0.y);
          v3_0.z = Math.abs(v3_0.z);
          Vec3.multiplyScalar(this.halfExtent, v, .5);
          Vec3.multiply(this.box.halfExtents, this.halfExtent, v3_0);
          this.box.updateConvexPolyhedronRepresentation();
          -1 != this._index && (0, _cannonUtil.commitShapeUpdates)(this._body);
        }
      } ]);
      return CannonBoxShape;
    })(_cannonShape.CannonShape);
    exports.CannonBoxShape = CannonBoxShape;
  }), {
    "../../../../../../external/cannon/cannon": 463,
    "../cannon-util": 54,
    "./cannon-shape": 58
  } ],
  58: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.CannonShape = void 0;
    var _cannon = _interopRequireDefault(require("../../../../../../external/cannon/cannon"));
    var _util = require("../../framework/util");
    var _cannonUtil = require("../cannon-util");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var TriggerEventObject = {
      type: "trigger-enter",
      selfCollider: null,
      otherCollider: null
    };
    var Vec3 = cc.Vec3;
    var v3_0 = new Vec3();
    var CannonShape = (function() {
      function CannonShape() {
        this._collider = void 0;
        this._shape = void 0;
        this._offset = new _cannon["default"].Vec3();
        this._orient = new _cannon["default"].Quaternion();
        this._index = -1;
        this._sharedBody = void 0;
        this.onTriggerListener = this.onTrigger.bind(this);
      }
      var _proto = CannonShape.prototype;
      _proto.__preload = function __preload(comp) {
        this._collider = comp;
        (0, _util.setWrap)(this._shape, this);
        this._shape.addEventListener("cc-trigger", this.onTriggerListener);
        this._sharedBody = cc.director.getPhysics3DManager().physicsWorld.getSharedBody(this._collider.node);
        this._sharedBody.reference = true;
      };
      _proto.onLoad = function onLoad() {
        this.center = this._collider.center;
        this.isTrigger = this._collider.isTrigger;
      };
      _proto.onEnable = function onEnable() {
        this._sharedBody.addShape(this);
        this._sharedBody.enabled = true;
      };
      _proto.onDisable = function onDisable() {
        this._sharedBody.removeShape(this);
        this._sharedBody.enabled = false;
      };
      _proto.onDestroy = function onDestroy() {
        this._sharedBody.reference = false;
        this._shape.removeEventListener("cc-trigger", this.onTriggerListener);
        delete _cannon["default"].World["idToShapeMap"][this._shape.id];
        this._sharedBody = null;
        (0, _util.setWrap)(this._shape, null);
        this._offset = null;
        this._orient = null;
        this._shape = null;
        this._collider = null;
        this.onTriggerListener = null;
      };
      _proto.setScale = function setScale(scale) {
        this._setCenter(this._collider.center);
      };
      _proto.setIndex = function setIndex(index) {
        this._index = index;
      };
      _proto.setOffsetAndOrient = function setOffsetAndOrient(offset, orient) {
        cc.Vec3.copy(offset, this._offset);
        cc.Vec3.copy(orient, this._orient);
        this._offset = offset;
        this._orient = orient;
      };
      _proto._setCenter = function _setCenter(v) {
        var lpos = this._offset;
        Vec3.copy(lpos, v);
        this._collider.node.getWorldScale(v3_0);
        Vec3.multiply(lpos, lpos, v3_0);
      };
      _proto.onTrigger = function onTrigger(event) {
        TriggerEventObject.type = event.event;
        var self = (0, _util.getWrap)(event.selfShape);
        var other = (0, _util.getWrap)(event.otherShape);
        if (self) {
          TriggerEventObject.selfCollider = self.collider;
          TriggerEventObject.otherCollider = other ? other.collider : null;
          TriggerEventObject.type = _cannonUtil.deprecatedEventMap[TriggerEventObject.type];
          this._collider.emit(TriggerEventObject.type, TriggerEventObject);
          TriggerEventObject.type = event.event;
          this._collider.emit(TriggerEventObject.type, TriggerEventObject);
        }
      };
      _createClass(CannonShape, [ {
        key: "shape",
        get: function get() {
          return this._shape;
        }
      }, {
        key: "collider",
        get: function get() {
          return this._collider;
        }
      }, {
        key: "attachedRigidBody",
        get: function get() {
          if (this._sharedBody.wrappedBody) return this._sharedBody.wrappedBody.rigidBody;
          return null;
        }
      }, {
        key: "sharedBody",
        get: function get() {
          return this._sharedBody;
        }
      }, {
        key: "material",
        set: function set(mat) {
          if (null == mat) this._shape.material = null; else {
            null == CannonShape.idToMaterial[mat._uuid] && (CannonShape.idToMaterial[mat._uuid] = new _cannon["default"].Material(mat._uuid));
            this._shape.material = CannonShape.idToMaterial[mat._uuid];
            this._shape.material.friction = mat.friction;
            this._shape.material.restitution = mat.restitution;
          }
        }
      }, {
        key: "isTrigger",
        set: function set(v) {
          this._shape.collisionResponse = !v;
          this._index >= 0 && this._body.updateHasTrigger();
        }
      }, {
        key: "center",
        set: function set(v) {
          this._setCenter(v);
          this._index >= 0 && (0, _cannonUtil.commitShapeUpdates)(this._body);
        }
      }, {
        key: "_body",
        get: function get() {
          return this._sharedBody.body;
        }
      } ]);
      return CannonShape;
    })();
    exports.CannonShape = CannonShape;
    CannonShape.idToMaterial = {};
  }), {
    "../../../../../../external/cannon/cannon": 463,
    "../../framework/util": 82,
    "../cannon-util": 54
  } ],
  59: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.CannonSphereShape = void 0;
    var _cannon = _interopRequireDefault(require("../../../../../../external/cannon/cannon"));
    var _cannonUtil = require("../cannon-util");
    var _cannonShape = require("./cannon-shape");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var v3_0 = new cc.Vec3();
    var CannonSphereShape = (function(_CannonShape) {
      _inheritsLoose(CannonSphereShape, _CannonShape);
      function CannonSphereShape(radius) {
        var _this;
        _this = _CannonShape.call(this) || this;
        _this._radius = void 0;
        _this._radius = radius;
        _this._shape = new _cannon["default"].Sphere(_this._radius);
        return _this;
      }
      var _proto = CannonSphereShape.prototype;
      _proto.onLoad = function onLoad() {
        _CannonShape.prototype.onLoad.call(this);
        this.radius = this.sphereCollider.radius;
      };
      _proto.setScale = function setScale(scale) {
        _CannonShape.prototype.setScale.call(this, scale);
        this.radius = this.sphereCollider.radius;
      };
      _createClass(CannonSphereShape, [ {
        key: "sphereCollider",
        get: function get() {
          return this.collider;
        }
      }, {
        key: "sphere",
        get: function get() {
          return this._shape;
        }
      }, {
        key: "radius",
        get: function get() {
          return this._radius;
        },
        set: function set(v) {
          this.collider.node.getWorldScale(v3_0);
          var max = v3_0.maxAxis();
          this.sphere.radius = v * Math.abs(max);
          this.sphere.updateBoundingSphereRadius();
          -1 != this._index && (0, _cannonUtil.commitShapeUpdates)(this._body);
        }
      } ]);
      return CannonSphereShape;
    })(_cannonShape.CannonShape);
    exports.CannonSphereShape = CannonSphereShape;
  }), {
    "../../../../../../external/cannon/cannon": 463,
    "../cannon-util": 54,
    "./cannon-shape": 58
  } ],
  60: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.BuiltinSharedBody = void 0;
    var _util = require("../framework/util");
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var intersect = cc.geomUtils.intersect;
    var fastRemove = cc.js.array.fastRemove;
    var v3_0 = new cc.Vec3();
    var v3_1 = new cc.Vec3();
    var quat_0 = new cc.Quat();
    var BuiltinSharedBody = (function() {
      BuiltinSharedBody.getSharedBody = function getSharedBody(node, wrappedWorld) {
        var key = node._id;
        if (BuiltinSharedBody.sharedBodiesMap.has(key)) return BuiltinSharedBody.sharedBodiesMap.get(key);
        var newSB = new BuiltinSharedBody(node, wrappedWorld);
        BuiltinSharedBody.sharedBodiesMap.set(node._id, newSB);
        return newSB;
      };
      function BuiltinSharedBody(node, world) {
        this._id = void 0;
        this.index = -1;
        this.ref = 0;
        this.node = void 0;
        this.world = void 0;
        this.shapes = [];
        this._id = BuiltinSharedBody.idCounter++;
        this.node = node;
        this.world = world;
      }
      var _proto = BuiltinSharedBody.prototype;
      _proto.intersects = function intersects(body) {
        for (var i = 0; i < this.shapes.length; i++) {
          var shapeA = this.shapes[i];
          for (var j = 0; j < body.shapes.length; j++) {
            var shapeB = body.shapes[j];
            if (intersect.resolve(shapeA.worldShape, shapeB.worldShape)) {
              this.world.shapeArr.push(shapeA);
              this.world.shapeArr.push(shapeB);
            }
          }
        }
      };
      _proto.addShape = function addShape(shape) {
        var i = this.shapes.indexOf(shape);
        i < 0 && this.shapes.push(shape);
      };
      _proto.removeShape = function removeShape(shape) {
        fastRemove(this.shapes, shape);
      };
      _proto.syncSceneToPhysics = function syncSceneToPhysics(force) {
        void 0 === force && (force = false);
        var node = this.node;
        var needUpdateTransform = (0, _util.worldDirty)(node);
        if (!force && !needUpdateTransform) return;
        node.getWorldPosition(v3_0);
        node.getWorldRotation(quat_0);
        node.getWorldScale(v3_1);
        for (var i = 0; i < this.shapes.length; i++) this.shapes[i].transform(node._worldMatrix, v3_0, quat_0, v3_1);
      };
      _proto.destory = function destory() {
        BuiltinSharedBody.sharedBodiesMap["delete"](this.node._id);
        this.node = null;
        this.world = null;
        this.shapes = null;
      };
      _createClass(BuiltinSharedBody, [ {
        key: "id",
        get: function get() {
          return this._id;
        }
      }, {
        key: "enabled",
        set: function set(v) {
          if (v) {
            if (this.index < 0) {
              this.index = this.world.bodies.length;
              this.world.addSharedBody(this);
              this.syncSceneToPhysics(true);
            }
          } else if (this.index >= 0) {
            var isRemove = 0 == this.shapes.length;
            if (isRemove) {
              this.index = -1;
              this.world.removeSharedBody(this);
            }
          }
        }
      }, {
        key: "reference",
        set: function set(v) {
          v ? this.ref++ : this.ref--;
          0 == this.ref && this.destory();
        }
      } ]);
      return BuiltinSharedBody;
    })();
    exports.BuiltinSharedBody = BuiltinSharedBody;
    BuiltinSharedBody.sharedBodiesMap = new Map();
    BuiltinSharedBody.idCounter = 0;
  }), {
    "../framework/util": 82
  } ],
  61: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.BuiltInWorld = void 0;
    var _builtinSharedBody = require("./builtin-shared-body");
    var _arrayCollisionMatrix = require("./utils/array-collision-matrix");
    var _util = require("../framework/util");
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var fastRemove = cc.js.array.fastRemove;
    var intersect = cc.geomUtils.intersect;
    var Vec3 = cc.Vec3;
    var hitPoint = new Vec3();
    var TriggerEventObject = {
      type: "collision-enter",
      selfCollider: null,
      otherCollider: null
    };
    var BuiltInWorld = (function() {
      function BuiltInWorld() {
        this.shapeArr = [];
        this.bodies = [];
        this._shapeArrOld = [];
        this._collisionMatrix = new _arrayCollisionMatrix.ArrayCollisionMatrix();
        this._collisionMatrixPrev = new _arrayCollisionMatrix.ArrayCollisionMatrix();
      }
      var _proto = BuiltInWorld.prototype;
      _proto.step = function step() {
        this._shapeArrOld = this.shapeArr.slice();
        this.shapeArr.length = 0;
        (0, _util.clearNodeTransformRecord)();
        for (var i = 0; i < this.bodies.length; i++) this.bodies[i].syncSceneToPhysics();
        (0, _util.clearNodeTransformDirtyFlag)();
        var collisionMatrix = cc.game.collisionMatrix;
        for (var _i = 0; _i < this.bodies.length; _i++) {
          var bodyA = this.bodies[_i];
          var nodeA = bodyA.node;
          var nodeACollisionMatrix = collisionMatrix[nodeA.groupIndex];
          if (!nodeACollisionMatrix) continue;
          for (var j = _i + 1; j < this.bodies.length; j++) {
            var bodyB = this.bodies[j];
            var nodeB = bodyB.node;
            nodeA !== nodeB && nodeACollisionMatrix[nodeB.groupIndex] && bodyA.intersects(bodyB);
          }
        }
        this.emitColliderEvent();
      };
      _proto.raycastClosest = function raycastClosest(worldRay, options, out) {
        var tmp_d = Infinity;
        var max_d = options.maxDistance;
        var groupIndex = options.groupIndex;
        var collisionMatrix = cc.game.collisionMatrix;
        var rayCollisionMatrix = collisionMatrix[groupIndex];
        if (!rayCollisionMatrix) return false;
        for (var i = 0; i < this.bodies.length; i++) {
          var body = this.bodies[i];
          var bodyGroupIndex = body.node.groupIndex;
          var canCollider = rayCollisionMatrix[bodyGroupIndex];
          if (!canCollider) continue;
          for (var _i2 = 0; _i2 < body.shapes.length; _i2++) {
            var shape = body.shapes[_i2];
            var distance = intersect.resolve(worldRay, shape.worldShape);
            if (0 == distance || distance > max_d) continue;
            if (tmp_d > distance) {
              tmp_d = distance;
              Vec3.normalize(hitPoint, worldRay.d);
              Vec3.scaleAndAdd(hitPoint, worldRay.o, hitPoint, distance);
              out._assign(hitPoint, distance, shape.collider);
            }
          }
        }
        return !(Infinity == tmp_d);
      };
      _proto.raycast = function raycast(worldRay, options, pool, results) {
        var max_d = options.maxDistance;
        var groupIndex = options.groupIndex;
        var collisionMatrix = cc.game.collisionMatrix;
        var rayCollisionMatrix = collisionMatrix[groupIndex];
        if (!rayCollisionMatrix) return false;
        for (var i = 0; i < this.bodies.length; i++) {
          var body = this.bodies[i];
          var bodyGroupIndex = body.node.groupIndex;
          var canCollider = rayCollisionMatrix[bodyGroupIndex];
          if (!canCollider) continue;
          for (var _i3 = 0; _i3 < body.shapes.length; _i3++) {
            var shape = body.shapes[_i3];
            var distance = intersect.resolve(worldRay, shape.worldShape);
            if (0 == distance || distance > max_d) continue;
            var r = pool.add();
            worldRay.computeHit(hitPoint, distance);
            r._assign(hitPoint, distance, shape.collider);
            results.push(r);
          }
        }
        return results.length > 0;
      };
      _proto.getSharedBody = function getSharedBody(node) {
        return _builtinSharedBody.BuiltinSharedBody.getSharedBody(node, this);
      };
      _proto.addSharedBody = function addSharedBody(body) {
        var index = this.bodies.indexOf(body);
        index < 0 && this.bodies.push(body);
      };
      _proto.removeSharedBody = function removeSharedBody(body) {
        fastRemove(this.bodies, body);
      };
      _proto.emitColliderEvent = function emitColliderEvent() {
        var shapeA;
        var shapeB;
        for (var i = 0; i < this.shapeArr.length; i += 2) {
          shapeA = this.shapeArr[i];
          shapeB = this.shapeArr[i + 1];
          TriggerEventObject.selfCollider = shapeA.collider;
          TriggerEventObject.otherCollider = shapeB.collider;
          this._collisionMatrix.set(shapeA.id, shapeB.id, true);
          this._collisionMatrixPrev.get(shapeA.id, shapeB.id) ? TriggerEventObject.type = "trigger-stay" : TriggerEventObject.type = "trigger-enter";
          shapeA.collider && shapeA.collider.emit(TriggerEventObject.type, TriggerEventObject);
          TriggerEventObject.selfCollider = shapeB.collider;
          TriggerEventObject.otherCollider = shapeA.collider;
          shapeB.collider && shapeB.collider.emit(TriggerEventObject.type, TriggerEventObject);
        }
        for (var _i4 = 0; _i4 < this._shapeArrOld.length; _i4 += 2) {
          shapeA = this._shapeArrOld[_i4];
          shapeB = this._shapeArrOld[_i4 + 1];
          if (this._collisionMatrixPrev.get(shapeA.id, shapeB.id) && !this._collisionMatrix.get(shapeA.id, shapeB.id)) {
            TriggerEventObject.type = "trigger-exit";
            TriggerEventObject.selfCollider = shapeA.collider;
            TriggerEventObject.otherCollider = shapeB.collider;
            shapeA.collider && shapeA.collider.emit(TriggerEventObject.type, TriggerEventObject);
            TriggerEventObject.selfCollider = shapeB.collider;
            TriggerEventObject.otherCollider = shapeA.collider;
            shapeB.collider && shapeB.collider.emit(TriggerEventObject.type, TriggerEventObject);
            this._collisionMatrix.set(shapeA.id, shapeB.id, false);
          }
        }
        this._collisionMatrixPrev.matrix = this._collisionMatrix.matrix.slice();
        this._collisionMatrix.reset();
      };
      _createClass(BuiltInWorld, [ {
        key: "gravity",
        set: function set(v) {}
      }, {
        key: "allowSleep",
        set: function set(v) {}
      }, {
        key: "defaultMaterial",
        set: function set(v) {}
      } ]);
      return BuiltInWorld;
    })();
    exports.BuiltInWorld = BuiltInWorld;
  }), {
    "../framework/util": 82,
    "./builtin-shared-body": 60,
    "./utils/array-collision-matrix": 66
  } ],
  62: [ (function(require, module, exports) {
    "use strict";
    var _physicsSelector = require("../framework/physics-selector");
    var _builtinWorld = require("./builtin-world");
    var _builtinBoxShape = require("./shapes/builtin-box-shape");
    var _builtinSphereShape = require("./shapes/builtin-sphere-shape");
    false;
  }), {
    "../framework/physics-selector": 81,
    "./builtin-world": 61,
    "./shapes/builtin-box-shape": 63,
    "./shapes/builtin-sphere-shape": 65
  } ],
  63: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.BuiltinBoxShape = void 0;
    var _builtinShape = require("./builtin-shape");
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Obb = cc.geomUtils.Obb;
    var Vec3 = cc.Vec3;
    var _worldScale = new Vec3();
    var BuiltinBoxShape = (function(_BuiltinShape) {
      _inheritsLoose(BuiltinBoxShape, _BuiltinShape);
      function BuiltinBoxShape(size) {
        var _this;
        _this = _BuiltinShape.call(this) || this;
        _this._localShape = new Obb();
        _this._worldShape = new Obb();
        Vec3.multiplyScalar(_this.localObb.halfExtents, size, .5);
        Vec3.copy(_this.worldObb.halfExtents, _this.localObb.halfExtents);
        return _this;
      }
      var _proto = BuiltinBoxShape.prototype;
      _proto.onLoad = function onLoad() {
        _BuiltinShape.prototype.onLoad.call(this);
        this.size = this.boxCollider.size;
      };
      _createClass(BuiltinBoxShape, [ {
        key: "localObb",
        get: function get() {
          return this._localShape;
        }
      }, {
        key: "worldObb",
        get: function get() {
          return this._worldShape;
        }
      }, {
        key: "boxCollider",
        get: function get() {
          return this.collider;
        }
      }, {
        key: "size",
        set: function set(size) {
          Vec3.multiplyScalar(this.localObb.halfExtents, size, .5);
          this.collider.node.getWorldScale(_worldScale);
          _worldScale.x = Math.abs(_worldScale.x);
          _worldScale.y = Math.abs(_worldScale.y);
          _worldScale.z = Math.abs(_worldScale.z);
          Vec3.multiply(this.worldObb.halfExtents, this.localObb.halfExtents, _worldScale);
        }
      } ]);
      return BuiltinBoxShape;
    })(_builtinShape.BuiltinShape);
    exports.BuiltinBoxShape = BuiltinBoxShape;
  }), {
    "./builtin-shape": 64
  } ],
  64: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.BuiltinShape = void 0;
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var Vec3 = cc.Vec3;
    var BuiltinShape = (function() {
      function BuiltinShape() {
        this.id = BuiltinShape.idCounter++;
        this._sharedBody = void 0;
        this._collider = void 0;
        this._localShape = void 0;
        this._worldShape = void 0;
      }
      var _proto = BuiltinShape.prototype;
      _proto.__preload = function __preload(comp) {
        this._collider = comp;
        this._sharedBody = cc.director.getPhysics3DManager().physicsWorld.getSharedBody(this._collider.node);
        this._sharedBody.reference = true;
      };
      _proto.onLoad = function onLoad() {
        this.center = this._collider.center;
      };
      _proto.onEnable = function onEnable() {
        this._sharedBody.addShape(this);
        this._sharedBody.enabled = true;
      };
      _proto.onDisable = function onDisable() {
        this._sharedBody.removeShape(this);
        this._sharedBody.enabled = false;
      };
      _proto.onDestroy = function onDestroy() {
        this._sharedBody.reference = false;
        this._collider = null;
        this._localShape = null;
        this._worldShape = null;
      };
      _proto.transform = function transform(m, pos, rot, scale) {
        this._localShape.transform(m, pos, rot, scale, this._worldShape);
      };
      _createClass(BuiltinShape, [ {
        key: "material",
        set: function set(v) {}
      }, {
        key: "isTrigger",
        set: function set(v) {}
      }, {
        key: "attachedRigidBody",
        get: function get() {
          return null;
        }
      }, {
        key: "center",
        set: function set(v) {
          Vec3.copy(this._localShape.center, v);
        }
      }, {
        key: "localShape",
        get: function get() {
          return this._worldShape;
        }
      }, {
        key: "worldShape",
        get: function get() {
          return this._worldShape;
        }
      }, {
        key: "sharedBody",
        get: function get() {
          return this._sharedBody;
        }
      }, {
        key: "collider",
        get: function get() {
          return this._collider;
        }
      } ]);
      return BuiltinShape;
    })();
    exports.BuiltinShape = BuiltinShape;
    BuiltinShape.idCounter = 0;
  }), {} ],
  65: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.BuiltinSphereShape = void 0;
    var _builtinShape = require("./builtin-shape");
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Sphere = cc.geomUtils.Sphere;
    var _worldScale = new cc.Vec3();
    var BuiltinSphereShape = (function(_BuiltinShape) {
      _inheritsLoose(BuiltinSphereShape, _BuiltinShape);
      function BuiltinSphereShape(radius) {
        var _this;
        _this = _BuiltinShape.call(this) || this;
        _this._localShape = new Sphere(0, 0, 0, radius);
        _this._worldShape = new Sphere(0, 0, 0, radius);
        return _this;
      }
      var _proto = BuiltinSphereShape.prototype;
      _proto.onLoad = function onLoad() {
        _BuiltinShape.prototype.onLoad.call(this);
        this.radius = this.sphereCollider.radius;
      };
      _createClass(BuiltinSphereShape, [ {
        key: "radius",
        set: function set(radius) {
          this.localSphere.radius = radius;
          this.collider.node.getWorldScale(_worldScale);
          var s = _worldScale.maxAxis();
          this.worldSphere.radius = this.localSphere.radius * s;
        }
      }, {
        key: "localSphere",
        get: function get() {
          return this._localShape;
        }
      }, {
        key: "worldSphere",
        get: function get() {
          return this._worldShape;
        }
      }, {
        key: "sphereCollider",
        get: function get() {
          return this.collider;
        }
      } ]);
      return BuiltinSphereShape;
    })(_builtinShape.BuiltinShape);
    exports.BuiltinSphereShape = BuiltinSphereShape;
  }), {
    "./builtin-shape": 64
  } ],
  66: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.ArrayCollisionMatrix = void 0;
    var ArrayCollisionMatrix = (function() {
      function ArrayCollisionMatrix() {
        this.matrix = [];
      }
      var _proto = ArrayCollisionMatrix.prototype;
      _proto.get = function get(i, j) {
        if (j > i) {
          var temp = j;
          j = i;
          i = temp;
        }
        return this.matrix[(i * (i + 1) >> 1) + j - 1];
      };
      _proto.set = function set(i, j, value) {
        if (j > i) {
          var temp = j;
          j = i;
          i = temp;
        }
        this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
      };
      _proto.reset = function reset() {
        for (var i = 0, l = this.matrix.length; i !== l; i++) this.matrix[i] = 0;
      };
      _proto.setNumObjects = function setNumObjects(n) {
        this.matrix.length = n * (n - 1) >> 1;
      };
      return ArrayCollisionMatrix;
    })();
    exports.ArrayCollisionMatrix = ArrayCollisionMatrix;
  }), {} ],
  67: [ (function(require, module, exports) {
    "use strict";
    require("../cocos/instantiate");
  }), {
    "../cocos/instantiate": 62
  } ],
  68: [ (function(require, module, exports) {
    "use strict";
    require("../cannon/instantiate");
    var _cannon = _interopRequireDefault(require("../../../../../external/cannon/cannon"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    window && (window.CANNON = _cannon["default"]);
  }), {
    "../../../../../external/cannon/cannon": 463,
    "../cannon/instantiate": 56
  } ],
  69: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _framework = require("../framework");
    Object.keys(_framework).forEach((function(key) {
      if ("default" === key || "__esModule" === key) return;
      if (key in exports && exports[key] === _framework[key]) return;
      exports[key] = _framework[key];
    }));
  }), {
    "../framework": 76
  } ],
  70: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.PhysicsMaterial = void 0;
    var _dec, _class, _class2, _descriptor, _descriptor2, _class3;
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _assertThisInitialized(self) {
      if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var _cc$_decorator = cc._decorator, ccclass = _cc$_decorator.ccclass, property = _cc$_decorator.property;
    var fastRemove = cc.js.array.fastRemove;
    var equals = cc.math.equals;
    var PhysicsMaterial = (_dec = ccclass("cc.PhysicsMaterial"), _dec(_class = (_class2 = (_class3 = (function(_cc$Asset) {
      _inheritsLoose(PhysicsMaterial, _cc$Asset);
      function PhysicsMaterial() {
        var _this;
        _this = _cc$Asset.call(this) || this;
        _initializerDefineProperty(_this, "_friction", _descriptor, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_restitution", _descriptor2, _assertThisInitialized(_this));
        cc.EventTarget.call(_assertThisInitialized(_this));
        PhysicsMaterial.allMaterials.push(_assertThisInitialized(_this));
        "" == _this._uuid && (_this._uuid = "pm_" + PhysicsMaterial._idCounter++);
        return _this;
      }
      var _proto = PhysicsMaterial.prototype;
      _proto.clone = function clone() {
        var c = new PhysicsMaterial();
        c._friction = this._friction;
        c._restitution = this._restitution;
        return c;
      };
      _proto.destroy = function destroy() {
        if (_cc$Asset.prototype.destroy.call(this)) {
          fastRemove(PhysicsMaterial.allMaterials, this);
          return true;
        }
        return false;
      };
      _createClass(PhysicsMaterial, [ {
        key: "friction",
        get: function get() {
          return this._friction;
        },
        set: function set(value) {
          if (!equals(this._friction, value)) {
            this._friction = value;
            this.emit("physics_material_update");
          }
        }
      }, {
        key: "restitution",
        get: function get() {
          return this._restitution;
        },
        set: function set(value) {
          if (!equals(this._restitution, value)) {
            this._restitution = value;
            this.emit("physics_material_update");
          }
        }
      } ]);
      return PhysicsMaterial;
    })(cc.Asset), _class3.allMaterials = [], _class3._idCounter = 0, _class3), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_friction", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return .1;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_restitution", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return .1;
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "friction", [ property ], Object.getOwnPropertyDescriptor(_class2.prototype, "friction"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "restitution", [ property ], Object.getOwnPropertyDescriptor(_class2.prototype, "restitution"), _class2.prototype), 
    _class2)) || _class);
    exports.PhysicsMaterial = PhysicsMaterial;
    cc.js.mixin(PhysicsMaterial.prototype, cc.EventTarget.prototype);
    cc.PhysicsMaterial = PhysicsMaterial;
  }), {} ],
  71: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.BoxCollider3D = void 0;
    var _instance = require("../../instance");
    var _colliderComponent = require("./collider-component");
    var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor;
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _assertThisInitialized(self) {
      if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    var _cc$_decorator = cc._decorator, ccclass = _cc$_decorator.ccclass, executeInEditMode = _cc$_decorator.executeInEditMode, executionOrder = _cc$_decorator.executionOrder, menu = _cc$_decorator.menu, property = _cc$_decorator.property;
    var Vec3 = cc.Vec3;
    var BoxCollider3D = (_dec = ccclass("cc.BoxCollider3D"), _dec2 = executionOrder(98), 
    _dec3 = menu("i18n:MAIN_MENU.component.physics/Collider/Box 3D"), _dec4 = property({
      type: cc.Vec3
    }), _dec(_class = _dec2(_class = _dec3(_class = executeInEditMode(_class = (_class2 = (function(_Collider3D) {
      _inheritsLoose(BoxCollider3D, _Collider3D);
      function BoxCollider3D() {
        var _this;
        _this = _Collider3D.call(this) || this;
        _initializerDefineProperty(_this, "_size", _descriptor, _assertThisInitialized(_this));
        true;
        _this._shape = (0, _instance.createBoxShape)(_this._size);
        return _this;
      }
      _createClass(BoxCollider3D, [ {
        key: "size",
        get: function get() {
          return this._size;
        },
        set: function set(value) {
          Vec3.copy(this._size, value);
          true;
          this.boxShape.size = this._size;
        }
      }, {
        key: "boxShape",
        get: function get() {
          return this._shape;
        }
      } ]);
      return BoxCollider3D;
    })(_colliderComponent.Collider3D), _applyDecoratedDescriptor(_class2.prototype, "size", [ _dec4 ], Object.getOwnPropertyDescriptor(_class2.prototype, "size"), _class2.prototype), 
    _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_size", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new Vec3(1, 1, 1);
      }
    }), _class2)) || _class) || _class) || _class) || _class);
    exports.BoxCollider3D = BoxCollider3D;
  }), {
    "../../instance": 77,
    "./collider-component": 72
  } ],
  72: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.Collider3D = void 0;
    var _physicsMaterial = require("../../assets/physics-material");
    var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3;
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _assertThisInitialized(self) {
      if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    var _cc$_decorator = cc._decorator, ccclass = _cc$_decorator.ccclass, property = _cc$_decorator.property;
    var Vec3 = cc.Vec3;
    var Collider3D = (_dec = ccclass("cc.Collider3D"), _dec2 = property({
      type: _physicsMaterial.PhysicsMaterial,
      displayName: "Material",
      displayOrder: -1
    }), _dec3 = property({
      displayOrder: 0
    }), _dec4 = property({
      type: cc.Vec3,
      displayOrder: 1
    }), _dec5 = property({
      type: _physicsMaterial.PhysicsMaterial
    }), _dec(_class = (_class2 = (function(_cc$Component) {
      _inheritsLoose(Collider3D, _cc$Component);
      function Collider3D() {
        var _this;
        _this = _cc$Component.call(this) || this;
        _this._shape = void 0;
        _this._isSharedMaterial = true;
        _initializerDefineProperty(_this, "_material", _descriptor, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_isTrigger", _descriptor2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_center", _descriptor3, _assertThisInitialized(_this));
        cc.EventTarget.call(_assertThisInitialized(_this));
        return _this;
      }
      var _proto = Collider3D.prototype;
      _proto.on = function on(type, callback, target, useCapture) {};
      _proto.off = function off(type, callback, target) {};
      _proto.once = function once(type, callback, target) {};
      _proto.emit = function emit(key) {};
      _proto.__preload = function __preload() {
        true;
        this._shape.__preload(this);
      };
      _proto.onLoad = function onLoad() {
        true;
        true;
        this.sharedMaterial = null == this._material ? cc.director.getPhysics3DManager().defaultMaterial : this._material;
        this._shape.onLoad();
      };
      _proto.onEnable = function onEnable() {
        true;
        this._shape.onEnable();
      };
      _proto.onDisable = function onDisable() {
        true;
        this._shape.onDisable();
      };
      _proto.onDestroy = function onDestroy() {
        true;
        this._material && this._material.off("physics_material_update", this._updateMaterial, this);
        this._shape.onDestroy();
      };
      _proto._updateMaterial = function _updateMaterial() {
        true;
        this._shape.material = this._material;
      };
      _createClass(Collider3D, [ {
        key: "sharedMaterial",
        get: function get() {
          return this._material;
        },
        set: function set(value) {
          this.material = value;
        }
      }, {
        key: "material",
        get: function get() {
          true;
          if (this._isSharedMaterial && null != this._material) {
            this._material.off("physics_material_update", this._updateMaterial, this);
            this._material = this._material.clone();
            this._material.on("physics_material_update", this._updateMaterial, this);
            this._isSharedMaterial = false;
          }
          return this._material;
        },
        set: function set(value) {
          false, false;
          if (null != value && null != this._material) {
            if (this._material._uuid != value._uuid) {
              this._material.off("physics_material_update", this._updateMaterial, this);
              value.on("physics_material_update", this._updateMaterial, this);
              this._isSharedMaterial = false;
              this._material = value;
            }
          } else if (null != value && null == this._material) {
            value.on("physics_material_update", this._updateMaterial, this);
            this._material = value;
          } else if (null == value && null != this._material) {
            this._material.off("physics_material_update", this._updateMaterial, this);
            this._material = value;
          }
          this._updateMaterial();
        }
      }, {
        key: "isTrigger",
        get: function get() {
          return this._isTrigger;
        },
        set: function set(value) {
          this._isTrigger = value;
          true;
          this._shape.isTrigger = this._isTrigger;
        }
      }, {
        key: "center",
        get: function get() {
          return this._center;
        },
        set: function set(value) {
          Vec3.copy(this._center, value);
          true;
          this._shape.center = this._center;
        }
      }, {
        key: "attachedRigidbody",
        get: function get() {
          return this.shape.attachedRigidBody;
        }
      }, {
        key: "shape",
        get: function get() {
          return this._shape;
        }
      }, {
        key: "_assertOnload",
        get: function get() {
          var r = 0 == this._isOnLoadCalled;
          r && cc.error("Physics Error: Please make sure that the node has been added to the scene");
          return !r;
        }
      } ]);
      return Collider3D;
    })(cc.Component), _applyDecoratedDescriptor(_class2.prototype, "sharedMaterial", [ _dec2 ], Object.getOwnPropertyDescriptor(_class2.prototype, "sharedMaterial"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "isTrigger", [ _dec3 ], Object.getOwnPropertyDescriptor(_class2.prototype, "isTrigger"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "center", [ _dec4 ], Object.getOwnPropertyDescriptor(_class2.prototype, "center"), _class2.prototype), 
    _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_material", [ _dec5 ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return null;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_isTrigger", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_center", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new Vec3();
      }
    }), _class2)) || _class);
    exports.Collider3D = Collider3D;
    cc.js.mixin(Collider3D.prototype, cc.EventTarget.prototype);
  }), {
    "../../assets/physics-material": 70
  } ],
  73: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.SphereCollider3D = void 0;
    var _instance = require("../../instance");
    var _colliderComponent = require("./collider-component");
    var _dec, _dec2, _dec3, _class, _class2, _descriptor;
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _assertThisInitialized(self) {
      if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    var _cc$_decorator = cc._decorator, ccclass = _cc$_decorator.ccclass, executeInEditMode = _cc$_decorator.executeInEditMode, executionOrder = _cc$_decorator.executionOrder, menu = _cc$_decorator.menu, property = _cc$_decorator.property;
    var SphereCollider3D = (_dec = ccclass("cc.SphereCollider3D"), _dec2 = executionOrder(98), 
    _dec3 = menu("i18n:MAIN_MENU.component.physics/Collider/Sphere 3D"), _dec(_class = _dec2(_class = _dec3(_class = executeInEditMode(_class = (_class2 = (function(_Collider3D) {
      _inheritsLoose(SphereCollider3D, _Collider3D);
      function SphereCollider3D() {
        var _this;
        _this = _Collider3D.call(this) || this;
        _initializerDefineProperty(_this, "_radius", _descriptor, _assertThisInitialized(_this));
        true;
        _this._shape = (0, _instance.createSphereShape)(_this._radius);
        return _this;
      }
      _createClass(SphereCollider3D, [ {
        key: "radius",
        get: function get() {
          return this._radius;
        },
        set: function set(value) {
          this._radius = value;
          true;
          this.sphereShape.radius = this._radius;
        }
      }, {
        key: "sphereShape",
        get: function get() {
          return this._shape;
        }
      } ]);
      return SphereCollider3D;
    })(_colliderComponent.Collider3D), _applyDecoratedDescriptor(_class2.prototype, "radius", [ property ], Object.getOwnPropertyDescriptor(_class2.prototype, "radius"), _class2.prototype), 
    _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_radius", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return .5;
      }
    }), _class2)) || _class) || _class) || _class) || _class);
    exports.SphereCollider3D = SphereCollider3D;
  }), {
    "../../instance": 77,
    "./collider-component": 72
  } ],
  74: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.ConstantForce = void 0;
    var _rigidBodyComponent = require("./rigid-body-component");
    var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _assertThisInitialized(self) {
      if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var _cc$_decorator = cc._decorator, ccclass = _cc$_decorator.ccclass, executeInEditMode = _cc$_decorator.executeInEditMode, executionOrder = _cc$_decorator.executionOrder, menu = _cc$_decorator.menu, property = _cc$_decorator.property, requireComponent = _cc$_decorator.requireComponent, disallowMultiple = _cc$_decorator.disallowMultiple;
    var Vec3 = cc.Vec3;
    var ConstantForce = (_dec = ccclass("cc.ConstantForce"), _dec2 = executionOrder(98), 
    _dec3 = requireComponent(_rigidBodyComponent.RigidBody3D), _dec4 = menu("i18n:MAIN_MENU.component.physics/Constant Force 3D"), 
    _dec5 = property({
      displayOrder: 0
    }), _dec6 = property({
      displayOrder: 1
    }), _dec7 = property({
      displayOrder: 2
    }), _dec8 = property({
      displayOrder: 3
    }), _dec(_class = _dec2(_class = _dec3(_class = _dec4(_class = disallowMultiple(_class = executeInEditMode(_class = (_class2 = (function(_cc$Component) {
      _inheritsLoose(ConstantForce, _cc$Component);
      function ConstantForce() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        _this = _cc$Component.call.apply(_cc$Component, [ this ].concat(args)) || this;
        _this._rigidbody = null;
        _initializerDefineProperty(_this, "_force", _descriptor, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_localForce", _descriptor2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_torque", _descriptor3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_localTorque", _descriptor4, _assertThisInitialized(_this));
        _this._mask = 0;
        return _this;
      }
      var _proto = ConstantForce.prototype;
      _proto.onLoad = function onLoad() {
        true;
        this._rigidbody = this.node.getComponent(_rigidBodyComponent.RigidBody3D);
        this._maskUpdate(this._force, 1);
        this._maskUpdate(this._localForce, 2);
        this._maskUpdate(this._torque, 4);
        this._maskUpdate(this._localTorque, 8);
      };
      _proto.lateUpdate = function lateUpdate(dt) {
        true;
        if (null != this._rigidbody && 0 != this._mask) {
          1 & this._mask && this._rigidbody.applyForce(this._force);
          2 & this._mask && this._rigidbody.applyLocalForce(this.localForce);
          4 & this._mask && this._rigidbody.applyTorque(this._torque);
          8 & this._mask && this._rigidbody.applyLocalTorque(this._localTorque);
        }
      };
      _proto._maskUpdate = function _maskUpdate(t, m) {
        Vec3.strictEquals(t, Vec3.ZERO) ? this._mask &= ~m : this._mask |= m;
      };
      _createClass(ConstantForce, [ {
        key: "force",
        get: function get() {
          return this._force;
        },
        set: function set(value) {
          Vec3.copy(this._force, value);
          this._maskUpdate(this._force, 1);
        }
      }, {
        key: "localForce",
        get: function get() {
          return this._localForce;
        },
        set: function set(value) {
          Vec3.copy(this._localForce, value);
          this._maskUpdate(this.localForce, 2);
        }
      }, {
        key: "torque",
        get: function get() {
          return this._torque;
        },
        set: function set(value) {
          Vec3.copy(this._torque, value);
          this._maskUpdate(this._torque, 4);
        }
      }, {
        key: "localTorque",
        get: function get() {
          return this._localTorque;
        },
        set: function set(value) {
          Vec3.copy(this._localTorque, value);
          this._maskUpdate(this._localTorque, 8);
        }
      } ]);
      return ConstantForce;
    })(cc.Component), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_force", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new Vec3();
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_localForce", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new Vec3();
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_torque", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new Vec3();
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_localTorque", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new Vec3();
      }
    }), _applyDecoratedDescriptor(_class2.prototype, "force", [ _dec5 ], Object.getOwnPropertyDescriptor(_class2.prototype, "force"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "localForce", [ _dec6 ], Object.getOwnPropertyDescriptor(_class2.prototype, "localForce"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "torque", [ _dec7 ], Object.getOwnPropertyDescriptor(_class2.prototype, "torque"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "localTorque", [ _dec8 ], Object.getOwnPropertyDescriptor(_class2.prototype, "localTorque"), _class2.prototype), 
    _class2)) || _class) || _class) || _class) || _class) || _class) || _class);
    exports.ConstantForce = ConstantForce;
  }), {
    "./rigid-body-component": 75
  } ],
  75: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.RigidBody3D = void 0;
    var _instance = require("../instance");
    var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8;
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _assertThisInitialized(self) {
      if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    var _cc$_decorator = cc._decorator, ccclass = _cc$_decorator.ccclass, disallowMultiple = _cc$_decorator.disallowMultiple, executeInEditMode = _cc$_decorator.executeInEditMode, executionOrder = _cc$_decorator.executionOrder, menu = _cc$_decorator.menu, property = _cc$_decorator.property;
    var Vec3 = cc.Vec3;
    var RigidBody3D = (_dec = ccclass("cc.RigidBody3D"), _dec2 = executionOrder(99), 
    _dec3 = menu("i18n:MAIN_MENU.component.physics/Rigid Body 3D"), _dec4 = property({
      displayOrder: 0
    }), _dec5 = property({
      displayOrder: 1
    }), _dec6 = property({
      displayOrder: 2
    }), _dec7 = property({
      displayOrder: 3
    }), _dec8 = property({
      displayOrder: 4
    }), _dec9 = property({
      displayOrder: 5
    }), _dec10 = property({
      displayOrder: 6
    }), _dec11 = property({
      displayOrder: 7
    }), _dec(_class = _dec2(_class = _dec3(_class = executeInEditMode(_class = disallowMultiple(_class = (_class2 = (function(_cc$Component) {
      _inheritsLoose(RigidBody3D, _cc$Component);
      function RigidBody3D() {
        var _this;
        _this = _cc$Component.call(this) || this;
        _this._body = void 0;
        _this._allowSleep = true;
        _initializerDefineProperty(_this, "_mass", _descriptor, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_linearDamping", _descriptor2, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_angularDamping", _descriptor3, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_fixedRotation", _descriptor4, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_isKinematic", _descriptor5, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_useGravity", _descriptor6, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_linearFactor", _descriptor7, _assertThisInitialized(_this));
        _initializerDefineProperty(_this, "_angularFactor", _descriptor8, _assertThisInitialized(_this));
        true, true;
        _this._body = (0, _instance.createRigidBody)();
        return _this;
      }
      var _proto = RigidBody3D.prototype;
      _proto.__preload = function __preload() {
        true, true;
        this._body.__preload(this);
      };
      _proto.onEnable = function onEnable() {
        true, true;
        this._body.onEnable();
      };
      _proto.onDisable = function onDisable() {
        true, true;
        this._body.onDisable();
      };
      _proto.onDestroy = function onDestroy() {
        true, true;
        this._body.onDestroy();
      };
      _proto.applyForce = function applyForce(force, relativePoint) {
        this._assertOnload && true && this._body.applyForce(force, relativePoint);
      };
      _proto.applyLocalForce = function applyLocalForce(force, localPoint) {
        this._assertOnload && true && this._body.applyLocalForce(force, localPoint);
      };
      _proto.applyImpulse = function applyImpulse(impulse, relativePoint) {
        this._assertOnload && true && this._body.applyImpulse(impulse, relativePoint);
      };
      _proto.applyLocalImpulse = function applyLocalImpulse(impulse, localPoint) {
        this._assertOnload && true && this._body.applyLocalImpulse(impulse, localPoint);
      };
      _proto.applyTorque = function applyTorque(torque) {
        this._assertOnload && true && this._body.applyTorque(torque);
      };
      _proto.applyLocalTorque = function applyLocalTorque(torque) {
        this._assertOnload && true && this._body.applyLocalTorque(torque);
      };
      _proto.wakeUp = function wakeUp() {
        this._assertOnload && true && this._body.wakeUp();
      };
      _proto.sleep = function sleep() {
        this._assertOnload && true && this._body.sleep();
      };
      _proto.getLinearVelocity = function getLinearVelocity(out) {
        this._assertOnload && true && this._body.getLinearVelocity(out);
      };
      _proto.setLinearVelocity = function setLinearVelocity(value) {
        this._assertOnload && true && this._body.setLinearVelocity(value);
      };
      _proto.getAngularVelocity = function getAngularVelocity(out) {
        this._assertOnload && true && this._body.getAngularVelocity(out);
      };
      _proto.setAngularVelocity = function setAngularVelocity(value) {
        this._assertOnload && true && this._body.setAngularVelocity(value);
      };
      _createClass(RigidBody3D, [ {
        key: "allowSleep",
        get: function get() {
          return this._allowSleep;
        },
        set: function set(v) {
          this._allowSleep = v;
          true, true;
          this._body.allowSleep = v;
        }
      }, {
        key: "mass",
        get: function get() {
          return this._mass;
        },
        set: function set(value) {
          this._mass = value;
          true, true;
          this._body.mass = value;
        }
      }, {
        key: "linearDamping",
        get: function get() {
          return this._linearDamping;
        },
        set: function set(value) {
          this._linearDamping = value;
          true, true;
          this._body.linearDamping = value;
        }
      }, {
        key: "angularDamping",
        get: function get() {
          return this._angularDamping;
        },
        set: function set(value) {
          this._angularDamping = value;
          true, true;
          this._body.angularDamping = value;
        }
      }, {
        key: "isKinematic",
        get: function get() {
          return this._isKinematic;
        },
        set: function set(value) {
          this._isKinematic = value;
          true, true;
          this._body.isKinematic = value;
        }
      }, {
        key: "useGravity",
        get: function get() {
          return this._useGravity;
        },
        set: function set(value) {
          this._useGravity = value;
          true, true;
          this._body.useGravity = value;
        }
      }, {
        key: "fixedRotation",
        get: function get() {
          return this._fixedRotation;
        },
        set: function set(value) {
          this._fixedRotation = value;
          true, true;
          this._body.fixedRotation = value;
        }
      }, {
        key: "linearFactor",
        get: function get() {
          return this._linearFactor;
        },
        set: function set(value) {
          Vec3.copy(this._linearFactor, value);
          true, true;
          this._body.linearFactor = this._linearFactor;
        }
      }, {
        key: "angularFactor",
        get: function get() {
          return this._angularFactor;
        },
        set: function set(value) {
          Vec3.copy(this._angularFactor, value);
          true, true;
          this._body.angularFactor = this._angularFactor;
        }
      }, {
        key: "isAwake",
        get: function get() {
          if (this._assertOnload && true) return this._body.isAwake;
          return false;
        }
      }, {
        key: "isSleepy",
        get: function get() {
          if (this._assertOnload && true) return this._body.isSleepy;
          return false;
        }
      }, {
        key: "isSleeping",
        get: function get() {
          if (this._assertOnload && true) return this._body.isSleeping;
          return false;
        }
      }, {
        key: "rigidBody",
        get: function get() {
          return this._body;
        }
      }, {
        key: "_assertOnload",
        get: function get() {
          var r = 0 == this._isOnLoadCalled;
          r && cc.error("Physics Error: Please make sure that the node has been added to the scene");
          return !r;
        }
      } ]);
      return RigidBody3D;
    })(cc.Component), _applyDecoratedDescriptor(_class2.prototype, "mass", [ _dec4 ], Object.getOwnPropertyDescriptor(_class2.prototype, "mass"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "linearDamping", [ _dec5 ], Object.getOwnPropertyDescriptor(_class2.prototype, "linearDamping"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "angularDamping", [ _dec6 ], Object.getOwnPropertyDescriptor(_class2.prototype, "angularDamping"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "isKinematic", [ _dec7 ], Object.getOwnPropertyDescriptor(_class2.prototype, "isKinematic"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "useGravity", [ _dec8 ], Object.getOwnPropertyDescriptor(_class2.prototype, "useGravity"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "fixedRotation", [ _dec9 ], Object.getOwnPropertyDescriptor(_class2.prototype, "fixedRotation"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "linearFactor", [ _dec10 ], Object.getOwnPropertyDescriptor(_class2.prototype, "linearFactor"), _class2.prototype), 
    _applyDecoratedDescriptor(_class2.prototype, "angularFactor", [ _dec11 ], Object.getOwnPropertyDescriptor(_class2.prototype, "angularFactor"), _class2.prototype), 
    _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_mass", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 10;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_linearDamping", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return .1;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_angularDamping", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return .1;
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_fixedRotation", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_isKinematic", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "_useGravity", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return true;
      }
    }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "_linearFactor", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new Vec3(1, 1, 1);
      }
    }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "_angularFactor", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new Vec3(1, 1, 1);
      }
    }), _class2)) || _class) || _class) || _class) || _class) || _class);
    exports.RigidBody3D = RigidBody3D;
  }), {
    "../instance": 77
  } ],
  76: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _physicsManager = require("./physics-manager");
    exports.Physics3DManager = _physicsManager.Physics3DManager;
    var _physicsRayResult = require("./physics-ray-result");
    exports.PhysicsRayResult = _physicsRayResult.PhysicsRayResult;
    var _boxColliderComponent = require("./components/collider/box-collider-component");
    exports.BoxCollider3D = _boxColliderComponent.BoxCollider3D;
    var _colliderComponent = require("./components/collider/collider-component");
    exports.Collider3D = _colliderComponent.Collider3D;
    var _sphereColliderComponent = require("./components/collider/sphere-collider-component");
    exports.SphereCollider3D = _sphereColliderComponent.SphereCollider3D;
    var _rigidBodyComponent = require("./components/rigid-body-component");
    exports.RigidBody3D = _rigidBodyComponent.RigidBody3D;
    var _constantForce = require("./components/constant-force");
    var _physicsMaterial = require("./assets/physics-material");
    exports.PhysicsMaterial = _physicsMaterial.PhysicsMaterial;
    cc.Physics3DManager = _physicsManager.Physics3DManager;
    cc.Collider3D = _colliderComponent.Collider3D;
    cc.BoxCollider3D = _boxColliderComponent.BoxCollider3D;
    cc.SphereCollider3D = _sphereColliderComponent.SphereCollider3D;
    cc.RigidBody3D = _rigidBodyComponent.RigidBody3D;
    cc.PhysicsRayResult = _physicsRayResult.PhysicsRayResult;
    cc.ConstantForce = _constantForce.ConstantForce;
  }), {
    "./assets/physics-material": 70,
    "./components/collider/box-collider-component": 71,
    "./components/collider/collider-component": 72,
    "./components/collider/sphere-collider-component": 73,
    "./components/constant-force": 74,
    "./components/rigid-body-component": 75,
    "./physics-manager": 79,
    "./physics-ray-result": 80
  } ],
  77: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.createBoxShape = createBoxShape;
    exports.createPhysicsWorld = createPhysicsWorld;
    exports.createRigidBody = createRigidBody;
    exports.createSphereShape = createSphereShape;
    var _physicsSelector = require("./physics-selector");
    function createPhysicsWorld() {
      return new _physicsSelector.PhysicsWorld();
    }
    function createRigidBody() {
      return new _physicsSelector.RigidBody();
    }
    function createBoxShape(size) {
      return new _physicsSelector.BoxShape(size);
    }
    function createSphereShape(radius) {
      return new _physicsSelector.SphereShape(radius);
    }
  }), {
    "./physics-selector": 81
  } ],
  78: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.ERigidBodyType = void 0;
    var ERigidBodyType;
    exports.ERigidBodyType = ERigidBodyType;
    (function(ERigidBodyType) {
      ERigidBodyType[ERigidBodyType["DYNAMIC"] = 1] = "DYNAMIC";
      ERigidBodyType[ERigidBodyType["STATIC"] = 2] = "STATIC";
      ERigidBodyType[ERigidBodyType["KINEMATIC"] = 4] = "KINEMATIC";
    })(ERigidBodyType || (exports.ERigidBodyType = ERigidBodyType = {}));
  }), {} ],
  79: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.Physics3DManager = void 0;
    var _instance = require("./instance");
    var _physicsMaterial = require("./assets/physics-material");
    var _physicsRayResult = require("./physics-ray-result");
    var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;
    function _initializerDefineProperty(target, property, descriptor, context) {
      if (!descriptor) return;
      Object.defineProperty(target, property, {
        enumerable: descriptor.enumerable,
        configurable: descriptor.configurable,
        writable: descriptor.writable,
        value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
      });
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
      var desc = {};
      Object.keys(descriptor).forEach((function(key) {
        desc[key] = descriptor[key];
      }));
      desc.enumerable = !!desc.enumerable;
      desc.configurable = !!desc.configurable;
      ("value" in desc || desc.initializer) && (desc.writable = true);
      desc = decorators.slice().reverse().reduce((function(desc, decorator) {
        return decorator(target, property, desc) || desc;
      }), desc);
      if (context && void 0 !== desc.initializer) {
        desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
        desc.initializer = void 0;
      }
      if (void 0 === desc.initializer) {
        Object.defineProperty(target, property, desc);
        desc = null;
      }
      return desc;
    }
    function _initializerWarningHelper(descriptor, context) {
      throw new Error("Decorating class property failed. Please ensure that proposal-class-properties is enabled and runs after the decorators transform.");
    }
    var _cc$_decorator = cc._decorator, property = _cc$_decorator.property, ccclass = _cc$_decorator.ccclass;
    var Physics3DManager = (_dec = ccclass("cc.Physics3DManager"), _dec(_class = (_class2 = (function() {
      function Physics3DManager() {
        this.physicsWorld = void 0;
        this.raycastClosestResult = new _physicsRayResult.PhysicsRayResult();
        this.raycastResults = [];
        _initializerDefineProperty(this, "_enabled", _descriptor, this);
        _initializerDefineProperty(this, "_allowSleep", _descriptor2, this);
        _initializerDefineProperty(this, "_gravity", _descriptor3, this);
        _initializerDefineProperty(this, "_maxSubStep", _descriptor4, this);
        _initializerDefineProperty(this, "_fixedTime", _descriptor5, this);
        _initializerDefineProperty(this, "_useFixedTime", _descriptor6, this);
        this.useAccumulator = false;
        this._accumulator = 0;
        this.useFixedDigit = false;
        this.useInternalTime = false;
        this.fixDigits = {
          position: 5,
          rotation: 12,
          timeNow: 3
        };
        this._deltaTime = 0;
        this._lastTime = 0;
        this._material = null;
        this.raycastOptions = {
          groupIndex: -1,
          queryTrigger: true,
          maxDistance: Infinity
        };
        this.raycastResultPool = new cc.RecyclePool(function() {
          return new _physicsRayResult.PhysicsRayResult();
        }, 1);
        cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
        this.physicsWorld = (0, _instance.createPhysicsWorld)();
        this._lastTime = performance.now();
        true;
        this.gravity = this._gravity;
        this.allowSleep = this._allowSleep;
        this._material = new _physicsMaterial.PhysicsMaterial();
        this._material.friction = .1;
        this._material.restitution = .1;
        this._material.on("physics_material_update", this._updateMaterial, this);
        this.physicsWorld.defaultMaterial = this._material;
      }
      var _proto = Physics3DManager.prototype;
      _proto.update = function update(deltaTime) {
        false;
        if (!this._enabled) return;
        if (this.useInternalTime) {
          var now = parseFloat(performance.now().toFixed(this.fixDigits.timeNow));
          this._deltaTime = now > this._lastTime ? (now - this._lastTime) / 1e3 : 0;
          this._lastTime = now;
        } else this._deltaTime = deltaTime;
        cc.director.emit(cc.Director.EVENT_BEFORE_PHYSICS);
        false;
        if (this._useFixedTime) this.physicsWorld.step(this._fixedTime); else if (this.useAccumulator) {
          var i = 0;
          this._accumulator += this._deltaTime;
          while (i < this._maxSubStep && this._accumulator > this._fixedTime) {
            this.physicsWorld.step(this._fixedTime);
            this._accumulator -= this._fixedTime;
            i++;
          }
        } else this.physicsWorld.step(this._fixedTime, this._deltaTime, this._maxSubStep);
        cc.director.emit(cc.Director.EVENT_AFTER_PHYSICS);
      };
      _proto.raycast = function raycast(worldRay, groupIndexOrName, maxDistance, queryTrigger) {
        void 0 === groupIndexOrName && (groupIndexOrName = 0);
        void 0 === maxDistance && (maxDistance = Infinity);
        void 0 === queryTrigger && (queryTrigger = true);
        this.raycastResultPool.reset();
        this.raycastResults.length = 0;
        if ("string" == typeof groupIndexOrName) {
          var groupIndex = cc.game.groupList.indexOf(groupIndexOrName);
          -1 == groupIndex && (groupIndex = 0);
          this.raycastOptions.groupIndex = groupIndex;
        } else this.raycastOptions.groupIndex = groupIndexOrName;
        this.raycastOptions.maxDistance = maxDistance;
        this.raycastOptions.queryTrigger = queryTrigger;
        var result = this.physicsWorld.raycast(worldRay, this.raycastOptions, this.raycastResultPool, this.raycastResults);
        if (result) return this.raycastResults;
        return null;
      };
      _proto.raycastClosest = function raycastClosest(worldRay, groupIndexOrName, maxDistance, queryTrigger) {
        void 0 === groupIndexOrName && (groupIndexOrName = 0);
        void 0 === maxDistance && (maxDistance = Infinity);
        void 0 === queryTrigger && (queryTrigger = true);
        if ("string" == typeof groupIndexOrName) {
          var groupIndex = cc.game.groupList.indexOf(groupIndexOrName);
          -1 == groupIndex && (groupIndex = 0);
          this.raycastOptions.groupIndex = groupIndex;
        } else this.raycastOptions.groupIndex = groupIndexOrName;
        this.raycastOptions.maxDistance = maxDistance;
        this.raycastOptions.queryTrigger = queryTrigger;
        var result = this.physicsWorld.raycastClosest(worldRay, this.raycastOptions, this.raycastClosestResult);
        if (result) return this.raycastClosestResult;
        return null;
      };
      _proto._updateMaterial = function _updateMaterial() {
        true;
        this.physicsWorld.defaultMaterial = this._material;
      };
      _createClass(Physics3DManager, [ {
        key: "enabled",
        get: function get() {
          return this._enabled;
        },
        set: function set(value) {
          this._enabled = value;
        }
      }, {
        key: "allowSleep",
        get: function get() {
          return this._allowSleep;
        },
        set: function set(v) {
          this._allowSleep = v;
          true, true;
          this.physicsWorld.allowSleep = this._allowSleep;
        }
      }, {
        key: "maxSubStep",
        get: function get() {
          return this._maxSubStep;
        },
        set: function set(value) {
          this._maxSubStep = value;
        }
      }, {
        key: "deltaTime",
        get: function get() {
          return this._fixedTime;
        },
        set: function set(value) {
          this._fixedTime = value;
        }
      }, {
        key: "useFixedTime",
        get: function get() {
          return this._useFixedTime;
        },
        set: function set(value) {
          this._useFixedTime = value;
        }
      }, {
        key: "gravity",
        get: function get() {
          return this._gravity;
        },
        set: function set(gravity) {
          this._gravity.set(gravity);
          true, true;
          this.physicsWorld.gravity = gravity;
        }
      }, {
        key: "defaultMaterial",
        get: function get() {
          return this._material;
        }
      } ]);
      return Physics3DManager;
    })(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_enabled", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return false;
      }
    }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_allowSleep", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return true;
      }
    }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_gravity", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return new cc.Vec3(0, -10, 0);
      }
    }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_maxSubStep", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1;
      }
    }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_fixedTime", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return 1 / 60;
      }
    }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "_useFixedTime", [ property ], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: function initializer() {
        return true;
      }
    }), _class2)) || _class);
    exports.Physics3DManager = Physics3DManager;
  }), {
    "./assets/physics-material": 70,
    "./instance": 77,
    "./physics-ray-result": 80
  } ],
  80: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.PhysicsRayResult = void 0;
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var Vec3 = cc.Vec3;
    var PhysicsRayResult = (function() {
      function PhysicsRayResult() {
        this._hitPoint = new Vec3();
        this._distance = 0;
        this._collidier = null;
      }
      var _proto = PhysicsRayResult.prototype;
      _proto._assign = function _assign(hitPoint, distance, collider) {
        Vec3.copy(this._hitPoint, hitPoint);
        this._distance = distance;
        this._collidier = collider;
      };
      _proto.clone = function clone() {
        var c = new PhysicsRayResult();
        Vec3.copy(c._hitPoint, this._hitPoint);
        c._distance = this._distance;
        c._collidier = this._collidier;
        return c;
      };
      _createClass(PhysicsRayResult, [ {
        key: "hitPoint",
        get: function get() {
          return this._hitPoint;
        }
      }, {
        key: "distance",
        get: function get() {
          return this._distance;
        }
      }, {
        key: "collider",
        get: function get() {
          return this._collidier;
        }
      } ]);
      return PhysicsRayResult;
    })();
    exports.PhysicsRayResult = PhysicsRayResult;
  }), {} ],
  81: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.SphereShape = exports.RigidBody = exports.PhysicsWorld = exports.BoxShape = void 0;
    exports.instantiate = instantiate;
    var BoxShape;
    exports.BoxShape = BoxShape;
    var SphereShape;
    exports.SphereShape = SphereShape;
    var RigidBody;
    exports.RigidBody = RigidBody;
    var PhysicsWorld;
    exports.PhysicsWorld = PhysicsWorld;
    function instantiate(boxShape, sphereShape, body, world) {
      exports.BoxShape = BoxShape = boxShape;
      exports.SphereShape = SphereShape = sphereShape;
      exports.RigidBody = RigidBody = body;
      exports.PhysicsWorld = PhysicsWorld = world;
    }
  }), {} ],
  82: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.clearNodeTransformDirtyFlag = clearNodeTransformDirtyFlag;
    exports.clearNodeTransformRecord = clearNodeTransformRecord;
    exports.getWrap = getWrap;
    exports.setWrap = setWrap;
    exports.stringfyQuat = stringfyQuat;
    exports.stringfyVec3 = stringfyVec3;
    exports.updateWorldRT = updateWorldRT;
    exports.updateWorldTransform = updateWorldTransform;
    exports.worldDirty = worldDirty;
    function stringfyVec3(value) {
      return "(x: " + value.x + ", y: " + value.y + ", z: " + value.z + ")";
    }
    function stringfyQuat(value) {
      return "(x: " + value.x + ", y: " + value.y + ", z: " + value.z + ", w: " + value.w + ")";
    }
    function setWrap(object, wrapper) {
      object.__cc_wrapper__ = wrapper;
    }
    function getWrap(object) {
      return object.__cc_wrapper__;
    }
    var LocalDirtyFlag = cc.Node._LocalDirtyFlag;
    var PHYSICS_TRS = LocalDirtyFlag.PHYSICS_TRS;
    var ALL_TRS = LocalDirtyFlag.ALL_TRS;
    var SKEW = LocalDirtyFlag.SKEW;
    var FLAG_TRANSFORM = cc.RenderFlow.FLAG_TRANSFORM;
    var Mat3 = cc.Mat3;
    var Mat4 = cc.Mat4;
    var Vec3 = cc.Vec3;
    var Quat = cc.Quat;
    var Trs = cc.Trs;
    var _nodeArray = [];
    var _lpos = cc.v3();
    var _lrot = cc.quat();
    var _mat3 = new Mat3();
    var _mat3m = _mat3.m;
    var _quat = cc.quat();
    var _mat4 = cc.mat4();
    var _nodeTransformRecord = {};
    function clearNodeTransformDirtyFlag() {
      for (var key in _nodeTransformRecord) {
        var physicsNode = _nodeTransformRecord[key];
        physicsNode._localMatDirty &= ~ALL_TRS;
        if (!(physicsNode._localMatDirty & SKEW)) {
          physicsNode._worldMatDirty = false;
          false;
        }
      }
      _nodeTransformRecord = {};
      _nodeArray.length = 0;
    }
    function clearNodeTransformRecord() {
      _nodeTransformRecord = {};
      _nodeArray.length = 0;
    }
    function updateWorldTransform(node, traverseAllNode) {
      void 0 === traverseAllNode && (traverseAllNode = false);
      var cur = node;
      var i = 0;
      var needUpdateTransform = false;
      var physicsDirtyFlag = 0;
      while (cur) {
        if (!traverseAllNode && _nodeTransformRecord[cur._id]) {
          physicsDirtyFlag |= cur._localMatDirty & PHYSICS_TRS;
          needUpdateTransform = needUpdateTransform || !!physicsDirtyFlag;
          break;
        }
        _nodeArray[i++] = cur;
        cur._localMatDirty & PHYSICS_TRS && (needUpdateTransform = true);
        cur = cur._parent;
      }
      if (!needUpdateTransform) return false;
      var child;
      var childWorldMat, curWorldMat, childTrs, childLocalMat;
      var wpos, wrot, wscale;
      _nodeArray.length = i;
      while (i) {
        child = _nodeArray[--i];
        !traverseAllNode && (_nodeTransformRecord[child._id] = child);
        childWorldMat = child._worldMatrix;
        childLocalMat = child._matrix;
        childTrs = child._trs;
        wpos = child.__wpos = child.__wpos || cc.v3();
        wrot = child.__wrot = child.__wrot || cc.quat();
        wscale = child.__wscale = child.__wscale || cc.v3();
        child._localMatDirty & PHYSICS_TRS && Trs.toMat4(childLocalMat, childTrs);
        child._localMatDirty |= physicsDirtyFlag;
        physicsDirtyFlag |= child._localMatDirty & PHYSICS_TRS;
        if (!(physicsDirtyFlag & PHYSICS_TRS)) {
          cur = child;
          continue;
        }
        if (cur) {
          curWorldMat = cur._worldMatrix;
          Trs.toPosition(_lpos, childTrs);
          Vec3.transformMat4(wpos, _lpos, curWorldMat);
          Mat4.multiply(childWorldMat, curWorldMat, childLocalMat);
          Trs.toRotation(_lrot, childTrs);
          Quat.multiply(wrot, cur.__wrot, _lrot);
          Mat3.fromQuat(_mat3, Quat.conjugate(_quat, wrot));
          Mat3.multiplyMat4(_mat3, _mat3, childWorldMat);
          wscale.x = _mat3m[0];
          wscale.y = _mat3m[4];
          wscale.z = _mat3m[8];
        } else {
          Trs.toPosition(wpos, childTrs);
          Trs.toRotation(wrot, childTrs);
          Trs.toScale(wscale, childTrs);
          Mat4.copy(childWorldMat, childLocalMat);
        }
        cur = child;
      }
      return true;
    }
    function updateWorldRT(node, position, rotation) {
      var parent = node.parent;
      if (parent) {
        updateWorldTransform(parent, true);
        Vec3.transformMat4(_lpos, position, Mat4.invert(_mat4, parent._worldMatrix));
        Quat.multiply(_quat, Quat.conjugate(_quat, parent.__wrot), rotation);
        node.setPosition(_lpos);
        node.setRotation(_quat);
      } else {
        node.setPosition(position);
        node.setRotation(rotation);
      }
    }
    function worldDirty(node) {
      var cur = node;
      while (cur) {
        if (cur._worldMatDirty) return true;
        cur = cur._parent;
      }
      return false;
    }
  }), {} ],
  83: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = _default;
    var _vec = _interopRequireDefault(require("../../value-types/vec3"));
    var _vertexData = _interopRequireDefault(require("./vertex-data"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var temp1 = new _vec["default"]();
    var temp2 = new _vec["default"]();
    var temp3 = new _vec["default"]();
    var r = new _vec["default"]();
    var c0 = new _vec["default"]();
    var c1 = new _vec["default"]();
    var c2 = new _vec["default"]();
    var c3 = new _vec["default"]();
    var c4 = new _vec["default"]();
    var c5 = new _vec["default"]();
    var c6 = new _vec["default"]();
    var c7 = new _vec["default"]();
    function _default(width, height, length, opts) {
      void 0 === width && (width = 1);
      void 0 === height && (height = 1);
      void 0 === length && (length = 1);
      void 0 === opts && (opts = {
        widthSegments: 1,
        heightSegments: 1,
        lengthSegments: 1,
        invWinding: false
      });
      var ws = opts.widthSegments;
      var hs = opts.heightSegments;
      var ls = opts.lengthSegments;
      var inv = opts.invWinding;
      var hw = .5 * width;
      var hh = .5 * height;
      var hl = .5 * length;
      var corners = [ _vec["default"].set(c0, -hw, -hh, hl), _vec["default"].set(c1, hw, -hh, hl), _vec["default"].set(c2, hw, hh, hl), _vec["default"].set(c3, -hw, hh, hl), _vec["default"].set(c4, hw, -hh, -hl), _vec["default"].set(c5, -hw, -hh, -hl), _vec["default"].set(c6, -hw, hh, -hl), _vec["default"].set(c7, hw, hh, -hl) ];
      var faceAxes = [ [ 2, 3, 1 ], [ 4, 5, 7 ], [ 7, 6, 2 ], [ 1, 0, 4 ], [ 1, 4, 2 ], [ 5, 0, 6 ] ];
      var faceNormals = [ [ 0, 0, 1 ], [ 0, 0, -1 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 1, 0, 0 ], [ -1, 0, 0 ] ];
      var positions = [];
      var normals = [];
      var uvs = [];
      var indices = [];
      var minPos = new _vec["default"](-hw, -hh, -hl);
      var maxPos = new _vec["default"](hw, hh, hl);
      var boundingRadius = Math.sqrt(hw * hw + hh * hh + hl * hl);
      function _buildPlane(side, uSegments, vSegments) {
        var u, v;
        var ix, iy;
        var offset = positions.length / 3;
        var faceAxe = faceAxes[side];
        var faceNormal = faceNormals[side];
        for (iy = 0; iy <= vSegments; iy++) for (ix = 0; ix <= uSegments; ix++) {
          u = ix / uSegments;
          v = iy / vSegments;
          _vec["default"].lerp(temp1, corners[faceAxe[0]], corners[faceAxe[1]], u);
          _vec["default"].lerp(temp2, corners[faceAxe[0]], corners[faceAxe[2]], v);
          _vec["default"].subtract(temp3, temp2, corners[faceAxe[0]]);
          _vec["default"].add(r, temp1, temp3);
          positions.push(r.x, r.y, r.z);
          normals.push(faceNormal[0], faceNormal[1], faceNormal[2]);
          uvs.push(u, v);
          if (ix < uSegments && iy < vSegments) {
            var useg1 = uSegments + 1;
            var a = ix + iy * useg1;
            var b = ix + (iy + 1) * useg1;
            var c = ix + 1 + (iy + 1) * useg1;
            var d = ix + 1 + iy * useg1;
            if (inv) {
              indices.push(offset + a, offset + b, offset + d);
              indices.push(offset + d, offset + b, offset + c);
            } else {
              indices.push(offset + a, offset + d, offset + b);
              indices.push(offset + b, offset + d, offset + c);
            }
          }
        }
      }
      _buildPlane(0, ws, hs);
      _buildPlane(4, ls, hs);
      _buildPlane(1, ws, hs);
      _buildPlane(5, ls, hs);
      _buildPlane(3, ws, ls);
      _buildPlane(2, ws, ls);
      return new _vertexData["default"](positions, normals, uvs, indices, minPos, maxPos, boundingRadius);
    }
    module.exports = exports["default"];
  }), {
    "../../value-types/vec3": 411,
    "./vertex-data": 94
  } ],
  84: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = _default;
    var _vec = _interopRequireDefault(require("../../value-types/vec3"));
    var _vertexData = _interopRequireDefault(require("./vertex-data"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var temp1 = cc.v3(0, 0, 0);
    var temp2 = cc.v3(0, 0, 0);
    function _default(radiusTop, radiusBottom, height, opts) {
      void 0 === radiusTop && (radiusTop = .5);
      void 0 === radiusBottom && (radiusBottom = .5);
      void 0 === height && (height = 2);
      void 0 === opts && (opts = {
        sides: 32,
        heightSegments: 32,
        arc: 2 * Math.PI
      });
      var torsoHeight = height - radiusTop - radiusBottom;
      var sides = opts.sides;
      var heightSegments = opts.heightSegments;
      var bottomProp = radiusBottom / height;
      var torProp = torsoHeight / height;
      var topProp = radiusTop / height;
      var bottomSegments = Math.floor(heightSegments * bottomProp);
      var topSegments = Math.floor(heightSegments * topProp);
      var torSegments = Math.floor(heightSegments * torProp);
      var topOffset = torsoHeight + radiusBottom - height / 2;
      var torOffset = radiusBottom - height / 2;
      var bottomOffset = radiusBottom - height / 2;
      var arc = opts.arc;
      var positions = [];
      var normals = [];
      var uvs = [];
      var indices = [];
      var maxRadius = Math.max(radiusTop, radiusBottom);
      var minPos = cc.v3(-maxRadius, -height / 2, -maxRadius);
      var maxPos = cc.v3(maxRadius, height / 2, maxRadius);
      var boundingRadius = height / 2;
      var index = 0;
      var indexArray = [];
      generateBottom();
      generateTorso();
      generateTop();
      return new _vertexData["default"](positions, normals, uvs, indices, minPos, maxPos, boundingRadius);
      function generateTorso() {
        var slope = (radiusTop - radiusBottom) / torsoHeight;
        for (var y = 0; y <= torSegments; y++) {
          var indexRow = [];
          var lat = y / torSegments;
          var radius = lat * (radiusTop - radiusBottom) + radiusBottom;
          for (var x = 0; x <= sides; ++x) {
            var u = x / sides;
            var v = lat * torProp + bottomProp;
            var theta = u * arc - arc / 4;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            positions.push(radius * sinTheta);
            positions.push(lat * torsoHeight + torOffset);
            positions.push(radius * cosTheta);
            _vec["default"].normalize(temp1, _vec["default"].set(temp2, sinTheta, -slope, cosTheta));
            normals.push(temp1.x);
            normals.push(temp1.y);
            normals.push(temp1.z);
            uvs.push(u, v);
            indexRow.push(index);
            ++index;
          }
          indexArray.push(indexRow);
        }
        for (var _y = 0; _y < torSegments; ++_y) for (var _x = 0; _x < sides; ++_x) {
          var i1 = indexArray[_y][_x];
          var i2 = indexArray[_y + 1][_x];
          var i3 = indexArray[_y + 1][_x + 1];
          var i4 = indexArray[_y][_x + 1];
          indices.push(i1);
          indices.push(i4);
          indices.push(i2);
          indices.push(i4);
          indices.push(i3);
          indices.push(i2);
        }
      }
      function generateBottom() {
        for (var lat = 0; lat <= bottomSegments; ++lat) {
          var theta = lat * Math.PI / bottomSegments / 2;
          var sinTheta = Math.sin(theta);
          var cosTheta = -Math.cos(theta);
          for (var lon = 0; lon <= sides; ++lon) {
            var phi = 2 * lon * Math.PI / sides - Math.PI / 2;
            var sinPhi = Math.sin(phi);
            var cosPhi = Math.cos(phi);
            var x = sinPhi * sinTheta;
            var y = cosTheta;
            var z = cosPhi * sinTheta;
            var u = lon / sides;
            var v = lat / heightSegments;
            positions.push(x * radiusBottom, y * radiusBottom + bottomOffset, z * radiusBottom);
            normals.push(x, y, z);
            uvs.push(u, v);
            if (lat < bottomSegments && lon < sides) {
              var seg1 = sides + 1;
              var a = seg1 * lat + lon;
              var b = seg1 * (lat + 1) + lon;
              var c = seg1 * (lat + 1) + lon + 1;
              var d = seg1 * lat + lon + 1;
              indices.push(a, d, b);
              indices.push(d, c, b);
            }
            ++index;
          }
        }
      }
      function generateTop() {
        for (var lat = 0; lat <= topSegments; ++lat) {
          var theta = lat * Math.PI / topSegments / 2 + Math.PI / 2;
          var sinTheta = Math.sin(theta);
          var cosTheta = -Math.cos(theta);
          for (var lon = 0; lon <= sides; ++lon) {
            var phi = 2 * lon * Math.PI / sides - Math.PI / 2;
            var sinPhi = Math.sin(phi);
            var cosPhi = Math.cos(phi);
            var x = sinPhi * sinTheta;
            var y = cosTheta;
            var z = cosPhi * sinTheta;
            var u = lon / sides;
            var v = lat / heightSegments + (1 - topProp);
            positions.push(x * radiusTop, y * radiusTop + topOffset, z * radiusTop);
            normals.push(x, y, z);
            uvs.push(u, v);
            if (lat < topSegments && lon < sides) {
              var seg1 = sides + 1;
              var a = seg1 * lat + lon + indexArray[torSegments][sides] + 1;
              var b = seg1 * (lat + 1) + lon + indexArray[torSegments][sides] + 1;
              var c = seg1 * (lat + 1) + lon + 1 + indexArray[torSegments][sides] + 1;
              var d = seg1 * lat + lon + 1 + indexArray[torSegments][sides] + 1;
              indices.push(a, d, b);
              indices.push(d, c, b);
            }
          }
        }
      }
    }
    module.exports = exports["default"];
  }), {
    "../../value-types/vec3": 411,
    "./vertex-data": 94
  } ],
  85: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = _default;
    var _cylinder = _interopRequireDefault(require("./cylinder"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _default(radius, height, opts) {
      void 0 === radius && (radius = .5);
      void 0 === height && (height = 1);
      void 0 === opts && (opts = {
        radialSegments: 32,
        heightSegments: 1,
        capped: true,
        arc: 2 * Math.PI
      });
      return (0, _cylinder["default"])(0, radius, height, opts);
    }
    module.exports = exports["default"];
  }), {
    "./cylinder": 86
  } ],
  86: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = _default;
    var _vec = _interopRequireDefault(require("../../value-types/vec3"));
    var _vertexData = _interopRequireDefault(require("./vertex-data"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var temp1 = new _vec["default"]();
    var temp2 = new _vec["default"]();
    function _default(radiusTop, radiusBottom, height, opts) {
      void 0 === radiusTop && (radiusTop = .5);
      void 0 === radiusBottom && (radiusBottom = .5);
      void 0 === height && (height = 2);
      void 0 === opts && (opts = {
        radialSegments: 32,
        heightSegments: 1,
        capped: true,
        arc: 2 * Math.PI
      });
      var halfHeight = .5 * height;
      var radialSegments = opts.radialSegments;
      var heightSegments = opts.heightSegments;
      var capped = opts.capped;
      var arc = opts.arc;
      var cntCap = 0;
      if (!capped) {
        radiusTop > 0 && cntCap++;
        radiusBottom > 0 && cntCap++;
      }
      var vertCount = (radialSegments + 1) * (heightSegments + 1);
      capped && (vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap);
      var indexCount = radialSegments * heightSegments * 2 * 3;
      capped && (indexCount += radialSegments * cntCap * 3);
      var indices = new Array(indexCount);
      var positions = new Array(3 * vertCount);
      var normals = new Array(3 * vertCount);
      var uvs = new Array(2 * vertCount);
      var maxRadius = Math.max(radiusTop, radiusBottom);
      var minPos = new _vec["default"](-maxRadius, -halfHeight, -maxRadius);
      var maxPos = new _vec["default"](maxRadius, halfHeight, maxRadius);
      var boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight);
      var index = 0;
      var indexOffset = 0;
      generateTorso();
      if (capped) {
        radiusBottom > 0 && generateCap(false);
        radiusTop > 0 && generateCap(true);
      }
      return new _vertexData["default"](positions, normals, uvs, indices, minPos, maxPos, boundingRadius);
      function generateTorso() {
        var indexArray = [];
        var r = radiusTop - radiusBottom;
        var slope = r * r / height * Math.sign(r);
        for (var y = 0; y <= heightSegments; y++) {
          var indexRow = [];
          var v = y / heightSegments;
          var radius = v * r + radiusBottom;
          for (var x = 0; x <= radialSegments; ++x) {
            var u = x / radialSegments;
            var theta = u * arc;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            positions[3 * index] = radius * sinTheta;
            positions[3 * index + 1] = v * height - halfHeight;
            positions[3 * index + 2] = radius * cosTheta;
            _vec["default"].normalize(temp1, _vec["default"].set(temp2, sinTheta, -slope, cosTheta));
            normals[3 * index] = temp1.x;
            normals[3 * index + 1] = temp1.y;
            normals[3 * index + 2] = temp1.z;
            uvs[2 * index] = 2 * (1 - u) % 1;
            uvs[2 * index + 1] = v;
            indexRow.push(index);
            ++index;
          }
          indexArray.push(indexRow);
        }
        for (var _y = 0; _y < heightSegments; ++_y) for (var _x = 0; _x < radialSegments; ++_x) {
          var i1 = indexArray[_y][_x];
          var i2 = indexArray[_y + 1][_x];
          var i3 = indexArray[_y + 1][_x + 1];
          var i4 = indexArray[_y][_x + 1];
          indices[indexOffset] = i1;
          ++indexOffset;
          indices[indexOffset] = i4;
          ++indexOffset;
          indices[indexOffset] = i2;
          ++indexOffset;
          indices[indexOffset] = i4;
          ++indexOffset;
          indices[indexOffset] = i3;
          ++indexOffset;
          indices[indexOffset] = i2;
          ++indexOffset;
        }
      }
      function generateCap(top) {
        var centerIndexStart, centerIndexEnd;
        var radius = top ? radiusTop : radiusBottom;
        var sign = top ? 1 : -1;
        centerIndexStart = index;
        for (var x = 1; x <= radialSegments; ++x) {
          positions[3 * index] = 0;
          positions[3 * index + 1] = halfHeight * sign;
          positions[3 * index + 2] = 0;
          normals[3 * index] = 0;
          normals[3 * index + 1] = sign;
          normals[3 * index + 2] = 0;
          uvs[2 * index] = .5;
          uvs[2 * index + 1] = .5;
          ++index;
        }
        centerIndexEnd = index;
        for (var _x2 = 0; _x2 <= radialSegments; ++_x2) {
          var u = _x2 / radialSegments;
          var theta = u * arc;
          var cosTheta = Math.cos(theta);
          var sinTheta = Math.sin(theta);
          positions[3 * index] = radius * sinTheta;
          positions[3 * index + 1] = halfHeight * sign;
          positions[3 * index + 2] = radius * cosTheta;
          normals[3 * index] = 0;
          normals[3 * index + 1] = sign;
          normals[3 * index + 2] = 0;
          uvs[2 * index] = .5 - .5 * sinTheta * sign;
          uvs[2 * index + 1] = .5 + .5 * cosTheta;
          ++index;
        }
        for (var _x3 = 0; _x3 < radialSegments; ++_x3) {
          var c = centerIndexStart + _x3;
          var i = centerIndexEnd + _x3;
          if (top) {
            indices[indexOffset] = i + 1;
            ++indexOffset;
            indices[indexOffset] = c;
            ++indexOffset;
            indices[indexOffset] = i;
            ++indexOffset;
          } else {
            indices[indexOffset] = c;
            ++indexOffset;
            indices[indexOffset] = i + 1;
            ++indexOffset;
            indices[indexOffset] = i;
            ++indexOffset;
          }
        }
      }
    }
    module.exports = exports["default"];
  }), {
    "../../value-types/vec3": 411,
    "./vertex-data": 94
  } ],
  87: [ (function(require, module, exports) {
    "use strict";
    var utils = _interopRequireWildcard(require("./utils"));
    var _box = _interopRequireDefault(require("./box"));
    var _cone = _interopRequireDefault(require("./cone"));
    var _cylinder = _interopRequireDefault(require("./cylinder"));
    var _plane = _interopRequireDefault(require("./plane"));
    var _quad = _interopRequireDefault(require("./quad"));
    var _sphere = _interopRequireDefault(require("./sphere"));
    var _torus = _interopRequireDefault(require("./torus"));
    var _capsule = _interopRequireDefault(require("./capsule"));
    var _polyhedron = require("./polyhedron");
    var _vertexData = _interopRequireDefault(require("./vertex-data"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if ("function" !== typeof WeakMap) return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) return obj;
      if (null === obj || "object" !== typeof obj && "function" !== typeof obj) return {
        default: obj
      };
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) return cache.get(obj);
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
      }
      newObj["default"] = obj;
      cache && cache.set(obj, newObj);
      return newObj;
    }
    cc.primitive = Object.assign({
      box: _box["default"],
      cone: _cone["default"],
      cylinder: _cylinder["default"],
      plane: _plane["default"],
      quad: _quad["default"],
      sphere: _sphere["default"],
      torus: _torus["default"],
      capsule: _capsule["default"],
      polyhedron: _polyhedron.polyhedron,
      PolyhedronType: _polyhedron.PolyhedronType,
      VertexData: _vertexData["default"]
    }, utils);
  }), {
    "./box": 83,
    "./capsule": 84,
    "./cone": 85,
    "./cylinder": 86,
    "./plane": 88,
    "./polyhedron": 89,
    "./quad": 90,
    "./sphere": 91,
    "./torus": 92,
    "./utils": 93,
    "./vertex-data": 94
  } ],
  88: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = _default;
    var _vec = _interopRequireDefault(require("../../value-types/vec3"));
    var _vertexData = _interopRequireDefault(require("./vertex-data"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var temp1 = new _vec["default"]();
    var temp2 = new _vec["default"]();
    var temp3 = new _vec["default"]();
    var r = new _vec["default"]();
    var c00 = new _vec["default"]();
    var c10 = new _vec["default"]();
    var c01 = new _vec["default"]();
    function _default(width, length, opts) {
      void 0 === width && (width = 10);
      void 0 === length && (length = 10);
      void 0 === opts && (opts = {
        widthSegments: 10,
        lengthSegments: 10
      });
      var uSegments = opts.widthSegments;
      var vSegments = opts.lengthSegments;
      var hw = .5 * width;
      var hl = .5 * length;
      var positions = [];
      var normals = [];
      var uvs = [];
      var indices = [];
      var minPos = new _vec["default"](-hw, 0, -hl);
      var maxPos = new _vec["default"](hw, 0, hl);
      var boundingRadius = Math.sqrt(width * width + length * length);
      _vec["default"].set(c00, -hw, 0, hl);
      _vec["default"].set(c10, hw, 0, hl);
      _vec["default"].set(c01, -hw, 0, -hl);
      for (var y = 0; y <= vSegments; y++) for (var x = 0; x <= uSegments; x++) {
        var u = x / uSegments;
        var v = y / vSegments;
        _vec["default"].lerp(temp1, c00, c10, u);
        _vec["default"].lerp(temp2, c00, c01, v);
        _vec["default"].sub(temp3, temp2, c00);
        _vec["default"].add(r, temp1, temp3);
        positions.push(r.x, r.y, r.z);
        normals.push(0, 1, 0);
        uvs.push(u, v);
        if (x < uSegments && y < vSegments) {
          var useg1 = uSegments + 1;
          var a = x + y * useg1;
          var b = x + (y + 1) * useg1;
          var c = x + 1 + (y + 1) * useg1;
          var d = x + 1 + y * useg1;
          indices.push(a, d, b);
          indices.push(d, c, b);
        }
      }
      return new _vertexData["default"](positions, normals, uvs, indices, minPos, maxPos, boundingRadius);
    }
    module.exports = exports["default"];
  }), {
    "../../value-types/vec3": 411,
    "./vertex-data": 94
  } ],
  89: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.polyhedron = exports.PolyhedronType = void 0;
    var _utils = require("./utils");
    var _vertexData = _interopRequireDefault(require("./vertex-data"));
    var _valueTypes = require("../../value-types");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PolyhedronType = cc.Enum({
      Tetrahedron: 0,
      Octahedron: 1,
      Dodecahedron: 2,
      Icosahedron: 3,
      Rhombicuboctahedron: 4,
      TriangularPrism: 5,
      PentagonalPrism: 6,
      HexagonalPrism: 7,
      SquarePyramid: 8,
      PentagonalPyramid: 9,
      TriangularDipyramid: 10,
      PentagonalDipyramid: 11,
      ElongatedSquareDipyramid: 12,
      ElongatedPentagonalDipyramid: 13,
      ElongatedPentagonalCupola: 14
    });
    exports.PolyhedronType = PolyhedronType;
    var polyhedra = [];
    polyhedra[0] = {
      vertex: [ [ 0, 0, 1.732051 ], [ 1.632993, 0, -.5773503 ], [ -.8164966, 1.414214, -.5773503 ], [ -.8164966, -1.414214, -.5773503 ] ],
      face: [ [ 0, 1, 2 ], [ 0, 2, 3 ], [ 0, 3, 1 ], [ 1, 3, 2 ] ]
    };
    polyhedra[1] = {
      vertex: [ [ 0, 0, 1.414214 ], [ 1.414214, 0, 0 ], [ 0, 1.414214, 0 ], [ -1.414214, 0, 0 ], [ 0, -1.414214, 0 ], [ 0, 0, -1.414214 ] ],
      face: [ [ 0, 1, 2 ], [ 0, 2, 3 ], [ 0, 3, 4 ], [ 0, 4, 1 ], [ 1, 4, 5 ], [ 1, 5, 2 ], [ 2, 5, 3 ], [ 3, 5, 4 ] ]
    };
    polyhedra[2] = {
      vertex: [ [ 0, 0, 1.070466 ], [ .7136442, 0, .7978784 ], [ -.3568221, .618034, .7978784 ], [ -.3568221, -.618034, .7978784 ], [ .7978784, .618034, .3568221 ], [ .7978784, -.618034, .3568221 ], [ -.9341724, .381966, .3568221 ], [ .1362939, 1, .3568221 ], [ .1362939, -1, .3568221 ], [ -.9341724, -.381966, .3568221 ], [ .9341724, .381966, -.3568221 ], [ .9341724, -.381966, -.3568221 ], [ -.7978784, .618034, -.3568221 ], [ -.1362939, 1, -.3568221 ], [ -.1362939, -1, -.3568221 ], [ -.7978784, -.618034, -.3568221 ], [ .3568221, .618034, -.7978784 ], [ .3568221, -.618034, -.7978784 ], [ -.7136442, 0, -.7978784 ], [ 0, 0, -1.070466 ] ],
      face: [ [ 0, 1, 4, 7, 2 ], [ 0, 2, 6, 9, 3 ], [ 0, 3, 8, 5, 1 ], [ 1, 5, 11, 10, 4 ], [ 2, 7, 13, 12, 6 ], [ 3, 9, 15, 14, 8 ], [ 4, 10, 16, 13, 7 ], [ 5, 8, 14, 17, 11 ], [ 6, 12, 18, 15, 9 ], [ 10, 11, 17, 19, 16 ], [ 12, 13, 16, 19, 18 ], [ 14, 15, 18, 19, 17 ] ]
    };
    polyhedra[3] = {
      vertex: [ [ 0, 0, 1.175571 ], [ 1.051462, 0, .5257311 ], [ .3249197, 1, .5257311 ], [ -.8506508, .618034, .5257311 ], [ -.8506508, -.618034, .5257311 ], [ .3249197, -1, .5257311 ], [ .8506508, .618034, -.5257311 ], [ .8506508, -.618034, -.5257311 ], [ -.3249197, 1, -.5257311 ], [ -1.051462, 0, -.5257311 ], [ -.3249197, -1, -.5257311 ], [ 0, 0, -1.175571 ] ],
      face: [ [ 0, 1, 2 ], [ 0, 2, 3 ], [ 0, 3, 4 ], [ 0, 4, 5 ], [ 0, 5, 1 ], [ 1, 5, 7 ], [ 1, 7, 6 ], [ 1, 6, 2 ], [ 2, 6, 8 ], [ 2, 8, 3 ], [ 3, 8, 9 ], [ 3, 9, 4 ], [ 4, 9, 10 ], [ 4, 10, 5 ], [ 5, 10, 7 ], [ 6, 7, 11 ], [ 6, 11, 8 ], [ 7, 10, 11 ], [ 8, 11, 9 ], [ 9, 11, 10 ] ]
    };
    polyhedra[4] = {
      vertex: [ [ 0, 0, 1.070722 ], [ .7148135, 0, .7971752 ], [ -.104682, .7071068, .7971752 ], [ -.6841528, .2071068, .7971752 ], [ -.104682, -.7071068, .7971752 ], [ .6101315, .7071068, .5236279 ], [ 1.04156, .2071068, .1367736 ], [ .6101315, -.7071068, .5236279 ], [ -.3574067, 1, .1367736 ], [ -.7888348, -.5, .5236279 ], [ -.9368776, .5, .1367736 ], [ -.3574067, -1, .1367736 ], [ .3574067, 1, -.1367736 ], [ .9368776, -.5, -.1367736 ], [ .7888348, .5, -.5236279 ], [ .3574067, -1, -.1367736 ], [ -.6101315, .7071068, -.5236279 ], [ -1.04156, -.2071068, -.1367736 ], [ -.6101315, -.7071068, -.5236279 ], [ .104682, .7071068, -.7971752 ], [ .6841528, -.2071068, -.7971752 ], [ .104682, -.7071068, -.7971752 ], [ -.7148135, 0, -.7971752 ], [ 0, 0, -1.070722 ] ],
      face: [ [ 0, 2, 3 ], [ 1, 6, 5 ], [ 4, 9, 11 ], [ 7, 15, 13 ], [ 8, 16, 10 ], [ 12, 14, 19 ], [ 17, 22, 18 ], [ 20, 21, 23 ], [ 0, 1, 5, 2 ], [ 0, 3, 9, 4 ], [ 0, 4, 7, 1 ], [ 1, 7, 13, 6 ], [ 2, 5, 12, 8 ], [ 2, 8, 10, 3 ], [ 3, 10, 17, 9 ], [ 4, 11, 15, 7 ], [ 5, 6, 14, 12 ], [ 6, 13, 20, 14 ], [ 8, 12, 19, 16 ], [ 9, 17, 18, 11 ], [ 10, 16, 22, 17 ], [ 11, 18, 21, 15 ], [ 13, 15, 21, 20 ], [ 14, 20, 23, 19 ], [ 16, 19, 23, 22 ], [ 18, 22, 23, 21 ] ]
    };
    polyhedra[5] = {
      vertex: [ [ 0, 0, 1.322876 ], [ 1.309307, 0, .1889822 ], [ -.9819805, .8660254, .1889822 ], [ .1636634, -1.299038, .1889822 ], [ .3273268, .8660254, -.9449112 ], [ -.8183171, -.4330127, -.9449112 ] ],
      face: [ [ 0, 3, 1 ], [ 2, 4, 5 ], [ 0, 1, 4, 2 ], [ 0, 2, 5, 3 ], [ 1, 3, 5, 4 ] ]
    };
    polyhedra[6] = {
      vertex: [ [ 0, 0, 1.159953 ], [ 1.013464, 0, .5642542 ], [ -.3501431, .9510565, .5642542 ], [ -.7715208, -.6571639, .5642542 ], [ .6633206, .9510565, -.03144481 ], [ .8682979, -.6571639, -.3996071 ], [ -1.121664, .2938926, -.03144481 ], [ -.2348831, -1.063314, -.3996071 ], [ .5181548, .2938926, -.9953061 ], [ -.5850262, -.112257, -.9953061 ] ],
      face: [ [ 0, 1, 4, 2 ], [ 0, 2, 6, 3 ], [ 1, 5, 8, 4 ], [ 3, 6, 9, 7 ], [ 5, 7, 9, 8 ], [ 0, 3, 7, 5, 1 ], [ 2, 4, 8, 9, 6 ] ]
    };
    polyhedra[7] = {
      vertex: [ [ 0, 0, 1.118034 ], [ .8944272, 0, .6708204 ], [ -.2236068, .8660254, .6708204 ], [ -.7826238, -.4330127, .6708204 ], [ .6708204, .8660254, .2236068 ], [ 1.006231, -.4330127, -.2236068 ], [ -1.006231, .4330127, .2236068 ], [ -.6708204, -.8660254, -.2236068 ], [ .7826238, .4330127, -.6708204 ], [ .2236068, -.8660254, -.6708204 ], [ -.8944272, 0, -.6708204 ], [ 0, 0, -1.118034 ] ],
      face: [ [ 0, 1, 4, 2 ], [ 0, 2, 6, 3 ], [ 1, 5, 8, 4 ], [ 3, 6, 10, 7 ], [ 5, 9, 11, 8 ], [ 7, 10, 11, 9 ], [ 0, 3, 7, 9, 5, 1 ], [ 2, 4, 8, 11, 10, 6 ] ]
    };
    polyhedra[8] = {
      vertex: [ [ -.729665, .670121, .319155 ], [ -.655235, -.29213, -.754096 ], [ -.093922, -.607123, .537818 ], [ .702196, .595691, .485187 ], [ .776626, -.36656, -.588064 ] ],
      face: [ [ 1, 4, 2 ], [ 0, 1, 2 ], [ 3, 0, 2 ], [ 4, 3, 2 ], [ 4, 1, 0, 3 ] ]
    };
    polyhedra[9] = {
      vertex: [ [ -.868849, -.100041, .61257 ], [ -.329458, .976099, .28078 ], [ -.26629, -.013796, -.477654 ], [ -.13392, -1.034115, .229829 ], [ .738834, .707117, -.307018 ], [ .859683, -.535264, -.338508 ] ],
      face: [ [ 3, 0, 2 ], [ 5, 3, 2 ], [ 4, 5, 2 ], [ 1, 4, 2 ], [ 0, 1, 2 ], [ 0, 3, 5, 4, 1 ] ]
    };
    polyhedra[10] = {
      vertex: [ [ -.610389, .243975, .531213 ], [ -.187812, -.48795, -.664016 ], [ -.187812, .9759, -.664016 ], [ .187812, -.9759, .664016 ], [ .798201, .243975, .132803 ] ],
      face: [ [ 1, 3, 0 ], [ 3, 4, 0 ], [ 3, 1, 4 ], [ 0, 2, 1 ], [ 0, 4, 2 ], [ 2, 4, 1 ] ]
    };
    polyhedra[11] = {
      vertex: [ [ -1.028778, .392027, -.048786 ], [ -.640503, -.646161, .621837 ], [ -.125162, -.395663, -.540059 ], [ .004683, .888447, -.651988 ], [ .125161, .395663, .540059 ], [ .632925, -.791376, .433102 ], [ 1.031672, .157063, -.354165 ] ],
      face: [ [ 3, 2, 0 ], [ 2, 1, 0 ], [ 2, 5, 1 ], [ 0, 4, 3 ], [ 0, 1, 4 ], [ 4, 1, 5 ], [ 2, 3, 6 ], [ 3, 4, 6 ], [ 5, 2, 6 ], [ 4, 5, 6 ] ]
    };
    polyhedra[12] = {
      vertex: [ [ -.669867, .334933, -.529576 ], [ -.669867, .334933, .529577 ], [ -.4043, 1.212901, 0 ], [ -.334933, -.669867, -.529576 ], [ -.334933, -.669867, .529577 ], [ .334933, .669867, -.529576 ], [ .334933, .669867, .529577 ], [ .4043, -1.212901, 0 ], [ .669867, -.334933, -.529576 ], [ .669867, -.334933, .529577 ] ],
      face: [ [ 8, 9, 7 ], [ 6, 5, 2 ], [ 3, 8, 7 ], [ 5, 0, 2 ], [ 4, 3, 7 ], [ 0, 1, 2 ], [ 9, 4, 7 ], [ 1, 6, 2 ], [ 9, 8, 5, 6 ], [ 8, 3, 0, 5 ], [ 3, 4, 1, 0 ], [ 4, 9, 6, 1 ] ]
    };
    polyhedra[13] = {
      vertex: [ [ -.931836, .219976, -.264632 ], [ -.636706, .318353, .692816 ], [ -.613483, -.735083, -.264632 ], [ -.326545, .979634, 0 ], [ -.318353, -.636706, .692816 ], [ -.159176, .477529, -.856368 ], [ .159176, -.477529, -.856368 ], [ .318353, .636706, .692816 ], [ .326545, -.979634, 0 ], [ .613482, .735082, -.264632 ], [ .636706, -.318353, .692816 ], [ .931835, -.219977, -.264632 ] ],
      face: [ [ 11, 10, 8 ], [ 7, 9, 3 ], [ 6, 11, 8 ], [ 9, 5, 3 ], [ 2, 6, 8 ], [ 5, 0, 3 ], [ 4, 2, 8 ], [ 0, 1, 3 ], [ 10, 4, 8 ], [ 1, 7, 3 ], [ 10, 11, 9, 7 ], [ 11, 6, 5, 9 ], [ 6, 2, 0, 5 ], [ 2, 4, 1, 0 ], [ 4, 10, 7, 1 ] ]
    };
    polyhedra[14] = {
      vertex: [ [ -.93465, .300459, -.271185 ], [ -.838689, -.260219, -.516017 ], [ -.711319, .717591, .128359 ], [ -.710334, -.156922, .080946 ], [ -.599799, .556003, -.725148 ], [ -.503838, -.004675, -.969981 ], [ -.487004, .26021, .48049 ], [ -.460089, -.750282, -.512622 ], [ -.376468, .973135, -.325605 ], [ -.331735, -.646985, .084342 ], [ -.254001, .831847, .530001 ], [ -.125239, -.494738, -.966586 ], [ .029622, .027949, .730817 ], [ .056536, -.982543, -.262295 ], [ .08085, 1.087391, .076037 ], [ .125583, -.532729, .485984 ], [ .262625, .599586, .780328 ], [ .391387, -.726999, -.716259 ], [ .513854, -.868287, .139347 ], [ .597475, .85513, .326364 ], [ .641224, .109523, .783723 ], [ .737185, -.451155, .538891 ], [ .848705, -.612742, -.314616 ], [ .976075, .365067, .32976 ], [ 1.072036, -.19561, .084927 ] ],
      face: [ [ 15, 18, 21 ], [ 12, 20, 16 ], [ 6, 10, 2 ], [ 3, 0, 1 ], [ 9, 7, 13 ], [ 2, 8, 4, 0 ], [ 0, 4, 5, 1 ], [ 1, 5, 11, 7 ], [ 7, 11, 17, 13 ], [ 13, 17, 22, 18 ], [ 18, 22, 24, 21 ], [ 21, 24, 23, 20 ], [ 20, 23, 19, 16 ], [ 16, 19, 14, 10 ], [ 10, 14, 8, 2 ], [ 15, 9, 13, 18 ], [ 12, 15, 21, 20 ], [ 6, 12, 16, 10 ], [ 3, 6, 2, 0 ], [ 9, 3, 1, 7 ], [ 9, 15, 12, 6, 3 ], [ 22, 17, 11, 5, 4, 8, 14, 19, 23, 24 ] ]
    };
    var polyhedron = function polyhedron(type, size, opts) {
      void 0 === size && (size = 1);
      void 0 === opts && (opts = {
        sizeX: 0,
        sizeY: 0,
        sizeZ: 0
      });
      type = type && (type < 0 || type >= polyhedra.length) ? 0 : type || 0;
      var sizeX = opts.sizeX || size;
      var sizeY = opts.sizeY || size;
      var sizeZ = opts.sizeZ || size;
      var data = polyhedra[type];
      var nbfaces = data.face.length;
      var positions = [];
      var indices = [];
      var normals = [];
      var uvs = [];
      var minPos = new _valueTypes.Vec3(Infinity, Infinity, Infinity);
      var maxPos = new _valueTypes.Vec3(-Infinity, -Infinity, -Infinity);
      for (var i = 0; i < data.vertex.length; i++) {
        var x = data.vertex[i][0] * sizeX;
        var y = data.vertex[i][1] * sizeY;
        var z = data.vertex[i][2] * sizeZ;
        minPos.x = Math.min(minPos.x, x);
        minPos.y = Math.min(minPos.y, y);
        minPos.z = Math.min(minPos.z, z);
        maxPos.x = Math.max(maxPos.x, x);
        maxPos.y = Math.max(maxPos.y, y);
        maxPos.z = Math.max(maxPos.z, z);
        positions.push(x, y, z);
        uvs.push(0, 0);
      }
      for (var f = 0; f < nbfaces; f++) for (var _i = 0; _i < data.face[f].length - 2; _i++) indices.push(data.face[f][0], data.face[f][_i + 2], data.face[f][_i + 1]);
      (0, _utils.calcNormals)(positions, indices, normals);
      var boundingRadius = Math.sqrt(Math.pow(maxPos.x - minPos.x, 2), Math.pow(maxPos.y - minPos.y, 2), Math.pow(maxPos.z - minPos.z, 2));
      return new _vertexData["default"](positions, normals, uvs, indices, minPos, maxPos, boundingRadius);
    };
    exports.polyhedron = polyhedron;
  }), {
    "../../value-types": 401,
    "./utils": 93,
    "./vertex-data": 94
  } ],
  90: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = _default;
    var _vertexData = _interopRequireDefault(require("./vertex-data"));
    var _valueTypes = require("../../value-types");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var positions = [ -.5, -.5, 0, -.5, .5, 0, .5, .5, 0, .5, -.5, 0 ];
    var normals = [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ];
    var uvs = [ 0, 0, 0, 1, 1, 1, 1, 0 ];
    var indices = [ 0, 3, 1, 3, 2, 1 ];
    var minPos = new _valueTypes.Vec3(-.5, -.5, 0);
    var maxPos = new _valueTypes.Vec3(.5, .5, 0);
    var boundingRadius = Math.sqrt(.5);
    function _default() {
      return new _vertexData["default"](positions, normals, uvs, indices, minPos, maxPos, boundingRadius);
    }
    module.exports = exports["default"];
  }), {
    "../../value-types": 401,
    "./vertex-data": 94
  } ],
  91: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = _default;
    var _vertexData = _interopRequireDefault(require("./vertex-data"));
    var _valueTypes = require("../../value-types");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _default(radius, opts) {
      void 0 === radius && (radius = .5);
      void 0 === opts && (opts = {
        segments: 32
      });
      var segments = opts.segments;
      var positions = [];
      var normals = [];
      var uvs = [];
      var indices = [];
      var minPos = new _valueTypes.Vec3(-radius, -radius, -radius);
      var maxPos = new _valueTypes.Vec3(radius, radius, radius);
      var boundingRadius = radius;
      for (var lat = 0; lat <= segments; ++lat) {
        var theta = lat * Math.PI / segments;
        var sinTheta = Math.sin(theta);
        var cosTheta = -Math.cos(theta);
        for (var lon = 0; lon <= segments; ++lon) {
          var phi = 2 * lon * Math.PI / segments - Math.PI / 2;
          var sinPhi = Math.sin(phi);
          var cosPhi = Math.cos(phi);
          var x = sinPhi * sinTheta;
          var y = cosTheta;
          var z = cosPhi * sinTheta;
          var u = lon / segments;
          var v = lat / segments;
          positions.push(x * radius, y * radius, z * radius);
          normals.push(x, y, z);
          uvs.push(u, v);
          if (lat < segments && lon < segments) {
            var seg1 = segments + 1;
            var a = seg1 * lat + lon;
            var b = seg1 * (lat + 1) + lon;
            var c = seg1 * (lat + 1) + lon + 1;
            var d = seg1 * lat + lon + 1;
            indices.push(a, d, b);
            indices.push(d, c, b);
          }
        }
      }
      return new _vertexData["default"](positions, normals, uvs, indices, minPos, maxPos, boundingRadius);
    }
    module.exports = exports["default"];
  }), {
    "../../value-types": 401,
    "./vertex-data": 94
  } ],
  92: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = _default;
    var _vertexData = _interopRequireDefault(require("./vertex-data"));
    var _valueTypes = require("../../value-types");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _default(radius, tube, opts) {
      void 0 === radius && (radius = .4);
      void 0 === tube && (tube = .1);
      void 0 === opts && (opts = {
        radialSegments: 32,
        tubularSegments: 32,
        arc: 2 * Math.PI
      });
      var radialSegments = opts.radialSegments;
      var tubularSegments = opts.tubularSegments;
      var arc = opts.arc;
      var positions = [];
      var normals = [];
      var uvs = [];
      var indices = [];
      var minPos = new _valueTypes.Vec3(-radius - tube, -tube, -radius - tube);
      var maxPos = new _valueTypes.Vec3(radius + tube, tube, radius + tube);
      var boundingRadius = radius + tube;
      for (var j = 0; j <= radialSegments; j++) for (var i = 0; i <= tubularSegments; i++) {
        var u = i / tubularSegments;
        var v = j / radialSegments;
        var u1 = u * arc;
        var v1 = v * Math.PI * 2;
        var x = (radius + tube * Math.cos(v1)) * Math.sin(u1);
        var y = tube * Math.sin(v1);
        var z = (radius + tube * Math.cos(v1)) * Math.cos(u1);
        var nx = Math.sin(u1) * Math.cos(v1);
        var ny = Math.sin(v1);
        var nz = Math.cos(u1) * Math.cos(v1);
        positions.push(x, y, z);
        normals.push(nx, ny, nz);
        uvs.push(u, v);
        if (i < tubularSegments && j < radialSegments) {
          var seg1 = tubularSegments + 1;
          var a = seg1 * j + i;
          var b = seg1 * (j + 1) + i;
          var c = seg1 * (j + 1) + i + 1;
          var d = seg1 * j + i + 1;
          indices.push(a, d, b);
          indices.push(d, c, b);
        }
      }
      return new _vertexData["default"](positions, normals, uvs, indices, minPos, maxPos, boundingRadius);
    }
    module.exports = exports["default"];
  }), {
    "../../value-types": 401,
    "./vertex-data": 94
  } ],
  93: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.calcNormals = calcNormals;
    exports.invWinding = invWinding;
    exports.normals = normals;
    exports.toWavefrontOBJ = toWavefrontOBJ;
    exports.wireframe = wireframe;
    var _vec = _interopRequireDefault(require("../../value-types/vec3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function wireframe(indices) {
      var offsets = [ [ 0, 1 ], [ 1, 2 ], [ 2, 0 ] ];
      var lines = [];
      var lineIDs = {};
      for (var i = 0; i < indices.length; i += 3) for (var k = 0; k < 3; ++k) {
        var i1 = indices[i + offsets[k][0]];
        var i2 = indices[i + offsets[k][1]];
        var id = i1 > i2 ? i2 << 16 | i1 : i1 << 16 | i2;
        if (void 0 === lineIDs[id]) {
          lineIDs[id] = 0;
          lines.push(i1, i2);
        }
      }
      return lines;
    }
    function invWinding(indices) {
      var newIB = [];
      for (var i = 0; i < indices.length; i += 3) newIB.push(indices[i], indices[i + 2], indices[i + 1]);
      return newIB;
    }
    function toWavefrontOBJ(primitive, scale) {
      void 0 === scale && (scale = 1);
      var v = primitive.positions, t = primitive.uvs, n = primitive.normals, IB = primitive.indices;
      var V = function V(i) {
        return IB[i] + 1 + "/" + (IB[i] + 1) + "/" + (IB[i] + 1);
      };
      var content = "";
      for (var i = 0; i < v.length; i += 3) content += "v " + v[i] * scale + " " + v[i + 1] * scale + " " + v[i + 2] * scale + "\n";
      for (var _i = 0; _i < t.length; _i += 2) content += "vt " + t[_i] + " " + t[_i + 1] + "\n";
      for (var _i2 = 0; _i2 < n.length; _i2 += 3) content += "vn " + n[_i2] + " " + n[_i2 + 1] + " " + n[_i2 + 2] + "\n";
      for (var _i3 = 0; _i3 < IB.length; _i3 += 3) content += "f " + V(_i3) + " " + V(_i3 + 1) + " " + V(_i3 + 2) + "\n";
      return content;
    }
    function normals(positions, normals, length) {
      void 0 === length && (length = 1);
      var verts = new Array(2 * positions.length);
      for (var i = 0; i < positions.length / 3; ++i) {
        var i3 = 3 * i;
        var i6 = 6 * i;
        verts[i6 + 0] = positions[i3 + 0];
        verts[i6 + 1] = positions[i3 + 1];
        verts[i6 + 2] = positions[i3 + 2];
        verts[i6 + 3] = positions[i3 + 0] + normals[i3 + 0] * length;
        verts[i6 + 4] = positions[i3 + 1] + normals[i3 + 1] * length;
        verts[i6 + 5] = positions[i3 + 2] + normals[i3 + 2] * length;
      }
      return verts;
    }
    function fromArray(out, a, offset) {
      out.x = a[offset];
      out.y = a[offset + 1];
      out.z = a[offset + 2];
    }
    function calcNormals(positions, indices, normals) {
      normals = normals || new Array(positions.length);
      for (var i = 0, l = normals.length; i < l; i++) normals[i] = 0;
      var vA, vB, vC;
      var pA = cc.v3(), pB = cc.v3(), pC = cc.v3();
      var cb = cc.v3(), ab = cc.v3();
      for (var _i4 = 0, il = indices.length; _i4 < il; _i4 += 3) {
        vA = 3 * indices[_i4 + 0];
        vB = 3 * indices[_i4 + 1];
        vC = 3 * indices[_i4 + 2];
        fromArray(pA, positions, vA);
        fromArray(pB, positions, vB);
        fromArray(pC, positions, vC);
        _vec["default"].subtract(cb, pC, pB);
        _vec["default"].subtract(ab, pA, pB);
        _vec["default"].cross(cb, cb, ab);
        normals[vA] += cb.x;
        normals[vA + 1] += cb.y;
        normals[vA + 2] += cb.z;
        normals[vB] += cb.x;
        normals[vB + 1] += cb.y;
        normals[vB + 2] += cb.z;
        normals[vC] += cb.x;
        normals[vC + 1] += cb.y;
        normals[vC + 2] += cb.z;
      }
      var tempNormal = cc.v3();
      for (var _i5 = 0, _l = normals.length; _i5 < _l; _i5 += 3) {
        tempNormal.x = normals[_i5];
        tempNormal.y = normals[_i5 + 1];
        tempNormal.z = normals[_i5 + 2];
        tempNormal.normalizeSelf();
        normals[_i5] = tempNormal.x;
        normals[_i5 + 1] = tempNormal.y;
        normals[_i5 + 2] = tempNormal.z;
      }
      return normals;
    }
  }), {
    "../../value-types/vec3": 411
  } ],
  94: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var VertexData = function VertexData(positions, normals, uvs, indices, minPos, maxPos, boundingRadius) {
      this.positions = void 0;
      this.normals = void 0;
      this.uvs = void 0;
      this.indices = void 0;
      this.minPos = void 0;
      this.maxPos = void 0;
      this.boundingRadius = void 0;
      this.positions = positions;
      this.normals = normals;
      this.uvs = uvs;
      this.indices = indices;
      this.minPos = minPos;
      this.maxPos = maxPos;
      this.boundingRadius = boundingRadius;
    };
    exports["default"] = VertexData;
    module.exports = exports["default"];
  }), {} ],
  95: [ (function(require, module, exports) {
    "use strict";
    var _require = require("../../../animation/animation-curves"), DynamicAnimCurve = _require.DynamicAnimCurve, quickFindIndex = _require.quickFindIndex;
    var JointMatrixCurve = cc.Class({
      name: "cc.JointMatrixCurve",
      extends: DynamicAnimCurve,
      _findFrameIndex: quickFindIndex,
      sample: function sample(time, ratio) {
        var ratios = this.ratios;
        var index = this._findFrameIndex(ratios, ratio);
        index < -1 && (index = ~index - 1);
        var pairs = this.pairs;
        for (var i = 0; i < pairs.length; i++) {
          var pair = pairs[i];
          pair.target._jointMatrix = pair.values[index];
        }
      }
    });
    module.exports = JointMatrixCurve;
  }), {
    "../../../animation/animation-curves": 12
  } ],
  96: [ (function(require, module, exports) {
    "use strict";
    var Skeleton = cc.Class({
      name: "cc.Skeleton",
      extends: cc.Asset,
      ctor: function ctor() {
        this.loaded = false;
        this._bindposes = [];
        this._uniqueBindPoses = [];
        this._jointPaths = [];
      },
      properties: {
        _model: cc.Model,
        _jointIndices: [],
        _skinIndex: -1,
        jointPaths: {
          get: function get() {
            return this._jointPaths;
          }
        },
        bindposes: {
          get: function get() {
            return this._bindposes;
          }
        },
        uniqueBindPoses: {
          get: function get() {
            return this._uniqueBindPoses;
          }
        },
        model: {
          get: function get() {
            return this._model;
          }
        }
      },
      onLoad: function onLoad() {
        var nodes = this._model.nodes;
        var jointIndices = this._jointIndices;
        var jointPaths = this._jointPaths;
        var bindposes = this._bindposes;
        var uniqueBindPoses = this._uniqueBindPoses;
        for (var i = 0; i < jointIndices.length; i++) {
          var node = nodes[jointIndices[i]];
          jointPaths[i] = node.path;
          node.uniqueBindPose ? bindposes[i] = uniqueBindPoses[i] = node.uniqueBindPose : bindposes[i] = node.bindpose[this._skinIndex];
        }
      }
    });
    cc.Skeleton = module.exports = Skeleton;
  }), {} ],
  97: [ (function(require, module, exports) {
    "use strict";
    var Animation = require("../../components/CCAnimation");
    var Model = require("../CCModel");
    var SkeletonAnimationClip = require("./CCSkeletonAnimationClip");
    var SkeletonAnimation = cc.Class({
      name: "cc.SkeletonAnimation",
      extends: Animation,
      editor: false,
      properties: {
        _model: {
          default: null,
          type: Model
        },
        _defaultClip: {
          override: true,
          default: null,
          type: SkeletonAnimationClip
        },
        _clips: {
          override: true,
          default: [],
          type: [ SkeletonAnimationClip ],
          visible: true
        },
        defaultClip: {
          override: true,
          get: function get() {
            return this._defaultClip;
          },
          set: function set(v) {
            this._defaultClip = v;
          },
          type: SkeletonAnimationClip
        },
        model: {
          get: function get() {
            return this._model;
          },
          set: function set(val) {
            this._model = val;
            this._updateClipModel();
          },
          type: Model
        }
      },
      __preload: function __preload() {
        this._updateClipModel();
      },
      _updateClipModel: function _updateClipModel() {
        this._defaultClip && (this._defaultClip._model = this._model);
        var clips = this._clips;
        for (var i = 0; i < clips.length; i++) clips[i]._model = this._model;
      },
      addClip: function addClip(clip, newName) {
        clip._model = this._model;
        return Animation.prototype.addClip.call(this, clip, newName);
      },
      searchClips: false
    });
    cc.SkeletonAnimation = module.exports = SkeletonAnimation;
  }), {
    "../../components/CCAnimation": 176,
    "../CCModel": 28,
    "./CCSkeletonAnimationClip": 98,
    "fire-path": void 0
  } ],
  98: [ (function(require, module, exports) {
    "use strict";
    var _mat = _interopRequireDefault(require("../../value-types/mat4"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var AnimationClip = require("../../../animation/animation-clip");
    var JointMatrixCurve = require("./CCJointMatrixCurve");
    function maxtrixToArray(matrix) {
      var data = new Float32Array(16);
      data.set(matrix.m);
      return data;
    }
    var SkeletonAnimationClip = cc.Class({
      name: "cc.SkeletonAnimationClip",
      extends: AnimationClip,
      properties: {
        _nativeAsset: {
          override: true,
          get: function get() {
            return this._buffer;
          },
          set: function set(bin) {
            var buffer = ArrayBuffer.isView(bin) ? bin.buffer : bin;
            this._buffer = new Float32Array(buffer || bin, 0, buffer.byteLength / 4);
          }
        },
        description: {
          default: null,
          type: Object
        },
        curveData: {
          visible: false,
          override: true,
          get: function get() {
            return this._curveData || {};
          },
          set: function set() {}
        }
      },
      statics: {
        preventDeferredLoadDependents: true
      },
      _init: function _init() {
        if (this._curveData) return this._curveData;
        this._curveData = {};
        this._generateCommonCurve();
        this._model.precomputeJointMatrix && this._generateJointMatrixCurve();
        return this._curveData;
      },
      _generateCommonCurve: function _generateCommonCurve() {
        var buffer = this._buffer;
        var description = this.description;
        var offset = 0;
        function getValue() {
          return buffer[offset++];
        }
        this._curveData.paths || (this._curveData.paths = {});
        var paths = this._curveData.paths;
        for (var path in description) {
          var des = description[path];
          var curves = {};
          paths[path] = {
            props: curves
          };
          for (var property in des) {
            var frames = [];
            var frameCount = des[property].frameCount;
            offset = des[property].offset;
            for (var i = 0; i < frameCount; i++) {
              var frame = getValue();
              var value = void 0;
              "position" === property || "scale" === property ? value = cc.v3(getValue(), getValue(), getValue()) : "quat" === property && (value = cc.quat(getValue(), getValue(), getValue(), getValue()));
              frames.push({
                frame: frame,
                value: value
              });
            }
            curves[property] = frames;
          }
        }
      },
      _generateJointMatrixCurve: function _generateJointMatrixCurve() {
        var rootNode = this._model.rootNode;
        var curveData = this._curveData;
        var paths = curveData.paths;
        var newCurveData = {
          ratios: [],
          jointMatrixMap: {}
        };
        var jointMatrixMap = newCurveData.jointMatrixMap;
        function walk(node, time, pm) {
          var matrix;
          var EPSILON = 1e-4;
          var path = paths[node.path];
          if (node !== rootNode && path) {
            var props = path.props;
            for (var prop in props) {
              var frames = props[prop];
              for (var i = 0; i < frames.length; i++) {
                var end = frames[i];
                if (Math.abs(end.frame - time) < EPSILON) {
                  node[prop].set(end.value);
                  break;
                }
                if (end.frame > time) {
                  var start = frames[i - 1];
                  var ratio = (time - start.frame) / (end.frame - start.frame);
                  start.value.lerp(end.value, ratio, node[prop]);
                  break;
                }
              }
            }
            matrix = cc.mat4();
            _mat["default"].fromRTS(matrix, node.quat, node.position, node.scale);
            pm && _mat["default"].mul(matrix, pm, matrix);
            props._jointMatrix || (props._jointMatrix = []);
            var bindWorldMatrix;
            if (node.uniqueBindPose) {
              bindWorldMatrix = cc.mat4();
              _mat["default"].mul(bindWorldMatrix, matrix, node.uniqueBindPose);
            }
            jointMatrixMap[node.path] || (jointMatrixMap[node.path] = []);
            bindWorldMatrix ? jointMatrixMap[node.path].push(maxtrixToArray(bindWorldMatrix)) : jointMatrixMap[node.path].push(matrix);
          }
          var children = node.children;
          for (var name in children) {
            var child = children[name];
            walk(child, time, matrix);
          }
        }
        var time = 0;
        var duration = this.duration;
        var step = 1 / this.sample;
        while (time < duration) {
          newCurveData.ratios.push(time / duration);
          walk(rootNode, time);
          time += step;
        }
        this._curveData = newCurveData;
      },
      _createJointMatrixCurve: function _createJointMatrixCurve(state, root) {
        var curve = new JointMatrixCurve();
        curve.ratios = this.curveData.ratios;
        curve.pairs = [];
        var jointMatrixMap = this.curveData.jointMatrixMap;
        for (var path in jointMatrixMap) {
          var target = cc.find(path, root);
          if (!target) continue;
          curve.pairs.push({
            target: target,
            values: jointMatrixMap[path]
          });
        }
        return [ curve ];
      },
      createCurves: function createCurves(state, root) {
        if (!this._model) {
          cc.warn("Skeleton Animation Clip [" + this.name + "] Can not find model");
          return [];
        }
        this._init();
        return this._model.precomputeJointMatrix ? this._createJointMatrixCurve(state, root) : AnimationClip.prototype.createCurves.call(this, state, root);
      }
    });
    cc.SkeletonAnimationClip = module.exports = SkeletonAnimationClip;
  }), {
    "../../../animation/animation-clip": 11,
    "../../value-types/mat4": 403,
    "./CCJointMatrixCurve": 95
  } ],
  99: [ (function(require, module, exports) {
    "use strict";
    var _mat = _interopRequireDefault(require("../../value-types/mat4"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Skeleton = require("./CCSkeleton");
    var MeshRenderer = require("../../mesh/CCMeshRenderer");
    var RenderFlow = require("../../renderer/render-flow");
    var enums = require("../../../renderer/enums");
    var _m4_tmp = cc.mat4();
    var _m4_tmp2 = cc.mat4();
    var SkinnedMeshRenderer = cc.Class({
      name: "cc.SkinnedMeshRenderer",
      extends: MeshRenderer,
      editor: false,
      ctor: function ctor() {
        this._jointsData = this._jointsFloat32Data = null;
        this._jointsTexture = null;
        this._joints = [];
        this._dummyNode = new cc.Node();
        this._jointsTextureOptions = null;
        this._usingRGBA8Texture = false;
      },
      properties: {
        _skeleton: Skeleton,
        _rootBone: cc.Node,
        skeleton: {
          get: function get() {
            return this._skeleton;
          },
          set: function set(val) {
            this._skeleton = val;
            this._init();
          },
          type: Skeleton
        },
        rootBone: {
          get: function get() {
            return this._rootBone;
          },
          set: function set(val) {
            this._rootBone = val;
            this._init();
          },
          type: cc.Node
        },
        enableAutoBatch: {
          get: function get() {
            return false;
          },
          visible: false,
          override: true
        }
      },
      __preload: function __preload() {
        this._super();
        this._init();
      },
      _init: function _init() {
        this._model = this._skeleton && this._skeleton.model;
        this._calFunc = null;
        this._initJoints();
        this._initJointsTexture();
        this._initCalcFunc();
        this._updateRenderNode();
      },
      _calcWorldMatrixToRoot: function _calcWorldMatrixToRoot(joint) {
        var worldMatrixToRoot = joint._worldMatrixToRoot;
        if (worldMatrixToRoot) return;
        joint._worldMatrixToRoot = worldMatrixToRoot = cc.mat4();
        joint.getLocalMatrix(worldMatrixToRoot);
        var parent = joint.parent;
        if (parent !== this.rootBone) {
          parent._worldMatrixToRoot || this._calcWorldMatrixToRoot(parent);
          _mat["default"].mul(worldMatrixToRoot, parent._worldMatrixToRoot, worldMatrixToRoot);
        }
      },
      _validateRender: function _validateRender() {
        if (!this._jointsData) {
          this.disableRender();
          return;
        }
        this._super();
      },
      _initJoints: function _initJoints() {
        var joints = this._joints;
        joints.length = 0;
        if (!this.skeleton || !this.rootBone) return;
        var useJointMatrix = this._useJointMatrix();
        var jointPaths = this.skeleton.jointPaths;
        var rootBone = this.rootBone;
        for (var i = 0; i < jointPaths.length; i++) {
          var joint = cc.find(jointPaths[i], rootBone);
          joint || cc.warn("Can not find joint in root bone [%s] with path [%s]", rootBone.name, jointPaths[i]);
          if (useJointMatrix) {
            joint._renderFlag &= ~RenderFlow.FLAG_CHILDREN;
            this._calcWorldMatrixToRoot(joint);
          }
          joints.push(joint);
        }
        if (useJointMatrix) {
          var uniqueBindPoses = this.skeleton.uniqueBindPoses;
          for (var _i = 0; _i < jointPaths.length; _i++) {
            var _joint = joints[_i];
            if (uniqueBindPoses[_i]) {
              _mat["default"].mul(_m4_tmp, _joint._worldMatrixToRoot, uniqueBindPoses[_i]);
              _joint._jointMatrix = _mat["default"].toArray([], _m4_tmp);
            } else _joint._jointMatrix = _joint._worldMatrixToRoot;
          }
        }
      },
      _initJointsTexture: function _initJointsTexture() {
        if (!this._skeleton) return;
        var jointCount = this._joints.length;
        var inited = false;
        if (jointCount <= cc.sys.getMaxJointMatrixSize()) {
          inited = true;
          this._jointsData = this._jointsFloat32Data = new Float32Array(16 * jointCount);
        }
        if (!inited) {
          var SUPPORT_FLOAT_TEXTURE = !!cc.sys.glExtension("OES_texture_float");
          var size;
          size = jointCount > 256 ? 64 : jointCount > 64 ? 32 : jointCount > 16 ? 16 : 8;
          this._jointsData = this._jointsFloat32Data = new Float32Array(size * size * 4);
          var pixelFormat = cc.Texture2D.PixelFormat.RGBA32F, width = size, height = size;
          if (!SUPPORT_FLOAT_TEXTURE) {
            this._jointsData = new Uint8Array(this._jointsFloat32Data.buffer);
            pixelFormat = cc.Texture2D.PixelFormat.RGBA8888;
            width *= 4;
            this._usingRGBA8Texture = true;
            cc.warn("SkinnedMeshRenderer [" + this.node.name + "] has too many joints [" + jointCount + "] and device do not support float32 texture, fallback to use RGBA8888 texture, which is much slower.");
          }
          var texture = this._jointsTexture || new cc.Texture2D();
          var NEAREST = cc.Texture2D.Filter.NEAREST;
          texture.setFilters(NEAREST, NEAREST);
          texture.initWithData(this._jointsData, pixelFormat, width, height);
          this._jointsTexture = texture;
          this._jointsTextureOptions = {
            format: pixelFormat,
            width: texture.width,
            height: texture.height,
            images: []
          };
        }
        this._updateMaterial();
      },
      _updateMaterial: function _updateMaterial() {
        MeshRenderer.prototype._updateMaterial.call(this);
        var materials = this.getMaterials();
        for (var i = 0; i < materials.length; i++) {
          var material = materials[i];
          if (this._jointsTexture) {
            material.setProperty("jointsTexture", this._jointsTexture);
            material.setProperty("jointsTextureSize", new Float32Array([ this._jointsTexture.width, this._jointsTexture.height ]));
            material.define("CC_JOINTS_TEXTURE_FLOAT32", !!cc.sys.glExtension("OES_texture_float"));
            material.define("CC_USE_JOINTS_TEXTRUE", true);
          } else {
            this._jointsFloat32Data && material.setProperty("jointMatrices", this._jointsFloat32Data, void 0, true);
            material.define("CC_USE_JOINTS_TEXTRUE", false);
          }
          material.define("CC_USE_SKINNING", true);
        }
      },
      _setJointsDataWithArray: function _setJointsDataWithArray(iMatrix, matrixArray) {
        var data = this._jointsFloat32Data;
        data.set(matrixArray, 16 * iMatrix);
      },
      _setJointsDataWithMatrix: function _setJointsDataWithMatrix(iMatrix, matrix) {
        this._jointsFloat32Data.set(matrix.m, 16 * iMatrix);
      },
      _commitJointsData: function _commitJointsData() {
        if (this._jointsTexture) {
          this._jointsTextureOptions.images[0] = this._jointsData;
          this._jointsTexture.update(this._jointsTextureOptions);
        }
      },
      _useJointMatrix: function _useJointMatrix() {
        return this._model && this._model.precomputeJointMatrix;
      },
      _updateRenderNode: function _updateRenderNode() {
        this._useJointMatrix() || this._usingRGBA8Texture ? this._assembler.setRenderNode(this.rootBone) : this._assembler.setRenderNode(this._dummyNode);
      },
      _initCalcFunc: function _initCalcFunc() {
        this._useJointMatrix() ? this._calFunc = this._calJointMatrix : this._usingRGBA8Texture ? this._calFunc = this._calRGBA8WorldMatrix : this._calFunc = this._calWorldMatrix;
      },
      _calJointMatrix: function _calJointMatrix() {
        var joints = this._joints;
        var bindposes = this.skeleton.bindposes;
        var uniqueBindPoses = this.skeleton.uniqueBindPoses;
        for (var i = 0; i < joints.length; ++i) {
          var joint = joints[i];
          var jointMatrix = joint._jointMatrix;
          if (uniqueBindPoses[i]) this._setJointsDataWithArray(i, jointMatrix); else {
            _mat["default"].multiply(_m4_tmp, jointMatrix, bindposes[i]);
            this._setJointsDataWithMatrix(i, _m4_tmp);
          }
        }
      },
      _calRGBA8WorldMatrix: function _calRGBA8WorldMatrix() {
        var joints = this._joints;
        var bindposes = this.skeleton.bindposes;
        this.rootBone._updateWorldMatrix();
        var rootMatrix = this.rootBone._worldMatrix;
        var invRootMat = _mat["default"].invert(_m4_tmp2, rootMatrix);
        for (var i = 0; i < joints.length; ++i) {
          var joint = joints[i];
          joint._updateWorldMatrix();
          _mat["default"].multiply(_m4_tmp, invRootMat, joint._worldMatrix);
          _mat["default"].multiply(_m4_tmp, _m4_tmp, bindposes[i]);
          this._setJointsDataWithMatrix(i, _m4_tmp);
        }
      },
      _calWorldMatrix: function _calWorldMatrix() {
        var joints = this._joints;
        var bindposes = this.skeleton.bindposes;
        for (var i = 0; i < joints.length; ++i) {
          var joint = joints[i];
          joint._updateWorldMatrix();
          _mat["default"].multiply(_m4_tmp, joint._worldMatrix, bindposes[i]);
          this._setJointsDataWithMatrix(i, _m4_tmp);
        }
      },
      calcJointMatrix: function calcJointMatrix() {
        if (!this.skeleton || !this.rootBone) return;
        this._calFunc.call(this);
        this._commitJointsData();
      }
    });
    cc.SkinnedMeshRenderer = module.exports = SkinnedMeshRenderer;
  }), {
    "../../../renderer/enums": 426,
    "../../mesh/CCMeshRenderer": 241,
    "../../renderer/render-flow": 323,
    "../../value-types/mat4": 403,
    "./CCSkeleton": 96
  } ],
  100: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var SkinnedMeshRenderer = require("./CCSkinnedMeshRenderer");
    var MeshRendererAssembler = require("../../mesh/mesh-renderer");
    var RenderFlow = require("../../renderer/render-flow");
    var SkinnedMeshRendererAssembler = (function(_MeshRendererAssemble) {
      _inheritsLoose(SkinnedMeshRendererAssembler, _MeshRendererAssemble);
      function SkinnedMeshRendererAssembler() {
        return _MeshRendererAssemble.apply(this, arguments) || this;
      }
      var _proto = SkinnedMeshRendererAssembler.prototype;
      _proto.fillBuffers = function fillBuffers(comp, renderer) {
        comp.calcJointMatrix();
        _MeshRendererAssemble.prototype.fillBuffers.call(this, comp, renderer);
      };
      return SkinnedMeshRendererAssembler;
    })(MeshRendererAssembler);
    exports["default"] = SkinnedMeshRendererAssembler;
    cc.Assembler.register(SkinnedMeshRenderer, SkinnedMeshRendererAssembler);
    module.exports = exports["default"];
  }), {
    "../../mesh/mesh-renderer": 244,
    "../../renderer/render-flow": 323,
    "./CCSkinnedMeshRenderer": 99
  } ],
  101: [ (function(require, module, exports) {
    "use strict";
    var utils = require("./platform/utils");
    var debugInfos = require("../../DebugInfos") || {};
    var ERROR_MAP_URL = "https://github.com/cocos-creator/engine/blob/master/EngineErrorMap.md";
    var logList;
    cc.log = cc.warn = cc.error = cc.assert = console.log.bind ? console.log.bind(console) : console.log;
    var resetDebugSetting = function resetDebugSetting(mode) {
      cc.log = cc.warn = cc.error = cc.assert = function() {};
      if (mode === DebugMode.NONE) return;
      if (mode > DebugMode.ERROR) {
        var logToWebPage = function logToWebPage(msg) {
          if (!cc.game.canvas) return;
          if (!logList) {
            var logDiv = document.createElement("Div");
            logDiv.setAttribute("id", "logInfoDiv");
            logDiv.setAttribute("width", "200");
            logDiv.setAttribute("height", cc.game.canvas.height);
            var logDivStyle = logDiv.style;
            logDivStyle.zIndex = "99999";
            logDivStyle.position = "absolute";
            logDivStyle.top = logDivStyle.left = "0";
            logList = document.createElement("textarea");
            logList.setAttribute("rows", "20");
            logList.setAttribute("cols", "30");
            logList.setAttribute("disabled", "true");
            var logListStyle = logList.style;
            logListStyle.backgroundColor = "transparent";
            logListStyle.borderBottom = "1px solid #cccccc";
            logListStyle.borderTopWidth = logListStyle.borderLeftWidth = logListStyle.borderRightWidth = "0px";
            logListStyle.borderTopStyle = logListStyle.borderLeftStyle = logListStyle.borderRightStyle = "none";
            logListStyle.padding = "0px";
            logListStyle.margin = 0;
            logDiv.appendChild(logList);
            cc.game.canvas.parentNode.appendChild(logDiv);
          }
          logList.value = logList.value + msg + "\r\n";
          logList.scrollTop = logList.scrollHeight;
        };
        cc.error = function() {
          logToWebPage("ERROR :  " + cc.js.formatStr.apply(null, arguments));
        };
        cc.assert = function(cond, msg) {
          if (!cond && msg) {
            msg = cc.js.formatStr.apply(null, cc.js.shiftArguments.apply(null, arguments));
            logToWebPage("ASSERT: " + msg);
          }
        };
        mode !== DebugMode.ERROR_FOR_WEB_PAGE && (cc.warn = function() {
          logToWebPage("WARN :  " + cc.js.formatStr.apply(null, arguments));
        });
        mode === DebugMode.INFO_FOR_WEB_PAGE && (cc.log = function() {
          logToWebPage(cc.js.formatStr.apply(null, arguments));
        });
      } else if (console && console.log.apply) {
        console.error || (console.error = console.log);
        console.warn || (console.warn = console.log);
        false;
        console.error.bind ? cc.error = console.error.bind(console) : cc.error = console.error;
        cc.assert = function(cond, msg) {
          if (!cond) {
            msg && (msg = cc.js.formatStr.apply(null, cc.js.shiftArguments.apply(null, arguments)));
            true;
            debugger;
            false;
            throw new Error(msg);
          }
        };
      }
      if (mode !== DebugMode.ERROR) {
        false;
        console.warn.bind ? cc.warn = console.warn.bind(console) : cc.warn = console.warn;
      }
      false;
      if (mode === DebugMode.INFO) {
        true;
        "JavaScriptCore" === scriptEngineType ? cc.log = function() {
          return console.log.apply(console, arguments);
        } : cc.log = console.log;
      }
    };
    cc._throw = function(error) {
      utils.callInNextTick((function() {
        throw error;
      }));
    };
    function getTypedFormatter(type) {
      return function() {
        var id = arguments[0];
        var msg = debugInfos[id] || "unknown id";
        if (1 === arguments.length) return msg;
        if (2 === arguments.length) return cc.js.formatStr(msg, arguments[1]);
        var argsArray = cc.js.shiftArguments.apply(null, arguments);
        return cc.js.formatStr.apply(null, [ msg ].concat(argsArray));
      };
    }
    var logFormatter = getTypedFormatter("Log");
    cc.logID = function() {
      cc.log(logFormatter.apply(null, arguments));
    };
    var warnFormatter = getTypedFormatter("Warning");
    cc.warnID = function() {
      cc.warn(warnFormatter.apply(null, arguments));
    };
    var errorFormatter = getTypedFormatter("Error");
    cc.errorID = function() {
      cc.error(errorFormatter.apply(null, arguments));
    };
    var assertFormatter = getTypedFormatter("Assert");
    cc.assertID = function(cond) {
      if (cond) return;
      cc.assert(false, assertFormatter.apply(null, cc.js.shiftArguments.apply(null, arguments)));
    };
    var DebugMode = cc.Enum({
      NONE: 0,
      INFO: 1,
      WARN: 2,
      ERROR: 3,
      INFO_FOR_WEB_PAGE: 4,
      WARN_FOR_WEB_PAGE: 5,
      ERROR_FOR_WEB_PAGE: 6
    });
    module.exports = cc.debug = {
      DebugMode: DebugMode,
      _resetDebugSetting: resetDebugSetting,
      getError: getTypedFormatter("ERROR"),
      isDisplayStats: function isDisplayStats() {
        return !!cc.profiler && cc.profiler.isShowingStats();
      },
      setDisplayStats: function setDisplayStats(displayStats) {
        if (cc.profiler && cc.game.renderType !== cc.game.RENDER_TYPE_CANVAS) {
          displayStats ? cc.profiler.showStats() : cc.profiler.hideStats();
          cc.game.config.showFPS = !!displayStats;
        }
      }
    };
  }), {
    "../../DebugInfos": 1,
    "./platform/utils": 297
  } ],
  102: [ (function(require, module, exports) {
    "use strict";
    var EventTarget = require("./event/event-target");
    var ComponentScheduler = require("./component-scheduler");
    var NodeActivator = require("./node-activator");
    var Obj = require("./platform/CCObject");
    var game = require("./CCGame");
    var renderer = require("./renderer");
    var eventManager = require("./event-manager");
    var Scheduler = require("./CCScheduler");
    cc.Director = function() {
      EventTarget.call(this);
      this._paused = false;
      this._purgeDirectorInNextLoop = false;
      this._winSizeInPoints = null;
      this._scene = null;
      this._loadingScene = "";
      this._totalFrames = 0;
      this._lastUpdate = 0;
      this._deltaTime = 0;
      this._startTime = 0;
      this._maxParticleDeltaTime = 0;
      this._scheduler = null;
      this._compScheduler = null;
      this._nodeActivator = null;
      this._actionManager = null;
      var self = this;
      game.on(game.EVENT_SHOW, (function() {
        self._lastUpdate = performance.now();
      }));
      game.once(game.EVENT_ENGINE_INITED, this.init, this);
    };
    cc.Director.prototype = {
      constructor: cc.Director,
      init: function init() {
        this._totalFrames = 0;
        this._lastUpdate = performance.now();
        this._startTime = this._lastUpdate;
        this._paused = false;
        this._purgeDirectorInNextLoop = false;
        this._winSizeInPoints = cc.size(0, 0);
        this._scheduler = new Scheduler();
        if (cc.ActionManager) {
          this._actionManager = new cc.ActionManager();
          this._scheduler.scheduleUpdate(this._actionManager, Scheduler.PRIORITY_SYSTEM, false);
        } else this._actionManager = null;
        this.sharedInit();
        return true;
      },
      sharedInit: function sharedInit() {
        this._compScheduler = new ComponentScheduler();
        this._nodeActivator = new NodeActivator();
        eventManager && eventManager.setEnabled(true);
        if (cc.AnimationManager) {
          this._animationManager = new cc.AnimationManager();
          this._scheduler.scheduleUpdate(this._animationManager, Scheduler.PRIORITY_SYSTEM, false);
        } else this._animationManager = null;
        if (cc.CollisionManager) {
          this._collisionManager = new cc.CollisionManager();
          this._scheduler.scheduleUpdate(this._collisionManager, Scheduler.PRIORITY_SYSTEM, false);
        } else this._collisionManager = null;
        if (cc.PhysicsManager) {
          this._physicsManager = new cc.PhysicsManager();
          this._scheduler.scheduleUpdate(this._physicsManager, Scheduler.PRIORITY_SYSTEM, false);
        } else this._physicsManager = null;
        if (cc.Physics3DManager && (false, true)) {
          this._physics3DManager = new cc.Physics3DManager();
          this._scheduler.scheduleUpdate(this._physics3DManager, Scheduler.PRIORITY_SYSTEM, false);
        } else this._physics3DManager = null;
        cc._widgetManager && cc._widgetManager.init(this);
      },
      calculateDeltaTime: function calculateDeltaTime(now) {
        now || (now = performance.now());
        this._deltaTime = now > this._lastUpdate ? (now - this._lastUpdate) / 1e3 : 0;
        (true, this._deltaTime > 1) && (this._deltaTime = 1 / 60);
        this._lastUpdate = now;
      },
      convertToGL: function convertToGL(uiPoint) {
        var container = game.container;
        var view = cc.view;
        var box = container.getBoundingClientRect();
        var left = box.left + window.pageXOffset - container.clientLeft;
        var top = box.top + window.pageYOffset - container.clientTop;
        var x = view._devicePixelRatio * (uiPoint.x - left);
        var y = view._devicePixelRatio * (top + box.height - uiPoint.y);
        return view._isRotated ? cc.v2(view._viewportRect.width - y, x) : cc.v2(x, y);
      },
      convertToUI: function convertToUI(glPoint) {
        var container = game.container;
        var view = cc.view;
        var box = container.getBoundingClientRect();
        var left = box.left + window.pageXOffset - container.clientLeft;
        var top = box.top + window.pageYOffset - container.clientTop;
        var uiPoint = cc.v2(0, 0);
        if (view._isRotated) {
          uiPoint.x = left + glPoint.y / view._devicePixelRatio;
          uiPoint.y = top + box.height - (view._viewportRect.width - glPoint.x) / view._devicePixelRatio;
        } else {
          uiPoint.x = left + glPoint.x * view._devicePixelRatio;
          uiPoint.y = top + box.height - glPoint.y * view._devicePixelRatio;
        }
        return uiPoint;
      },
      end: function end() {
        this._purgeDirectorInNextLoop = true;
      },
      getWinSize: function getWinSize() {
        return cc.size(cc.winSize);
      },
      getWinSizeInPixels: function getWinSizeInPixels() {
        return cc.size(cc.winSize);
      },
      pause: function pause() {
        if (this._paused) return;
        this._paused = true;
      },
      purgeCachedData: function purgeCachedData() {
        cc.assetManager.releaseAll();
      },
      purgeDirector: function purgeDirector() {
        this._scheduler.unscheduleAll();
        this._compScheduler.unscheduleAll();
        this._nodeActivator.reset();
        eventManager && eventManager.setEnabled(false);
        true;
        cc.isValid(this._scene) && this._scene.destroy();
        this._scene = null;
        cc.renderer.clear();
        cc.assetManager.builtins.clear();
        cc.game.pause();
        cc.assetManager.releaseAll();
      },
      reset: function reset() {
        this.purgeDirector();
        eventManager && eventManager.setEnabled(true);
        this._actionManager && this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._animationManager && this._scheduler.scheduleUpdate(this._animationManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._collisionManager && this._scheduler.scheduleUpdate(this._collisionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        this._physicsManager && this._scheduler.scheduleUpdate(this._physicsManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        cc.game.resume();
      },
      runSceneImmediate: function runSceneImmediate(scene, onBeforeLoadScene, onLaunched) {
        cc.assertID(scene instanceof cc.Scene || scene instanceof cc.SceneAsset, 1216);
        scene instanceof cc.SceneAsset && (scene = scene.scene);
        false;
        scene._load();
        false;
        false;
        var persistNodeList = Object.keys(game._persistRootNodes).map((function(x) {
          return game._persistRootNodes[x];
        }));
        for (var i = 0; i < persistNodeList.length; i++) {
          var node = persistNodeList[i];
          var existNode = scene.getChildByUuid(node.uuid);
          if (existNode) {
            var index = existNode.getSiblingIndex();
            existNode._destroyImmediate();
            scene.insertChild(node, index);
          } else node.parent = scene;
        }
        false;
        var oldScene = this._scene;
        true;
        false;
        cc.assetManager._releaseManager._autoRelease(oldScene, scene, game._persistRootNodes);
        false;
        false;
        cc.isValid(oldScene) && oldScene.destroy();
        this._scene = null;
        Obj._deferredDestroy();
        false;
        onBeforeLoadScene && onBeforeLoadScene();
        this.emit(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, scene);
        this._scene = scene;
        false;
        scene._activate();
        false;
        cc.game.resume();
        onLaunched && onLaunched(null, scene);
        this.emit(cc.Director.EVENT_AFTER_SCENE_LAUNCH, scene);
      },
      runScene: function runScene(scene, onBeforeLoadScene, onLaunched) {
        cc.assertID(scene, 1205);
        cc.assertID(scene instanceof cc.Scene || scene instanceof cc.SceneAsset, 1216);
        scene instanceof cc.SceneAsset && (scene = scene.scene);
        scene._load();
        this.once(cc.Director.EVENT_AFTER_DRAW, (function() {
          this.runSceneImmediate(scene, onBeforeLoadScene, onLaunched);
        }), this);
      },
      loadScene: function loadScene(sceneName, onLaunched, _onUnloaded) {
        if (this._loadingScene) {
          cc.warnID(1208, sceneName, this._loadingScene);
          return false;
        }
        var bundle = cc.assetManager.bundles.find((function(bundle) {
          return bundle.getSceneInfo(sceneName);
        }));
        if (bundle) {
          this.emit(cc.Director.EVENT_BEFORE_SCENE_LOADING, sceneName);
          this._loadingScene = sceneName;
          var self = this;
          console.time("LoadScene " + sceneName);
          bundle.loadScene(sceneName, (function(err, scene) {
            console.timeEnd("LoadScene " + sceneName);
            self._loadingScene = "";
            if (err) {
              err = "Failed to load scene: " + err;
              cc.error(err);
              onLaunched && onLaunched(err);
            } else self.runSceneImmediate(scene, _onUnloaded, onLaunched);
          }));
          return true;
        }
        cc.errorID(1209, sceneName);
        return false;
      },
      preloadScene: function preloadScene(sceneName, onProgress, onLoaded) {
        var bundle = cc.assetManager.bundles.find((function(bundle) {
          return bundle.getSceneInfo(sceneName);
        }));
        if (!bundle) {
          cc.errorID(1209, sceneName);
          return null;
        }
        bundle.preloadScene(sceneName, null, onProgress, onLoaded);
      },
      resume: function resume() {
        if (!this._paused) return;
        this._lastUpdate = performance.now();
        this._lastUpdate || cc.logID(1200);
        this._paused = false;
        this._deltaTime = 0;
      },
      setDepthTest: function setDepthTest(value) {
        if (!cc.Camera.main) return;
        cc.Camera.main.depth = !!value;
      },
      setClearColor: function setClearColor(clearColor) {
        if (!cc.Camera.main) return;
        cc.Camera.main.backgroundColor = clearColor;
      },
      getRunningScene: function getRunningScene() {
        return this._scene;
      },
      getScene: function getScene() {
        return this._scene;
      },
      getAnimationInterval: function getAnimationInterval() {
        return 1e3 / game.getFrameRate();
      },
      setAnimationInterval: function setAnimationInterval(value) {
        game.setFrameRate(Math.round(1e3 / value));
      },
      getDeltaTime: function getDeltaTime() {
        return this._deltaTime;
      },
      getTotalTime: function getTotalTime() {
        return performance.now() - this._startTime;
      },
      getTotalFrames: function getTotalFrames() {
        return this._totalFrames;
      },
      isPaused: function isPaused() {
        return this._paused;
      },
      getScheduler: function getScheduler() {
        return this._scheduler;
      },
      setScheduler: function setScheduler(scheduler) {
        this._scheduler !== scheduler && (this._scheduler = scheduler);
      },
      getActionManager: function getActionManager() {
        return this._actionManager;
      },
      setActionManager: function setActionManager(actionManager) {
        if (this._actionManager !== actionManager) {
          this._actionManager && this._scheduler.unscheduleUpdate(this._actionManager);
          this._actionManager = actionManager;
          this._scheduler.scheduleUpdate(this._actionManager, cc.Scheduler.PRIORITY_SYSTEM, false);
        }
      },
      getAnimationManager: function getAnimationManager() {
        return this._animationManager;
      },
      getCollisionManager: function getCollisionManager() {
        return this._collisionManager;
      },
      getPhysicsManager: function getPhysicsManager() {
        return this._physicsManager;
      },
      getPhysics3DManager: function getPhysics3DManager() {
        return this._physics3DManager;
      },
      startAnimation: function startAnimation() {
        cc.game.resume();
      },
      stopAnimation: function stopAnimation() {
        cc.game.pause();
      },
      _resetDeltaTime: function _resetDeltaTime() {
        this._lastUpdate = performance.now();
        this._deltaTime = 0;
      },
      mainLoop: function(now) {
        if (this._purgeDirectorInNextLoop) {
          this._purgeDirectorInNextLoop = false;
          this.purgeDirector();
        } else {
          this.calculateDeltaTime(now);
          if (!this._paused) {
            this.emit(cc.Director.EVENT_BEFORE_UPDATE);
            this._compScheduler.startPhase();
            this._compScheduler.updatePhase(this._deltaTime);
            this._scheduler.update(this._deltaTime);
            this._compScheduler.lateUpdatePhase(this._deltaTime);
            this.emit(cc.Director.EVENT_AFTER_UPDATE);
            Obj._deferredDestroy();
          }
          this.emit(cc.Director.EVENT_BEFORE_DRAW);
          renderer.render(this._scene, this._deltaTime);
          this.emit(cc.Director.EVENT_AFTER_DRAW);
          eventManager.frameUpdateListeners();
          this._totalFrames++;
        }
      },
      __fastOn: function __fastOn(type, callback, target) {
        this.on(type, callback, target);
      },
      __fastOff: function __fastOff(type, callback, target) {
        this.off(type, callback, target);
      }
    };
    cc.js.addon(cc.Director.prototype, EventTarget.prototype);
    cc.Director.EVENT_PROJECTION_CHANGED = "director_projection_changed";
    cc.Director.EVENT_BEFORE_SCENE_LOADING = "director_before_scene_loading";
    cc.Director.EVENT_BEFORE_SCENE_LAUNCH = "director_before_scene_launch";
    cc.Director.EVENT_AFTER_SCENE_LAUNCH = "director_after_scene_launch";
    cc.Director.EVENT_BEFORE_UPDATE = "director_before_update";
    cc.Director.EVENT_AFTER_UPDATE = "director_after_update";
    cc.Director.EVENT_BEFORE_VISIT = "director_before_draw";
    cc.Director.EVENT_AFTER_VISIT = "director_before_draw";
    cc.Director.EVENT_BEFORE_DRAW = "director_before_draw";
    cc.Director.EVENT_AFTER_DRAW = "director_after_draw";
    cc.Director.PROJECTION_2D = 0;
    cc.Director.PROJECTION_3D = 1;
    cc.Director.PROJECTION_CUSTOM = 3;
    cc.Director.PROJECTION_DEFAULT = cc.Director.PROJECTION_2D;
    cc.Director.EVENT_BEFORE_PHYSICS = "director_before_physics";
    cc.Director.EVENT_AFTER_PHYSICS = "director_after_physics";
    cc.director = new cc.Director();
    module.exports = cc.director;
  }), {
    "./CCGame": 103,
    "./CCScheduler": 107,
    "./component-scheduler": 175,
    "./event-manager": 217,
    "./event/event-target": 219,
    "./node-activator": 245,
    "./platform/CCObject": 278,
    "./renderer": 322
  } ],
  103: [ (function(require, module, exports) {
    "use strict";
    var EventTarget = require("./event/event-target");
    require("../audio/CCAudioEngine");
    var debug = require("./CCDebug");
    var renderer = require("./renderer/index.js");
    var dynamicAtlasManager = require("../core/renderer/utils/dynamic-atlas/manager");
    var game = {
      EVENT_HIDE: "game_on_hide",
      EVENT_SHOW: "game_on_show",
      EVENT_RESTART: "game_on_restart",
      EVENT_GAME_INITED: "game_inited",
      EVENT_ENGINE_INITED: "engine_inited",
      EVENT_RENDERER_INITED: "engine_inited",
      RENDER_TYPE_CANVAS: 0,
      RENDER_TYPE_WEBGL: 1,
      RENDER_TYPE_OPENGL: 2,
      _persistRootNodes: {},
      _paused: true,
      _configLoaded: false,
      _isCloning: false,
      _prepared: false,
      _rendererInitialized: false,
      _renderContext: null,
      _intervalId: null,
      _lastTime: null,
      _frameTime: null,
      frame: null,
      container: null,
      canvas: null,
      renderType: -1,
      config: null,
      onStart: null,
      setFrameRate: function setFrameRate(frameRate) {
        var config = this.config;
        config.frameRate = frameRate;
        this._intervalId && window.cancelAnimFrame(this._intervalId);
        this._intervalId = 0;
        this._paused = true;
        this._setAnimFrame();
        this._runMainLoop();
      },
      getFrameRate: function getFrameRate() {
        return this.config.frameRate;
      },
      step: function step() {
        cc.director.mainLoop();
      },
      pause: function pause() {
        if (this._paused) return;
        this._paused = true;
        cc.audioEngine && cc.audioEngine._break();
        this._intervalId && window.cancelAnimFrame(this._intervalId);
        this._intervalId = 0;
      },
      resume: function resume() {
        if (!this._paused) return;
        this._paused = false;
        cc.audioEngine && cc.audioEngine._restore();
        cc.director._resetDeltaTime();
        this._runMainLoop();
      },
      isPaused: function isPaused() {
        return this._paused;
      },
      restart: function restart() {
        cc.director.once(cc.Director.EVENT_AFTER_DRAW, (function() {
          for (var id in game._persistRootNodes) game.removePersistRootNode(game._persistRootNodes[id]);
          cc.director.getScene().destroy();
          cc.Object._deferredDestroy();
          cc.audioEngine && cc.audioEngine.uncacheAll();
          cc.director.reset();
          game.pause();
          cc.assetManager.builtins.init((function() {
            game.onStart();
            game.emit(game.EVENT_RESTART);
          }));
        }));
      },
      end: function end() {
        close();
      },
      _initEngine: function _initEngine() {
        if (this._rendererInitialized) return;
        this._initRenderer();
        true;
        this._initEvents();
        this.emit(this.EVENT_ENGINE_INITED);
      },
      _loadPreviewScript: function _loadPreviewScript(cb) {
        true, window.__quick_compile_project__ ? window.__quick_compile_project__.load(cb) : cb();
      },
      _prepareFinished: function _prepareFinished(cb) {
        var _this = this;
        this._initEngine();
        this._setAnimFrame();
        cc.assetManager.builtins.init((function() {
          console.log("Cocos Creator SP v" + cc.ENGINE_VERSION);
          _this._prepared = true;
          _this._runMainLoop();
          _this.emit(_this.EVENT_GAME_INITED);
          cb && cb();
        }));
      },
      eventTargetOn: EventTarget.prototype.on,
      eventTargetOnce: EventTarget.prototype.once,
      on: function on(type, callback, target, once) {
        this._prepared && type === this.EVENT_ENGINE_INITED || !this._paused && type === this.EVENT_GAME_INITED ? callback.call(target) : this.eventTargetOn(type, callback, target, once);
      },
      once: function once(type, callback, target) {
        this._prepared && type === this.EVENT_ENGINE_INITED || !this._paused && type === this.EVENT_GAME_INITED ? callback.call(target) : this.eventTargetOnce(type, callback, target);
      },
      prepare: function prepare(cb) {
        var _this2 = this;
        if (this._prepared) {
          cb && cb();
          return;
        }
        this._loadPreviewScript((function() {
          _this2._prepareFinished(cb);
        }));
      },
      run: function run(config, onStart) {
        this._initConfig(config);
        this.onStart = onStart;
        this.prepare(game.onStart && game.onStart.bind(game));
      },
      addPersistRootNode: function addPersistRootNode(node) {
        if (!cc.Node.isNode(node) || !node.uuid) {
          cc.warnID(3800);
          return;
        }
        var id = node.uuid;
        if (!this._persistRootNodes[id]) {
          var scene = cc.director._scene;
          if (cc.isValid(scene)) if (node.parent) {
            if (!(node.parent instanceof cc.Scene)) {
              cc.warnID(3801);
              return;
            }
            if (node.parent !== scene) {
              cc.warnID(3802);
              return;
            }
          } else node.parent = scene;
          this._persistRootNodes[id] = node;
          node._persistNode = true;
          cc.assetManager._releaseManager._addPersistNodeRef(node);
        }
      },
      removePersistRootNode: function removePersistRootNode(node) {
        var id = node.uuid || "";
        if (node === this._persistRootNodes[id]) {
          delete this._persistRootNodes[id];
          node._persistNode = false;
          cc.assetManager._releaseManager._removePersistNodeRef(node);
        }
      },
      isPersistRootNode: function isPersistRootNode(node) {
        return node._persistNode;
      },
      _setAnimFrame: function _setAnimFrame() {
        this._lastTime = performance.now();
        var frameRate = game.config.frameRate;
        this._frameTime = 1e3 / frameRate;
        cc.director._maxParticleDeltaTime = this._frameTime / 1e3 * 2;
        var rAF;
        true;
        jsb.setPreferredFramesPerSecond(frameRate);
        window.requestAnimFrame = window.requestAnimationFrame;
        window.cancelAnimFrame = window.cancelAnimationFrame;
      },
      _stTimeWithRAF: function _stTimeWithRAF(callback) {
        var currTime = performance.now();
        var timeToCall = Math.max(0, game._frameTime - (currTime - game._lastTime));
        var id = window.setTimeout((function() {
          window.requestAnimationFrame(callback);
        }), timeToCall);
        game._lastTime = currTime + timeToCall;
        return id;
      },
      _stTime: function _stTime(callback) {
        var currTime = performance.now();
        var timeToCall = Math.max(0, game._frameTime - (currTime - game._lastTime));
        var id = window.setTimeout((function() {
          callback();
        }), timeToCall);
        game._lastTime = currTime + timeToCall;
        return id;
      },
      _ctTime: function _ctTime(id) {
        window.clearTimeout(id);
      },
      _runMainLoop: function _runMainLoop() {
        false;
        if (!this._prepared) return;
        var self = this, _callback, config = self.config, director = cc.director, skip = true, frameRate = config.frameRate;
        debug.setDisplayStats(config.showFPS);
        _callback = function callback(now) {
          if (!self._paused) {
            self._intervalId = window.requestAnimFrame(_callback);
            false;
            director.mainLoop(now);
          }
        };
        self._intervalId = window.requestAnimFrame(_callback);
        self._paused = false;
      },
      _initConfig: function _initConfig(config) {
        "number" !== typeof config.debugMode && (config.debugMode = 0);
        config.exposeClassName = !!config.exposeClassName;
        "number" !== typeof config.frameRate && (config.frameRate = 60);
        var renderMode = config.renderMode;
        ("number" !== typeof renderMode || renderMode > 2 || renderMode < 0) && (config.renderMode = 0);
        "boolean" !== typeof config.registerSystemEvent && (config.registerSystemEvent = true);
        config.showFPS = 1 !== renderMode && !!config.showFPS;
        this.collisionMatrix = config.collisionMatrix || [];
        this.groupList = config.groupList || [];
        debug._resetDebugSetting(config.debugMode);
        this.config = config;
        this._configLoaded = true;
      },
      _determineRenderType: function _determineRenderType() {
        var config = this.config, userRenderMode = parseInt(config.renderMode) || 0;
        this.renderType = this.RENDER_TYPE_CANVAS;
        var supportRender = false;
        if (0 === userRenderMode) {
          if (cc.sys.capabilities["opengl"]) {
            this.renderType = this.RENDER_TYPE_WEBGL;
            supportRender = true;
          } else if (cc.sys.capabilities["canvas"]) {
            this.renderType = this.RENDER_TYPE_CANVAS;
            supportRender = true;
          }
        } else if (1 === userRenderMode && cc.sys.capabilities["canvas"]) {
          this.renderType = this.RENDER_TYPE_CANVAS;
          supportRender = true;
        } else if (2 === userRenderMode && cc.sys.capabilities["opengl"]) {
          this.renderType = this.RENDER_TYPE_WEBGL;
          supportRender = true;
        }
        if (!supportRender) throw new Error(debug.getError(3820, userRenderMode));
      },
      _initRenderer: function _initRenderer() {
        if (this._rendererInitialized) return;
        var el = this.config.id, width, height, localCanvas, localContainer;
        var addClass;
        var element;
        true;
        this.container = localContainer = document.createElement("DIV");
        this.frame = localContainer.parentNode === document.body ? document.documentElement : localContainer.parentNode;
        localCanvas = window.__canvas;
        this.canvas = localCanvas;
        this._determineRenderType();
        if (this.renderType === this.RENDER_TYPE_WEBGL) {
          var opts = {
            stencil: true,
            antialias: cc.macro.ENABLE_WEBGL_ANTIALIAS,
            alpha: cc.macro.ENABLE_TRANSPARENT_CANVAS
          };
          renderer.initWebGL(localCanvas, opts);
          this._renderContext = renderer.device._gl;
          !cc.macro.CLEANUP_IMAGE_CACHE && dynamicAtlasManager && (dynamicAtlasManager.enabled = true);
        }
        if (!this._renderContext) {
          this.renderType = this.RENDER_TYPE_CANVAS;
          renderer.initCanvas(localCanvas);
          this._renderContext = renderer.device._ctx;
        }
        this.canvas.oncontextmenu = function() {
          if (!cc._isContextMenuEnable) return false;
        };
        this._rendererInitialized = true;
      },
      _initEvents: function _initEvents() {
        var win = window, hiddenPropName;
        this.config.registerSystemEvent && cc.internal.inputManager.registerSystemEvent(this.canvas);
        "undefined" !== typeof document.hidden ? hiddenPropName = "hidden" : "undefined" !== typeof document.mozHidden ? hiddenPropName = "mozHidden" : "undefined" !== typeof document.msHidden ? hiddenPropName = "msHidden" : "undefined" !== typeof document.webkitHidden && (hiddenPropName = "webkitHidden");
        var hidden = false;
        function onHidden() {
          if (!hidden) {
            hidden = true;
            game.emit(game.EVENT_HIDE);
          }
        }
        function onShown(arg0, arg1, arg2, arg3, arg4) {
          if (hidden) {
            hidden = false;
            game.emit(game.EVENT_SHOW, arg0, arg1, arg2, arg3, arg4);
          }
        }
        if (hiddenPropName) {
          var changeList = [ "visibilitychange", "mozvisibilitychange", "msvisibilitychange", "webkitvisibilitychange", "qbrowserVisibilityChange" ];
          for (var i = 0; i < changeList.length; i++) document.addEventListener(changeList[i], (function(event) {
            var visible = document[hiddenPropName];
            visible = visible || event["hidden"];
            visible ? onHidden() : onShown();
          }));
        } else {
          win.addEventListener("blur", onHidden);
          win.addEventListener("focus", onShown);
        }
        navigator.userAgent.indexOf("MicroMessenger") > -1 && (win.onfocus = onShown);
        if ("onpageshow" in window && "onpagehide" in window) {
          win.addEventListener("pagehide", onHidden);
          win.addEventListener("pageshow", onShown);
          document.addEventListener("pagehide", onHidden);
          document.addEventListener("pageshow", onShown);
        }
        this.on(game.EVENT_HIDE, (function() {
          game.pause();
        }));
        this.on(game.EVENT_SHOW, (function() {
          game.resume();
        }));
      }
    };
    EventTarget.call(game);
    cc.js.addon(game, EventTarget.prototype);
    cc.game = module.exports = game;
  }), {
    "../audio/CCAudioEngine": 22,
    "../core/renderer/utils/dynamic-atlas/manager": 324,
    "./CCDebug": 101,
    "./event/event-target": 219,
    "./renderer/index.js": 322
  } ],
  104: [ (function(require, module, exports) {
    "use strict";
    var _valueTypes = require("./value-types");
    var _utils = require("./value-types/utils");
    var BaseNode = require("./utils/base-node");
    var PrefabHelper = require("./utils/prefab-helper");
    var nodeMemPool = require("./utils/trans-pool").NodeMemPool;
    var AffineTrans = require("./utils/affine-transform");
    var eventManager = require("./event-manager");
    var macro = require("./platform/CCMacro");
    var js = require("./platform/js");
    var Event = require("./event/event");
    var EventTarget = require("./event/event-target");
    var RenderFlow = require("./renderer/render-flow");
    var Flags = cc.Object.Flags;
    var Destroying = Flags.Destroying;
    var ERR_INVALID_NUMBER = false;
    var ONE_DEGREE = Math.PI / 180;
    var ActionManagerExist = !!cc.ActionManager;
    var emptyFunc = function emptyFunc() {};
    var _gwpVec3 = new _valueTypes.Vec3();
    var _gwpQuat = new _valueTypes.Quat();
    var _tpVec3a = new _valueTypes.Vec3();
    var _tpVec3b = new _valueTypes.Vec3();
    var _tpQuata = new _valueTypes.Quat();
    var _tpQuatb = new _valueTypes.Quat();
    var _swpVec3 = new _valueTypes.Vec3();
    var _gwsVec3 = new _valueTypes.Vec3();
    var _swsVec3 = new _valueTypes.Vec3();
    var _gwrtVec3a = new _valueTypes.Vec3();
    var _gwrtVec3b = new _valueTypes.Vec3();
    var _gwrtQuata = new _valueTypes.Quat();
    var _gwrtQuatb = new _valueTypes.Quat();
    var _laVec3 = new _valueTypes.Vec3();
    var _laQuat = new _valueTypes.Quat();
    var _urfVec3 = new _valueTypes.Vec3();
    var _urfQuat = new _valueTypes.Quat();
    var _htVec3a = new _valueTypes.Vec3();
    var _htVec3b = new _valueTypes.Vec3();
    var _gwrQuat = new _valueTypes.Quat();
    var _swrQuat = new _valueTypes.Quat();
    var _quata = new _valueTypes.Quat();
    var _mat4_temp = cc.mat4();
    var _vec3_temp = new _valueTypes.Vec3();
    var POSITION_ON = 1;
    var SCALE_ON = 2;
    var ROTATION_ON = 4;
    var SIZE_ON = 8;
    var ANCHOR_ON = 16;
    var COLOR_ON = 32;
    var _cachedPool = new js.Pool();
    _cachedPool.get = function() {
      return this._get() || [];
    };
    var BuiltinGroupIndex = cc.Enum({
      DEBUG: 31
    });
    var LocalDirtyFlag = cc.Enum({
      POSITION: 1,
      SCALE: 2,
      ROTATION: 4,
      SKEW: 8,
      TRS: 7,
      RS: 6,
      TRSS: 15,
      PHYSICS_POSITION: 16,
      PHYSICS_SCALE: 32,
      PHYSICS_ROTATION: 64,
      PHYSICS_TRS: 112,
      PHYSICS_RS: 96,
      ALL_POSITION: 17,
      ALL_SCALE: 34,
      ALL_ROTATION: 68,
      ALL_TRS: 119,
      ALL: 65535
    });
    var EventType = cc.Enum({
      TOUCH_START: "touchstart",
      TOUCH_MOVE: "touchmove",
      TOUCH_END: "touchend",
      TOUCH_CANCEL: "touchcancel",
      MOUSE_DOWN: "mousedown",
      MOUSE_MOVE: "mousemove",
      MOUSE_ENTER: "mouseenter",
      MOUSE_LEAVE: "mouseleave",
      MOUSE_UP: "mouseup",
      MOUSE_WHEEL: "mousewheel",
      POSITION_CHANGED: "position-changed",
      ROTATION_CHANGED: "rotation-changed",
      SCALE_CHANGED: "scale-changed",
      SIZE_CHANGED: "size-changed",
      ANCHOR_CHANGED: "anchor-changed",
      COLOR_CHANGED: "color-changed",
      CHILD_ADDED: "child-added",
      CHILD_REMOVED: "child-removed",
      CHILD_REORDER: "child-reorder",
      GROUP_CHANGED: "group-changed",
      SIBLING_ORDER_CHANGED: "sibling-order-changed"
    });
    var _touchEvents = [ EventType.TOUCH_START, EventType.TOUCH_MOVE, EventType.TOUCH_END, EventType.TOUCH_CANCEL ];
    var _mouseEvents = [ EventType.MOUSE_DOWN, EventType.MOUSE_ENTER, EventType.MOUSE_MOVE, EventType.MOUSE_LEAVE, EventType.MOUSE_UP, EventType.MOUSE_WHEEL ];
    var _skewNeedWarn = true;
    var _skewWarn = function _skewWarn(value, node) {
      if (0 !== value) {
        var nodePath = "";
        var NodeUtils;
        false;
        _skewNeedWarn && cc.warn("`cc.Node.skewX/Y` is deprecated since v2.2.1, please use 3D node instead.", nodePath);
        true, _skewNeedWarn = false;
      }
    };
    var _currentHovered = null;
    var _touchStartHandler = function _touchStartHandler(touch, event) {
      var pos = touch.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        event.type = EventType.TOUCH_START;
        event.touch = touch;
        event.bubbles = true;
        node.dispatchEvent(event);
        return true;
      }
      return false;
    };
    var _touchMoveHandler = function _touchMoveHandler(touch, event) {
      var node = this.owner;
      event.type = EventType.TOUCH_MOVE;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
    };
    var _touchEndHandler = function _touchEndHandler(touch, event) {
      var pos = touch.getLocation();
      var node = this.owner;
      node._hitTest(pos, this) ? event.type = EventType.TOUCH_END : event.type = EventType.TOUCH_CANCEL;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
    };
    var _touchCancelHandler = function _touchCancelHandler(touch, event) {
      var pos = touch.getLocation();
      var node = this.owner;
      event.type = EventType.TOUCH_CANCEL;
      event.touch = touch;
      event.bubbles = true;
      node.dispatchEvent(event);
    };
    var _mouseDownHandler = function _mouseDownHandler(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        event.type = EventType.MOUSE_DOWN;
        event.bubbles = true;
        node.dispatchEvent(event);
      }
    };
    var _mouseMoveHandler = function _mouseMoveHandler(event) {
      var pos = event.getLocation();
      var node = this.owner;
      var hit = node._hitTest(pos, this);
      if (hit) {
        if (!this._previousIn) {
          if (_currentHovered && _currentHovered._mouseListener) {
            event.type = EventType.MOUSE_LEAVE;
            _currentHovered.dispatchEvent(event);
            _currentHovered._mouseListener._previousIn = false;
          }
          _currentHovered = this.owner;
          event.type = EventType.MOUSE_ENTER;
          node.dispatchEvent(event);
          this._previousIn = true;
        }
        event.type = EventType.MOUSE_MOVE;
        event.bubbles = true;
        node.dispatchEvent(event);
      } else {
        if (!this._previousIn) return;
        event.type = EventType.MOUSE_LEAVE;
        node.dispatchEvent(event);
        this._previousIn = false;
        _currentHovered = null;
      }
      event.stopPropagation();
    };
    var _mouseUpHandler = function _mouseUpHandler(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        event.type = EventType.MOUSE_UP;
        event.bubbles = true;
        node.dispatchEvent(event);
        event.stopPropagation();
      }
    };
    var _mouseWheelHandler = function _mouseWheelHandler(event) {
      var pos = event.getLocation();
      var node = this.owner;
      if (node._hitTest(pos, this)) {
        event.type = EventType.MOUSE_WHEEL;
        event.bubbles = true;
        node.dispatchEvent(event);
        event.stopPropagation();
      }
    };
    function _searchComponentsInParent(node, comp) {
      if (comp) {
        var index = 0;
        var list = null;
        for (var curr = node; curr && cc.Node.isNode(curr); curr = curr._parent, ++index) if (curr.getComponent(comp)) {
          var next = {
            index: index,
            node: curr
          };
          list ? list.push(next) : list = [ next ];
        }
        return list;
      }
      return null;
    }
    function _checkListeners(node, events) {
      if (!(node._objFlags & Destroying)) {
        if (node._bubblingListeners) for (var i = 0, l = events.length; i < l; ++i) if (node._bubblingListeners.hasEventListener(events[i])) return true;
        if (node._capturingListeners) for (var _i = 0, _l = events.length; _i < _l; ++_i) if (node._capturingListeners.hasEventListener(events[_i])) return true;
        return false;
      }
      return true;
    }
    function _doDispatchEvent(owner, event, cachedArray) {
      var target, i;
      event.target = owner;
      cachedArray.length = 0;
      owner._getCapturingTargets(event.type, cachedArray);
      event.eventPhase = 1;
      for (i = cachedArray.length - 1; i >= 0; --i) {
        target = cachedArray[i];
        if (target._capturingListeners) {
          event.currentTarget = target;
          target._capturingListeners.emit(event.type, event, cachedArray);
          if (event._propagationStopped) {
            cachedArray.length = 0;
            return;
          }
        }
      }
      cachedArray.length = 0;
      event.eventPhase = 2;
      event.currentTarget = owner;
      owner._capturingListeners && owner._capturingListeners.emit(event.type, event);
      !event._propagationImmediateStopped && owner._bubblingListeners && owner._bubblingListeners.emit(event.type, event);
      if (!event._propagationStopped && event.bubbles) {
        owner._getBubblingTargets(event.type, cachedArray);
        event.eventPhase = 3;
        for (i = 0; i < cachedArray.length; ++i) {
          target = cachedArray[i];
          if (target._bubblingListeners) {
            event.currentTarget = target;
            target._bubblingListeners.emit(event.type, event);
            if (event._propagationStopped) {
              cachedArray.length = 0;
              return;
            }
          }
        }
      }
      cachedArray.length = 0;
    }
    function _getActualGroupIndex(node) {
      var groupIndex = node.groupIndex;
      0 === groupIndex && node.parent && (groupIndex = _getActualGroupIndex(node.parent));
      return groupIndex;
    }
    function _updateCullingMask(node) {
      var index = _getActualGroupIndex(node);
      node._cullingMask = 1 << index;
      true, true;
      node._proxy && node._proxy.updateCullingMask();
      for (var i = 0; i < node._children.length; i++) _updateCullingMask(node._children[i]);
    }
    function updateLocalMatrix3D() {
      if (this._localMatDirty & LocalDirtyFlag.TRSS) {
        var t = this._matrix;
        var tm = t.m;
        _valueTypes.Trs.toMat4(t, this._trs);
        if (this._skewX || this._skewY) {
          var a = tm[0], b = tm[1], c = tm[4], d = tm[5];
          var skx = Math.tan(this._skewX * ONE_DEGREE);
          var sky = Math.tan(this._skewY * ONE_DEGREE);
          Infinity === skx && (skx = 99999999);
          Infinity === sky && (sky = 99999999);
          tm[0] = a + c * sky;
          tm[1] = b + d * sky;
          tm[4] = c + a * skx;
          tm[5] = d + b * skx;
        }
        this._localMatDirty &= ~LocalDirtyFlag.TRSS;
        this._worldMatDirty = true;
      }
    }
    function updateLocalMatrix2D() {
      var dirtyFlag = this._localMatDirty;
      if (!(dirtyFlag & LocalDirtyFlag.TRSS)) return;
      var t = this._matrix;
      var tm = t.m;
      var trs = this._trs;
      if (dirtyFlag & (LocalDirtyFlag.RS | LocalDirtyFlag.SKEW)) {
        var rotation = -this._eulerAngles.z;
        var hasSkew = this._skewX || this._skewY;
        var sx = trs[7], sy = trs[8];
        if (rotation || hasSkew) {
          var a = 1, b = 0, c = 0, d = 1;
          if (rotation) {
            var rotationRadians = rotation * ONE_DEGREE;
            c = Math.sin(rotationRadians);
            d = Math.cos(rotationRadians);
            a = d;
            b = -c;
          }
          tm[0] = a *= sx;
          tm[1] = b *= sx;
          tm[4] = c *= sy;
          tm[5] = d *= sy;
          if (hasSkew) {
            var _a = tm[0], _b = tm[1], _c = tm[4], _d = tm[5];
            var skx = Math.tan(this._skewX * ONE_DEGREE);
            var sky = Math.tan(this._skewY * ONE_DEGREE);
            Infinity === skx && (skx = 99999999);
            Infinity === sky && (sky = 99999999);
            tm[0] = _a + _c * sky;
            tm[1] = _b + _d * sky;
            tm[4] = _c + _a * skx;
            tm[5] = _d + _b * skx;
          }
        } else {
          tm[0] = sx;
          tm[1] = 0;
          tm[4] = 0;
          tm[5] = sy;
        }
      }
      tm[12] = trs[0];
      tm[13] = trs[1];
      this._localMatDirty &= ~LocalDirtyFlag.TRSS;
      this._worldMatDirty = true;
    }
    function calculWorldMatrix3D() {
      this._localMatDirty & LocalDirtyFlag.TRSS && this._updateLocalMatrix();
      if (this._parent) {
        var parentMat = this._parent._worldMatrix;
        _valueTypes.Mat4.mul(this._worldMatrix, parentMat, this._matrix);
      } else _valueTypes.Mat4.copy(this._worldMatrix, this._matrix);
      this._worldMatDirty = false;
    }
    function calculWorldMatrix2D() {
      this._localMatDirty & LocalDirtyFlag.TRSS && this._updateLocalMatrix();
      var parent = this._parent;
      parent ? this._mulMat(this._worldMatrix, parent._worldMatrix, this._matrix) : _valueTypes.Mat4.copy(this._worldMatrix, this._matrix);
      this._worldMatDirty = false;
    }
    function mulMat2D(out, a, b) {
      var am = a.m, bm = b.m, outm = out.m;
      var aa = am[0], ab = am[1], ac = am[4], ad = am[5], atx = am[12], aty = am[13];
      var ba = bm[0], bb = bm[1], bc = bm[4], bd = bm[5], btx = bm[12], bty = bm[13];
      if (0 !== ab || 0 !== ac) {
        outm[0] = ba * aa + bb * ac;
        outm[1] = ba * ab + bb * ad;
        outm[4] = bc * aa + bd * ac;
        outm[5] = bc * ab + bd * ad;
        outm[12] = aa * btx + ac * bty + atx;
        outm[13] = ab * btx + ad * bty + aty;
      } else {
        outm[0] = ba * aa;
        outm[1] = bb * ad;
        outm[4] = bc * aa;
        outm[5] = bd * ad;
        outm[12] = aa * btx + atx;
        outm[13] = ad * bty + aty;
      }
    }
    var mulMat3D = _valueTypes.Mat4.mul;
    var NodeDefines = {
      name: "cc.Node",
      extends: BaseNode,
      properties: {
        _opacity: 255,
        _color: cc.Color.WHITE,
        _contentSize: cc.Size,
        _anchorPoint: cc.v2(.5, .5),
        _position: void 0,
        _scale: void 0,
        _trs: null,
        _eulerAngles: cc.Vec3,
        _skewX: 0,
        _skewY: 0,
        _zIndex: {
          default: void 0,
          type: cc.Integer
        },
        _localZOrder: {
          default: 0,
          serializable: false
        },
        _is3DNode: false,
        _groupIndex: {
          default: 0,
          formerlySerializedAs: "groupIndex"
        },
        groupIndex: {
          get: function get() {
            return this._groupIndex;
          },
          set: function set(value) {
            this._groupIndex = value;
            _updateCullingMask(this);
            this.emit(EventType.GROUP_CHANGED, this);
          }
        },
        group: {
          get: function get() {
            return cc.game.groupList[this.groupIndex] || "";
          },
          set: function set(value) {
            this.groupIndex = cc.game.groupList.indexOf(value);
          }
        },
        x: {
          get: function get() {
            return this._trs[0];
          },
          set: function set(value) {
            var trs = this._trs;
            if (value !== trs[0]) {
              true;
              var oldValue;
              false;
              trs[0] = value;
              this.setLocalDirty(LocalDirtyFlag.ALL_POSITION);
              if (this._eventMask & POSITION_ON) {
                false;
                this.emit(EventType.POSITION_CHANGED);
              }
            }
          }
        },
        y: {
          get: function get() {
            return this._trs[1];
          },
          set: function set(value) {
            var trs = this._trs;
            if (value !== trs[1]) {
              true;
              var oldValue;
              false;
              trs[1] = value;
              this.setLocalDirty(LocalDirtyFlag.ALL_POSITION);
              if (this._eventMask & POSITION_ON) {
                false;
                this.emit(EventType.POSITION_CHANGED);
              }
            }
          }
        },
        z: {
          get: function get() {
            return this._trs[2];
          },
          set: function set(value) {
            var trs = this._trs;
            if (value !== trs[2]) {
              true;
              var oldValue;
              false;
              trs[2] = value;
              this.setLocalDirty(LocalDirtyFlag.ALL_POSITION);
              false;
              if (this._eventMask & POSITION_ON) {
                false;
                this.emit(EventType.POSITION_CHANGED);
              }
            }
          }
        },
        rotation: {
          get: function get() {
            true;
            cc.warn("`cc.Node.rotation` is deprecated since v2.1.0, please use `-angle` instead. (`this.node.rotation` -> `-this.node.angle`)");
            return -this.angle;
          },
          set: function set(value) {
            true;
            cc.warn("`cc.Node.rotation` is deprecated since v2.1.0, please set `-angle` instead. (`this.node.rotation = x` -> `this.node.angle = -x`)");
            this.angle = -value;
          }
        },
        angle: {
          get: function get() {
            return this._eulerAngles.z;
          },
          set: function set(value) {
            _valueTypes.Vec3.set(this._eulerAngles, 0, 0, value);
            _valueTypes.Trs.fromAngleZ(this._trs, value);
            this.setLocalDirty(LocalDirtyFlag.ALL_ROTATION);
            this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
          }
        },
        rotationX: {
          get: function get() {
            true;
            cc.warn("`cc.Node.rotationX` is deprecated since v2.1.0, please use `eulerAngles.x` instead. (`this.node.rotationX` -> `this.node.eulerAngles.x`)");
            return this._eulerAngles.x;
          },
          set: function set(value) {
            true;
            cc.warn("`cc.Node.rotationX` is deprecated since v2.1.0, please set `eulerAngles` instead. (`this.node.rotationX = x` -> `this.node.is3DNode = true; this.node.eulerAngles = cc.v3(x, 0, 0)`");
            if (this._eulerAngles.x !== value) {
              this._eulerAngles.x = value;
              this._eulerAngles.x === this._eulerAngles.y ? _valueTypes.Trs.fromAngleZ(this._trs, -value) : _valueTypes.Trs.fromEulerNumber(this._trs, value, this._eulerAngles.y, 0);
              this.setLocalDirty(LocalDirtyFlag.ALL_ROTATION);
              this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
            }
          }
        },
        rotationY: {
          get: function get() {
            true;
            cc.warn("`cc.Node.rotationY` is deprecated since v2.1.0, please use `eulerAngles.y` instead. (`this.node.rotationY` -> `this.node.eulerAngles.y`)");
            return this._eulerAngles.y;
          },
          set: function set(value) {
            true;
            cc.warn("`cc.Node.rotationY` is deprecated since v2.1.0, please set `eulerAngles` instead. (`this.node.rotationY = y` -> `this.node.is3DNode = true; this.node.eulerAngles = cc.v3(0, y, 0)`");
            if (this._eulerAngles.y !== value) {
              this._eulerAngles.y = value;
              this._eulerAngles.x === this._eulerAngles.y ? _valueTypes.Trs.fromAngleZ(this._trs, -value) : _valueTypes.Trs.fromEulerNumber(this._trs, this._eulerAngles.x, value, 0);
              this.setLocalDirty(LocalDirtyFlag.ALL_ROTATION);
              this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
            }
          }
        },
        eulerAngles: {
          get: function get() {
            false;
            return _valueTypes.Trs.toEuler(this._eulerAngles, this._trs);
          },
          set: function set(v) {
            false;
            _valueTypes.Trs.fromEuler(this._trs, v);
            this.setLocalDirty(LocalDirtyFlag.ALL_ROTATION);
            false;
            this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
          }
        },
        quat: {
          get: function get() {
            var trs = this._trs;
            return new _valueTypes.Quat(trs[3], trs[4], trs[5], trs[6]);
          },
          set: function set(v) {
            this.setRotation(v);
          }
        },
        scale: {
          get: function get() {
            return this._trs[7];
          },
          set: function set(v) {
            this.setScale(v);
          }
        },
        scaleX: {
          get: function get() {
            return this._trs[7];
          },
          set: function set(value) {
            if (this._trs[7] !== value) {
              this._trs[7] = value;
              this.setLocalDirty(LocalDirtyFlag.ALL_SCALE);
              this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
            }
          }
        },
        scaleY: {
          get: function get() {
            return this._trs[8];
          },
          set: function set(value) {
            if (this._trs[8] !== value) {
              this._trs[8] = value;
              this.setLocalDirty(LocalDirtyFlag.ALL_SCALE);
              this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
            }
          }
        },
        scaleZ: {
          get: function get() {
            return this._trs[9];
          },
          set: function set(value) {
            if (this._trs[9] !== value) {
              this._trs[9] = value;
              this.setLocalDirty(LocalDirtyFlag.ALL_SCALE);
              false;
              this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
            }
          }
        },
        skewX: {
          get: function get() {
            return this._skewX;
          },
          set: function set(value) {
            _skewWarn(value, this);
            this._skewX = value;
            this.setLocalDirty(LocalDirtyFlag.SKEW);
            true, true;
            this._proxy.updateSkew();
          }
        },
        skewY: {
          get: function get() {
            return this._skewY;
          },
          set: function set(value) {
            _skewWarn(value, this);
            this._skewY = value;
            this.setLocalDirty(LocalDirtyFlag.SKEW);
            true, true;
            this._proxy.updateSkew();
          }
        },
        opacity: {
          get: function get() {
            return this._opacity;
          },
          set: function set(value) {
            value = cc.misc.clampf(value, 0, 255);
            if (this._opacity !== value) {
              this._opacity = value;
              true, true;
              this._proxy.updateOpacity();
              this._renderFlag |= RenderFlow.FLAG_OPACITY_COLOR;
            }
          },
          range: [ 0, 255 ]
        },
        color: {
          get: function get() {
            return this._color.clone();
          },
          set: function set(value) {
            if (!this._color.equals(value)) {
              this._color.set(value);
              (true, 255 !== value.a) && cc.warnID(1626);
              this._renderFlag |= RenderFlow.FLAG_COLOR;
              this._eventMask & COLOR_ON && this.emit(EventType.COLOR_CHANGED, value);
            }
          }
        },
        anchorX: {
          get: function get() {
            return this._anchorPoint.x;
          },
          set: function set(value) {
            var anchorPoint = this._anchorPoint;
            if (anchorPoint.x !== value) {
              anchorPoint.x = value;
              this._eventMask & ANCHOR_ON && this.emit(EventType.ANCHOR_CHANGED);
            }
          }
        },
        anchorY: {
          get: function get() {
            return this._anchorPoint.y;
          },
          set: function set(value) {
            var anchorPoint = this._anchorPoint;
            if (anchorPoint.y !== value) {
              anchorPoint.y = value;
              this._eventMask & ANCHOR_ON && this.emit(EventType.ANCHOR_CHANGED);
            }
          }
        },
        width: {
          get: function get() {
            return this._contentSize.width;
          },
          set: function set(value) {
            if (value !== this._contentSize.width) {
              var clone;
              false;
              this._contentSize.width = value;
              if (this._eventMask & SIZE_ON) {
                false;
                this.emit(EventType.SIZE_CHANGED);
              }
            }
          }
        },
        height: {
          get: function get() {
            return this._contentSize.height;
          },
          set: function set(value) {
            if (value !== this._contentSize.height) {
              var clone;
              false;
              this._contentSize.height = value;
              if (this._eventMask & SIZE_ON) {
                false;
                this.emit(EventType.SIZE_CHANGED);
              }
            }
          }
        },
        zIndex: {
          get: function get() {
            return this._localZOrder >> 16;
          },
          set: function set(value) {
            if (value > macro.MAX_ZINDEX) {
              cc.warnID(1636);
              value = macro.MAX_ZINDEX;
            } else if (value < macro.MIN_ZINDEX) {
              cc.warnID(1637);
              value = macro.MIN_ZINDEX;
            }
            if (this.zIndex !== value) {
              this._localZOrder = 65535 & this._localZOrder | value << 16;
              this.emit(EventType.SIBLING_ORDER_CHANGED);
              this._onSiblingIndexChanged();
            }
          }
        },
        is3DNode: {
          get: function get() {
            return this._is3DNode;
          },
          set: function set(v) {
            if (this._is3DNode === v) return;
            this._is3DNode = v;
            this._update3DFunction();
          }
        },
        up: {
          get: function get() {
            var _up = _valueTypes.Vec3.transformQuat(_urfVec3, _valueTypes.Vec3.UP, this.getWorldRotation(_urfQuat));
            return _up.clone();
          }
        },
        right: {
          get: function get() {
            var _right = _valueTypes.Vec3.transformQuat(_urfVec3, _valueTypes.Vec3.RIGHT, this.getWorldRotation(_urfQuat));
            return _right.clone();
          }
        },
        forward: {
          get: function get() {
            var _forward = _valueTypes.Vec3.transformQuat(_urfVec3, _valueTypes.Vec3.FORWARD, this.getWorldRotation(_urfQuat));
            return _forward.clone();
          }
        }
      },
      ctor: function ctor() {
        this._reorderChildDirty = false;
        this._widget = null;
        this._renderComponent = null;
        this._capturingListeners = null;
        this._bubblingListeners = null;
        this._touchListener = null;
        this._mouseListener = null;
        this._initDataFromPool();
        this._eventMask = 0;
        this._cullingMask = 1;
        this._childArrivalOrder = 1;
        true, true;
        this._proxy = new renderer.NodeProxy(this._spaceInfo.unitID, this._spaceInfo.index, this._id, this._name);
        this._proxy.init(this);
        this._renderFlag = RenderFlow.FLAG_TRANSFORM | RenderFlow.FLAG_OPACITY_COLOR;
      },
      statics: {
        EventType: EventType,
        _LocalDirtyFlag: LocalDirtyFlag,
        isNode: function isNode(obj) {
          return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cc.Scene));
        },
        BuiltinGroupIndex: BuiltinGroupIndex
      },
      _onSiblingIndexChanged: function _onSiblingIndexChanged() {
        this._parent && this._parent._delaySort();
      },
      _onPreDestroy: function _onPreDestroy() {
        var destroyByParent = this._onPreDestroyBase();
        ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
        _currentHovered === this && (_currentHovered = null);
        this._bubblingListeners && this._bubblingListeners.clear();
        this._capturingListeners && this._capturingListeners.clear();
        if (this._touchListener || this._mouseListener) {
          eventManager.removeListeners(this);
          if (this._touchListener) {
            this._touchListener.owner = null;
            this._touchListener.mask = null;
            this._touchListener = null;
          }
          if (this._mouseListener) {
            this._mouseListener.owner = null;
            this._mouseListener.mask = null;
            this._mouseListener = null;
          }
        }
        true, true;
        this._proxy.destroy();
        this._proxy = null;
        this._backDataIntoPool();
        this._reorderChildDirty && cc.director.__fastOff(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        destroyByParent || false;
      },
      _onPostActivated: function _onPostActivated(active) {
        var actionManager = ActionManagerExist ? cc.director.getActionManager() : null;
        if (active) {
          this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM;
          actionManager && actionManager.resumeTarget(this);
          eventManager.resumeTarget(this);
          this._checkListenerMask();
        } else {
          actionManager && actionManager.pauseTarget(this);
          eventManager.pauseTarget(this);
        }
      },
      _onHierarchyChanged: function _onHierarchyChanged(oldParent) {
        this._updateOrderOfArrival();
        _updateCullingMask(this);
        this._parent && this._parent._delaySort();
        this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM | RenderFlow.FLAG_OPACITY_COLOR;
        this._onHierarchyChangedBase(oldParent);
        cc._widgetManager && (cc._widgetManager._nodesOrderDirty = true);
        oldParent && this._activeInHierarchy && this._checkListenerMask();
        true, true;
        this._proxy.updateParent();
      },
      _update3DFunction: function _update3DFunction() {
        if (this._is3DNode) {
          this._updateLocalMatrix = updateLocalMatrix3D;
          this._calculWorldMatrix = calculWorldMatrix3D;
          this._mulMat = mulMat3D;
        } else {
          this._updateLocalMatrix = updateLocalMatrix2D;
          this._calculWorldMatrix = calculWorldMatrix2D;
          this._mulMat = mulMat2D;
        }
        this._renderComponent && this._renderComponent._on3DNodeChanged && this._renderComponent._on3DNodeChanged();
        this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
        this._localMatDirty = LocalDirtyFlag.ALL;
        true, true;
        this._proxy.update3DNode();
      },
      _initDataFromPool: function _initDataFromPool() {
        if (!this._spaceInfo) {
          false, false;
          this._spaceInfo = nodeMemPool.pop();
        }
        var spaceInfo = this._spaceInfo;
        this._matrix = cc.mat4(spaceInfo.localMat);
        _valueTypes.Mat4.identity(this._matrix);
        this._worldMatrix = cc.mat4(spaceInfo.worldMat);
        _valueTypes.Mat4.identity(this._worldMatrix);
        this._localMatDirty = LocalDirtyFlag.ALL;
        this._worldMatDirty = true;
        var trs = this._trs = spaceInfo.trs;
        trs[0] = 0;
        trs[1] = 0;
        trs[2] = 0;
        trs[3] = 0;
        trs[4] = 0;
        trs[5] = 0;
        trs[6] = 1;
        trs[7] = 1;
        trs[8] = 1;
        trs[9] = 1;
      },
      _backDataIntoPool: function _backDataIntoPool() {
        if (!(false, false)) {
          nodeMemPool.push(this._spaceInfo);
          this._matrix = null;
          this._worldMatrix = null;
          this._trs = null;
          this._spaceInfo = null;
        }
      },
      _toEuler: function _toEuler() {
        if (this.is3DNode) _valueTypes.Trs.toEuler(this._eulerAngles, this._trs); else {
          var z = Math.asin(this._trs[5]) / ONE_DEGREE * 2;
          _valueTypes.Vec3.set(this._eulerAngles, 0, 0, z);
        }
      },
      _fromEuler: function _fromEuler() {
        this.is3DNode ? _valueTypes.Trs.fromEuler(this._trs, this._eulerAngles) : _valueTypes.Trs.fromAngleZ(this._trs, this._eulerAngles.z);
      },
      _initProperties: function _initProperties() {
        this._is3DNode && this._update3DFunction();
        var trs = this._trs;
        if (trs) {
          var desTrs = trs;
          trs = this._trs = this._spaceInfo.trs;
          11 === desTrs.length ? trs.set(desTrs.subarray(1)) : trs.set(desTrs);
        } else trs = this._trs = this._spaceInfo.trs;
        var NodeUtils;
        false;
        this._fromEuler();
        true, true;
        this._renderFlag |= RenderFlow.FLAG_TRANSFORM | RenderFlow.FLAG_OPACITY_COLOR;
      },
      _onBatchCreated: function _onBatchCreated(dontSyncChildPrefab) {
        this._initProperties();
        this._cullingMask = 1 << _getActualGroupIndex(this);
        true, true;
        this._proxy && this._proxy.updateCullingMask();
        if (!this._activeInHierarchy) {
          ActionManagerExist && cc.director.getActionManager().pauseTarget(this);
          eventManager.pauseTarget(this);
        }
        var children = this._children;
        for (var i = 0, len = children.length; i < len; i++) {
          var child = children[i];
          if (!dontSyncChildPrefab) {
            var prefabInfo = child._prefab;
            prefabInfo && prefabInfo.sync && prefabInfo.root === child && PrefabHelper.syncWithPrefab(child);
            child._updateOrderOfArrival();
          }
          child._onBatchCreated(dontSyncChildPrefab);
        }
        children.length > 0 && (this._renderFlag |= RenderFlow.FLAG_CHILDREN);
        true, true;
        this._proxy.initNative();
      },
      _checkListenerMask: function _checkListenerMask() {
        if (this._touchListener) {
          var mask = this._touchListener.mask = _searchComponentsInParent(this, cc.Mask);
          this._mouseListener && (this._mouseListener.mask = mask);
        } else this._mouseListener && (this._mouseListener.mask = _searchComponentsInParent(this, cc.Mask));
      },
      _checknSetupSysEvent: function _checknSetupSysEvent(type) {
        var newAdded = false;
        var forDispatch = false;
        if (-1 !== _touchEvents.indexOf(type)) {
          if (!this._touchListener) {
            this._touchListener = cc.EventListener.create({
              event: cc.EventListener.TOUCH_ONE_BY_ONE,
              swallowTouches: true,
              owner: this,
              mask: _searchComponentsInParent(this, cc.Mask),
              onTouchBegan: _touchStartHandler,
              onTouchMoved: _touchMoveHandler,
              onTouchEnded: _touchEndHandler,
              onTouchCancelled: _touchCancelHandler
            });
            eventManager.addListener(this._touchListener, this);
            newAdded = true;
          }
          forDispatch = true;
        } else if (-1 !== _mouseEvents.indexOf(type)) {
          if (!this._mouseListener) {
            this._mouseListener = cc.EventListener.create({
              event: cc.EventListener.MOUSE,
              _previousIn: false,
              owner: this,
              mask: _searchComponentsInParent(this, cc.Mask),
              onMouseDown: _mouseDownHandler,
              onMouseMove: _mouseMoveHandler,
              onMouseUp: _mouseUpHandler,
              onMouseScroll: _mouseWheelHandler
            });
            eventManager.addListener(this._mouseListener, this);
            newAdded = true;
          }
          forDispatch = true;
        }
        newAdded && !this._activeInHierarchy && cc.director.getScheduler().schedule((function() {
          this._activeInHierarchy || eventManager.pauseTarget(this);
        }), this, 0, 0, 0, false);
        return forDispatch;
      },
      on: function on(type, callback, target, useCapture) {
        var forDispatch = this._checknSetupSysEvent(type);
        if (forDispatch) return this._onDispatch(type, callback, target, useCapture);
        switch (type) {
         case EventType.POSITION_CHANGED:
          this._eventMask |= POSITION_ON;
          break;

         case EventType.SCALE_CHANGED:
          this._eventMask |= SCALE_ON;
          break;

         case EventType.ROTATION_CHANGED:
          this._eventMask |= ROTATION_ON;
          break;

         case EventType.SIZE_CHANGED:
          this._eventMask |= SIZE_ON;
          break;

         case EventType.ANCHOR_CHANGED:
          this._eventMask |= ANCHOR_ON;
          break;

         case EventType.COLOR_CHANGED:
          this._eventMask |= COLOR_ON;
        }
        this._bubblingListeners || (this._bubblingListeners = new EventTarget());
        return this._bubblingListeners.on(type, callback, target);
      },
      once: function once(type, callback, target, useCapture) {
        var _this = this;
        var forDispatch = this._checknSetupSysEvent(type);
        var listeners = null;
        listeners = forDispatch && useCapture ? this._capturingListeners = this._capturingListeners || new EventTarget() : this._bubblingListeners = this._bubblingListeners || new EventTarget();
        listeners.once(type, callback, target);
        listeners.once(type, (function() {
          _this.off(type, callback, target);
        }), void 0);
      },
      _onDispatch: function _onDispatch(type, callback, target, useCapture) {
        if ("boolean" === typeof target) {
          useCapture = target;
          target = void 0;
        } else useCapture = !!useCapture;
        if (!callback) {
          cc.errorID(6800);
          return;
        }
        var listeners = null;
        listeners = useCapture ? this._capturingListeners = this._capturingListeners || new EventTarget() : this._bubblingListeners = this._bubblingListeners || new EventTarget();
        if (!listeners.hasEventListener(type, callback, target)) {
          listeners.on(type, callback, target);
          target && target.__eventTargets && target.__eventTargets.push(this);
        }
        return callback;
      },
      off: function off(type, callback, target, useCapture) {
        var touchEvent = -1 !== _touchEvents.indexOf(type);
        var mouseEvent = !touchEvent && -1 !== _mouseEvents.indexOf(type);
        if (touchEvent || mouseEvent) {
          this._offDispatch(type, callback, target, useCapture);
          if (touchEvent) {
            if (this._touchListener && !_checkListeners(this, _touchEvents)) {
              eventManager.removeListener(this._touchListener);
              this._touchListener = null;
            }
          } else if (mouseEvent && this._mouseListener && !_checkListeners(this, _mouseEvents)) {
            eventManager.removeListener(this._mouseListener);
            this._mouseListener = null;
          }
        } else if (this._bubblingListeners) {
          this._bubblingListeners.off(type, callback, target);
          var hasListeners = this._bubblingListeners.hasEventListener(type);
          if (!hasListeners) switch (type) {
           case EventType.POSITION_CHANGED:
            this._eventMask &= ~POSITION_ON;
            break;

           case EventType.SCALE_CHANGED:
            this._eventMask &= ~SCALE_ON;
            break;

           case EventType.ROTATION_CHANGED:
            this._eventMask &= ~ROTATION_ON;
            break;

           case EventType.SIZE_CHANGED:
            this._eventMask &= ~SIZE_ON;
            break;

           case EventType.ANCHOR_CHANGED:
            this._eventMask &= ~ANCHOR_ON;
            break;

           case EventType.COLOR_CHANGED:
            this._eventMask &= ~COLOR_ON;
          }
        }
      },
      _offDispatch: function _offDispatch(type, callback, target, useCapture) {
        if ("boolean" === typeof target) {
          useCapture = target;
          target = void 0;
        } else useCapture = !!useCapture;
        if (callback) {
          var listeners = useCapture ? this._capturingListeners : this._bubblingListeners;
          if (listeners) {
            listeners.off(type, callback, target);
            target && target.__eventTargets && js.array.fastRemove(target.__eventTargets, this);
          }
        } else {
          this._capturingListeners && this._capturingListeners.removeAll(type);
          this._bubblingListeners && this._bubblingListeners.removeAll(type);
        }
      },
      targetOff: function targetOff(target) {
        var listeners = this._bubblingListeners;
        if (listeners) {
          listeners.targetOff(target);
          this._eventMask & POSITION_ON && !listeners.hasEventListener(EventType.POSITION_CHANGED) && (this._eventMask &= ~POSITION_ON);
          this._eventMask & SCALE_ON && !listeners.hasEventListener(EventType.SCALE_CHANGED) && (this._eventMask &= ~SCALE_ON);
          this._eventMask & ROTATION_ON && !listeners.hasEventListener(EventType.ROTATION_CHANGED) && (this._eventMask &= ~ROTATION_ON);
          this._eventMask & SIZE_ON && !listeners.hasEventListener(EventType.SIZE_CHANGED) && (this._eventMask &= ~SIZE_ON);
          this._eventMask & ANCHOR_ON && !listeners.hasEventListener(EventType.ANCHOR_CHANGED) && (this._eventMask &= ~ANCHOR_ON);
          this._eventMask & COLOR_ON && !listeners.hasEventListener(EventType.COLOR_CHANGED) && (this._eventMask &= ~COLOR_ON);
        }
        this._capturingListeners && this._capturingListeners.targetOff(target);
        target && target.__eventTargets && js.array.fastRemove(target.__eventTargets, this);
        if (this._touchListener && !_checkListeners(this, _touchEvents)) {
          eventManager.removeListener(this._touchListener);
          this._touchListener = null;
        }
        if (this._mouseListener && !_checkListeners(this, _mouseEvents)) {
          eventManager.removeListener(this._mouseListener);
          this._mouseListener = null;
        }
      },
      hasEventListener: function hasEventListener(type) {
        var has = false;
        this._bubblingListeners && (has = this._bubblingListeners.hasEventListener(type));
        !has && this._capturingListeners && (has = this._capturingListeners.hasEventListener(type));
        return has;
      },
      emit: function emit(type, arg1, arg2, arg3, arg4, arg5) {
        this._bubblingListeners && this._bubblingListeners.emit(type, arg1, arg2, arg3, arg4, arg5);
      },
      dispatchEvent: function dispatchEvent(event) {
        var _array = _cachedPool.get();
        _doDispatchEvent(this, event, _array);
        _cachedPool.put(_array);
      },
      pauseSystemEvents: function pauseSystemEvents(recursive) {
        eventManager.pauseTarget(this, recursive);
      },
      resumeSystemEvents: function resumeSystemEvents(recursive) {
        eventManager.resumeTarget(this, recursive);
      },
      _hitTest: function _hitTest(point, listener) {
        var w = this._contentSize.width, h = this._contentSize.height, cameraPt = _htVec3a, testPt = _htVec3b;
        var camera = cc.Camera.findCamera(this);
        camera ? camera.getScreenToWorldPoint(point, cameraPt) : cameraPt.set(point);
        this._updateWorldMatrix();
        if (!_valueTypes.Mat4.invert(_mat4_temp, this._worldMatrix)) return false;
        _valueTypes.Vec2.transformMat4(testPt, cameraPt, _mat4_temp);
        testPt.x += this._anchorPoint.x * w;
        testPt.y += this._anchorPoint.y * h;
        var hit = false;
        if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
          hit = true;
          if (listener && listener.mask) {
            var mask = listener.mask;
            var parent = this;
            var length = mask ? mask.length : 0;
            for (var i = 0, j = 0; parent && j < length; ++i, parent = parent.parent) {
              var temp = mask[j];
              if (i === temp.index) {
                if (parent !== temp.node) {
                  mask.length = j;
                  break;
                }
                var comp = parent.getComponent(cc.Mask);
                if (comp && comp._enabled && !comp._hitTest(cameraPt)) {
                  hit = false;
                  break;
                }
                j++;
              } else if (i > temp.index) {
                mask.length = j;
                break;
              }
            }
          }
        }
        return hit;
      },
      _getCapturingTargets: function _getCapturingTargets(type, array) {
        var parent = this.parent;
        while (parent) {
          parent._capturingListeners && parent._capturingListeners.hasEventListener(type) && array.push(parent);
          parent = parent.parent;
        }
      },
      _getBubblingTargets: function _getBubblingTargets(type, array) {
        var parent = this.parent;
        while (parent) {
          parent._bubblingListeners && parent._bubblingListeners.hasEventListener(type) && array.push(parent);
          parent = parent.parent;
        }
      },
      runAction: ActionManagerExist ? function(action) {
        if (!this.active) return;
        cc.assertID(action, 1618);
        var am = cc.director.getActionManager();
        if (!am._suppressDeprecation) {
          am._suppressDeprecation = true;
          cc.warnID(1639);
        }
        am.addAction(action, this, false);
        return action;
      } : emptyFunc,
      pauseAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().pauseTarget(this);
      } : emptyFunc,
      resumeAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().resumeTarget(this);
      } : emptyFunc,
      stopAllActions: ActionManagerExist ? function() {
        cc.director.getActionManager().removeAllActionsFromTarget(this);
      } : emptyFunc,
      stopAction: ActionManagerExist ? function(action) {
        cc.director.getActionManager().removeAction(action);
      } : emptyFunc,
      stopActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1612);
          return;
        }
        cc.director.getActionManager().removeActionByTag(tag, this);
      } : emptyFunc,
      getActionByTag: ActionManagerExist ? function(tag) {
        if (tag === cc.Action.TAG_INVALID) {
          cc.logID(1613);
          return null;
        }
        return cc.director.getActionManager().getActionByTag(tag, this);
      } : function() {
        return null;
      },
      getNumberOfRunningActions: ActionManagerExist ? function() {
        return cc.director.getActionManager().getNumberOfRunningActionsInTarget(this);
      } : function() {
        return 0;
      },
      getPosition: function getPosition(out) {
        out = out || new _valueTypes.Vec3();
        return _valueTypes.Trs.toPosition(out, this._trs);
      },
      setPosition: function setPosition(newPosOrX, y, z) {
        var x;
        if (void 0 === y) {
          x = newPosOrX.x;
          y = newPosOrX.y;
          z = newPosOrX.z;
        } else x = newPosOrX;
        var trs = this._trs;
        void 0 === z && (z = trs[2]);
        if (trs[0] === x && trs[1] === y && trs[2] === z) return;
        var oldPosition;
        false;
        trs[0] = x;
        trs[1] = y;
        trs[2] = z;
        this.setLocalDirty(LocalDirtyFlag.ALL_POSITION);
        false;
        if (this._eventMask & POSITION_ON) {
          false;
          this.emit(EventType.POSITION_CHANGED);
        }
      },
      getScale: function getScale(out) {
        if (void 0 !== out) return _valueTypes.Trs.toScale(out, this._trs);
        cc.errorID(1400, "cc.Node.getScale", "cc.Node.scale or cc.Node.getScale(cc.Vec3)");
        return this._trs[7];
      },
      setScale: function setScale(newScaleOrX, y, z) {
        var x;
        if (newScaleOrX && "number" !== typeof newScaleOrX) {
          x = newScaleOrX.x;
          y = newScaleOrX.y;
          z = newScaleOrX.z;
        } else if (void 0 !== newScaleOrX && void 0 === y) {
          x = newScaleOrX;
          y = newScaleOrX;
          z = newScaleOrX;
        } else x = newScaleOrX;
        var trs = this._trs;
        void 0 === z && (z = trs[9]);
        if (trs[7] !== x || trs[8] !== y || trs[9] !== z) {
          trs[7] = x;
          trs[8] = y;
          trs[9] = z;
          this.setLocalDirty(LocalDirtyFlag.ALL_SCALE);
          false;
          this._eventMask & SCALE_ON && this.emit(EventType.SCALE_CHANGED);
        }
      },
      getRotation: function getRotation(out) {
        if (out instanceof _valueTypes.Quat) return _valueTypes.Trs.toRotation(out, this._trs);
        true;
        cc.warn("`cc.Node.getRotation()` is deprecated since v2.1.0, please use `-cc.Node.angle` instead. (`this.node.getRotation()` -> `-this.node.angle`)");
        return -this.angle;
      },
      setRotation: function setRotation(rotation, y, z, w) {
        if ("number" === typeof rotation && void 0 === y) {
          true;
          cc.warn("`cc.Node.setRotation(degree)` is deprecated since v2.1.0, please set `-cc.Node.angle` instead. (`this.node.setRotation(x)` -> `this.node.angle = -x`)");
          this.angle = -rotation;
        } else {
          var x = rotation;
          if (void 0 === y) {
            x = rotation.x;
            y = rotation.y;
            z = rotation.z;
            w = rotation.w;
          }
          var trs = this._trs;
          if (trs[3] !== x || trs[4] !== y || trs[5] !== z || trs[6] !== w) {
            trs[3] = x;
            trs[4] = y;
            trs[5] = z;
            trs[6] = w;
            this.setLocalDirty(LocalDirtyFlag.ALL_ROTATION);
            this._eventMask & ROTATION_ON && this.emit(EventType.ROTATION_CHANGED);
            false;
          }
        }
      },
      getContentSize: function getContentSize() {
        return cc.size(this._contentSize.width, this._contentSize.height);
      },
      setContentSize: function setContentSize(size, height) {
        var locContentSize = this._contentSize;
        var clone;
        if (void 0 === height) {
          if ((0, _utils.approx)(size.width, locContentSize.width) && (0, _utils.approx)(size.height, locContentSize.height)) return;
          false;
          locContentSize.width = size.width;
          locContentSize.height = size.height;
        } else {
          if ((0, _utils.approx)(size, locContentSize.width) && (0, _utils.approx)(height, locContentSize.height)) return;
          false;
          locContentSize.width = size;
          locContentSize.height = height;
        }
        if (this._eventMask & SIZE_ON) {
          false;
          this.emit(EventType.SIZE_CHANGED);
        }
      },
      getAnchorPoint: function getAnchorPoint() {
        return cc.v2(this._anchorPoint);
      },
      setAnchorPoint: function setAnchorPoint(point, y) {
        var locAnchorPoint = this._anchorPoint;
        if (void 0 === y) {
          if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) return;
          locAnchorPoint.x = point.x;
          locAnchorPoint.y = point.y;
        } else {
          if (point === locAnchorPoint.x && y === locAnchorPoint.y) return;
          locAnchorPoint.x = point;
          locAnchorPoint.y = y;
        }
        this.setLocalDirty(LocalDirtyFlag.ALL_POSITION);
        this._eventMask & ANCHOR_ON && this.emit(EventType.ANCHOR_CHANGED);
      },
      _invTransformPoint: function _invTransformPoint(out, pos) {
        this._parent ? this._parent._invTransformPoint(out, pos) : _valueTypes.Vec3.copy(out, pos);
        var ltrs = this._trs;
        _valueTypes.Trs.toPosition(_tpVec3a, ltrs);
        _valueTypes.Vec3.sub(out, out, _tpVec3a);
        _valueTypes.Trs.toRotation(_tpQuata, ltrs);
        _valueTypes.Quat.conjugate(_tpQuatb, _tpQuata);
        _valueTypes.Vec3.transformQuat(out, out, _tpQuatb);
        _valueTypes.Trs.toScale(_tpVec3a, ltrs);
        _valueTypes.Vec3.inverseSafe(_tpVec3b, _tpVec3a);
        _valueTypes.Vec3.mul(out, out, _tpVec3b);
        return out;
      },
      getWorldPosition: function getWorldPosition(out) {
        _valueTypes.Trs.toPosition(out, this._trs);
        var curr = this._parent;
        var ltrs;
        while (curr) {
          ltrs = curr._trs;
          _valueTypes.Trs.toScale(_gwpVec3, ltrs);
          _valueTypes.Vec3.mul(out, out, _gwpVec3);
          _valueTypes.Trs.toRotation(_gwpQuat, ltrs);
          _valueTypes.Vec3.transformQuat(out, out, _gwpQuat);
          _valueTypes.Trs.toPosition(_gwpVec3, ltrs);
          _valueTypes.Vec3.add(out, out, _gwpVec3);
          curr = curr._parent;
        }
        return out;
      },
      setWorldPosition: function setWorldPosition(pos) {
        var ltrs = this._trs;
        var oldPosition;
        false;
        this._parent ? this._parent._invTransformPoint(_swpVec3, pos) : _valueTypes.Vec3.copy(_swpVec3, pos);
        _valueTypes.Trs.fromPosition(ltrs, _swpVec3);
        this.setLocalDirty(LocalDirtyFlag.ALL_POSITION);
        if (this._eventMask & POSITION_ON) {
          false;
          this.emit(EventType.POSITION_CHANGED);
        }
      },
      getWorldRotation: function getWorldRotation(out) {
        _valueTypes.Trs.toRotation(_gwrQuat, this._trs);
        _valueTypes.Quat.copy(out, _gwrQuat);
        var curr = this._parent;
        while (curr) {
          _valueTypes.Trs.toRotation(_gwrQuat, curr._trs);
          _valueTypes.Quat.mul(out, _gwrQuat, out);
          curr = curr._parent;
        }
        return out;
      },
      setWorldRotation: function setWorldRotation(val) {
        if (this._parent) {
          this._parent.getWorldRotation(_swrQuat);
          _valueTypes.Quat.conjugate(_swrQuat, _swrQuat);
          _valueTypes.Quat.mul(_swrQuat, _swrQuat, val);
        } else _valueTypes.Quat.copy(_swrQuat, val);
        _valueTypes.Trs.fromRotation(this._trs, _swrQuat);
        false;
        this.setLocalDirty(LocalDirtyFlag.ALL_ROTATION);
      },
      getWorldScale: function getWorldScale(out) {
        _valueTypes.Trs.toScale(_gwsVec3, this._trs);
        _valueTypes.Vec3.copy(out, _gwsVec3);
        var curr = this._parent;
        while (curr) {
          _valueTypes.Trs.toScale(_gwsVec3, curr._trs);
          _valueTypes.Vec3.mul(out, out, _gwsVec3);
          curr = curr._parent;
        }
        return out;
      },
      setWorldScale: function setWorldScale(scale) {
        if (this._parent) {
          this._parent.getWorldScale(_swsVec3);
          _valueTypes.Vec3.div(_swsVec3, scale, _swsVec3);
        } else _valueTypes.Vec3.copy(_swsVec3, scale);
        _valueTypes.Trs.fromScale(this._trs, _swsVec3);
        this.setLocalDirty(LocalDirtyFlag.ALL_SCALE);
      },
      getWorldRT: function getWorldRT(out) {
        var opos = _gwrtVec3a;
        var orot = _gwrtQuata;
        var ltrs = this._trs;
        _valueTypes.Trs.toPosition(opos, ltrs);
        _valueTypes.Trs.toRotation(orot, ltrs);
        var curr = this._parent;
        while (curr) {
          ltrs = curr._trs;
          _valueTypes.Trs.toScale(_gwrtVec3b, ltrs);
          _valueTypes.Vec3.mul(opos, opos, _gwrtVec3b);
          _valueTypes.Trs.toRotation(_gwrtQuatb, ltrs);
          _valueTypes.Vec3.transformQuat(opos, opos, _gwrtQuatb);
          _valueTypes.Trs.toPosition(_gwrtVec3b, ltrs);
          _valueTypes.Vec3.add(opos, opos, _gwrtVec3b);
          _valueTypes.Quat.mul(orot, _gwrtQuatb, orot);
          curr = curr._parent;
        }
        _valueTypes.Mat4.fromRT(out, orot, opos);
        return out;
      },
      lookAt: function lookAt(pos, up) {
        this.getWorldPosition(_laVec3);
        _valueTypes.Vec3.sub(_laVec3, _laVec3, pos);
        _valueTypes.Vec3.normalize(_laVec3, _laVec3);
        _valueTypes.Quat.fromViewUp(_laQuat, _laVec3, up);
        this.setWorldRotation(_laQuat);
      },
      _updateLocalMatrix: updateLocalMatrix2D,
      _calculWorldMatrix: function _calculWorldMatrix() {
        this._localMatDirty & LocalDirtyFlag.TRSS && this._updateLocalMatrix();
        var parent = this._parent;
        parent ? this._mulMat(this._worldMatrix, parent._worldMatrix, this._matrix) : _valueTypes.Mat4.copy(this._worldMatrix, this._matrix);
        this._worldMatDirty = false;
      },
      _mulMat: mulMat2D,
      _updateWorldMatrix: function _updateWorldMatrix() {
        this._parent && this._parent._updateWorldMatrix();
        if (this._worldMatDirty) {
          this._calculWorldMatrix();
          var children = this._children;
          for (var i = 0, l = children.length; i < l; i++) children[i]._worldMatDirty = true;
        }
      },
      setLocalDirty: function setLocalDirty(flag) {
        this._localMatDirty |= flag;
        this._worldMatDirty = true;
        flag === LocalDirtyFlag.ALL_POSITION || flag === LocalDirtyFlag.POSITION ? this._renderFlag |= RenderFlow.FLAG_WORLD_TRANSFORM : this._renderFlag |= RenderFlow.FLAG_TRANSFORM;
      },
      setWorldDirty: function setWorldDirty() {
        this._worldMatDirty = true;
      },
      getLocalMatrix: function getLocalMatrix(out) {
        this._updateLocalMatrix();
        return _valueTypes.Mat4.copy(out, this._matrix);
      },
      getWorldMatrix: function getWorldMatrix(out) {
        this._updateWorldMatrix();
        return _valueTypes.Mat4.copy(out, this._worldMatrix);
      },
      convertToNodeSpaceAR: function convertToNodeSpaceAR(worldPoint, out) {
        this._updateWorldMatrix();
        _valueTypes.Mat4.invert(_mat4_temp, this._worldMatrix);
        if (worldPoint instanceof cc.Vec2) {
          out = out || new cc.Vec2();
          return _valueTypes.Vec2.transformMat4(out, worldPoint, _mat4_temp);
        }
        out = out || new cc.Vec3();
        return _valueTypes.Vec3.transformMat4(out, worldPoint, _mat4_temp);
      },
      convertToWorldSpaceAR: function convertToWorldSpaceAR(nodePoint, out) {
        this._updateWorldMatrix();
        if (nodePoint instanceof cc.Vec2) {
          out = out || new cc.Vec2();
          return _valueTypes.Vec2.transformMat4(out, nodePoint, this._worldMatrix);
        }
        out = out || new cc.Vec3();
        return _valueTypes.Vec3.transformMat4(out, nodePoint, this._worldMatrix);
      },
      convertToNodeSpace: function convertToNodeSpace(worldPoint) {
        this._updateWorldMatrix();
        _valueTypes.Mat4.invert(_mat4_temp, this._worldMatrix);
        var out = new cc.Vec2();
        _valueTypes.Vec2.transformMat4(out, worldPoint, _mat4_temp);
        out.x += this._anchorPoint.x * this._contentSize.width;
        out.y += this._anchorPoint.y * this._contentSize.height;
        return out;
      },
      convertToWorldSpace: function convertToWorldSpace(nodePoint) {
        this._updateWorldMatrix();
        var out = new cc.Vec2(nodePoint.x - this._anchorPoint.x * this._contentSize.width, nodePoint.y - this._anchorPoint.y * this._contentSize.height);
        return _valueTypes.Vec2.transformMat4(out, out, this._worldMatrix);
      },
      getNodeToParentTransform: function getNodeToParentTransform(out) {
        out || (out = AffineTrans.identity());
        this._updateLocalMatrix();
        var contentSize = this._contentSize;
        _vec3_temp.x = -this._anchorPoint.x * contentSize.width;
        _vec3_temp.y = -this._anchorPoint.y * contentSize.height;
        _valueTypes.Mat4.copy(_mat4_temp, this._matrix);
        _valueTypes.Mat4.transform(_mat4_temp, _mat4_temp, _vec3_temp);
        return AffineTrans.fromMat4(out, _mat4_temp);
      },
      getNodeToParentTransformAR: function getNodeToParentTransformAR(out) {
        out || (out = AffineTrans.identity());
        this._updateLocalMatrix();
        return AffineTrans.fromMat4(out, this._matrix);
      },
      getNodeToWorldTransform: function getNodeToWorldTransform(out) {
        out || (out = AffineTrans.identity());
        this._updateWorldMatrix();
        var contentSize = this._contentSize;
        _vec3_temp.x = -this._anchorPoint.x * contentSize.width;
        _vec3_temp.y = -this._anchorPoint.y * contentSize.height;
        _valueTypes.Mat4.copy(_mat4_temp, this._worldMatrix);
        _valueTypes.Mat4.transform(_mat4_temp, _mat4_temp, _vec3_temp);
        return AffineTrans.fromMat4(out, _mat4_temp);
      },
      getNodeToWorldTransformAR: function getNodeToWorldTransformAR(out) {
        out || (out = AffineTrans.identity());
        this._updateWorldMatrix();
        return AffineTrans.fromMat4(out, this._worldMatrix);
      },
      getParentToNodeTransform: function getParentToNodeTransform(out) {
        out || (out = AffineTrans.identity());
        this._updateLocalMatrix();
        _valueTypes.Mat4.invert(_mat4_temp, this._matrix);
        return AffineTrans.fromMat4(out, _mat4_temp);
      },
      getWorldToNodeTransform: function getWorldToNodeTransform(out) {
        out || (out = AffineTrans.identity());
        this._updateWorldMatrix();
        _valueTypes.Mat4.invert(_mat4_temp, this._worldMatrix);
        return AffineTrans.fromMat4(out, _mat4_temp);
      },
      convertTouchToNodeSpace: function convertTouchToNodeSpace(touch) {
        return this.convertToNodeSpace(touch.getLocation());
      },
      convertTouchToNodeSpaceAR: function convertTouchToNodeSpaceAR(touch) {
        return this.convertToNodeSpaceAR(touch.getLocation());
      },
      getBoundingBox: function getBoundingBox() {
        this._updateLocalMatrix();
        var width = this._contentSize.width;
        var height = this._contentSize.height;
        var rect = cc.rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
        return rect.transformMat4(rect, this._matrix);
      },
      getBoundingBoxToWorld: function getBoundingBoxToWorld() {
        if (this._parent) {
          this._parent._updateWorldMatrix();
          return this._getBoundingBoxTo();
        }
        return this.getBoundingBox();
      },
      _getBoundingBoxTo: function _getBoundingBoxTo() {
        var width = this._contentSize.width;
        var height = this._contentSize.height;
        var rect = cc.rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
        this._calculWorldMatrix();
        rect.transformMat4(rect, this._worldMatrix);
        if (!this._children) return rect;
        var locChildren = this._children;
        for (var i = 0; i < locChildren.length; i++) {
          var child = locChildren[i];
          if (child && child.active) {
            var childRect = child._getBoundingBoxTo();
            childRect && rect.union(rect, childRect);
          }
        }
        return rect;
      },
      _updateOrderOfArrival: function _updateOrderOfArrival() {
        var arrivalOrder = this._parent ? ++this._parent._childArrivalOrder : 0;
        this._localZOrder = 4294901760 & this._localZOrder | arrivalOrder;
        this.emit(EventType.SIBLING_ORDER_CHANGED);
      },
      setSelfGroupIndex: function setSelfGroupIndex(groupIndex) {
        this._groupIndex = groupIndex || 0;
        this._cullingMask = 1 << groupIndex;
        true, true;
        this._proxy && this._proxy.updateCullingMask();
      },
      addChild: function addChild(child, zIndex, name) {
        if (true, !cc.Node.isNode(child)) return cc.errorID(1634, cc.js.getClassName(child));
        cc.assertID(child, 1606);
        cc.assertID(null === child._parent, 1605);
        child.parent = this;
        void 0 !== zIndex && (child.zIndex = zIndex);
        void 0 !== name && (child.name = name);
      },
      cleanup: function cleanup() {
        ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
        eventManager.removeListeners(this);
        var i, len = this._children.length, node;
        for (i = 0; i < len; ++i) {
          node = this._children[i];
          node && node.cleanup();
        }
      },
      sortAllChildren: function sortAllChildren() {
        if (this._reorderChildDirty) {
          this._reorderChildDirty = false;
          var _children = this._children, child;
          this._childArrivalOrder = 1;
          for (var i = 0, len = _children.length; i < len; i++) {
            child = _children[i];
            child._updateOrderOfArrival();
          }
          eventManager._setDirtyForNode(this);
          if (_children.length > 1) {
            var _child, child2;
            for (var _i2 = 1, count = _children.length; _i2 < count; _i2++) {
              _child = _children[_i2];
              var j = _i2;
              for (;j > 0 && (child2 = _children[j - 1])._localZOrder > _child._localZOrder; j--) _children[j] = child2;
              _children[j] = _child;
            }
            this.emit(EventType.CHILD_REORDER, this);
          }
          cc.director.__fastOff(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        }
      },
      _delaySort: function _delaySort() {
        if (!this._reorderChildDirty) {
          this._reorderChildDirty = true;
          cc.director.__fastOn(cc.Director.EVENT_AFTER_UPDATE, this.sortAllChildren, this);
        }
      },
      _restoreProperties: false,
      onRestore: false
    };
    false;
    var Node = cc.Class(NodeDefines);
    var _p = Node.prototype;
    js.getset(_p, "position", _p.getPosition, _p.setPosition, false, true);
    var vec3_tmp;
    false;
    cc.Node = module.exports = Node;
  }), {
    "./event-manager": 217,
    "./event/event": 220,
    "./event/event-target": 219,
    "./platform/CCMacro": 277,
    "./platform/js": 294,
    "./renderer/render-flow": 323,
    "./utils/affine-transform": 377,
    "./utils/base-node": 378,
    "./utils/prefab-helper": 389,
    "./utils/trans-pool": 395,
    "./value-types": 401,
    "./value-types/utils": 408
  } ],
  105: [ (function(require, module, exports) {
    "use strict";
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = "undefined" !== typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" === typeof o.length) {
        it && (o = it);
        var i = 0;
        return function() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if ("string" === typeof o) return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      "Object" === n && o.constructor && (n = o.constructor.name);
      if ("Map" === n || "Set" === n) return Array.from(o);
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      (null == len || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    var Node = require("./CCNode");
    var RenderFlow = require("./renderer/render-flow");
    var HideInHierarchy = cc.Object.Flags.HideInHierarchy;
    var LocalDirtyFlag = Node._LocalDirtyFlag;
    var POSITION_ON = 1;
    var PrivateNode = cc.Class({
      name: "cc.PrivateNode",
      extends: Node,
      properties: {
        x: {
          get: function get() {
            return this._originPos.x;
          },
          set: function set(value) {
            var localPosition = this._originPos;
            if (value !== localPosition.x) {
              localPosition.x = value;
              this._posDirty(true);
            }
          },
          override: true
        },
        y: {
          get: function get() {
            return this._originPos.y;
          },
          set: function set(value) {
            var localPosition = this._originPos;
            if (value !== localPosition.y) {
              localPosition.y = value;
              this._posDirty(true);
            }
          },
          override: true
        },
        zIndex: {
          get: function get() {
            return cc.macro.MIN_ZINDEX;
          },
          set: function set() {},
          override: true
        },
        showInEditor: {
          default: false,
          editorOnly: true,
          override: true
        }
      },
      ctor: function ctor(name) {
        this._localZOrder = cc.macro.MIN_ZINDEX << 16;
        this._originPos = cc.v2();
        false;
      },
      _posDirty: function _posDirty(sendEvent) {
        this.setLocalDirty(LocalDirtyFlag.POSITION);
        false;
        true === sendEvent && this._eventMask & POSITION_ON && this.emit(Node.EventType.POSITION_CHANGED);
      },
      _updateLocalMatrix: function _updateLocalMatrix() {
        if (!this._localMatDirty) return;
        var parent = this.parent;
        if (parent) {
          this._trs[0] = this._originPos.x - (parent._anchorPoint.x - .5) * parent._contentSize.width;
          this._trs[1] = this._originPos.y - (parent._anchorPoint.y - .5) * parent._contentSize.height;
        }
        this._super();
      },
      getPosition: function getPosition() {
        return new cc.Vec2(this._originPos);
      },
      setPosition: function setPosition(x, y) {
        if (void 0 === y) {
          x = x.x;
          y = x.y;
        }
        var pos = this._originPos;
        if (pos.x === x && pos.y === y) return;
        pos.x = x;
        pos.y = y;
        this._posDirty(true);
      },
      setParent: function setParent(value) {
        var oldParent = this._parent;
        this._super(value);
        if (oldParent !== value) {
          oldParent && oldParent.off(Node.EventType.ANCHOR_CHANGED, this._posDirty, this);
          value && value.on(Node.EventType.ANCHOR_CHANGED, this._posDirty, this);
        }
      },
      _updateOrderOfArrival: function _updateOrderOfArrival() {}
    });
    var proto = PrivateNode.prototype;
    cc.js.getset(proto, "parent", proto.getParent, proto.setParent);
    cc.js.getset(proto, "position", proto.getPosition, proto.setPosition);
    false;
    cc.PrivateNode = module.exports = PrivateNode;
  }), {
    "./CCNode": 104,
    "./renderer/render-flow": 323
  } ],
  106: [ (function(require, module, exports) {
    "use strict";
    var NIL = function NIL() {};
    cc.Scene = cc.Class({
      name: "cc.Scene",
      extends: require("./CCNode"),
      properties: {
        _is3DNode: {
          default: true,
          override: true
        },
        autoReleaseAssets: false
      },
      ctor: function ctor() {
        this._anchorPoint.x = 0;
        this._anchorPoint.y = 0;
        this._activeInHierarchy = false;
        this._inited = !cc.game._isCloning;
        false;
        this.dependAssets = null;
      },
      destroy: function destroy() {
        if (cc.Object.prototype.destroy.call(this)) {
          var children = this._children;
          for (var i = 0; i < children.length; ++i) children[i].active = false;
        }
        this._active = false;
        this._activeInHierarchy = false;
      },
      _onHierarchyChanged: NIL,
      _instantiate: null,
      _load: function _load() {
        if (!this._inited) {
          false;
          this._onBatchCreated(false);
          this._inited = true;
        }
      },
      _activate: function _activate(active) {
        active = false !== active;
        false, false;
        cc.director._nodeActivator.activateNode(this, active);
      }
    });
    module.exports = cc.Scene;
  }), {
    "./CCNode": 104
  } ],
  107: [ (function(require, module, exports) {
    "use strict";
    var js = require("./platform/js");
    var IdGenerater = require("./platform/id-generater");
    var MAX_POOL_SIZE = 20;
    var idGenerater = new IdGenerater("Scheduler");
    var ListEntry = function ListEntry(target, priority, paused, markedForDeletion) {
      this.target = target;
      this.priority = priority;
      this.paused = paused;
      this.markedForDeletion = markedForDeletion;
    };
    var _listEntries = [];
    ListEntry.get = function(target, priority, paused, markedForDeletion) {
      var result = _listEntries.pop();
      if (result) {
        result.target = target;
        result.priority = priority;
        result.paused = paused;
        result.markedForDeletion = markedForDeletion;
      } else result = new ListEntry(target, priority, paused, markedForDeletion);
      return result;
    };
    ListEntry.put = function(entry) {
      if (_listEntries.length < MAX_POOL_SIZE) {
        entry.target = null;
        _listEntries.push(entry);
      }
    };
    var HashUpdateEntry = function HashUpdateEntry(list, entry, target, callback) {
      this.list = list;
      this.entry = entry;
      this.target = target;
      this.callback = callback;
    };
    var _hashUpdateEntries = [];
    HashUpdateEntry.get = function(list, entry, target, callback) {
      var result = _hashUpdateEntries.pop();
      if (result) {
        result.list = list;
        result.entry = entry;
        result.target = target;
        result.callback = callback;
      } else result = new HashUpdateEntry(list, entry, target, callback);
      return result;
    };
    HashUpdateEntry.put = function(entry) {
      if (_hashUpdateEntries.length < MAX_POOL_SIZE) {
        entry.list = entry.entry = entry.target = entry.callback = null;
        _hashUpdateEntries.push(entry);
      }
    };
    var HashTimerEntry = function HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
      var _t = this;
      _t.timers = timers;
      _t.target = target;
      _t.timerIndex = timerIndex;
      _t.currentTimer = currentTimer;
      _t.currentTimerSalvaged = currentTimerSalvaged;
      _t.paused = paused;
    };
    var _hashTimerEntries = [];
    HashTimerEntry.get = function(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
      var result = _hashTimerEntries.pop();
      if (result) {
        result.timers = timers;
        result.target = target;
        result.timerIndex = timerIndex;
        result.currentTimer = currentTimer;
        result.currentTimerSalvaged = currentTimerSalvaged;
        result.paused = paused;
      } else result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
      return result;
    };
    HashTimerEntry.put = function(entry) {
      if (_hashTimerEntries.length < MAX_POOL_SIZE) {
        entry.timers = entry.target = entry.currentTimer = null;
        _hashTimerEntries.push(entry);
      }
    };
    function CallbackTimer() {
      this._lock = false;
      this._scheduler = null;
      this._elapsed = -1;
      this._runForever = false;
      this._useDelay = false;
      this._timesExecuted = 0;
      this._repeat = 0;
      this._delay = 0;
      this._interval = 0;
      this._target = null;
      this._callback = null;
    }
    var proto = CallbackTimer.prototype;
    proto.initWithCallback = function(scheduler, callback, target, seconds, repeat, delay) {
      this._lock = false;
      this._scheduler = scheduler;
      this._target = target;
      this._callback = callback;
      this._elapsed = -1;
      this._interval = seconds;
      this._delay = delay;
      this._useDelay = this._delay > 0;
      this._repeat = repeat;
      this._runForever = this._repeat === cc.macro.REPEAT_FOREVER;
      return true;
    };
    proto.getInterval = function() {
      return this._interval;
    };
    proto.setInterval = function(interval) {
      this._interval = interval;
    };
    proto.update = function(dt) {
      if (-1 === this._elapsed) {
        this._elapsed = 0;
        this._timesExecuted = 0;
      } else {
        this._elapsed += dt;
        if (this._runForever && !this._useDelay) {
          if (this._elapsed >= this._interval) {
            this.trigger();
            this._elapsed = 0;
          }
        } else {
          if (this._useDelay) {
            if (this._elapsed >= this._delay) {
              this.trigger();
              this._elapsed -= this._delay;
              this._timesExecuted += 1;
              this._useDelay = false;
            }
          } else if (this._elapsed >= this._interval) {
            this.trigger();
            this._elapsed = 0;
            this._timesExecuted += 1;
          }
          this._callback && !this._runForever && this._timesExecuted > this._repeat && this.cancel();
        }
      }
    };
    proto.getCallback = function() {
      return this._callback;
    };
    proto.trigger = function() {
      if (this._target && this._callback) {
        this._lock = true;
        this._callback.call(this._target, this._elapsed);
        this._lock = false;
      }
    };
    proto.cancel = function() {
      this._scheduler.unschedule(this._callback, this._target);
    };
    var _timers = [];
    CallbackTimer.get = function() {
      return _timers.pop() || new CallbackTimer();
    };
    CallbackTimer.put = function(timer) {
      if (_timers.length < MAX_POOL_SIZE && !timer._lock) {
        timer._scheduler = timer._target = timer._callback = null;
        _timers.push(timer);
      }
    };
    cc.Scheduler = function() {
      this._timeScale = 1;
      this._updatesNegList = [];
      this._updates0List = [];
      this._updatesPosList = [];
      this._hashForUpdates = js.createMap(true);
      this._hashForTimers = js.createMap(true);
      this._currentTarget = null;
      this._currentTargetSalvaged = false;
      this._updateHashLocked = false;
      this._arrayForTimers = [];
    };
    cc.Scheduler.prototype = {
      constructor: cc.Scheduler,
      _removeHashElement: function _removeHashElement(element) {
        delete this._hashForTimers[element.target._id];
        var arr = this._arrayForTimers;
        for (var i = 0, l = arr.length; i < l; i++) if (arr[i] === element) {
          arr.splice(i, 1);
          break;
        }
        HashTimerEntry.put(element);
      },
      _removeUpdateFromHash: function _removeUpdateFromHash(entry) {
        var targetId = entry.target._id;
        var self = this, element = self._hashForUpdates[targetId];
        if (element) {
          var list = element.list, listEntry = element.entry;
          for (var i = 0, l = list.length; i < l; i++) if (list[i] === listEntry) {
            list.splice(i, 1);
            break;
          }
          delete self._hashForUpdates[targetId];
          ListEntry.put(listEntry);
          HashUpdateEntry.put(element);
        }
      },
      _priorityIn: function _priorityIn(ppList, listElement, priority) {
        for (var i = 0; i < ppList.length; i++) if (priority < ppList[i].priority) {
          ppList.splice(i, 0, listElement);
          return;
        }
        ppList.push(listElement);
      },
      _appendIn: function _appendIn(ppList, listElement) {
        ppList.push(listElement);
      },
      enableForTarget: function enableForTarget(target) {
        target._id || (target.__instanceId ? cc.warnID(1513) : target._id = idGenerater.getNewId());
      },
      setTimeScale: function setTimeScale(timeScale) {
        this._timeScale = timeScale;
      },
      getTimeScale: function getTimeScale() {
        return this._timeScale;
      },
      update: function update(dt) {
        this._updateHashLocked = true;
        1 !== this._timeScale && (dt *= this._timeScale);
        var i, list, len, entry;
        for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || entry.target.update(dt);
        }
        for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || entry.target.update(dt);
        }
        for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
          entry = list[i];
          entry.paused || entry.markedForDeletion || entry.target.update(dt);
        }
        var elt, arr = this._arrayForTimers;
        for (i = 0; i < arr.length; i++) {
          elt = arr[i];
          this._currentTarget = elt;
          this._currentTargetSalvaged = false;
          if (!elt.paused) for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
            elt.currentTimer = elt.timers[elt.timerIndex];
            elt.currentTimerSalvaged = false;
            elt.currentTimer.update(dt);
            elt.currentTimer = null;
          }
          if (this._currentTargetSalvaged && 0 === this._currentTarget.timers.length) {
            this._removeHashElement(this._currentTarget);
            --i;
          }
        }
        for (i = 0, list = this._updatesNegList; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        for (i = 0, list = this._updates0List; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        for (i = 0, list = this._updatesPosList; i < list.length; ) {
          entry = list[i];
          entry.markedForDeletion ? this._removeUpdateFromHash(entry) : i++;
        }
        this._updateHashLocked = false;
        this._currentTarget = null;
      },
      schedule: function schedule(callback, target, interval, repeat, delay, paused) {
        if ("function" !== typeof callback) {
          var tmp = callback;
          callback = target;
          target = tmp;
        }
        if (4 === arguments.length || 5 === arguments.length) {
          paused = !!repeat;
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
        }
        cc.assertID(target, 1502);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForTimers[targetId];
        if (element) element.paused !== paused && cc.warnID(1511); else {
          element = HashTimerEntry.get(null, target, 0, null, null, paused);
          this._arrayForTimers.push(element);
          this._hashForTimers[targetId] = element;
        }
        var timer, i;
        if (null == element.timers) element.timers = []; else for (i = 0; i < element.timers.length; ++i) {
          timer = element.timers[i];
          if (timer && callback === timer._callback) {
            cc.logID(1507, timer.getInterval(), interval);
            timer._interval = interval;
            return;
          }
        }
        timer = CallbackTimer.get();
        timer.initWithCallback(this, callback, target, interval, repeat, delay);
        element.timers.push(timer);
        this._currentTarget === element && this._currentTargetSalvaged && (this._currentTargetSalvaged = false);
      },
      scheduleUpdate: function scheduleUpdate(target, priority, paused) {
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var hashElement = this._hashForUpdates[targetId];
        if (hashElement && hashElement.entry) {
          if (hashElement.entry.priority === priority) {
            hashElement.entry.markedForDeletion = false;
            hashElement.entry.paused = paused;
            return;
          }
          if (this._updateHashLocked) {
            cc.logID(1506);
            hashElement.entry.markedForDeletion = false;
            hashElement.entry.paused = paused;
            return;
          }
          this.unscheduleUpdate(target);
        }
        var listElement = ListEntry.get(target, priority, paused, false);
        var ppList;
        if (0 === priority) {
          ppList = this._updates0List;
          this._appendIn(ppList, listElement);
        } else {
          ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;
          this._priorityIn(ppList, listElement, priority);
        }
        this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
      },
      unschedule: function unschedule(callback, target) {
        if (!target || !callback) return;
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var self = this, element = self._hashForTimers[targetId];
        if (element) {
          var timers = element.timers;
          for (var i = 0, li = timers.length; i < li; i++) {
            var timer = timers[i];
            if (callback === timer._callback) {
              timer !== element.currentTimer || element.currentTimerSalvaged || (element.currentTimerSalvaged = true);
              timers.splice(i, 1);
              CallbackTimer.put(timer);
              element.timerIndex >= i && element.timerIndex--;
              0 === timers.length && (self._currentTarget === element ? self._currentTargetSalvaged = true : self._removeHashElement(element));
              return;
            }
          }
        }
      },
      unscheduleUpdate: function unscheduleUpdate(target) {
        if (!target) return;
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForUpdates[targetId];
        element && (this._updateHashLocked ? element.entry.markedForDeletion = true : this._removeUpdateFromHash(element.entry));
      },
      unscheduleAllForTarget: function unscheduleAllForTarget(target) {
        if (!target) return;
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForTimers[targetId];
        if (element) {
          var timers = element.timers;
          timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged && (element.currentTimerSalvaged = true);
          for (var i = 0, l = timers.length; i < l; i++) CallbackTimer.put(timers[i]);
          timers.length = 0;
          this._currentTarget === element ? this._currentTargetSalvaged = true : this._removeHashElement(element);
        }
        this.unscheduleUpdate(target);
      },
      unscheduleAll: function unscheduleAll() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      },
      unscheduleAllWithMinPriority: function unscheduleAllWithMinPriority(minPriority) {
        var i, element, arr = this._arrayForTimers;
        for (i = arr.length - 1; i >= 0; i--) {
          element = arr[i];
          this.unscheduleAllForTarget(element.target);
        }
        var entry;
        var temp_length = 0;
        if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; ) {
          temp_length = this._updatesNegList.length;
          entry = this._updatesNegList[i];
          entry && entry.priority >= minPriority && this.unscheduleUpdate(entry.target);
          temp_length == this._updatesNegList.length && i++;
        }
        if (minPriority <= 0) for (i = 0; i < this._updates0List.length; ) {
          temp_length = this._updates0List.length;
          entry = this._updates0List[i];
          entry && this.unscheduleUpdate(entry.target);
          temp_length == this._updates0List.length && i++;
        }
        for (i = 0; i < this._updatesPosList.length; ) {
          temp_length = this._updatesPosList.length;
          entry = this._updatesPosList[i];
          entry && entry.priority >= minPriority && this.unscheduleUpdate(entry.target);
          temp_length == this._updatesPosList.length && i++;
        }
      },
      isScheduled: function isScheduled(callback, target) {
        cc.assertID(callback, 1508);
        cc.assertID(target, 1509);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForTimers[targetId];
        if (!element) return false;
        if (null == element.timers) return false;
        var timers = element.timers;
        for (var i = 0; i < timers.length; ++i) {
          var timer = timers[i];
          if (callback === timer._callback) return true;
        }
        return false;
      },
      pauseAllTargets: function pauseAllTargets() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      },
      pauseAllTargetsWithMinPriority: function pauseAllTargetsWithMinPriority(minPriority) {
        var idsWithSelectors = [];
        var self = this, element, locArrayForTimers = self._arrayForTimers;
        var i, li;
        for (i = 0, li = locArrayForTimers.length; i < li; i++) {
          element = locArrayForTimers[i];
          if (element) {
            element.paused = true;
            idsWithSelectors.push(element.target);
          }
        }
        var entry;
        if (minPriority < 0) for (i = 0; i < this._updatesNegList.length; i++) {
          entry = this._updatesNegList[i];
          if (entry && entry.priority >= minPriority) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        if (minPriority <= 0) for (i = 0; i < this._updates0List.length; i++) {
          entry = this._updates0List[i];
          if (entry) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        for (i = 0; i < this._updatesPosList.length; i++) {
          entry = this._updatesPosList[i];
          if (entry && entry.priority >= minPriority) {
            entry.paused = true;
            idsWithSelectors.push(entry.target);
          }
        }
        return idsWithSelectors;
      },
      resumeTargets: function resumeTargets(targetsToResume) {
        if (!targetsToResume) return;
        for (var i = 0; i < targetsToResume.length; i++) this.resumeTarget(targetsToResume[i]);
      },
      pauseTarget: function pauseTarget(target) {
        cc.assertID(target, 1503);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var self = this, element = self._hashForTimers[targetId];
        element && (element.paused = true);
        var elementUpdate = self._hashForUpdates[targetId];
        elementUpdate && (elementUpdate.entry.paused = true);
      },
      resumeTarget: function resumeTarget(target) {
        cc.assertID(target, 1504);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var self = this, element = self._hashForTimers[targetId];
        element && (element.paused = false);
        var elementUpdate = self._hashForUpdates[targetId];
        elementUpdate && (elementUpdate.entry.paused = false);
      },
      isTargetPaused: function isTargetPaused(target) {
        cc.assertID(target, 1505);
        var targetId = target._id;
        if (!targetId) if (target.__instanceId) {
          cc.warnID(1513);
          targetId = target._id = target.__instanceId;
        } else cc.errorID(1510);
        var element = this._hashForTimers[targetId];
        if (element) return element.paused;
        var elementUpdate = this._hashForUpdates[targetId];
        if (elementUpdate) return elementUpdate.entry.paused;
        return false;
      }
    };
    cc.Scheduler.PRIORITY_SYSTEM = 1 << 31;
    cc.Scheduler.PRIORITY_NON_SYSTEM = cc.Scheduler.PRIORITY_SYSTEM + 1;
    module.exports = cc.Scheduler;
  }), {
    "./platform/id-generater": 290,
    "./platform/js": 294
  } ],
  108: [ (function(require, module, exports) {
    "use strict";
    var preprocess = require("./preprocess");
    var fetch = require("./fetch");
    var Cache = require("./cache");
    var helper = require("./helper");
    var releaseManager = require("./releaseManager");
    var dependUtil = require("./depend-util");
    var load = require("./load");
    var Pipeline = require("./pipeline");
    var Task = require("./task");
    var RequestItem = require("./request-item");
    var downloader = require("./downloader");
    var parser = require("./parser");
    var packManager = require("./pack-manager");
    var Bundle = require("./bundle");
    var builtins = require("./builtins");
    var factory = require("./factory");
    var _require = require("./urlTransformer"), parse = _require.parse, combine = _require.combine;
    var _require2 = require("./utilities"), parseParameters = _require2.parseParameters, asyncify = _require2.asyncify;
    var _require3 = require("./shared"), assets = _require3.assets, files = _require3.files, parsed = _require3.parsed, pipeline = _require3.pipeline, transformPipeline = _require3.transformPipeline, fetchPipeline = _require3.fetchPipeline, RequestType = _require3.RequestType, bundles = _require3.bundles, BuiltinBundleName = _require3.BuiltinBundleName;
    function AssetManager() {
      this._preprocessPipe = preprocess;
      this._fetchPipe = fetch;
      this._loadPipe = load;
      this.pipeline = pipeline.append(preprocess).append(load);
      this.fetchPipeline = fetchPipeline.append(preprocess).append(fetch);
      this.transformPipeline = transformPipeline.append(parse).append(combine);
      this.bundles = bundles;
      this.assets = assets;
      this._files = files;
      this._parsed = parsed;
      this.generalImportBase = "";
      this.generalNativeBase = "";
      this.dependUtil = dependUtil;
      this._releaseManager = releaseManager;
      this.cacheAsset = true;
      this.force = false;
      this.utils = helper;
      this.downloader = downloader;
      this.parser = parser;
      this.builtins = builtins;
      this.packManager = packManager;
      this.factory = factory;
      this.cacheManager = null;
      this.presets = {
        default: {
          priority: 0
        },
        preload: {
          maxConcurrency: 2,
          maxRequestsPerFrame: 2,
          priority: -1
        },
        scene: {
          maxConcurrency: 8,
          maxRequestsPerFrame: 8,
          priority: 1
        },
        bundle: {
          maxConcurrency: 8,
          maxRequestsPerFrame: 8,
          priority: 2
        },
        remote: {
          maxRetryCount: 4
        },
        script: {
          maxConcurrency: 1024,
          maxRequestsPerFrame: 1024,
          priority: 2
        }
      };
    }
    AssetManager.Pipeline = Pipeline;
    AssetManager.Task = Task;
    AssetManager.Cache = Cache;
    AssetManager.RequestItem = RequestItem;
    AssetManager.Bundle = Bundle;
    AssetManager.BuiltinBundleName = BuiltinBundleName;
    AssetManager.prototype = {
      constructor: AssetManager,
      get main() {
        return bundles.get(BuiltinBundleName.MAIN);
      },
      get resources() {
        return bundles.get(BuiltinBundleName.RESOURCES);
      },
      get internal() {
        return bundles.get(BuiltinBundleName.INTERNAL);
      },
      init: function init(options) {
        options = options || Object.create(null);
        this._files.clear();
        this._parsed.clear();
        this._releaseManager.init();
        this.assets.clear();
        this.bundles.clear();
        this.packManager.init();
        this.downloader.init(options.bundleVers, options.server);
        this.parser.init();
        this.dependUtil.init();
        this.generalImportBase = options.importBase;
        this.generalNativeBase = options.nativeBase;
      },
      getBundle: function getBundle(name) {
        return bundles.get(name);
      },
      removeBundle: function removeBundle(bundle) {
        bundle._destroy();
        bundles.remove(bundle.name);
      },
      loadAny: function loadAny(requests, options, onProgress, onComplete) {
        var _parseParameters = parseParameters(options, onProgress, onComplete), options = _parseParameters.options, onProgress = _parseParameters.onProgress, onComplete = _parseParameters.onComplete;
        options.preset = options.preset || "default";
        requests = Array.isArray(requests) ? requests.concat() : requests;
        var task = new Task({
          input: requests,
          onProgress: onProgress,
          onComplete: asyncify(onComplete),
          options: options
        });
        pipeline.async(task);
      },
      preloadAny: function preloadAny(requests, options, onProgress, onComplete) {
        var _parseParameters2 = parseParameters(options, onProgress, onComplete), options = _parseParameters2.options, onProgress = _parseParameters2.onProgress, onComplete = _parseParameters2.onComplete;
        options.preset = options.preset || "preload";
        requests = Array.isArray(requests) ? requests.concat() : requests;
        var task = new Task({
          input: requests,
          onProgress: onProgress,
          onComplete: asyncify(onComplete),
          options: options
        });
        fetchPipeline.async(task);
      },
      postLoadNative: function postLoadNative(asset, options, onComplete) {
        if (!(asset instanceof cc.Asset)) throw new Error("input is not asset");
        var _parseParameters3 = parseParameters(options, void 0, onComplete), options = _parseParameters3.options, onComplete = _parseParameters3.onComplete;
        if (!asset._native || asset._nativeAsset) return asyncify(onComplete)(null);
        var depend = dependUtil.getNativeDep(asset._uuid);
        if (depend) {
          if (!bundles.has(depend.bundle)) {
            var bundle = bundles.find((function(bundle) {
              return bundle.getAssetInfo(asset._uuid);
            }));
            bundle && (depend.bundle = bundle.name);
          }
          this.loadAny(depend, options, (function(err, _native) {
            err ? cc.error(err.message, err.stack) : asset.isValid && !asset._nativeAsset && (asset._nativeAsset = _native);
            onComplete && onComplete(err);
          }));
        }
      },
      loadRemote: function loadRemote(url, options, onComplete) {
        var _parseParameters4 = parseParameters(options, void 0, onComplete), options = _parseParameters4.options, onComplete = _parseParameters4.onComplete;
        if (this.assets.has(url)) return asyncify(onComplete)(null, this.assets.get(url));
        options.__isNative__ = true;
        options.preset = options.preset || "remote";
        this.loadAny({
          url: url
        }, options, null, (function(err, data) {
          if (err) {
            cc.error(err.message, err.stack);
            onComplete && onComplete(err, null);
          } else factory.create(url, data, options.ext || cc.path.extname(url), options, (function(err, out) {
            onComplete && onComplete(err, out);
          }));
        }));
      },
      loadScript: function loadScript(url, options, onComplete) {
        var _parseParameters5 = parseParameters(options, void 0, onComplete), options = _parseParameters5.options, onComplete = _parseParameters5.onComplete;
        options.__requestType__ = RequestType.URL;
        options.preset = options.preset || "script";
        this.loadAny(url, options, onComplete);
      },
      loadBundle: function loadBundle(nameOrUrl, options, onComplete) {
        var _parseParameters6 = parseParameters(options, void 0, onComplete), options = _parseParameters6.options, onComplete = _parseParameters6.onComplete;
        var bundleName = cc.path.basename(nameOrUrl);
        if (this.bundles.has(bundleName)) return asyncify(onComplete)(null, this.getBundle(bundleName));
        options.preset = options.preset || "bundle";
        options.ext = "bundle";
        this.loadRemote(nameOrUrl, options, onComplete);
      },
      releaseAsset: function releaseAsset(asset) {
        releaseManager.tryRelease(asset, true);
      },
      releaseUnusedAssets: function releaseUnusedAssets() {
        assets.forEach((function(asset) {
          releaseManager.tryRelease(asset);
        }));
      },
      releaseAll: function releaseAll() {
        assets.forEach((function(asset) {
          releaseManager.tryRelease(asset, true);
        }));
        false;
      },
      _transform: function _transform(input, options) {
        var subTask = Task.create({
          input: input,
          options: options
        });
        var urls = [];
        try {
          var result = transformPipeline.sync(subTask);
          for (var i = 0, l = result.length; i < l; i++) {
            var item = result[i];
            var url = item.url;
            item.recycle();
            urls.push(url);
          }
        } catch (e) {
          for (var i = 0, l = subTask.output.length; i < l; i++) subTask.output[i].recycle();
          cc.error(e.message, e.stack);
        }
        subTask.recycle();
        return urls.length > 1 ? urls : urls[0];
      }
    };
    cc.AssetManager = AssetManager;
    cc.assetManager = new AssetManager();
    Object.defineProperty(cc, "resources", {
      get: function get() {
        return bundles.get(BuiltinBundleName.RESOURCES);
      }
    });
    module.exports = cc.assetManager;
  }), {
    "./builtins": 109,
    "./bundle": 110,
    "./cache": 111,
    "./depend-util": 113,
    "./downloader": 120,
    "./factory": 121,
    "./fetch": 122,
    "./helper": 124,
    "./load": 126,
    "./pack-manager": 127,
    "./parser": 128,
    "./pipeline": 129,
    "./preprocess": 130,
    "./releaseManager": 131,
    "./request-item": 132,
    "./shared": 133,
    "./task": 134,
    "./urlTransformer": 135,
    "./utilities": 136
  } ],
  109: [ (function(require, module, exports) {
    "use strict";
    var Cache = require("./cache");
    var releaseManager = require("./releaseManager");
    var _require = require("./shared"), BuiltinBundleName = _require.BuiltinBundleName;
    var builtins = {
      _assets: new Cache({
        material: new Cache(),
        effect: new Cache()
      }),
      _loadBuiltins: function _loadBuiltins(name, cb) {
        var dirname = name + "s";
        var builtin = this._assets.get(name);
        return cc.assetManager.internal.loadDir(dirname, null, null, (function(err, assets) {
          if (err) cc.error(err.message, err.stack); else for (var i = 0; i < assets.length; i++) {
            var asset = assets[i];
            builtin.add(asset.name, asset.addRef());
          }
          cb();
        }));
      },
      init: function init(cb) {
        var _this = this;
        this.clear();
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS || !cc.assetManager.bundles.has(BuiltinBundleName.INTERNAL)) return cb && cb();
        this._loadBuiltins("effect", (function() {
          _this._loadBuiltins("material", (function() {
            _this._loadBuiltinsSP(cb);
          }));
        }));
      },
      _loadBuiltinsSP: function _loadBuiltinsSP(cb) {
        cc.sp.MAX_MULTITEXTURE_NUM = 8;
        this._loadMultiEffect("multi-2d-universal", (function(effect) {
          cc.sp.multi2dSpriteEffectAsset = effect;
          effect.addRef();
          cc.sp.inited = true;
          cc.sp.multiBatcher.init();
          -1 === cc.dynamicAtlasManager.maxAtlasCount && (cc.dynamicAtlasManager.maxAtlasCount = Math.max(0, cc.sp.MAX_MULTITEXTURE_NUM - cc.sp.charAtlasAutoBatchCount));
          cb();
        }));
      },
      _loadMultiEffect: function _loadMultiEffect(name, cb) {
        false;
        cc.assetManager.loadBundle("sp", (function(err, bundle) {
          err ? cc.error(err) : bundle.load("effects/" + name, cc.EffectAsset, (function(err, effect) {
            err ? cc.error(err) : cb(effect);
          }));
        }));
      },
      getBuiltin: function getBuiltin(type, name) {
        return 0 === arguments.length ? this._assets : 1 === arguments.length ? this._assets.get(type) : this._assets.get(type).get(name);
      },
      clear: function clear() {
        this._assets.forEach((function(assets) {
          assets.forEach((function(asset) {
            releaseManager.tryRelease(asset, true);
          }));
          assets.clear();
        }));
      }
    };
    module.exports = builtins;
  }), {
    "./cache": 111,
    "./releaseManager": 131,
    "./shared": 133
  } ],
  110: [ (function(require, module, exports) {
    "use strict";
    var Config = require("./config");
    var releaseManager = require("./releaseManager");
    var _require = require("./utilities"), parseParameters = _require.parseParameters, parseLoadResArgs = _require.parseLoadResArgs;
    var _require2 = require("./shared"), RequestType = _require2.RequestType, assets = _require2.assets, bundles = _require2.bundles;
    function Bundle() {
      this._config = new Config();
    }
    Bundle.prototype = {
      constructor: Bundle,
      get name() {
        return this._config.name;
      },
      get deps() {
        return this._config.deps;
      },
      get base() {
        return this._config.base;
      },
      getInfoWithPath: function getInfoWithPath(path, type) {
        return this._config.getInfoWithPath(path, type);
      },
      getDirWithPath: function getDirWithPath(path, type, out) {
        return this._config.getDirWithPath(path, type, out);
      },
      getAssetInfo: function getAssetInfo(uuid) {
        return this._config.getAssetInfo(uuid);
      },
      getSceneInfo: function getSceneInfo(name) {
        return this._config.getSceneInfo(name);
      },
      init: function init(options) {
        this._config.init(options);
        bundles.add(options.name, this);
      },
      load: function load(paths, type, onProgress, onComplete) {
        var _parseLoadResArgs = parseLoadResArgs(type, onProgress, onComplete), type = _parseLoadResArgs.type, onProgress = _parseLoadResArgs.onProgress, onComplete = _parseLoadResArgs.onComplete;
        cc.assetManager.loadAny(paths, {
          __requestType__: RequestType.PATH,
          type: type,
          bundle: this.name,
          __outputAsArray__: Array.isArray(paths)
        }, onProgress, onComplete);
      },
      preload: function preload(paths, type, onProgress, onComplete) {
        var _parseLoadResArgs2 = parseLoadResArgs(type, onProgress, onComplete), type = _parseLoadResArgs2.type, onProgress = _parseLoadResArgs2.onProgress, onComplete = _parseLoadResArgs2.onComplete;
        cc.assetManager.preloadAny(paths, {
          __requestType__: RequestType.PATH,
          type: type,
          bundle: this.name
        }, onProgress, onComplete);
      },
      loadDir: function loadDir(dir, type, onProgress, onComplete) {
        var _parseLoadResArgs3 = parseLoadResArgs(type, onProgress, onComplete), type = _parseLoadResArgs3.type, onProgress = _parseLoadResArgs3.onProgress, onComplete = _parseLoadResArgs3.onComplete;
        cc.assetManager.loadAny(dir, {
          __requestType__: RequestType.DIR,
          type: type,
          bundle: this.name,
          __outputAsArray__: true
        }, onProgress, onComplete);
      },
      preloadDir: function preloadDir(dir, type, onProgress, onComplete) {
        var _parseLoadResArgs4 = parseLoadResArgs(type, onProgress, onComplete), type = _parseLoadResArgs4.type, onProgress = _parseLoadResArgs4.onProgress, onComplete = _parseLoadResArgs4.onComplete;
        cc.assetManager.preloadAny(dir, {
          __requestType__: RequestType.DIR,
          type: type,
          bundle: this.name
        }, onProgress, onComplete);
      },
      loadScene: function loadScene(sceneName, options, onProgress, onComplete) {
        var _parseParameters = parseParameters(options, onProgress, onComplete), options = _parseParameters.options, onProgress = _parseParameters.onProgress, onComplete = _parseParameters.onComplete;
        options.preset = options.preset || "scene";
        options.bundle = this.name;
        cc.assetManager.loadAny({
          scene: sceneName
        }, options, onProgress, (function(err, sceneAsset) {
          if (err) {
            cc.error(err.message, err.stack);
            onComplete && onComplete(err);
          } else if (sceneAsset instanceof cc.SceneAsset) {
            var scene = sceneAsset.scene;
            scene._id = sceneAsset._uuid;
            scene._name = sceneAsset._name;
            onComplete && onComplete(null, sceneAsset);
          } else onComplete && onComplete(new Error("The asset " + sceneAsset._uuid + " is not a scene"));
        }));
      },
      preloadScene: function preloadScene(sceneName, options, onProgress, onComplete) {
        var _parseParameters2 = parseParameters(options, onProgress, onComplete), options = _parseParameters2.options, onProgress = _parseParameters2.onProgress, onComplete = _parseParameters2.onComplete;
        options.bundle = this.name;
        cc.assetManager.preloadAny({
          scene: sceneName
        }, options, onProgress, (function(err) {
          err && cc.errorID(1210, sceneName, err.message);
          onComplete && onComplete(err);
        }));
      },
      get: function get(path, type) {
        var info = this.getInfoWithPath(path, type);
        return assets.get(info && info.uuid);
      },
      release: function release(path, type) {
        releaseManager.tryRelease(this.get(path, type), true);
      },
      releaseUnusedAssets: function releaseUnusedAssets() {
        var self = this;
        assets.forEach((function(asset) {
          var info = self.getAssetInfo(asset._uuid);
          info && !info.redirect && releaseManager.tryRelease(asset);
        }));
      },
      releaseAll: function releaseAll() {
        var self = this;
        assets.forEach((function(asset) {
          var info = self.getAssetInfo(asset._uuid);
          info && !info.redirect && releaseManager.tryRelease(asset, true);
        }));
      },
      _destroy: function _destroy() {
        this._config.destroy();
      }
    };
    module.exports = Bundle;
  }), {
    "./config": 112,
    "./releaseManager": 131,
    "./shared": 133,
    "./utilities": 136
  } ],
  111: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    function Cache(map) {
      if (map) {
        this._map = map;
        this._count = Object.keys(map).length;
      } else {
        this._map = js.createMap(true);
        this._count = 0;
      }
    }
    Cache.prototype = {
      constructor: Cache,
      add: function add(key, val) {
        key in this._map || this._count++;
        return this._map[key] = val;
      },
      get: function get(key) {
        return this._map[key];
      },
      has: function has(key) {
        return key in this._map;
      },
      remove: function remove(key) {
        var out = this._map[key];
        if (key in this._map) {
          delete this._map[key];
          this._count--;
        }
        return out;
      },
      clear: function clear() {
        if (0 !== this._count) {
          this._map = js.createMap(true);
          this._count = 0;
        }
      },
      forEach: function forEach(func) {
        for (var key in this._map) func(this._map[key], key);
      },
      find: function find(predicate) {
        for (var key in this._map) if (predicate(this._map[key], key)) return this._map[key];
        return null;
      },
      get count() {
        return this._count;
      },
      destroy: function destroy() {
        this._map = null;
      }
    };
    module.exports = Cache;
  }), {
    "../platform/js": 294
  } ],
  112: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    var Cache = require("./cache");
    var _require = require("./helper"), normalize = _require.normalize;
    var _require2 = require("./utilities"), processOptions = _require2.processOptions;
    function Config() {
      this.name = "";
      this.base = "";
      this.importBase = "";
      this.nativeBase = "";
      this.deps = null;
      this.assetInfos = new Cache();
      this.scenes = new Cache();
      this.paths = new Cache();
    }
    Config.prototype = {
      constructor: Config,
      init: function init(options) {
        processOptions(options);
        this.importBase = options.importBase || "";
        this.nativeBase = options.nativeBase || "";
        this.base = options.base || "";
        this.name = options.name || "";
        this.deps = options.deps || [];
        this._initUuid(options.uuids);
        this._initPath(options.paths);
        this._initScene(options.scenes);
        this._initPackage(options.packs);
        this._initVersion(options.versions);
        this._initRedirect(options.redirect);
      },
      _initUuid: function _initUuid(uuidList) {
        if (!uuidList) return;
        this.assetInfos.clear();
        for (var i = 0, l = uuidList.length; i < l; i++) {
          var uuid = uuidList[i];
          this.assetInfos.add(uuid, {
            uuid: uuid
          });
        }
      },
      _initPath: function _initPath(pathList) {
        if (!pathList) return;
        var paths = this.paths;
        paths.clear();
        for (var uuid in pathList) {
          var info = pathList[uuid];
          var path = info[0];
          var type = info[1];
          var isSubAsset = 3 === info.length;
          var assetInfo = this.assetInfos.get(uuid);
          assetInfo.path = path;
          assetInfo.ctor = js._getClassById(type);
          paths.has(path) ? isSubAsset ? paths.get(path).push(assetInfo) : paths.get(path).unshift(assetInfo) : paths.add(path, [ assetInfo ]);
        }
      },
      _initScene: function _initScene(sceneList) {
        if (!sceneList) return;
        var scenes = this.scenes;
        scenes.clear();
        var assetInfos = this.assetInfos;
        for (var sceneName in sceneList) {
          var uuid = sceneList[sceneName];
          var assetInfo = assetInfos.get(uuid);
          assetInfo.url = sceneName;
          scenes.add(sceneName, assetInfo);
        }
      },
      _initPackage: function _initPackage(packageList) {
        if (!packageList) return;
        var assetInfos = this.assetInfos;
        for (var packUuid in packageList) {
          var uuids = packageList[packUuid];
          var pack = {
            uuid: packUuid,
            packs: uuids,
            ext: ".json"
          };
          assetInfos.add(packUuid, pack);
          for (var i = 0, l = uuids.length; i < l; i++) {
            var uuid = uuids[i];
            var assetInfo = assetInfos.get(uuid);
            var assetPacks = assetInfo.packs;
            assetPacks ? 1 === l ? assetPacks.unshift(pack) : assetPacks.push(pack) : assetInfo.packs = [ pack ];
          }
        }
      },
      _initVersion: function _initVersion(versions) {
        if (!versions) return;
        var assetInfos = this.assetInfos;
        var entries = versions["import"];
        if (entries) for (var i = 0, l = entries.length; i < l; i += 2) {
          var uuid = entries[i];
          var assetInfo = assetInfos.get(uuid);
          assetInfo.ver = entries[i + 1];
        }
        entries = versions["native"];
        if (entries) for (var i = 0, l = entries.length; i < l; i += 2) {
          var uuid = entries[i];
          var assetInfo = assetInfos.get(uuid);
          assetInfo.nativeVer = entries[i + 1];
        }
      },
      _initRedirect: function _initRedirect(redirect) {
        if (!redirect) return;
        var assetInfos = this.assetInfos;
        for (var i = 0, l = redirect.length; i < l; i += 2) {
          var uuid = redirect[i];
          var assetInfo = assetInfos.get(uuid);
          assetInfo.redirect = redirect[i + 1];
        }
      },
      getInfoWithPath: function getInfoWithPath(path, type) {
        if (!path) return null;
        path = normalize(path);
        var items = this.paths.get(path);
        if (items) {
          if (!type) return items[0];
          for (var i = 0, l = items.length; i < l; i++) {
            var assetInfo = items[i];
            if (js.isChildClassOf(assetInfo.ctor, type)) return assetInfo;
          }
        }
        return null;
      },
      getDirWithPath: function getDirWithPath(path, type, out) {
        path = normalize(path);
        "/" === path[path.length - 1] && (path = path.slice(0, -1));
        var infos = out || [];
        function isMatchByWord(path, test) {
          if (path.length > test.length) {
            var nextAscii = path.charCodeAt(test.length);
            return 47 === nextAscii;
          }
          return true;
        }
        this.paths.forEach((function(items, p) {
          if (p.startsWith(path) && isMatchByWord(p, path) || !path) for (var i = 0, l = items.length; i < l; i++) {
            var entry = items[i];
            type && !js.isChildClassOf(entry.ctor, type) || infos.push(entry);
          }
        }));
        return infos;
      },
      getAssetInfo: function getAssetInfo(uuid) {
        return this.assetInfos.get(uuid);
      },
      getSceneInfo: function getSceneInfo(name) {
        name.endsWith(".fire") || (name += ".fire");
        "/" === name[0] || name.startsWith("db://") || (name = "/" + name);
        var info = this.scenes.find((function(val, key) {
          return key.endsWith(name);
        }));
        return info;
      },
      destroy: function destroy() {
        this.paths.destroy();
        this.scenes.destroy();
        this.assetInfos.destroy();
      }
    };
    false;
    module.exports = Config;
  }), {
    "../platform/js": 294,
    "./cache": 111,
    "./helper": 124,
    "./utilities": 136
  } ],
  113: [ (function(require, module, exports) {
    "use strict";
    var _deserializeCompiled = _interopRequireWildcard(require("../platform/deserialize-compiled"));
    function _getRequireWildcardCache(nodeInterop) {
      if ("function" !== typeof WeakMap) return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) return obj;
      if (null === obj || "object" !== typeof obj && "function" !== typeof obj) return {
        default: obj
      };
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) return cache.get(obj);
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
      }
      newObj["default"] = obj;
      cache && cache.set(obj, newObj);
      return newObj;
    }
    var Cache = require("./cache");
    var deserialize = require("./deserialize");
    var _require = require("./shared"), files = _require.files, parsed = _require.parsed;
    var dependUtil = {
      _depends: new Cache(),
      init: function init() {
        this._depends.clear();
      },
      getNativeDep: function getNativeDep(uuid) {
        var depend = this._depends.get(uuid);
        if (depend) return depend.nativeDep && Object.assign({}, depend.nativeDep);
        return null;
      },
      getDeps: function getDeps(uuid) {
        if (this._depends.has(uuid)) return this._depends.get(uuid).deps;
        return [];
      },
      getDepsRecursively: function getDepsRecursively(uuid) {
        var exclude = Object.create(null), depends = [];
        this._descend(uuid, exclude, depends);
        return depends;
      },
      _descend: function _descend(uuid, exclude, depends) {
        var deps = this.getDeps(uuid);
        for (var i = 0; i < deps.length; i++) {
          var depend = deps[i];
          if (!exclude[depend]) {
            exclude[depend] = true;
            depends.push(depend);
            this._descend(depend, exclude, depends);
          }
        }
      },
      remove: function remove(uuid) {
        this._depends.remove(uuid);
      },
      parse: function parse(uuid, json) {
        var out = null;
        if (Array.isArray(json) || json.__type__) {
          if (out = this._depends.get(uuid)) return out;
          if (!Array.isArray(json) || (false, _deserializeCompiled["default"].isCompiledJson(json)) && (0, 
          _deserializeCompiled.hasNativeDep)(json)) try {
            var asset = deserialize(json);
            out = this._parseDepsFromAsset(asset);
            out.nativeDep && (out.nativeDep.uuid = uuid);
            parsed.add(uuid + "@import", asset);
          } catch (e) {
            files.remove(uuid + "@import");
            out = {
              deps: []
            };
          } else out = {
            deps: this._parseDepsFromJson(json)
          };
        } else {
          if ((true, out = this._depends.get(uuid)) && out.parsedFromExistAsset) return out;
          out = this._parseDepsFromAsset(json);
        }
        this._depends.add(uuid, out);
        return out;
      },
      _parseDepsFromAsset: function _parseDepsFromAsset(asset) {
        var out = {
          deps: [],
          parsedFromExistAsset: true,
          preventPreloadNativeObject: asset.constructor.preventPreloadNativeObject,
          preventDeferredLoadDependents: asset.constructor.preventDeferredLoadDependents
        };
        var deps = asset.__depends__;
        for (var i = 0, l = deps.length; i < l; i++) {
          var dep = deps[i].uuid;
          out.deps.push(dep);
        }
        asset.__nativeDepend__ && (out.nativeDep = asset._nativeDep);
        return out;
      },
      _parseDepsFromJson: (false, function(json) {
        if (_deserializeCompiled["default"].isCompiledJson(json)) {
          var _depends = (0, _deserializeCompiled.getDependUuidList)(json);
          _depends.forEach((function(uuid, index) {
            return _depends[index] = cc.assetManager.utils.decodeUuid(uuid);
          }));
          return _depends;
        }
        var depends = [];
        function parseDependRecursively(data, out) {
          if (!data || "object" !== typeof data || data.__id__) return;
          var uuid = data.__uuid__;
          if (Array.isArray(data)) for (var i = 0, l = data.length; i < l; i++) parseDependRecursively(data[i], out); else if (uuid) out.push(cc.assetManager.utils.decodeUuid(uuid)); else for (var prop in data) parseDependRecursively(data[prop], out);
        }
        parseDependRecursively(json, depends);
        return depends;
      })
    };
    module.exports = dependUtil;
  }), {
    "../platform/deserialize-compiled": 287,
    "./cache": 111,
    "./deserialize": 115,
    "./shared": 133
  } ],
  114: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    require("../CCDirector");
    var utilities = require("./utilities");
    var dependUtil = require("./depend-util");
    var releaseManager = require("./releaseManager");
    var downloader = require("./downloader");
    var factory = require("./factory");
    var helper = require("./helper");
    var ImageFmts = [ ".png", ".jpg", ".bmp", ".jpeg", ".gif", ".ico", ".tiff", ".webp", ".image", ".pvr", ".pkm" ];
    var AudioFmts = [ ".mp3", ".ogg", ".wav", ".m4a" ];
    function GetTrue() {
      return true;
    }
    var md5Pipe = {
      transformURL: function transformURL(url) {
        var uuid = helper.getUuidFromURL(url);
        if (!uuid) return url;
        var bundle = cc.assetManager.bundles.find((function(b) {
          return !!b.getAssetInfo(uuid);
        }));
        if (!bundle) return url;
        var hashValue = "";
        var info = bundle.getAssetInfo(uuid);
        hashValue = url.startsWith(bundle.base + bundle._config.nativeBase) ? info.nativeVer || "" : info.ver || "";
        if (!hashValue || -1 !== url.indexOf(hashValue)) return url;
        var hashPatchInFolder = false;
        ".ttf" === cc.path.extname(url) && (hashPatchInFolder = true);
        if (hashPatchInFolder) {
          var dirname = cc.path.dirname(url);
          var basename = cc.path.basename(url);
          url = dirname + "." + hashValue + "/" + basename;
        } else url = url.replace(/.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-]{8,})/, (function(match, uuid) {
          return match + "." + hashValue;
        }));
        return url;
      }
    };
    var loader = {
      onProgress: null,
      _autoReleaseSetting: Object.create(null),
      get _cache() {
        return cc.assetManager.assets._map;
      },
      load: function load(resources, progressCallback, completeCallback) {
        if (void 0 === completeCallback && void 0 !== progressCallback) {
          completeCallback = progressCallback;
          progressCallback = null;
        }
        resources = Array.isArray(resources) ? resources : [ resources ];
        for (var i = 0; i < resources.length; i++) {
          var item = resources[i];
          if ("string" === typeof item) resources[i] = {
            url: item,
            __isNative__: true
          }; else {
            if (item.type) {
              item.ext = "." + item.type;
              item.type = void 0;
            }
            item.url && (item.__isNative__ = true);
          }
        }
        var images = [];
        var audios = [];
        cc.assetManager.loadAny(resources, null, (function(finish, total, item) {
          item.content && (ImageFmts.includes(item.ext) ? images.push(item.content) : AudioFmts.includes(item.ext) && audios.push(item.content));
          progressCallback && progressCallback(finish, total, item);
        }), (function(err, _native) {
          var res = null;
          if (!err) {
            _native = Array.isArray(_native) ? _native : [ _native ];
            for (var i = 0; i < _native.length; i++) {
              var item = _native[i];
              if (!(item instanceof cc.Asset)) {
                var asset = item;
                var url = resources[i].url;
                images.includes(asset) ? factory.create(url, item, ".png", null, (function(err, image) {
                  asset = _native[i] = image;
                })) : audios.includes(asset) && factory.create(url, item, ".mp3", null, (function(err, audio) {
                  asset = _native[i] = audio;
                }));
                cc.assetManager.assets.add(url, asset);
              }
            }
            if (_native.length > 1) {
              var map = Object.create(null);
              _native.forEach((function(asset) {
                map[asset._uuid] = asset;
              }));
              res = {
                isCompleted: GetTrue,
                _map: map
              };
            } else res = _native[0];
          }
          completeCallback && completeCallback(err, res);
        }));
      },
      getXMLHttpRequest: function getXMLHttpRequest() {
        return new XMLHttpRequest();
      },
      _parseLoadResArgs: utilities.parseLoadResArgs,
      getItem: function getItem(key) {
        return cc.assetManager.assets.has(key) ? {
          content: cc.assetManager.assets.get(key)
        } : null;
      },
      loadRes: function loadRes(url, type, progressCallback, completeCallback) {
        var _this$_parseLoadResAr = this._parseLoadResArgs(type, progressCallback, completeCallback), type = _this$_parseLoadResAr.type, onProgress = _this$_parseLoadResAr.onProgress, onComplete = _this$_parseLoadResAr.onComplete;
        var extname = cc.path.extname(url);
        extname && (url = url.slice(0, -extname.length));
        cc.resources.load(url, type, onProgress, onComplete);
      },
      loadResArray: function loadResArray(urls, type, progressCallback, completeCallback) {
        var _this$_parseLoadResAr2 = this._parseLoadResArgs(type, progressCallback, completeCallback), type = _this$_parseLoadResAr2.type, onProgress = _this$_parseLoadResAr2.onProgress, onComplete = _this$_parseLoadResAr2.onComplete;
        urls.forEach((function(url, i) {
          var extname = cc.path.extname(url);
          extname && (urls[i] = url.slice(0, -extname.length));
        }));
        cc.resources.load(urls, type, onProgress, onComplete);
      },
      loadResDir: function loadResDir(url, type, progressCallback, completeCallback) {
        var _this$_parseLoadResAr3 = this._parseLoadResArgs(type, progressCallback, completeCallback), type = _this$_parseLoadResAr3.type, onProgress = _this$_parseLoadResAr3.onProgress, onComplete = _this$_parseLoadResAr3.onComplete;
        cc.resources.loadDir(url, type, onProgress, (function(err, assets) {
          var urls = [];
          if (!err) {
            var infos = cc.resources.getDirWithPath(url, type);
            urls = infos.map((function(info) {
              return info.path;
            }));
          }
          onComplete && onComplete(err, assets, urls);
        }));
      },
      getRes: function getRes(url, type) {
        return cc.assetManager.assets.has(url) ? cc.assetManager.assets.get(url) : cc.resources.get(url, type);
      },
      getResCount: function getResCount() {
        return cc.assetManager.assets.count;
      },
      getDependsRecursively: function getDependsRecursively(owner) {
        if (!owner) return [];
        return dependUtil.getDepsRecursively("string" === typeof owner ? owner : owner._uuid).concat([ owner._uuid ]);
      },
      get assetLoader() {
        true;
        cc.error("cc.loader.assetLoader was removed, assetLoader and md5Pipe were merged into cc.assetManager.transformPipeline");
      },
      get md5Pipe() {
        return md5Pipe;
      },
      get downloader() {
        return cc.assetManager.downloader;
      },
      get loader() {
        return cc.assetManager.parser;
      },
      addDownloadHandlers: function addDownloadHandlers(extMap) {
        true;
        cc.warn("`cc.loader.addDownloadHandlers` is deprecated, please use `cc.assetManager.downloader.register` instead");
        var handler = Object.create(null);
        for (var type in extMap) {
          var func = extMap[type];
          handler["." + type] = function(url, options, onComplete) {
            func({
              url: url
            }, onComplete);
          };
        }
        cc.assetManager.downloader.register(handler);
      },
      addLoadHandlers: function addLoadHandlers(extMap) {
        true;
        cc.warn("`cc.loader.addLoadHandlers` is deprecated, please use `cc.assetManager.parser.register` instead");
        var handler = Object.create(null);
        for (var type in extMap) {
          var func = extMap[type];
          handler["." + type] = function(file, options, onComplete) {
            func({
              content: file
            }, onComplete);
          };
        }
        cc.assetManager.parser.register(handler);
      },
      flowInDeps: function flowInDeps() {
        true;
        cc.error("cc.loader.flowInDeps was removed");
      },
      release: function release(asset) {
        if (Array.isArray(asset)) for (var i = 0; i < asset.length; i++) {
          var key = asset[i];
          "string" === typeof key && (key = cc.assetManager.assets.get(key));
          var isBuiltin = cc.assetManager.builtins._assets.find((function(assets) {
            return assets.find((function(builtinAsset) {
              return builtinAsset === key;
            }));
          }));
          if (isBuiltin) continue;
          cc.assetManager.releaseAsset(key);
        } else if (asset) {
          "string" === typeof asset && (asset = cc.assetManager.assets.get(asset));
          var _isBuiltin = cc.assetManager.builtins._assets.find((function(assets) {
            return assets.find((function(builtinAsset) {
              return builtinAsset === asset;
            }));
          }));
          if (_isBuiltin) return;
          cc.assetManager.releaseAsset(asset);
        }
      },
      releaseAsset: function releaseAsset(asset) {
        cc.assetManager.releaseAsset(asset);
      },
      releaseRes: function releaseRes(url, type) {
        cc.resources.release(url, type);
      },
      releaseResDir: function releaseResDir() {
        true;
        cc.error("cc.loader.releaseResDir was removed, please use cc.assetManager.releaseAsset instead");
      },
      releaseAll: function releaseAll() {
        cc.assetManager.releaseAll();
        cc.assetManager.assets.clear();
      },
      removeItem: function removeItem(key) {
        cc.assetManager.assets.remove(key);
      },
      setAutoRelease: function setAutoRelease(asset, autoRelease) {
        "object" === typeof asset && (asset = asset._uuid);
        this._autoReleaseSetting[asset] = !!autoRelease;
      },
      setAutoReleaseRecursively: function setAutoReleaseRecursively(asset, autoRelease) {
        "object" === typeof asset && (asset = asset._uuid);
        autoRelease = !!autoRelease;
        this._autoReleaseSetting[asset] = autoRelease;
        var depends = dependUtil.getDepsRecursively(asset);
        for (var i = 0; i < depends.length; i++) {
          var depend = depends[i];
          this._autoReleaseSetting[depend] = autoRelease;
        }
      },
      isAutoRelease: function isAutoRelease(asset) {
        "object" === typeof asset && (asset = asset._uuid);
        return !!this._autoReleaseSetting[asset];
      }
    };
    downloader.loadSubpackage = function(name, completeCallback) {
      cc.assetManager.loadBundle(name, null, completeCallback);
    };
    var AssetLibrary = {
      init: function init(options) {
        options.importBase = options.libraryPath;
        options.nativeBase = options.libraryPath;
        cc.assetManager.init(options);
        if (options.rawAssets) {
          var resources = new cc.AssetManager.Bundle();
          resources.init({
            name: cc.AssetManager.BuiltinBundleName.RESOURCES,
            importBase: options.importBase,
            nativeBase: options.nativeBase,
            paths: options.rawAssets.assets,
            uuids: Object.keys(options.rawAssets.assets)
          });
        }
      },
      loadAsset: function loadAsset(uuid, onComplete) {
        cc.assetManager.loadAny(uuid, onComplete);
      },
      getLibUrlNoExt: function getLibUrlNoExt() {
        true;
        cc.error("cc.AssetLibrary.getLibUrlNoExt was removed, if you want to transform url, please use cc.assetManager.utils.getUrlWithUuid instead");
      },
      queryAssetInfo: function queryAssetInfo() {
        true;
        cc.error("cc.AssetLibrary.queryAssetInfo was removed, only available in the editor by using cc.assetManager.editorExtend.queryAssetInfo");
      }
    };
    cc.url = {
      normalize: function normalize(url) {
        cc.warnID(1400, "cc.url.normalize", "cc.assetManager.utils.normalize");
        return cc.assetManager.utils.normalize(url);
      },
      raw: function raw(url) {
        cc.warnID(1400, "cc.url.raw", "cc.resources.load");
        if (url.startsWith("resources/")) return cc.assetManager._transform({
          path: cc.path.changeExtname(url.substr(10)),
          bundle: cc.AssetManager.BuiltinBundleName.RESOURCES,
          __isNative__: true,
          ext: cc.path.extname(url)
        });
        return "";
      }
    };
    var onceWarns = {
      loader: true,
      assetLibrary: true
    };
    Object.defineProperties(cc, {
      loader: {
        get: function get() {
          true;
          if (onceWarns.loader) {
            onceWarns.loader = false;
            cc.log("cc.loader is deprecated, use cc.assetManager instead please. See https://docs.cocos.com/creator/manual/zh/release-notes/asset-manager-upgrade-guide.html");
          }
          return loader;
        }
      },
      AssetLibrary: {
        get: function get() {
          true;
          if (onceWarns.assetLibrary) {
            onceWarns.assetLibrary = false;
            cc.log("cc.AssetLibrary is deprecated, use cc.assetManager instead please. See https://docs.cocos.com/creator/manual/zh/release-notes/asset-manager-upgrade-guide.html");
          }
          return AssetLibrary;
        }
      },
      LoadingItems: {
        get: function get() {
          cc.warnID(1400, "cc.LoadingItems", "cc.AssetManager.Task");
          return cc.AssetManager.Task;
        }
      },
      Pipeline: {
        get: function get() {
          cc.warnID(1400, "cc.Pipeline", "cc.AssetManager.Pipeline");
          return cc.AssetManager.Pipeline;
        }
      }
    });
    js.obsolete(cc, "cc.RawAsset", "cc.Asset");
    js.obsolete(cc.Asset.prototype, "cc.Asset.url", "nativeUrl");
    Object.defineProperties(cc.macro, {
      DOWNLOAD_MAX_CONCURRENT: {
        get: function get() {
          return cc.assetManager.downloader.maxConcurrency;
        },
        set: function set(val) {
          cc.assetManager.downloader.maxConcurrency = val;
        }
      }
    });
    Object.assign(cc.director, {
      _getSceneUuid: function _getSceneUuid(sceneName) {
        cc.assetManager.main.getSceneInfo(sceneName);
      }
    });
    Object.defineProperties(cc.game, {
      _sceneInfos: {
        get: function get() {
          var scenes = [];
          cc.assetManager.main._config.scenes.forEach((function(val) {
            scenes.push(val);
          }));
          return scenes;
        }
      }
    });
    var parseParameters = utilities.parseParameters;
    utilities.parseParameters = function(options, onProgress, onComplete) {
      var result = parseParameters(options, onProgress, onComplete);
      result.onProgress = result.onProgress || loader.onProgress;
      return result;
    };
    var autoRelease = releaseManager._autoRelease;
    releaseManager._autoRelease = function() {
      autoRelease.apply(this, arguments);
      var releaseSettings = loader._autoReleaseSetting;
      var keys = Object.keys(releaseSettings);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (true === releaseSettings[key]) {
          var asset = cc.assetManager.assets.get(key);
          asset && releaseManager.tryRelease(asset);
        }
      }
    };
  }), {
    "../CCDirector": 102,
    "../platform/js": 294,
    "./depend-util": 113,
    "./downloader": 120,
    "./factory": 121,
    "./helper": 124,
    "./releaseManager": 131,
    "./utilities": 136
  } ],
  115: [ (function(require, module, exports) {
    "use strict";
    var helper = require("./helper");
    var MissingClass = false;
    require("../platform/deserialize");
    function deserialize(json, options) {
      var classFinder, missingClass;
      false;
      classFinder = cc._MissingScript.safeFindClass;
      var pool = null;
      false;
      var _require = require("../platform/deserialize-compiled"), deserializeForCompiled = _require["default"];
      var deserializeForEditor = require("../platform/deserialize-editor");
      pool = deserializeForCompiled.isCompiledJson(json) ? deserializeForCompiled.Details.pool : deserializeForEditor.Details.pool;
      var tdInfo = pool.get();
      var asset;
      try {
        asset = cc.deserialize(json, tdInfo, {
          classFinder: classFinder,
          customEnv: options
        });
      } catch (e) {
        pool.put(tdInfo);
        throw e;
      }
      false;
      var uuidList = tdInfo.uuidList;
      var objList = tdInfo.uuidObjList;
      var propList = tdInfo.uuidPropList;
      var depends = [];
      for (var i = 0; i < uuidList.length; i++) {
        var dependUuid = uuidList[i];
        depends[i] = {
          uuid: helper.decodeUuid(dependUuid),
          owner: objList[i],
          prop: propList[i]
        };
      }
      asset.__depends__ = depends;
      asset._native && (asset.__nativeDepend__ = true);
      pool.put(tdInfo);
      return asset;
    }
    module.exports = deserialize;
  }), {
    "../platform/deserialize": 289,
    "../platform/deserialize-compiled": 287,
    "../platform/deserialize-editor": 288,
    "./helper": 124
  } ],
  116: [ (function(require, module, exports) {
    "use strict";
    var __audioSupport = cc.sys.__audioSupport;
    var _require = require("./utilities"), parseParameters = _require.parseParameters;
    function downloadDomAudio(url, options, onComplete) {
      var _parseParameters = parseParameters(options, void 0, onComplete), options = _parseParameters.options, onComplete = _parseParameters.onComplete;
      var dom = document.createElement("audio");
      dom.src = url;
      var clearEvent = function clearEvent() {
        clearTimeout(timer);
        dom.removeEventListener("canplaythrough", success, false);
        dom.removeEventListener("error", failure, false);
        __audioSupport.USE_LOADER_EVENT && dom.removeEventListener(__audioSupport.USE_LOADER_EVENT, success, false);
      };
      var timer = setTimeout((function() {
        0 === dom.readyState ? failure() : success();
      }), 8e3);
      var success = function success() {
        clearEvent();
        onComplete && onComplete(null, dom);
      };
      var failure = function failure() {
        clearEvent();
        var message = "load audio failure - " + url;
        cc.log(message);
        onComplete && onComplete(new Error(message));
      };
      dom.addEventListener("canplaythrough", success, false);
      dom.addEventListener("error", failure, false);
      __audioSupport.USE_LOADER_EVENT && dom.addEventListener(__audioSupport.USE_LOADER_EVENT, success, false);
      return dom;
    }
    module.exports = downloadDomAudio;
  }), {
    "./utilities": 136
  } ],
  117: [ (function(require, module, exports) {
    "use strict";
    var _require = require("./utilities"), parseParameters = _require.parseParameters;
    function downloadDomImage(url, options, onComplete) {
      var _parseParameters = parseParameters(options, void 0, onComplete), options = _parseParameters.options, onComplete = _parseParameters.onComplete;
      var img = new Image();
      "file:" !== window.location.protocol && (img.crossOrigin = "anonymous");
      function loadCallback() {
        img.removeEventListener("load", loadCallback);
        img.removeEventListener("error", errorCallback);
        onComplete && onComplete(null, img);
      }
      function errorCallback() {
        img.removeEventListener("load", loadCallback);
        img.removeEventListener("error", errorCallback);
        onComplete && onComplete(new Error(cc.debug.getError(4930, url)));
      }
      img.addEventListener("load", loadCallback);
      img.addEventListener("error", errorCallback);
      img.src = url;
      return img;
    }
    module.exports = downloadDomImage;
  }), {
    "./utilities": 136
  } ],
  118: [ (function(require, module, exports) {
    "use strict";
    var _require = require("./utilities"), parseParameters = _require.parseParameters;
    function downloadFile(url, options, onProgress, onComplete) {
      var _parseParameters = parseParameters(options, onProgress, onComplete), options = _parseParameters.options, onProgress = _parseParameters.onProgress, onComplete = _parseParameters.onComplete;
      var xhr = new XMLHttpRequest(), errInfo = "download failed: " + url + ", status: ";
      xhr.open("GET", url, true);
      void 0 !== options.responseType && (xhr.responseType = options.responseType);
      void 0 !== options.withCredentials && (xhr.withCredentials = options.withCredentials);
      void 0 !== options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType);
      void 0 !== options.timeout && (xhr.timeout = options.timeout);
      if (options.header) for (var header in options.header) xhr.setRequestHeader(header, options.header[header]);
      xhr.onload = function() {
        200 === xhr.status || 0 === xhr.status ? onComplete && onComplete(null, xhr.response) : onComplete && onComplete(new Error(errInfo + xhr.status + "(no response)"));
      };
      onProgress && (xhr.onprogress = function(e) {
        e.lengthComputable && onProgress(e.loaded, e.total);
      });
      xhr.onerror = function() {
        onComplete && onComplete(new Error(errInfo + xhr.status + "(error)"));
      };
      xhr.ontimeout = function() {
        onComplete && onComplete(new Error(errInfo + xhr.status + "(time out)"));
      };
      xhr.onabort = function() {
        onComplete && onComplete(new Error(errInfo + xhr.status + "(abort)"));
      };
      xhr.send(null);
      return xhr;
    }
    module.exports = downloadFile;
  }), {
    "./utilities": 136
  } ],
  119: [ (function(require, module, exports) {
    "use strict";
    var _require = require("./utilities"), parseParameters = _require.parseParameters;
    var downloaded = {};
    function downloadScript(url, options, onComplete) {
      var _parseParameters = parseParameters(options, void 0, onComplete), options = _parseParameters.options, onComplete = _parseParameters.onComplete;
      if (downloaded[url]) return onComplete && onComplete(null);
      var d = document, s = document.createElement("script");
      "file:" !== window.location.protocol && (s.crossOrigin = "anonymous");
      s.async = options.async;
      s.src = url;
      function loadHandler() {
        s.parentNode.removeChild(s);
        s.removeEventListener("load", loadHandler, false);
        s.removeEventListener("error", errorHandler, false);
        downloaded[url] = true;
        onComplete && onComplete(null);
      }
      function errorHandler() {
        s.parentNode.removeChild(s);
        s.removeEventListener("load", loadHandler, false);
        s.removeEventListener("error", errorHandler, false);
        onComplete && onComplete(new Error(cc.debug.getError(4928, url)));
      }
      s.addEventListener("load", loadHandler, false);
      s.addEventListener("error", errorHandler, false);
      d.body.appendChild(s);
    }
    module.exports = downloadScript;
  }), {
    "./utilities": 136
  } ],
  120: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    var debug = require("../CCDebug");
    var _require = require("./font-loader"), loadFont = _require.loadFont;
    var callInNextTick = require("../platform/utils").callInNextTick;
    var downloadDomImage = require("./download-dom-image");
    var downloadDomAudio = require("./download-dom-audio");
    var downloadFile = require("./download-file");
    var downloadScript = require("./download-script.js");
    var Cache = require("./cache");
    var _require2 = require("./shared"), files = _require2.files;
    var _require3 = require("../platform/CCSys"), __audioSupport = _require3.__audioSupport, capabilities = _require3.capabilities;
    var _require4 = require("./utilities"), urlAppendTimestamp = _require4.urlAppendTimestamp, retry = _require4.retry;
    var REGEX = /^(?:\w+:\/\/|\.+\/).+/;
    var formatSupport = __audioSupport.format || [];
    var unsupported = function unsupported(url, options, onComplete) {
      onComplete(new Error(debug.getError(4927)));
    };
    var downloadAudio = function downloadAudio(url, options, onComplete) {
      options.audioLoadMode !== cc.AudioClip.LoadMode.DOM_AUDIO ? downloadArrayBuffer(url, options, onComplete) : downloadDomAudio(url, options, onComplete);
    };
    var downloadAudio = 0 === formatSupport.length ? unsupported : __audioSupport.WEB_AUDIO ? downloadAudio : downloadDomAudio;
    var downloadImage = function downloadImage(url, options, onComplete) {
      var func = capabilities.imageBitmap && cc.macro.ALLOW_IMAGE_BITMAP ? downloadBlob : downloadDomImage;
      func.apply(this, arguments);
    };
    var downloadBlob = function downloadBlob(url, options, onComplete) {
      options.responseType = "blob";
      downloadFile(url, options, options.onFileProgress, onComplete);
    };
    var downloadJson = function downloadJson(url, options, onComplete) {
      options.responseType = "json";
      downloadFile(url, options, options.onFileProgress, (function(err, data) {
        if (!err && "string" === typeof data) try {
          data = JSON.parse(data);
        } catch (e) {
          err = e;
        }
        onComplete && onComplete(err, data);
      }));
    };
    var downloadArrayBuffer = function downloadArrayBuffer(url, options, onComplete) {
      options.responseType = "arraybuffer";
      downloadFile(url, options, options.onFileProgress, onComplete);
    };
    var downloadText = function downloadText(url, options, onComplete) {
      options.responseType = "text";
      downloadFile(url, options, options.onFileProgress, onComplete);
    };
    var downloadVideo = function downloadVideo(url, options, onComplete) {
      onComplete(null, url);
    };
    var downloadBundle = function downloadBundle(nameOrUrl, options, onComplete) {
      var bundleName = cc.path.basename(nameOrUrl);
      var url = nameOrUrl;
      REGEX.test(url) || (url = "assets/" + bundleName);
      var version = options.version || downloader.bundleVers[bundleName];
      var count = 0;
      var config = url + "/config." + (version ? version + "." : "") + "json";
      var out = null, error = null;
      downloadJson(config, options, (function(err, response) {
        err && (error = err);
        out = response;
        out && (out.base = url + "/");
        count++;
        2 === count && onComplete(error, out);
      }));
      var js = url + "/index." + (version ? version + "." : "") + "js";
      downloadScript(js, options, (function(err) {
        err && (error = err);
        count++;
        2 === count && onComplete(error, out);
      }));
    };
    var _downloading = new Cache();
    var _queue = [];
    var _queueDirty = false;
    var _totalNum = 0;
    var _totalNumThisPeriod = 0;
    var _lastDate = -1;
    var _checkNextPeriod = false;
    var updateTime = function updateTime() {
      var now = Date.now();
      var interval = cc.director._deltaTime > downloader._maxInterval ? downloader._maxInterval : cc.director._deltaTime;
      if (now - _lastDate > 1e3 * interval) {
        _totalNumThisPeriod = 0;
        _lastDate = now;
      }
    };
    var handleQueue = function handleQueue(maxConcurrency, maxRequestsPerFrame) {
      _checkNextPeriod = false;
      updateTime();
      while (_queue.length > 0 && _totalNum < maxConcurrency && _totalNumThisPeriod < maxRequestsPerFrame) {
        if (_queueDirty) {
          _queue.sort((function(a, b) {
            return a.priority - b.priority;
          }));
          _queueDirty = false;
        }
        var nextOne = _queue.pop();
        if (!nextOne) break;
        _totalNum++;
        _totalNumThisPeriod++;
        nextOne.invoke();
      }
      if (_queue.length > 0 && _totalNum < maxConcurrency) {
        callInNextTick(handleQueue, maxConcurrency, maxRequestsPerFrame);
        _checkNextPeriod = true;
      }
    };
    var downloader = {
      _remoteServerAddress: "",
      _maxInterval: 1 / 30,
      get remoteServerAddress() {
        return this._remoteServerAddress;
      },
      maxConcurrency: 6,
      maxRequestsPerFrame: 6,
      maxRetryCount: 3,
      appendTimeStamp: false,
      limited: true,
      retryInterval: 2e3,
      bundleVers: null,
      downloadDomImage: downloadDomImage,
      downloadDomAudio: downloadDomAudio,
      downloadFile: downloadFile,
      downloadScript: downloadScript,
      init: function init(bundleVers, remoteServerAddress) {
        _downloading.clear();
        _queue.length = 0;
        this._remoteServerAddress = remoteServerAddress || "";
        this.bundleVers = bundleVers || Object.create(null);
      },
      register: function register(type, handler) {
        "object" === typeof type ? js.mixin(downloaders, type) : downloaders[type] = handler;
      },
      download: function download(id, url, type, options, onComplete) {
        var func = downloaders[type] || downloaders["default"];
        var self = this;
        var file, downloadCallbacks;
        if (file = files.get(id)) onComplete(null, file); else if (downloadCallbacks = _downloading.get(id)) {
          downloadCallbacks.push(onComplete);
          for (var i = 0, l = _queue.length; i < l; i++) {
            var item = _queue[i];
            if (item.id === id) {
              var priority = options.priority || 0;
              if (item.priority < priority) {
                item.priority = priority;
                _queueDirty = true;
              }
              return;
            }
          }
        } else {
          var process = function process(index, callback) {
            0 === index && _downloading.add(id, [ onComplete ]);
            if (!self.limited) return func(urlAppendTimestamp(url), options, callback);
            updateTime();
            function invoke() {
              func(urlAppendTimestamp(url), options, (function() {
                _totalNum--;
                if (!_checkNextPeriod && _queue.length > 0) {
                  callInNextTick(handleQueue, maxConcurrency, maxRequestsPerFrame);
                  _checkNextPeriod = true;
                }
                callback.apply(this, arguments);
              }));
            }
            if (_totalNum < maxConcurrency && _totalNumThisPeriod < maxRequestsPerFrame) {
              invoke();
              _totalNum++;
              _totalNumThisPeriod++;
            } else {
              _queue.push({
                id: id,
                priority: options.priority || 0,
                invoke: invoke
              });
              _queueDirty = true;
              if (!_checkNextPeriod && _totalNum < maxConcurrency) {
                callInNextTick(handleQueue, maxConcurrency, maxRequestsPerFrame);
                _checkNextPeriod = true;
              }
            }
          };
          var finale = function finale(err, result) {
            err || files.add(id, result);
            var callbacks = _downloading.remove(id);
            for (var _i = 0, _l = callbacks.length; _i < _l; _i++) callbacks[_i](err, result);
          };
          var maxRetryCount = "undefined" !== typeof options.maxRetryCount ? options.maxRetryCount : this.maxRetryCount;
          var maxConcurrency = "undefined" !== typeof options.maxConcurrency ? options.maxConcurrency : this.maxConcurrency;
          var maxRequestsPerFrame = "undefined" !== typeof options.maxRequestsPerFrame ? options.maxRequestsPerFrame : this.maxRequestsPerFrame;
          retry(process, maxRetryCount, this.retryInterval, finale);
        }
      }
    };
    var downloaders = {
      ".png": downloadImage,
      ".jpg": downloadImage,
      ".bmp": downloadImage,
      ".jpeg": downloadImage,
      ".gif": downloadImage,
      ".ico": downloadImage,
      ".tiff": downloadImage,
      ".webp": downloadImage,
      ".image": downloadImage,
      ".pvr": downloadArrayBuffer,
      ".pkm": downloadArrayBuffer,
      ".mp3": downloadAudio,
      ".ogg": downloadAudio,
      ".wav": downloadAudio,
      ".m4a": downloadAudio,
      ".txt": downloadText,
      ".xml": downloadText,
      ".vsh": downloadText,
      ".fsh": downloadText,
      ".atlas": downloadText,
      ".tmx": downloadText,
      ".tsx": downloadText,
      ".json": downloadJson,
      ".ExportJson": downloadJson,
      ".plist": downloadText,
      ".fnt": downloadText,
      ".font": loadFont,
      ".eot": loadFont,
      ".ttf": loadFont,
      ".woff": loadFont,
      ".svg": loadFont,
      ".ttc": loadFont,
      ".mp4": downloadVideo,
      ".avi": downloadVideo,
      ".mov": downloadVideo,
      ".mpg": downloadVideo,
      ".mpeg": downloadVideo,
      ".rm": downloadVideo,
      ".rmvb": downloadVideo,
      ".binary": downloadArrayBuffer,
      ".bin": downloadArrayBuffer,
      ".dbbin": downloadArrayBuffer,
      ".skel": downloadArrayBuffer,
      ".js": downloadScript,
      bundle: downloadBundle,
      default: downloadText
    };
    downloader._downloaders = downloaders;
    module.exports = downloader;
  }), {
    "../CCDebug": 101,
    "../platform/CCSys": 281,
    "../platform/js": 294,
    "../platform/utils": 297,
    "./cache": 111,
    "./download-dom-audio": 116,
    "./download-dom-image": 117,
    "./download-file": 118,
    "./download-script.js": 119,
    "./font-loader": 123,
    "./shared": 133,
    "./utilities": 136
  } ],
  121: [ (function(require, module, exports) {
    "use strict";
    var Bundle = require("./bundle");
    var Cache = require("./cache");
    var _require = require("./shared"), assets = _require.assets, bundles = _require.bundles;
    var _creating = new Cache();
    function createTexture(id, data, options, onComplete) {
      var out = null, err = null;
      try {
        out = new cc.Texture2D();
        out._nativeUrl = id;
        out._nativeAsset = data;
      } catch (e) {
        err = e;
      }
      onComplete && onComplete(err, out);
    }
    function createAudioClip(id, data, options, onComplete) {
      var out = new cc.AudioClip();
      out._nativeUrl = id;
      out._nativeAsset = data;
      out.duration = data.duration;
      onComplete && onComplete(null, out);
    }
    function createVideoClip(id, data, options, onComplete) {
      var out = new cc.VideoClip();
      out._nativeUrl = id;
      out._nativeAsset = data;
      onComplete && onComplete(null, out);
    }
    function createJsonAsset(id, data, options, onComplete) {
      var out = new cc.JsonAsset();
      out.json = data;
      onComplete && onComplete(null, out);
    }
    function createTextAsset(id, data, options, onComplete) {
      var out = new cc.TextAsset();
      out.text = data;
      onComplete && onComplete(null, out);
    }
    function createFont(id, data, options, onComplete) {
      var out = new cc.TTFFont();
      out._nativeUrl = id;
      out._nativeAsset = data;
      onComplete && onComplete(null, out);
    }
    function createBufferAsset(id, data, options, onComplete) {
      var out = new cc.BufferAsset();
      out._nativeUrl = id;
      out._nativeAsset = data;
      onComplete && onComplete(null, out);
    }
    function createAsset(id, data, options, onComplete) {
      var out = new cc.Asset();
      out._nativeUrl = id;
      out._nativeAsset = data;
      onComplete && onComplete(null, out);
    }
    function createBundle(id, data, options, onComplete) {
      var bundle = bundles.get(data.name);
      if (!bundle) {
        bundle = new Bundle();
        data.base = data.base || id + "/";
        bundle.init(data);
      }
      onComplete && onComplete(null, bundle);
    }
    var factory = {
      register: function register(type, handler) {
        "object" === typeof type ? cc.js.mixin(producers, type) : producers[type] = handler;
      },
      create: function create(id, data, type, options, onComplete) {
        var func = producers[type] || producers["default"];
        var asset, creating;
        if (asset = assets.get(id)) onComplete(null, asset); else if (creating = _creating.get(id)) creating.push(onComplete); else {
          _creating.add(id, [ onComplete ]);
          func(id, data, options, (function(err, data) {
            if (!err && data instanceof cc.Asset) {
              data._uuid = id;
              assets.add(id, data);
            }
            var callbacks = _creating.remove(id);
            for (var i = 0, l = callbacks.length; i < l; i++) callbacks[i](err, data);
          }));
        }
      }
    };
    var producers = {
      ".png": createTexture,
      ".jpg": createTexture,
      ".bmp": createTexture,
      ".jpeg": createTexture,
      ".gif": createTexture,
      ".ico": createTexture,
      ".tiff": createTexture,
      ".webp": createTexture,
      ".image": createTexture,
      ".pvr": createTexture,
      ".pkm": createTexture,
      ".mp3": createAudioClip,
      ".ogg": createAudioClip,
      ".wav": createAudioClip,
      ".m4a": createAudioClip,
      ".mp4": createVideoClip,
      ".avi": createVideoClip,
      ".mov": createVideoClip,
      ".mpg": createVideoClip,
      ".mpeg": createVideoClip,
      ".rm": createVideoClip,
      ".rmvb": createVideoClip,
      ".txt": createTextAsset,
      ".xml": createTextAsset,
      ".vsh": createTextAsset,
      ".fsh": createTextAsset,
      ".atlas": createTextAsset,
      ".tmx": createTextAsset,
      ".tsx": createTextAsset,
      ".fnt": createTextAsset,
      ".json": createJsonAsset,
      ".ExportJson": createJsonAsset,
      ".font": createFont,
      ".eot": createFont,
      ".ttf": createFont,
      ".woff": createFont,
      ".svg": createFont,
      ".ttc": createFont,
      ".binary": createBufferAsset,
      ".bin": createBufferAsset,
      ".dbbin": createBufferAsset,
      ".skel": createBufferAsset,
      bundle: createBundle,
      default: createAsset
    };
    module.exports = factory;
  }), {
    "./bundle": 110,
    "./cache": 111,
    "./shared": 133
  } ],
  122: [ (function(require, module, exports) {
    "use strict";
    var packManager = require("./pack-manager");
    var Task = require("./task");
    var _require = require("./utilities"), getDepends = _require.getDepends, clear = _require.clear, forEach = _require.forEach;
    var _require2 = require("./shared"), assets = _require2.assets, fetchPipeline = _require2.fetchPipeline;
    function fetch(task, done) {
      var firstTask = false;
      if (!task.progress) {
        task.progress = {
          finish: 0,
          total: task.input.length,
          canInvoke: true
        };
        firstTask = true;
      }
      var options = task.options, depends = [], progress = task.progress, total = progress.total;
      options.__exclude__ = options.__exclude__ || Object.create(null);
      task.output = [];
      forEach(task.input, (function(item, cb) {
        if (!item.isNative && assets.has(item.uuid)) {
          var asset = assets.get(item.uuid);
          asset.addRef();
          handle(item, task, asset, null, asset.__asyncLoadAssets__, depends, total, done);
          return cb();
        }
        packManager.load(item, task.options, (function(err, data) {
          if (err) {
            if (!task.isFinish) if (!cc.assetManager.force || firstTask) {
              cc.error(err.message, err.stack);
              progress.canInvoke = false;
              done(err);
            } else handle(item, task, null, null, false, depends, total, done);
          } else task.isFinish || handle(item, task, null, data, !item.isNative, depends, total, done);
          cb();
        }));
      }), (function() {
        if (task.isFinish) {
          clear(task, true);
          return task.dispatch("error");
        }
        if (depends.length > 0) {
          var subTask = Task.create({
            name: task.name + " dependencies",
            input: depends,
            progress: progress,
            options: options,
            onProgress: task.onProgress,
            onError: Task.prototype.recycle,
            onComplete: function onComplete(err) {
              if (!err) {
                task.output.push.apply(task.output, this.output);
                subTask.recycle();
              }
              firstTask && decreaseRef(task);
              done(err);
            }
          });
          fetchPipeline.async(subTask);
          return;
        }
        firstTask && decreaseRef(task);
        done();
      }));
    }
    function decreaseRef(task) {
      var output = task.output;
      for (var i = 0, l = output.length; i < l; i++) output[i].content && output[i].content.decRef(false);
    }
    function handle(item, task, content, file, loadDepends, depends, last, done) {
      var exclude = task.options.__exclude__;
      var progress = task.progress;
      item.content = content;
      item.file = file;
      task.output.push(item);
      if (loadDepends) {
        exclude[item.uuid] = true;
        getDepends(item.uuid, file || content, exclude, depends, true, false, item.config);
        progress.total = last + depends.length;
      }
      progress.canInvoke && task.dispatch("progress", ++progress.finish, progress.total, item);
    }
    module.exports = fetch;
  }), {
    "./pack-manager": 127,
    "./shared": 133,
    "./task": 134,
    "./utilities": 136
  } ],
  123: [ (function(require, module, exports) {
    "use strict";
    var textUtils = require("../utils/text-utils");
    var _canvasContext = null;
    var _testString = "BES bswy:->@123\u4e01\u3041\u1101";
    var _fontFaces = Object.create(null);
    var _intervalId = -1;
    var _loadingFonts = [];
    var _timeout = 3e3;
    var useNativeCheck = (function() {
      var nativeCheck = void 0;
      return function() {
        if (void 0 === nativeCheck) if (!window.FontFace) nativeCheck = false; else {
          var match = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent);
          var safari10Match = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
          nativeCheck = match ? parseInt(match[1], 10) > 42 : !safari10Match;
        }
        return nativeCheck;
      };
    })();
    function _checkFontLoaded() {
      var allFontsLoaded = true;
      var now = Date.now();
      for (var i = _loadingFonts.length - 1; i >= 0; i--) {
        var fontLoadHandle = _loadingFonts[i];
        var fontFamily = fontLoadHandle.fontFamilyName;
        if (now - fontLoadHandle.startTime > _timeout) {
          cc.warnID(4933, fontFamily);
          fontLoadHandle.onComplete(null, fontFamily);
          _loadingFonts.splice(i, 1);
          continue;
        }
        var oldWidth = fontLoadHandle.refWidth;
        var fontDesc = "40px " + fontFamily;
        _canvasContext.font = fontDesc;
        var newWidth = textUtils.safeMeasureText(_canvasContext, _testString, fontDesc);
        if (oldWidth !== newWidth) {
          _loadingFonts.splice(i, 1);
          fontLoadHandle.onComplete(null, fontFamily);
        } else allFontsLoaded = false;
      }
      if (allFontsLoaded) {
        clearInterval(_intervalId);
        _intervalId = -1;
      }
    }
    function nativeCheckFontLoaded(start, font, callback) {
      var loader = new Promise(function(resolve, reject) {
        var check = function check() {
          var now = Date.now();
          now - start >= _timeout ? reject() : document.fonts.load("40px " + font).then((function(fonts) {
            fonts.length >= 1 ? resolve() : setTimeout(check, 100);
          }), (function() {
            reject();
          }));
        };
        check();
      });
      var timeoutId = null, timer = new Promise(function(resolve, reject) {
        timeoutId = setTimeout(reject, _timeout);
      });
      Promise.race([ timer, loader ]).then((function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        callback(null, font);
      }), (function() {
        cc.warnID(4933, font);
        callback(null, font);
      }));
    }
    var fontLoader = {
      loadFont: function loadFont(url, options, onComplete) {
        var fontFamilyName = fontLoader._getFontFamily(url);
        if (_fontFaces[fontFamilyName]) return onComplete(null, fontFamilyName);
        if (!_canvasContext) {
          var labelCanvas = document.createElement("canvas");
          labelCanvas.width = 100;
          labelCanvas.height = 100;
          _canvasContext = labelCanvas.getContext("2d");
        }
        var fontDesc = "40px " + fontFamilyName;
        _canvasContext.font = fontDesc;
        var refWidth = textUtils.safeMeasureText(_canvasContext, _testString, fontDesc);
        var fontStyle = document.createElement("style");
        fontStyle.type = "text/css";
        var fontStr = "";
        isNaN(fontFamilyName - 0) ? fontStr += "@font-face { font-family:" + fontFamilyName + "; src:" : fontStr += "@font-face { font-family:'" + fontFamilyName + "'; src:";
        fontStr += "url('" + url + "');";
        fontStyle.textContent = fontStr + "}";
        document.body.appendChild(fontStyle);
        var preloadDiv = document.createElement("div");
        var divStyle = preloadDiv.style;
        divStyle.fontFamily = fontFamilyName;
        preloadDiv.innerHTML = ".";
        divStyle.position = "absolute";
        divStyle.left = "-100px";
        divStyle.top = "-100px";
        document.body.appendChild(preloadDiv);
        if (useNativeCheck()) nativeCheckFontLoaded(Date.now(), fontFamilyName, onComplete); else {
          var fontLoadHandle = {
            fontFamilyName: fontFamilyName,
            refWidth: refWidth,
            onComplete: onComplete,
            startTime: Date.now()
          };
          _loadingFonts.push(fontLoadHandle);
          -1 === _intervalId && (_intervalId = setInterval(_checkFontLoaded, 100));
        }
        _fontFaces[fontFamilyName] = fontStyle;
      },
      _getFontFamily: function _getFontFamily(fontHandle) {
        var ttfIndex = fontHandle.lastIndexOf(".ttf");
        if (-1 === ttfIndex) return fontHandle;
        var slashPos = fontHandle.lastIndexOf("/");
        var fontFamilyName;
        fontFamilyName = -1 === slashPos ? fontHandle.substring(0, ttfIndex) + "_LABEL" : fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
        -1 !== fontFamilyName.indexOf(" ") && (fontFamilyName = '"' + fontFamilyName + '"');
        return fontFamilyName;
      }
    };
    module.exports = fontLoader;
  }), {
    "../utils/text-utils": 393
  } ],
  124: [ (function(require, module, exports) {
    "use strict";
    var _require = require("./shared"), bundles = _require.bundles;
    var helper = {
      decodeUuid: require("../utils/decode-uuid"),
      getUuidFromURL: (function() {
        var _uuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-]{8,})/;
        return function(url) {
          var matches = url.match(_uuidRegex);
          if (matches) return matches[1];
          return "";
        };
      })(),
      getUrlWithUuid: function getUrlWithUuid(uuid, options) {
        options = options || Object.create(null);
        options.__isNative__ = options.isNative;
        options.ext = options.nativeExt;
        var bundle = bundles.find((function(bundle) {
          return bundle.getAssetInfo(uuid);
        }));
        bundle && (options.bundle = bundle.name);
        return cc.assetManager._transform(uuid, options);
      },
      isScene: function isScene(asset) {
        return asset && (asset.constructor === cc.SceneAsset || asset instanceof cc.Scene);
      },
      normalize: function normalize(url) {
        url && (46 === url.charCodeAt(0) && 47 === url.charCodeAt(1) ? url = url.slice(2) : 47 === url.charCodeAt(0) && (url = url.slice(1)));
        return url;
      }
    };
    module.exports = helper;
  }), {
    "../utils/decode-uuid": 381,
    "./shared": 133
  } ],
  125: [ (function(require, module, exports) {
    "use strict";
    require("./deprecated");
    require("./CCAssetManager");
  }), {
    "./CCAssetManager": 108,
    "./deprecated": 114
  } ],
  126: [ (function(require, module, exports) {
    "use strict";
    var packManager = require("./pack-manager");
    var Pipeline = require("./pipeline");
    var parser = require("./parser");
    var _require = require("./utilities"), getDepends = _require.getDepends, cache = _require.cache, gatherAsset = _require.gatherAsset, setProperties = _require.setProperties, forEach = _require.forEach, clear = _require.clear, checkCircleReference = _require.checkCircleReference;
    var _require2 = require("./shared"), assets = _require2.assets, files = _require2.files, parsed = _require2.parsed, pipeline = _require2.pipeline;
    var Task = require("./task");
    function load(task, done) {
      var firstTask = false;
      if (!task.progress) {
        task.progress = {
          finish: 0,
          total: task.input.length,
          canInvoke: true
        };
        firstTask = true;
      }
      var options = task.options, progress = task.progress;
      options.__exclude__ = options.__exclude__ || Object.create(null);
      task.output = [];
      forEach(task.input, (function(item, cb) {
        var subTask = Task.create({
          input: item,
          onProgress: task.onProgress,
          options: options,
          progress: progress,
          onComplete: function onComplete(err, item) {
            if (err && !task.isFinish) if (!cc.assetManager.force || firstTask) {
              true;
              cc.error(err.message, err.stack);
              progress.canInvoke = false;
              done(err);
            } else progress.canInvoke && task.dispatch("progress", ++progress.finish, progress.total, item);
            task.output.push(item);
            subTask.recycle();
            cb();
          }
        });
        loadOneAssetPipeline.async(subTask);
      }), (function() {
        options.__exclude__ = null;
        if (task.isFinish) {
          clear(task, true);
          return task.dispatch("error");
        }
        gatherAsset(task);
        clear(task, true);
        done();
      }));
    }
    var loadOneAssetPipeline = new Pipeline("loadOneAsset", [ function fetch(task, done) {
      var item = task.output = task.input;
      var options = item.options, isNative = item.isNative, uuid = item.uuid, file = item.file;
      var reload = options.reload;
      if (file || !reload && !isNative && assets.has(uuid)) return done();
      packManager.load(item, task.options, (function(err, data) {
        item.file = data;
        done(err);
      }));
    }, function parse(task, done) {
      var item = task.output = task.input, progress = task.progress, exclude = task.options.__exclude__;
      var id = item.id, file = item.file, options = item.options;
      if (item.isNative) parser.parse(id, file, item.ext, options, (function(err, asset) {
        if (err) return done(err);
        item.content = asset;
        progress.canInvoke && task.dispatch("progress", ++progress.finish, progress.total, item);
        files.remove(id);
        parsed.remove(id);
        done();
      })); else {
        var uuid = item.uuid;
        if (uuid in exclude) {
          var _exclude$uuid = exclude[uuid], finish = _exclude$uuid.finish, content = _exclude$uuid.content, err = _exclude$uuid.err, callbacks = _exclude$uuid.callbacks;
          progress.canInvoke && task.dispatch("progress", ++progress.finish, progress.total, item);
          if (finish || checkCircleReference(uuid, uuid, exclude)) {
            content && content.addRef && content.addRef();
            item.content = content;
            done(err);
          } else callbacks.push({
            done: done,
            item: item
          });
        } else if (!options.reload && assets.has(uuid)) {
          var asset = assets.get(uuid);
          if (options.__asyncLoadAssets__ || !asset.__asyncLoadAssets__) {
            item.content = asset.addRef();
            progress.canInvoke && task.dispatch("progress", ++progress.finish, progress.total, item);
            done();
          } else loadDepends(task, asset, done, false);
        } else parser.parse(id, file, "import", options, (function(err, asset) {
          if (err) return done(err);
          asset._uuid = uuid;
          loadDepends(task, asset, done, true);
        }));
      }
    } ]);
    function loadDepends(task, asset, done, init) {
      var item = task.input, progress = task.progress;
      var uuid = item.uuid, id = item.id, options = item.options, config = item.config;
      var __asyncLoadAssets__ = options.__asyncLoadAssets__, cacheAsset = options.cacheAsset;
      var depends = [];
      asset.addRef && asset.addRef();
      getDepends(uuid, asset, Object.create(null), depends, false, __asyncLoadAssets__, config);
      progress.canInvoke && task.dispatch("progress", ++progress.finish, progress.total += depends.length, item);
      var repeatItem = task.options.__exclude__[uuid] = {
        content: asset,
        finish: false,
        callbacks: [ {
          done: done,
          item: item
        } ]
      };
      var subTask = Task.create({
        input: depends,
        options: task.options,
        onProgress: task.onProgress,
        onError: Task.prototype.recycle,
        progress: progress,
        onComplete: function onComplete(err) {
          asset.decRef && asset.decRef(false);
          asset.__asyncLoadAssets__ = __asyncLoadAssets__;
          repeatItem.finish = true;
          repeatItem.err = err;
          if (!err) {
            var assets = Array.isArray(subTask.output) ? subTask.output : [ subTask.output ];
            var map = Object.create(null);
            for (var _i = 0, _l = assets.length; _i < _l; _i++) {
              var dependAsset = assets[_i];
              dependAsset && (map[dependAsset instanceof cc.Asset ? dependAsset._uuid + "@import" : uuid + "@native"] = dependAsset);
            }
            if (init) {
              var missingAsset = setProperties(uuid, asset, map);
              if (!missingAsset && !asset.__onLoadInvoked__) try {
                asset.onLoad && asset.onLoad();
                asset.__onLoadInvoked__ = true;
              } catch (e) {
                cc.error(e.message, e.stack);
              }
              files.remove(id);
              parsed.remove(id);
              cache(uuid, asset, void 0 !== cacheAsset ? cacheAsset : cc.assetManager.cacheAsset);
            } else if (asset.__nativeDepend__ && !asset._nativeAsset) {
              var missingAsset = setProperties(uuid, asset, map);
              if (!missingAsset && !asset.__onLoadInvoked__) try {
                asset.onLoad && asset.onLoad();
                asset.__onLoadInvoked__ = true;
              } catch (e) {
                cc.error(e.message, e.stack);
              }
            }
            subTask.recycle();
          }
          var callbacks = repeatItem.callbacks;
          for (var i = 0, l = callbacks.length; i < l; i++) {
            var cb = callbacks[i];
            asset.addRef && asset.addRef();
            cb.item.content = asset;
            cb.done(err);
          }
          callbacks.length = 0;
        }
      });
      pipeline.async(subTask);
    }
    module.exports = load;
  }), {
    "./pack-manager": 127,
    "./parser": 128,
    "./pipeline": 129,
    "./shared": 133,
    "./task": 134,
    "./utilities": 136
  } ],
  127: [ (function(require, module, exports) {
    "use strict";
    var _deserializeCompiled = require("../platform/deserialize-compiled");
    var downloader = require("./downloader");
    var Cache = require("./cache");
    var js = require("../platform/js");
    var _require = require("./shared"), files = _require.files;
    var _loading = new Cache();
    function isLoading(val) {
      return _loading.has(val.uuid);
    }
    var packManager = {
      unpackJson: function unpackJson(pack, json, options, onComplete) {
        var out = js.createMap(true), err = null;
        if (Array.isArray(json)) {
          json = (0, _deserializeCompiled.unpackJSONs)(json);
          json.length !== pack.length && cc.errorID(4915);
          for (var i = 0; i < pack.length; i++) {
            var key = pack[i] + "@import";
            out[key] = json[i];
          }
        } else {
          var textureType = js._getClassId(cc.Texture2D);
          if (json.type === textureType) {
            if (json.data) {
              var datas = json.data.split("|");
              datas.length !== pack.length && cc.errorID(4915);
              for (var _i = 0; _i < pack.length; _i++) out[pack[_i] + "@import"] = (0, _deserializeCompiled.packCustomObjData)(textureType, datas[_i], true);
            }
          } else {
            err = new Error("unmatched type pack!");
            out = null;
          }
        }
        onComplete && onComplete(err, out);
      },
      init: function init() {
        _loading.clear();
      },
      register: function register(type, handler) {
        "object" === typeof type ? js.mixin(unpackers, type) : unpackers[type] = handler;
      },
      unpack: function unpack(pack, data, type, options, onComplete) {
        if (!data) {
          onComplete && onComplete(new Error("package data is wrong!"));
          return;
        }
        var unpacker = unpackers[type];
        unpacker(pack, data, options, onComplete);
      },
      load: function load(item, options, onComplete) {
        if (item.isNative || !item.info || !item.info.packs) return downloader.download(item.id, item.url, item.ext, item.options, onComplete);
        if (files.has(item.id)) return onComplete(null, files.get(item.id));
        var packs = item.info.packs;
        var pack = packs.find(isLoading);
        if (pack) return _loading.get(pack.uuid).push({
          onComplete: onComplete,
          id: item.id
        });
        pack = packs[0];
        _loading.add(pack.uuid, [ {
          onComplete: onComplete,
          id: item.id
        } ]);
        var url = cc.assetManager._transform(pack.uuid, {
          ext: pack.ext,
          bundle: item.config.name
        });
        downloader.download(pack.uuid, url, pack.ext, item.options, (function(err, data) {
          files.remove(pack.uuid);
          err && cc.error(err.message, err.stack);
          packManager.unpack(pack.packs, data, pack.ext, item.options, (function(err, result) {
            if (err) err.message = "unpack " + url + " failed! details: " + err.message; else for (var id in result) files.add(id, result[id]);
            var callbacks = _loading.remove(pack.uuid);
            for (var i = 0, l = callbacks.length; i < l; i++) {
              var cb = callbacks[i];
              if (err) {
                cb.onComplete(err);
                continue;
              }
              var data = result[cb.id];
              data ? cb.onComplete(null, data) : cb.onComplete(new Error("can not retrieve data from package"));
            }
          }));
        }));
      }
    };
    var unpackers = {
      ".json": packManager.unpackJson
    };
    module.exports = packManager;
  }), {
    "../platform/deserialize-compiled": 287,
    "../platform/js": 294,
    "./cache": 111,
    "./downloader": 120,
    "./shared": 133
  } ],
  128: [ (function(require, module, exports) {
    "use strict";
    var plistParser = require("../platform/CCSAXParser").plistParser;
    var js = require("../platform/js");
    var deserialize = require("./deserialize");
    var Cache = require("./cache");
    var _require = require("./helper"), isScene = _require.isScene;
    var _require2 = require("./shared"), parsed = _require2.parsed, files = _require2.files;
    var _require3 = require("../platform/CCSys"), __audioSupport = _require3.__audioSupport, capabilities = _require3.capabilities;
    var _parsing = new Cache();
    var parser = {
      parseImage: function parseImage(file, options, onComplete) {
        if (capabilities.imageBitmap && file instanceof Blob) {
          var imageOptions = {};
          imageOptions.imageOrientation = options.__flipY__ ? "flipY" : "none";
          imageOptions.premultiplyAlpha = options.__premultiplyAlpha__ ? "premultiply" : "none";
          createImageBitmap(file, imageOptions).then((function(result) {
            result.flipY = !!options.__flipY__;
            result.premultiplyAlpha = !!options.__premultiplyAlpha__;
            onComplete && onComplete(null, result);
          }), (function(err) {
            onComplete && onComplete(err, null);
          }));
        } else onComplete && onComplete(null, file);
      },
      parseAudio: function parseAudio(file, options, onComplete) {
        file instanceof ArrayBuffer ? __audioSupport.context.decodeAudioData(file, (function(buffer) {
          onComplete && onComplete(null, buffer);
        }), (function(e) {
          onComplete && onComplete(e, null);
        })) : onComplete && onComplete(null, file);
      },
      parsePVRTex: (function() {
        var PVR_HEADER_LENGTH = 13;
        var PVR_MAGIC = 55727696;
        var PVR_HEADER_MAGIC = 0;
        var PVR_HEADER_FORMAT = 2;
        var PVR_HEADER_HEIGHT = 6;
        var PVR_HEADER_WIDTH = 7;
        var PVR_HEADER_MIPMAPCOUNT = 11;
        var PVR_HEADER_METADATA = 12;
        return function(file, options, onComplete) {
          var err = null, out = null;
          try {
            var buffer = file instanceof ArrayBuffer ? file : file.buffer;
            var header = new Int32Array(buffer, 0, PVR_HEADER_LENGTH);
            if (header[PVR_HEADER_MAGIC] != PVR_MAGIC) throw new Error("Invalid magic number in PVR header");
            var width = header[PVR_HEADER_WIDTH];
            var height = header[PVR_HEADER_HEIGHT];
            var dataOffset = header[PVR_HEADER_METADATA] + 52;
            var pvrtcData = new Uint8Array(buffer, dataOffset);
            out = {
              _data: pvrtcData,
              _compressed: true,
              width: width,
              height: height
            };
          } catch (e) {
            err = e;
          }
          onComplete && onComplete(err, out);
        };
      })(),
      parsePKMTex: (function() {
        var ETC_PKM_HEADER_SIZE = 16;
        var ETC_PKM_FORMAT_OFFSET = 6;
        var ETC_PKM_ENCODED_WIDTH_OFFSET = 8;
        var ETC_PKM_ENCODED_HEIGHT_OFFSET = 10;
        var ETC_PKM_WIDTH_OFFSET = 12;
        var ETC_PKM_HEIGHT_OFFSET = 14;
        var ETC1_RGB_NO_MIPMAPS = 0;
        var ETC2_RGB_NO_MIPMAPS = 1;
        var ETC2_RGBA_NO_MIPMAPS = 3;
        function readBEUint16(header, offset) {
          return header[offset] << 8 | header[offset + 1];
        }
        return function(file, options, onComplete) {
          var err = null, out = null;
          try {
            var buffer = file instanceof ArrayBuffer ? file : file.buffer;
            var header = new Uint8Array(buffer);
            var format = readBEUint16(header, ETC_PKM_FORMAT_OFFSET);
            if (format !== ETC1_RGB_NO_MIPMAPS && format !== ETC2_RGB_NO_MIPMAPS && format !== ETC2_RGBA_NO_MIPMAPS) return new Error("Invalid magic number in ETC header");
            var width = readBEUint16(header, ETC_PKM_WIDTH_OFFSET);
            var height = readBEUint16(header, ETC_PKM_HEIGHT_OFFSET);
            var encodedWidth = readBEUint16(header, ETC_PKM_ENCODED_WIDTH_OFFSET);
            var encodedHeight = readBEUint16(header, ETC_PKM_ENCODED_HEIGHT_OFFSET);
            var etcData = new Uint8Array(buffer, ETC_PKM_HEADER_SIZE);
            out = {
              _data: etcData,
              _compressed: true,
              width: width,
              height: height
            };
          } catch (e) {
            err = e;
          }
          onComplete && onComplete(err, out);
        };
      })(),
      parsePlist: function parsePlist(file, options, onComplete) {
        var err = null;
        var result = plistParser.parse(file);
        result || (err = new Error("parse failed"));
        onComplete && onComplete(err, result);
      },
      parseImport: function parseImport(file, options, onComplete) {
        if (!file) return onComplete && onComplete(new Error("Json is empty"));
        var result, err = null;
        try {
          result = deserialize(file, options);
        } catch (e) {
          err = e;
        }
        onComplete && onComplete(err, result);
      },
      init: function init() {
        _parsing.clear();
      },
      register: function register(type, handler) {
        "object" === typeof type ? js.mixin(parsers, type) : parsers[type] = handler;
      },
      parse: function parse(id, file, type, options, onComplete) {
        var parsedAsset, parsing, parseHandler;
        if (parsedAsset = parsed.get(id)) onComplete(null, parsedAsset); else if (parsing = _parsing.get(id)) parsing.push(onComplete); else if (parseHandler = parsers[type]) {
          _parsing.add(id, [ onComplete ]);
          parseHandler(file, options, (function(err, data) {
            err ? files.remove(id) : isScene(data) || parsed.add(id, data);
            var callbacks = _parsing.remove(id);
            for (var i = 0, l = callbacks.length; i < l; i++) callbacks[i](err, data);
          }));
        } else onComplete(null, file);
      }
    };
    var parsers = {
      ".png": parser.parseImage,
      ".jpg": parser.parseImage,
      ".bmp": parser.parseImage,
      ".jpeg": parser.parseImage,
      ".gif": parser.parseImage,
      ".ico": parser.parseImage,
      ".tiff": parser.parseImage,
      ".webp": parser.parseImage,
      ".image": parser.parseImage,
      ".pvr": parser.parsePVRTex,
      ".pkm": parser.parsePKMTex,
      ".mp3": parser.parseAudio,
      ".ogg": parser.parseAudio,
      ".wav": parser.parseAudio,
      ".m4a": parser.parseAudio,
      ".plist": parser.parsePlist,
      import: parser.parseImport
    };
    module.exports = parser;
  }), {
    "../platform/CCSAXParser": 279,
    "../platform/CCSys": 281,
    "../platform/js": 294,
    "./cache": 111,
    "./deserialize": 115,
    "./helper": 124,
    "./shared": 133
  } ],
  129: [ (function(require, module, exports) {
    "use strict";
    var Task = require("./task");
    var _pipelineId = 0;
    function Pipeline(name, funcs) {
      if (!Array.isArray(funcs)) {
        cc.warn("funcs must be an array");
        return;
      }
      this.id = _pipelineId++;
      this.name = name;
      this.pipes = [];
      for (var i = 0, l = funcs.length; i < l; i++) "function" === typeof funcs[i] && this.pipes.push(funcs[i]);
    }
    Pipeline.prototype = {
      constructor: Pipeline,
      insert: function insert(func, index) {
        if ("function" !== typeof func || index > this.pipes.length) {
          cc.warnID(4921);
          return;
        }
        this.pipes.splice(index, 0, func);
        return this;
      },
      append: function append(func) {
        if ("function" !== typeof func) return;
        this.pipes.push(func);
        return this;
      },
      remove: function remove(index) {
        if ("number" !== typeof index) return;
        this.pipes.splice(index, 1);
        return this;
      },
      sync: function sync(task) {
        var pipes = this.pipes;
        if (!(task instanceof Task) || 0 === pipes.length) return;
        if (null != task.output) {
          task.input = task.output;
          task.output = null;
        }
        task._isFinish = false;
        for (var i = 0, l = pipes.length; i < l; ) {
          var pipe = pipes[i];
          var result = pipe(task);
          if (result) {
            task._isFinish = true;
            return result;
          }
          i++;
          if (i !== l) {
            task.input = task.output;
            task.output = null;
          }
        }
        task._isFinish = true;
        return task.output;
      },
      async: function async(task) {
        var pipes = this.pipes;
        if (!(task instanceof Task) || 0 === pipes.length) return;
        if (null != task.output) {
          task.input = task.output;
          task.output = null;
        }
        task._isFinish = false;
        this._flow(0, task);
      },
      _flow: function _flow(index, task) {
        var self = this;
        var pipe = this.pipes[index];
        pipe(task, (function(result) {
          if (result) {
            task._isFinish = true;
            task.onComplete && task.onComplete(result);
          } else {
            index++;
            if (index < self.pipes.length) {
              task.input = task.output;
              task.output = null;
              self._flow(index, task);
            } else {
              task._isFinish = true;
              task.onComplete && task.onComplete(result, task.output);
            }
          }
        }));
      }
    };
    module.exports = Pipeline;
  }), {
    "./task": 134
  } ],
  130: [ (function(require, module, exports) {
    "use strict";
    var Task = require("./task");
    var _require = require("./shared"), transformPipeline = _require.transformPipeline, RequestType = _require.RequestType;
    function preprocess(task, done) {
      var options = task.options, subOptions = Object.create(null), leftOptions = Object.create(null);
      for (var op in options) switch (op) {
       case RequestType.PATH:
       case RequestType.UUID:
       case RequestType.DIR:
       case RequestType.SCENE:
       case RequestType.URL:
        break;

       case "__requestType__":
       case "__isNative__":
       case "ext":
       case "type":
       case "__nativeName__":
       case "audioLoadMode":
       case "bundle":
        subOptions[op] = options[op];
        break;

       case "__exclude__":
       case "__outputAsArray__":
        leftOptions[op] = options[op];
        break;

       default:
        subOptions[op] = options[op];
        leftOptions[op] = options[op];
      }
      task.options = leftOptions;
      var subTask = Task.create({
        input: task.input,
        options: subOptions
      });
      var err = null;
      try {
        task.output = task.source = transformPipeline.sync(subTask);
      } catch (e) {
        err = e;
        for (var i = 0, l = subTask.output.length; i < l; i++) subTask.output[i].recycle();
      }
      subTask.recycle();
      done(err);
    }
    module.exports = preprocess;
  }), {
    "./shared": 133,
    "./task": 134
  } ],
  131: [ (function(require, module, exports) {
    "use strict";
    var dependUtil = require("./depend-util");
    var Cache = require("./cache");
    require("../assets/CCAsset");
    var _require = require("./shared"), assets = _require.assets;
    var _require2 = require("../platform/utils"), callInNextTick = _require2.callInNextTick;
    function visitAsset(asset, deps) {
      if (!asset._uuid) return;
      deps.push(asset._uuid);
    }
    function visitComponent(comp, deps) {
      var props = Object.getOwnPropertyNames(comp);
      for (var i = 0; i < props.length; i++) {
        var propName = props[i];
        if ("node" === propName || "__eventTargets" === propName) continue;
        var value = comp[propName];
        if ("object" === typeof value && value) if (Array.isArray(value)) for (var j = 0; j < value.length; j++) {
          var val = value[j];
          val instanceof cc.Asset && visitAsset(val, deps);
        } else if (value.constructor && value.constructor !== Object) value instanceof cc.Asset && visitAsset(value, deps); else {
          var keys = Object.getOwnPropertyNames(value);
          for (var _j = 0; _j < keys.length; _j++) {
            var _val = value[keys[_j]];
            _val instanceof cc.Asset && visitAsset(_val, deps);
          }
        }
      }
    }
    var _temp = [];
    function visitNode(node, deps) {
      for (var i = 0; i < node._components.length; i++) visitComponent(node._components[i], deps);
      for (var _i = 0; _i < node._children.length; _i++) visitNode(node._children[_i], deps);
    }
    function descendOpRef(asset, refs, exclude, op) {
      exclude.push(asset._uuid);
      var depends = dependUtil.getDeps(asset._uuid);
      for (var i = 0, l = depends.length; i < l; i++) {
        var dependAsset = assets.get(depends[i]);
        if (dependAsset) {
          var uuid = dependAsset._uuid;
          uuid in refs ? refs[uuid] += op : refs[uuid] = dependAsset.refCount + op;
          if (exclude.includes(uuid)) continue;
          descendOpRef(dependAsset, refs, exclude, op);
        }
      }
    }
    function checkCircularReference(asset) {
      var refs = Object.create(null);
      refs[asset._uuid] = asset.refCount;
      descendOpRef(asset, refs, _temp, -1);
      _temp.length = 0;
      if (0 !== refs[asset._uuid]) return refs[asset._uuid];
      for (var uuid in refs) 0 !== refs[uuid] && descendOpRef(assets.get(uuid), refs, _temp, 1);
      _temp.length = 0;
      return refs[asset._uuid];
    }
    var _persistNodeDeps = new Cache();
    var _toDelete = new Cache();
    var eventListener = false;
    function freeAssets() {
      eventListener = false;
      _toDelete.forEach((function(asset) {
        releaseManager._free(asset);
      }));
      _toDelete.clear();
    }
    var releaseManager = {
      init: function init() {
        _persistNodeDeps.clear();
        _toDelete.clear();
      },
      _addPersistNodeRef: function _addPersistNodeRef(node) {
        var deps = [];
        visitNode(node, deps);
        for (var i = 0, l = deps.length; i < l; i++) {
          var dependAsset = assets.get(deps[i]);
          dependAsset && dependAsset.addRef();
        }
        _persistNodeDeps.add(node.uuid, deps);
      },
      _removePersistNodeRef: function _removePersistNodeRef(node) {
        if (_persistNodeDeps.has(node.uuid)) {
          var deps = _persistNodeDeps.get(node.uuid);
          for (var i = 0, l = deps.length; i < l; i++) {
            var dependAsset = assets.get(deps[i]);
            dependAsset && dependAsset.decRef();
          }
          _persistNodeDeps.remove(node.uuid);
        }
      },
      _autoRelease: function _autoRelease(oldScene, newScene, persistNodes) {
        if (oldScene) {
          var childs = dependUtil.getDeps(oldScene._id);
          for (var i = 0, l = childs.length; i < l; i++) {
            var asset = assets.get(childs[i]);
            asset && asset.decRef((false, oldScene.autoReleaseAssets));
          }
          var dependencies = dependUtil._depends.get(oldScene._id);
          if (dependencies && dependencies.persistDeps) {
            var persistDeps = dependencies.persistDeps;
            for (var _i2 = 0, _l = persistDeps.length; _i2 < _l; _i2++) {
              var _asset = assets.get(persistDeps[_i2]);
              _asset && _asset.decRef((false, oldScene.autoReleaseAssets));
            }
          }
          oldScene._id !== newScene._id && dependUtil.remove(oldScene._id);
        }
        var sceneDeps = dependUtil._depends.get(newScene._id);
        sceneDeps && (sceneDeps.persistDeps = []);
        for (var key in persistNodes) {
          var node = persistNodes[key];
          var deps = _persistNodeDeps.get(node.uuid);
          for (var _i3 = 0, _l2 = deps.length; _i3 < _l2; _i3++) {
            var dependAsset = assets.get(deps[_i3]);
            dependAsset && dependAsset.addRef();
          }
          sceneDeps && sceneDeps.persistDeps.push.apply(sceneDeps.persistDeps, deps);
        }
      },
      _free: function _free(asset, force) {
        _toDelete.remove(asset._uuid);
        if (!cc.isValid(asset, true)) return;
        if (!force && asset.refCount > 0 && checkCircularReference(asset) > 0) return;
        assets.remove(asset._uuid);
        var depends = dependUtil.getDeps(asset._uuid);
        for (var i = 0, l = depends.length; i < l; i++) {
          var dependAsset = assets.get(depends[i]);
          if (dependAsset) {
            dependAsset.decRef(false);
            releaseManager._free(dependAsset, false);
          }
        }
        asset.destroy();
        dependUtil.remove(asset._uuid);
      },
      tryRelease: function tryRelease(asset, force) {
        if (!(asset instanceof cc.Asset)) return;
        if (force) releaseManager._free(asset, force); else {
          _toDelete.add(asset._uuid, asset);
          if (!eventListener) {
            eventListener = true;
            callInNextTick(freeAssets);
          }
        }
      }
    };
    module.exports = releaseManager;
  }), {
    "../assets/CCAsset": 137,
    "../platform/utils": 297,
    "./cache": 111,
    "./depend-util": 113,
    "./shared": 133
  } ],
  132: [ (function(require, module, exports) {
    "use strict";
    var MAX_DEAD_NUM = 500;
    var _deadPool = [];
    function RequestItem() {
      this._id = "";
      this.uuid = "";
      this.url = "";
      this.ext = ".json";
      this.content = null;
      this.file = null;
      this.info = null;
      this.config = null;
      this.isNative = false;
      this.options = Object.create(null);
    }
    RequestItem.prototype = {
      constructor: RequestItem,
      get id() {
        this._id || (this._id = this.uuid + "@" + (this.isNative ? "native" : "import"));
        return this._id;
      },
      recycle: function recycle() {
        if (_deadPool.length === MAX_DEAD_NUM) return;
        this._id = "";
        this.uuid = "";
        this.url = "";
        this.ext = ".json";
        this.content = null;
        this.file = null;
        this.info = null;
        this.config = null;
        this.isNative = false;
        this.options = Object.create(null);
        _deadPool.push(this);
      }
    };
    RequestItem.create = function() {
      var out = null;
      out = 0 !== _deadPool.length ? _deadPool.pop() : new RequestItem();
      return out;
    };
    module.exports = RequestItem;
  }), {} ],
  133: [ (function(require, module, exports) {
    "use strict";
    var Cache = require("./cache");
    var Pipeline = require("./pipeline");
    var assets = new Cache();
    var files = new Cache();
    var parsed = new Cache();
    var bundles = new Cache();
    var pipeline = new Pipeline("normal load", []);
    var fetchPipeline = new Pipeline("fetch", []);
    var transformPipeline = new Pipeline("transform url", []);
    var RequestType = {
      UUID: "uuid",
      PATH: "path",
      DIR: "dir",
      URL: "url",
      SCENE: "scene"
    };
    var BuiltinBundleName = {
      RESOURCES: "resources",
      INTERNAL: "internal",
      MAIN: "main",
      START_SCENE: "start-scene"
    };
    module.exports = {
      assets: assets,
      files: files,
      parsed: parsed,
      pipeline: pipeline,
      fetchPipeline: fetchPipeline,
      transformPipeline: transformPipeline,
      RequestType: RequestType,
      bundles: bundles,
      BuiltinBundleName: BuiltinBundleName
    };
  }), {
    "./cache": 111,
    "./pipeline": 129
  } ],
  134: [ (function(require, module, exports) {
    "use strict";
    var _taskId = 0;
    var MAX_DEAD_NUM = 500;
    var _deadPool = [];
    function Task(options) {
      this.id = _taskId++;
      this._isFinish = true;
      this.onComplete = null;
      this.onProgress = null;
      this.onError = null;
      this.source = null;
      this.output = null;
      this.input = null;
      this.progress = null;
      this.options = null;
      this.set(options);
    }
    Task.prototype = {
      constructor: Task,
      set: function set(options) {
        options = options || Object.create(null);
        this.onComplete = options.onComplete;
        this.onProgress = options.onProgress;
        this.onError = options.onError;
        this.source = this.input = options.input;
        this.output = null;
        this.progress = options.progress;
        this.options = options.options || Object.create(null);
      },
      dispatch: function dispatch(event, param1, param2, param3, param4) {
        switch (event) {
         case "complete":
          this.onComplete && this.onComplete(param1, param2, param3, param4);
          break;

         case "progress":
          this.onProgress && this.onProgress(param1, param2, param3, param4);
          break;

         case "error":
          this.onError && this.onError(param1, param2, param3, param4);
          break;

         default:
          var str = "on" + event[0].toUpperCase() + event.substr(1);
          "function" === typeof this[str] && this[str](param1, param2, param3, param4);
        }
      },
      recycle: function recycle() {
        if (_deadPool.length === MAX_DEAD_NUM) return;
        this.onComplete = null;
        this.onProgress = null;
        this.onError = null;
        this.source = this.output = this.input = null;
        this.progress = null;
        this.options = null;
        _deadPool.push(this);
      },
      get isFinish() {
        return this._isFinish;
      }
    };
    Task.create = function(options) {
      var out = null;
      if (0 !== _deadPool.length) {
        out = _deadPool.pop();
        out.set(options);
      } else out = new Task(options);
      return out;
    };
    module.exports = Task;
  }), {} ],
  135: [ (function(require, module, exports) {
    "use strict";
    var _require = require("./helper"), decodeUuid = _require.decodeUuid;
    var RequestItem = require("./request-item");
    var _require2 = require("./shared"), RequestType = _require2.RequestType, bundles = _require2.bundles;
    function parse(task) {
      var input = task.input, options = task.options;
      input = Array.isArray(input) ? input : [ input ];
      task.output = [];
      for (var i = 0; i < input.length; i++) {
        var item = input[i];
        var out = RequestItem.create();
        if ("string" === typeof item) {
          item = Object.create(null);
          item[options.__requestType__ || RequestType.UUID] = input[i];
        }
        if ("object" === typeof item) {
          cc.js.addon(item, options);
          item.preset && cc.js.addon(item, cc.assetManager.presets[item.preset]);
          for (var key in item) {
            switch (key) {
             case RequestType.UUID:
              var uuid = out.uuid = decodeUuid(item.uuid);
              if (bundles.has(item.bundle)) {
                var config = bundles.get(item.bundle)._config;
                var info = config.getAssetInfo(uuid);
                if (info && info.redirect) {
                  if (!bundles.has(info.redirect)) throw new Error("Please load bundle " + info.redirect + " first");
                  config = bundles.get(info.redirect)._config;
                  info = config.getAssetInfo(uuid);
                }
                out.config = config;
                out.info = info;
              }
              out.ext = item.ext || ".json";
              break;

             case "__requestType__":
             case "ext":
             case "bundle":
             case "preset":
             case "type":
              break;

             case RequestType.DIR:
              if (bundles.has(item.bundle)) {
                var infos = [];
                bundles.get(item.bundle)._config.getDirWithPath(item.dir, item.type, infos);
                for (var _i = 0, l = infos.length; _i < l; _i++) {
                  var info = infos[_i];
                  input.push({
                    uuid: info.uuid,
                    __isNative__: false,
                    ext: ".json",
                    bundle: item.bundle
                  });
                }
              }
              out.recycle();
              out = null;
              break;

             case RequestType.PATH:
              if (bundles.has(item.bundle)) {
                var config = bundles.get(item.bundle)._config;
                var info = config.getInfoWithPath(item.path, item.type);
                if (info && info.redirect) {
                  if (!bundles.has(info.redirect)) throw new Error("you need to load bundle " + info.redirect + " first");
                  config = bundles.get(info.redirect)._config;
                  info = config.getAssetInfo(info.uuid);
                }
                if (!info) {
                  out.recycle();
                  throw new Error("Bundle " + item.bundle + " doesn't contain " + item.path);
                }
                out.config = config;
                out.uuid = info.uuid;
                out.info = info;
              }
              out.ext = item.ext || ".json";
              break;

             case RequestType.SCENE:
              if (bundles.has(item.bundle)) {
                var config = bundles.get(item.bundle)._config;
                var info = config.getSceneInfo(item.scene);
                if (info && info.redirect) {
                  if (!bundles.has(info.redirect)) throw new Error("you need to load bundle " + info.redirect + " first");
                  config = bundles.get(info.redirect)._config;
                  info = config.getAssetInfo(info.uuid);
                }
                if (!info) {
                  out.recycle();
                  throw new Error("Bundle " + config.name + " doesn't contain scene " + item.scene);
                }
                out.config = config;
                out.uuid = info.uuid;
                out.info = info;
              }
              break;

             case "__isNative__":
              out.isNative = item.__isNative__;
              break;

             case RequestType.URL:
              out.url = item.url;
              out.uuid = item.uuid || item.url;
              out.ext = item.ext || cc.path.extname(item.url);
              out.isNative = void 0 === item.__isNative__ || item.__isNative__;
              break;

             default:
              out.options[key] = item[key];
            }
            if (!out) break;
          }
        }
        if (!out) continue;
        task.output.push(out);
        if (!out.uuid && !out.url) throw new Error("Can not parse this input:" + JSON.stringify(item));
      }
      return null;
    }
    function combine(task) {
      var input = task.output = task.input;
      for (var i = 0; i < input.length; i++) {
        var item = input[i];
        if (item.url) continue;
        var url = "", base = "";
        var config = item.config;
        base = item.isNative ? config && config.nativeBase ? config.base + config.nativeBase : cc.assetManager.generalNativeBase : config && config.importBase ? config.base + config.importBase : cc.assetManager.generalImportBase;
        var uuid = item.uuid;
        var ver = "";
        item.info && (ver = item.isNative ? item.info.nativeVer ? "." + item.info.nativeVer : "" : item.info.ver ? "." + item.info.ver : "");
        url = ".ttf" === item.ext ? base + "/" + uuid.slice(0, 2) + "/" + uuid + ver + "/" + item.options.__nativeName__ : base + "/" + uuid.slice(0, 2) + "/" + uuid + ver + item.ext;
        item.url = url;
      }
      return null;
    }
    module.exports = {
      parse: parse,
      combine: combine
    };
  }), {
    "./helper": 124,
    "./request-item": 132,
    "./shared": 133
  } ],
  136: [ (function(require, module, exports) {
    "use strict";
    var dependUtil = require("./depend-util");
    var _require = require("./helper"), isScene = _require.isScene, decodeUuid = _require.decodeUuid;
    var _require2 = require("./shared"), assets = _require2.assets;
    var _require3 = require("../platform/utils"), callInNextTick = _require3.callInNextTick;
    var MissingObjectReporter = false;
    require("../assets/CCAsset");
    var utils = {
      processOptions: function processOptions(options) {
        false;
        var uuids = options.uuids;
        var paths = options.paths;
        var types = options.types;
        var bundles = options.deps;
        var realEntries = options.paths = Object.create(null);
        if (false === options.debug) {
          for (var i = 0, l = uuids.length; i < l; i++) uuids[i] = decodeUuid(uuids[i]);
          for (var id in paths) {
            var entry = paths[id];
            var type = entry[1];
            entry[1] = types[type];
          }
        } else {
          var out = Object.create(null);
          for (var _i = 0, _l = uuids.length; _i < _l; _i++) {
            var uuid = uuids[_i];
            uuids[_i] = out[uuid] = decodeUuid(uuid);
          }
          uuids = out;
        }
        for (var _id in paths) {
          var _entry = paths[_id];
          realEntries[uuids[_id]] = _entry;
        }
        var scenes = options.scenes;
        for (var name in scenes) {
          var _uuid = scenes[name];
          scenes[name] = uuids[_uuid];
        }
        var packs = options.packs;
        for (var packId in packs) {
          var packedIds = packs[packId];
          for (var j = 0; j < packedIds.length; ++j) packedIds[j] = uuids[packedIds[j]];
        }
        var versions = options.versions;
        if (versions) for (var folder in versions) {
          var entries = versions[folder];
          for (var _i2 = 0; _i2 < entries.length; _i2 += 2) {
            var _uuid2 = entries[_i2];
            entries[_i2] = uuids[_uuid2] || _uuid2;
          }
        }
        var redirect = options.redirect;
        if (redirect) for (var _i3 = 0; _i3 < redirect.length; _i3 += 2) {
          redirect[_i3] = uuids[redirect[_i3]];
          redirect[_i3 + 1] = bundles[redirect[_i3 + 1]];
        }
      },
      clear: function clear(task, clearRef) {
        for (var i = 0, l = task.input.length; i < l; i++) {
          var item = task.input[i];
          clearRef && !item.isNative && item.content && item.content.decRef && item.content.decRef(false);
          item.recycle();
        }
        task.input = null;
      },
      urlAppendTimestamp: function urlAppendTimestamp(url) {
        if (cc.assetManager.downloader.appendTimeStamp && "string" === typeof url) return /\?/.test(url) ? url + "&_t=" + (new Date() - 0) : url + "?_t=" + (new Date() - 0);
        return url;
      },
      retry: function retry(process, times, wait, onComplete, index) {
        index = index || 0;
        process(index, (function(err, result) {
          index++;
          !err || index > times ? onComplete && onComplete(err, result) : setTimeout((function() {
            utils.retry(process, times, wait, onComplete, index);
          }), wait);
        }));
      },
      getDepends: function getDepends(uuid, data, exclude, depends, preload, asyncLoadAssets, config) {
        try {
          var info = dependUtil.parse(uuid, data);
          var includeNative = true;
          data instanceof cc.Asset && (!data.__nativeDepend__ || data._nativeAsset) && (includeNative = false);
          if (preload) {
            for (var _i4 = 0, _l2 = info.deps.length; _i4 < _l2; _i4++) {
              var _dep = info.deps[_i4];
              if (!(_dep in exclude)) {
                exclude[_dep] = true;
                depends.push({
                  uuid: _dep,
                  bundle: config && config.name
                });
              }
            }
            if (includeNative && info.nativeDep) {
              config && (info.nativeDep.bundle = config.name);
              depends.push(Object.assign({}, info.nativeDep));
            }
          } else {
            asyncLoadAssets = (true, !!data.asyncLoadAssets || asyncLoadAssets && !info.preventDeferredLoadDependents);
            for (var i = 0, l = info.deps.length; i < l; i++) {
              var dep = info.deps[i];
              if (!(dep in exclude)) {
                exclude[dep] = true;
                depends.push({
                  uuid: dep,
                  __asyncLoadAssets__: asyncLoadAssets,
                  bundle: config && config.name
                });
              }
            }
            if (includeNative && !asyncLoadAssets && !info.preventPreloadNativeObject && info.nativeDep) {
              config && (info.nativeDep.bundle = config.name);
              depends.push(Object.assign({}, info.nativeDep));
            }
          }
        } catch (e) {
          cc.error(e.message, e.stack);
        }
      },
      cache: function cache(id, asset, cacheAsset) {
        if (!asset) return;
        var _isScene = isScene(asset);
        !_isScene && cacheAsset && assets.add(id, asset);
        _isScene && false;
      },
      setProperties: function setProperties(uuid, asset, assetsMap) {
        var missingAsset = false;
        var depends = asset.__depends__;
        if (depends) {
          var missingAssetReporter = null;
          for (var i = 0, l = depends.length; i < l; i++) {
            var depend = depends[i];
            var dependAsset = assetsMap[depend.uuid + "@import"];
            if (dependAsset) depend.owner[depend.prop] = dependAsset.addRef(); else {
              false;
              cc.error("The asset " + depend.uuid + " is missing!");
              missingAsset = true;
            }
          }
          missingAssetReporter && missingAssetReporter.reportByOwner();
          asset.__depends__ = void 0;
        }
        if (asset.__nativeDepend__) {
          if (!asset._nativeAsset) if (assetsMap[uuid + "@native"]) asset._nativeAsset = assetsMap[uuid + "@native"]; else {
            missingAsset = true;
            false;
          }
          asset.__nativeDepend__ = void 0;
        }
        return missingAsset;
      },
      gatherAsset: function gatherAsset(task) {
        var source = task.source;
        if (task.options.__outputAsArray__ || 1 !== source.length) {
          var output = task.output = [];
          for (var i = 0, l = source.length; i < l; i++) output.push(source[i].content);
        } else task.output = source[0].content;
      },
      forEach: function forEach(array, process, onComplete) {
        var count = 0;
        var errs = [];
        0 === array.length && onComplete && onComplete(errs);
        for (var i = 0, l = array.length; i < l; i++) process(array[i], (function(err) {
          err && errs.push(err);
          count++;
          count === l && onComplete && onComplete(errs);
        }));
      },
      parseParameters: function parseParameters(options, onProgress, onComplete) {
        if (void 0 === onComplete) {
          var isCallback = "function" === typeof options;
          if (onProgress) {
            onComplete = onProgress;
            isCallback || (onProgress = null);
          } else if (void 0 === onProgress && isCallback) {
            onComplete = options;
            options = null;
            onProgress = null;
          }
          if (void 0 !== onProgress && isCallback) {
            onProgress = options;
            options = null;
          }
        }
        options = options || Object.create(null);
        return {
          options: options,
          onProgress: onProgress,
          onComplete: onComplete
        };
      },
      parseLoadResArgs: function parseLoadResArgs(type, onProgress, onComplete) {
        if (void 0 === onComplete) {
          var isValidType = cc.js.isChildClassOf(type, cc.Asset);
          if (onProgress) {
            onComplete = onProgress;
            isValidType && (onProgress = null);
          } else if (void 0 === onProgress && !isValidType) {
            onComplete = type;
            onProgress = null;
            type = null;
          }
          if (void 0 !== onProgress && !isValidType) {
            onProgress = type;
            type = null;
          }
        }
        return {
          type: type,
          onProgress: onProgress,
          onComplete: onComplete
        };
      },
      checkCircleReference: function checkCircleReference(owner, uuid, map, checked) {
        checked || (checked = Object.create(null));
        var item = map[uuid];
        if (!item || checked[uuid]) return false;
        checked[uuid] = true;
        var result = false;
        var deps = dependUtil.getDeps(uuid);
        if (deps) for (var i = 0, l = deps.length; i < l; i++) {
          var dep = deps[i];
          if (dep === owner || utils.checkCircleReference(owner, dep, map, checked)) {
            result = true;
            break;
          }
        }
        return result;
      },
      asyncify: function asyncify(cb) {
        return function(p1, p2) {
          if (!cb) return;
          var refs = [];
          Array.isArray(p2) ? p2.forEach((function(x) {
            return x instanceof cc.Asset && refs.push(x.addRef());
          })) : p2 instanceof cc.Asset && refs.push(p2.addRef());
          callInNextTick((function() {
            refs.forEach((function(x) {
              return x.decRef(false);
            }));
            cb(p1, p2);
          }));
        };
      }
    };
    module.exports = utils;
  }), {
    "../assets/CCAsset": 137,
    "../platform/utils": 297,
    "./depend-util": 113,
    "./helper": 124,
    "./shared": 133
  } ],
  137: [ (function(require, module, exports) {
    "use strict";
    var CCObject = require("../platform/CCObject");
    cc.Asset = cc.Class({
      name: "cc.Asset",
      extends: CCObject,
      ctor: function ctor() {
        Object.defineProperty(this, "_uuid", {
          value: "",
          writable: true
        });
        this.loaded = true;
        this._nativeUrl = "";
        this._ref = 0;
      },
      properties: {
        nativeUrl: {
          get: function get() {
            if (!this._nativeUrl && this._native) {
              var name = this._native;
              if (47 === name.charCodeAt(0)) return name.slice(1);
              46 === name.charCodeAt(0) ? this._nativeUrl = cc.assetManager.utils.getUrlWithUuid(this._uuid, {
                nativeExt: name,
                isNative: true
              }) : this._nativeUrl = cc.assetManager.utils.getUrlWithUuid(this._uuid, {
                __nativeName__: name,
                nativeExt: cc.path.extname(name),
                isNative: true
              });
            }
            return this._nativeUrl;
          },
          visible: false
        },
        refCount: {
          get: function get() {
            return this._ref;
          }
        },
        _native: "",
        _nativeAsset: {
          get: function get() {
            return this._$nativeAsset;
          },
          set: function set(obj) {
            this._$nativeAsset = obj;
          }
        },
        _nativeDep: {
          get: function get() {
            if (this._native) return {
              __isNative__: true,
              uuid: this._uuid,
              ext: this._native
            };
          }
        }
      },
      statics: {
        deserialize: false,
        preventDeferredLoadDependents: false,
        preventPreloadNativeObject: false
      },
      toString: function toString() {
        return this.nativeUrl;
      },
      serialize: false,
      createNode: null,
      _setRawAsset: function _setRawAsset(filename, inLibrary) {
        this._native = false !== inLibrary ? filename || void 0 : "/" + filename;
      },
      addRef: function addRef() {
        this._ref++;
        return this;
      },
      decRef: function decRef(autoRelease) {
        this._ref > 0 && this._ref--;
        false !== autoRelease && cc.assetManager._releaseManager.tryRelease(this);
        return this;
      },
      destroy: function destroy() {
        this.loaded = false;
        return this._super();
      }
    });
    module.exports = cc.Asset;
  }), {
    "../platform/CCObject": 278
  } ],
  138: [ (function(require, module, exports) {
    "use strict";
    var Asset = require("./CCAsset");
    var EventTarget = require("../event/event-target");
    var LoadMode = cc.Enum({
      WEB_AUDIO: 0,
      DOM_AUDIO: 1
    });
    var AudioClip = cc.Class({
      name: "cc.AudioClip",
      extends: Asset,
      mixins: [ EventTarget ],
      ctor: function ctor() {
        this._loading = false;
        this.loaded = false;
        this._audio = null;
      },
      properties: {
        duration: 0,
        loadMode: {
          default: LoadMode.WEB_AUDIO,
          type: LoadMode
        },
        _nativeAsset: {
          get: function get() {
            return this._audio;
          },
          set: function set(value) {
            value instanceof cc.AudioClip ? this._audio = value._nativeAsset : this._audio = value;
            if (this._audio) {
              this.loaded = true;
              this.emit("load");
            }
          },
          override: true
        },
        _nativeDep: {
          get: function get() {
            return {
              uuid: this._uuid,
              audioLoadMode: this.loadMode,
              ext: cc.path.extname(this._native),
              __isNative__: true
            };
          },
          override: true
        }
      },
      statics: {
        LoadMode: LoadMode,
        _loadByUrl: function _loadByUrl(url, callback) {
          var audioClip = cc.assetManager.assets.get(url);
          audioClip ? callback(null, audioClip) : cc.assetManager.loadRemote(url, (function(error, data) {
            if (error) return callback(error);
            callback(null, data);
          }));
        }
      },
      _ensureLoaded: function _ensureLoaded(onComplete) {
        if (!this.isValid) return;
        if (this.loaded) return onComplete && onComplete();
        onComplete && this.once("load", onComplete);
        if (!this._loading) {
          this._loading = true;
          var self = this;
          cc.assetManager.postLoadNative(this, (function(err) {
            self._loading = false;
          }));
        }
      },
      destroy: function destroy() {
        cc.audioEngine.uncache(this);
        this._super();
      }
    });
    cc.AudioClip = AudioClip;
    module.exports = AudioClip;
  }), {
    "../event/event-target": 219,
    "./CCAsset": 137
  } ],
  139: [ (function(require, module, exports) {
    "use strict";
    var FontLetterDefinition = function FontLetterDefinition() {
      this.u = 0;
      this.v = 0;
      this.w = 0;
      this.h = 0;
      this.offsetX = 0;
      this.offsetY = 0;
      this.textureID = 0;
      this.valid = false;
      this.xAdvance = 0;
    };
    var FontAtlas = function FontAtlas(texture) {
      this._letterDefinitions = {};
      this._texture = texture;
    };
    FontAtlas.prototype = {
      constructor: FontAtlas,
      addLetterDefinitions: function addLetterDefinitions(letter, letterDefinition) {
        this._letterDefinitions[letter] = letterDefinition;
      },
      cloneLetterDefinition: function cloneLetterDefinition() {
        var copyLetterDefinitions = {};
        for (var key in this._letterDefinitions) {
          var value = new FontLetterDefinition();
          cc.js.mixin(value, this._letterDefinitions[key]);
          copyLetterDefinitions[key] = value;
        }
        return copyLetterDefinitions;
      },
      getTexture: function getTexture() {
        return this._texture;
      },
      getLetter: function getLetter(key) {
        return this._letterDefinitions[key];
      },
      getLetterDefinitionForChar: function getLetterDefinitionForChar(_char) {
        var key = _char.charCodeAt(0);
        var hasKey = this._letterDefinitions.hasOwnProperty(key);
        var letter;
        letter = hasKey ? this._letterDefinitions[key] : null;
        return letter;
      },
      clear: function clear() {
        this._letterDefinitions = {};
      }
    };
    var BitmapFont = cc.Class({
      name: "cc.BitmapFont",
      extends: cc.Font,
      properties: {
        fntDataStr: {
          default: ""
        },
        spriteFrame: {
          default: null,
          type: cc.SpriteFrame
        },
        fontSize: {
          default: -1
        },
        _fntConfig: null,
        _fontDefDictionary: null
      },
      onLoad: function onLoad() {
        var spriteFrame = this.spriteFrame;
        if (!this._fontDefDictionary) {
          this._fontDefDictionary = new FontAtlas();
          spriteFrame && (this._fontDefDictionary._texture = spriteFrame._texture);
        }
        var fntConfig = this._fntConfig;
        if (!fntConfig) return;
        var fontDict = fntConfig.fontDefDictionary;
        for (var fontDef in fontDict) {
          var letter = new FontLetterDefinition();
          var rect = fontDict[fontDef].rect;
          letter.offsetX = fontDict[fontDef].xOffset;
          letter.offsetY = fontDict[fontDef].yOffset;
          letter.w = rect.width;
          letter.h = rect.height;
          letter.u = rect.x;
          letter.v = rect.y;
          letter.textureID = 0;
          letter.valid = true;
          letter.xAdvance = fontDict[fontDef].xAdvance;
          this._fontDefDictionary.addLetterDefinitions(fontDef, letter);
        }
      }
    });
    cc.BitmapFont = BitmapFont;
    cc.BitmapFont.FontLetterDefinition = FontLetterDefinition;
    cc.BitmapFont.FontAtlas = FontAtlas;
    module.exports = BitmapFont;
  }), {} ],
  140: [ (function(require, module, exports) {
    "use strict";
    var BufferAsset = cc.Class({
      name: "cc.BufferAsset",
      extends: cc.Asset,
      ctor: function ctor() {
        this._buffer = null;
      },
      properties: {
        _nativeAsset: {
          get: function get() {
            return this._buffer;
          },
          set: function set(bin) {
            this._buffer = bin.buffer || bin;
          },
          override: true
        },
        buffer: function buffer() {
          return this._buffer;
        }
      }
    });
    cc.BufferAsset = module.exports = BufferAsset;
  }), {} ],
  141: [ (function(require, module, exports) {
    "use strict";
    var Font = cc.Class({
      name: "cc.Font",
      extends: cc.Asset
    });
    cc.Font = module.exports = Font;
  }), {} ],
  142: [ (function(require, module, exports) {
    "use strict";
    var JsonAsset = cc.Class({
      name: "cc.JsonAsset",
      extends: cc.Asset,
      properties: {
        json: null
      }
    });
    module.exports = cc.JsonAsset = JsonAsset;
  }), {} ],
  143: [ (function(require, module, exports) {
    "use strict";
    var LabelAtlas = cc.Class({
      name: "cc.LabelAtlas",
      extends: cc.BitmapFont,
      onLoad: function onLoad() {
        if (!this.spriteFrame) {
          cc.warnID(9100, this.name);
          return;
        }
        if (!this._fntConfig) {
          cc.warnID(9101, this.name);
          return;
        }
        this._super();
      }
    });
    cc.LabelAtlas = LabelAtlas;
    module.exports = LabelAtlas;
  }), {} ],
  144: [ (function(require, module, exports) {
    "use strict";
    var OptimizationPolicy = cc.Enum({
      AUTO: 0,
      SINGLE_INSTANCE: 1,
      MULTI_INSTANCE: 2
    });
    var Prefab = cc.Class({
      name: "cc.Prefab",
      extends: cc.Asset,
      ctor: function ctor() {
        this._createFunction = null;
        this._instantiatedTimes = 0;
      },
      properties: {
        data: null,
        optimizationPolicy: OptimizationPolicy.AUTO,
        asyncLoadAssets: false,
        readonly: {
          default: false,
          editorOnly: true
        }
      },
      statics: {
        OptimizationPolicy: OptimizationPolicy,
        OptimizationPolicyThreshold: 3
      },
      createNode: false,
      compileCreateFunction: function compileCreateFunction() {
        var jit = require("../platform/instantiate-jit");
        this._createFunction = jit.compile(this.data);
      },
      _doInstantiate: function _doInstantiate(rootToRedirect) {
        this.data._prefab || cc.warnID(3700);
        this._createFunction || this.compileCreateFunction();
        return this._createFunction(rootToRedirect);
      },
      _instantiate: function _instantiate() {
        var node, useJit = false;
        true;
        useJit = this.optimizationPolicy !== OptimizationPolicy.SINGLE_INSTANCE && (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE || this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold);
        if (useJit) {
          node = this._doInstantiate();
          this.data._instantiate(node);
        } else node = this.data._instantiate();
        ++this._instantiatedTimes;
        var PrefabUtils;
        false, false;
        return node;
      },
      destroy: function destroy() {
        this.data && this.data.destroy();
        this._super();
      }
    });
    cc.Prefab = module.exports = Prefab;
    cc.js.obsolete(cc, "cc._Prefab", "Prefab");
  }), {
    "../platform/instantiate-jit": 292
  } ],
  145: [ (function(require, module, exports) {
    "use strict";
    var _gfx = _interopRequireDefault(require("../../renderer/gfx"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var renderer = require("../renderer");
    var Texture2D = require("./CCTexture2D");
    var DepthStencilFormat = cc.Enum({
      RB_FMT_D24S8: _gfx["default"].RB_FMT_D24S8,
      RB_FMT_S8: _gfx["default"].RB_FMT_S8,
      RB_FMT_D16: _gfx["default"].RB_FMT_D16
    });
    var RenderTexture = cc.Class({
      name: "cc.RenderTexture",
      extends: Texture2D,
      statics: {
        DepthStencilFormat: DepthStencilFormat
      },
      ctor: function ctor() {
        this._framebuffer = null;
      },
      initWithSize: function initWithSize(width, height, depthStencilFormat) {
        this.width = Math.floor(width || cc.visibleRect.width);
        this.height = Math.floor(height || cc.visibleRect.height);
        this._resetUnderlyingMipmaps();
        var opts = {
          colors: [ this._texture ]
        };
        this._depthStencilBuffer && this._depthStencilBuffer.destroy();
        var depthStencilBuffer;
        if (depthStencilFormat) {
          depthStencilBuffer = new _gfx["default"].RenderBuffer(renderer.device, depthStencilFormat, width, height);
          depthStencilFormat === _gfx["default"].RB_FMT_D24S8 ? opts.depthStencil = depthStencilBuffer : depthStencilFormat === _gfx["default"].RB_FMT_S8 ? opts.stencil = depthStencilBuffer : depthStencilFormat === _gfx["default"].RB_FMT_D16 && (opts.depth = depthStencilBuffer);
        }
        this._depthStencilBuffer = depthStencilBuffer;
        this._framebuffer && this._framebuffer.destroy();
        this._framebuffer = new _gfx["default"].FrameBuffer(renderer.device, width, height, opts);
        this._packable = false;
        this.loaded = true;
        this.emit("load");
      },
      updateSize: function updateSize(width, height) {
        this.width = Math.floor(width || cc.visibleRect.width);
        this.height = Math.floor(height || cc.visibleRect.height);
        this._resetUnderlyingMipmaps();
        var rbo = this._depthStencilBuffer;
        rbo && rbo.update(this.width, this.height);
        this._framebuffer._width = width;
        this._framebuffer._height = height;
      },
      drawTextureAt: function drawTextureAt(texture, x, y) {
        if (!texture._image || 0 === texture._image.width) return;
        this._texture.updateSubImage({
          x: x,
          y: y,
          image: texture._image,
          width: texture.width,
          height: texture.height,
          level: 0,
          flipY: false,
          premultiplyAlpha: texture._premultiplyAlpha
        });
      },
      readPixels: function readPixels(data, x, y, w, h) {
        if (!this._framebuffer || !this._texture) return data;
        x = x || 0;
        y = y || 0;
        var width = w || this.width;
        var height = h || this.height;
        data = data || new Uint8Array(width * height * 4);
        var gl = cc.game._renderContext;
        var oldFBO = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer.getHandle());
        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.bindFramebuffer(gl.FRAMEBUFFER, oldFBO);
        return data;
      },
      destroy: function destroy() {
        this._super();
        if (this._framebuffer) {
          this._framebuffer.destroy();
          this._framebuffer = null;
        }
      }
    });
    cc.RenderTexture = module.exports = RenderTexture;
  }), {
    "../../renderer/gfx": 427,
    "../renderer": 322,
    "./CCTexture2D": 152
  } ],
  146: [ (function(require, module, exports) {
    "use strict";
    var Scene = cc.Class({
      name: "cc.SceneAsset",
      extends: cc.Asset,
      properties: {
        scene: null,
        asyncLoadAssets: void 0
      }
    });
    cc.SceneAsset = Scene;
    module.exports = Scene;
  }), {} ],
  147: [ (function(require, module, exports) {
    "use strict";
    var Script = cc.Class({
      name: "cc.Script",
      extends: cc.Asset
    });
    cc._Script = Script;
    var JavaScript = cc.Class({
      name: "cc.JavaScript",
      extends: Script
    });
    cc._JavaScript = JavaScript;
    var TypeScript = cc.Class({
      name: "cc.TypeScript",
      extends: Script
    });
    cc._TypeScript = TypeScript;
  }), {} ],
  148: [ (function(require, module, exports) {
    "use strict";
    var SpriteAtlas = cc.Class({
      name: "cc.SpriteAtlas",
      extends: cc.Asset,
      properties: {
        _spriteFrames: {
          default: {}
        }
      },
      getTexture: function getTexture() {
        var keys = Object.keys(this._spriteFrames);
        if (keys.length > 0) {
          var spriteFrame = this._spriteFrames[keys[0]];
          return spriteFrame ? spriteFrame.getTexture() : null;
        }
        return null;
      },
      getSpriteFrame: function getSpriteFrame(key) {
        var sf = this._spriteFrames[key];
        if (!sf) return null;
        sf.name || (sf.name = key);
        return sf;
      },
      getSpriteFrames: function getSpriteFrames() {
        var frames = [];
        var spriteFrames = this._spriteFrames;
        for (var key in spriteFrames) frames.push(this.getSpriteFrame(key));
        return frames;
      }
    });
    cc.SpriteAtlas = SpriteAtlas;
    module.exports = SpriteAtlas;
  }), {} ],
  149: [ (function(require, module, exports) {
    "use strict";
    var EventTarget = require("../event/event-target");
    var INSET_LEFT = 0;
    var INSET_TOP = 1;
    var INSET_RIGHT = 2;
    var INSET_BOTTOM = 3;
    var temp_uvs = [ {
      u: 0,
      v: 0
    }, {
      u: 0,
      v: 0
    }, {
      u: 0,
      v: 0
    }, {
      u: 0,
      v: 0
    } ];
    var SpriteFrame = cc.Class({
      name: "cc.SpriteFrame",
      extends: require("../assets/CCAsset"),
      mixins: [ EventTarget ],
      properties: {
        _textureSetter: {
          set: function set(texture) {
            if (texture) {
              false;
              this._texture !== texture && this._refreshTexture(texture);
            }
          }
        },
        insetTop: {
          get: function get() {
            return this._capInsets[INSET_TOP];
          },
          set: function set(value) {
            this._capInsets[INSET_TOP] = value;
            this._texture && this._calculateSlicedUV();
          }
        },
        insetBottom: {
          get: function get() {
            return this._capInsets[INSET_BOTTOM];
          },
          set: function set(value) {
            this._capInsets[INSET_BOTTOM] = value;
            this._texture && this._calculateSlicedUV();
          }
        },
        insetLeft: {
          get: function get() {
            return this._capInsets[INSET_LEFT];
          },
          set: function set(value) {
            this._capInsets[INSET_LEFT] = value;
            this._texture && this._calculateSlicedUV();
          }
        },
        insetRight: {
          get: function get() {
            return this._capInsets[INSET_RIGHT];
          },
          set: function set(value) {
            this._capInsets[INSET_RIGHT] = value;
            this._texture && this._calculateSlicedUV();
          }
        }
      },
      ctor: function ctor() {
        EventTarget.call(this);
        var filename = arguments[0];
        var rect = arguments[1];
        var rotated = arguments[2];
        var offset = arguments[3];
        var originalSize = arguments[4];
        this._rect = null;
        this.uv = [];
        this._texture = null;
        this._original = null;
        this._offset = null;
        this._originalSize = null;
        this._rotated = false;
        this._flipX = false;
        this._flipY = false;
        this.vertices = null;
        this._capInsets = [ 0, 0, 0, 0 ];
        this.uvSliced = [];
        false;
        void 0 !== filename && this.setTexture(filename, rect, rotated, offset, originalSize);
      },
      textureLoaded: function textureLoaded() {
        return this._texture && this._texture.loaded;
      },
      onTextureLoaded: function onTextureLoaded(callback, target) {
        if (!this.textureLoaded()) {
          this.once("load", callback, target);
          this.ensureLoadTexture();
          return false;
        }
        callback.call(target);
        return true;
      },
      isRotated: function isRotated() {
        return this._rotated;
      },
      setRotated: function setRotated(bRotated) {
        this._rotated = bRotated;
        this._texture && this._calculateUV();
      },
      isFlipX: function isFlipX() {
        return this._flipX;
      },
      isFlipY: function isFlipY() {
        return this._flipY;
      },
      setFlipX: function setFlipX(flipX) {
        this._flipX = flipX;
        this._texture && this._calculateUV();
      },
      setFlipY: function setFlipY(flipY) {
        this._flipY = flipY;
        this._texture && this._calculateUV();
      },
      getRect: function getRect() {
        return cc.rect(this._rect);
      },
      setRect: function setRect(rect) {
        this._rect = rect;
        this._texture && this._calculateUV();
      },
      getOriginalSize: function getOriginalSize() {
        return cc.size(this._originalSize);
      },
      setOriginalSize: function setOriginalSize(size) {
        if (this._originalSize) {
          this._originalSize.width = size.width;
          this._originalSize.height = size.height;
        } else this._originalSize = cc.size(size);
      },
      getTexture: function getTexture() {
        return this._texture;
      },
      _textureLoadedCallback: function _textureLoadedCallback() {
        var self = this;
        var texture = this._texture;
        if (!texture) return;
        var w = texture.width, h = texture.height;
        self._rect ? self._checkRect(self._texture) : self._rect = cc.rect(0, 0, w, h);
        self._originalSize || self.setOriginalSize(cc.size(w, h));
        self._offset || self.setOffset(cc.v2(0, 0));
        self._calculateUV();
        self.emit("load");
      },
      _refreshTexture: function _refreshTexture(texture) {
        this._texture = texture;
        texture.loaded ? this._textureLoadedCallback() : texture.once("load", this._textureLoadedCallback, this);
      },
      getOffset: function getOffset() {
        return cc.v2(this._offset);
      },
      setOffset: function setOffset(offsets) {
        this._offset = cc.v2(offsets);
      },
      clone: function clone() {
        return new SpriteFrame(this._texture, this.getRect(), this._rotated, this.getOffset(), this.getOriginalSize());
      },
      setTexture: function setTexture(texture, rect, rotated, offset, originalSize) {
        if (1 === arguments.length && texture === this._texture) return;
        this._rect = rect || null;
        offset ? this.setOffset(offset) : this._offset = null;
        originalSize ? this.setOriginalSize(originalSize) : this._originalSize = null;
        this._rotated = rotated || false;
        if ("string" === typeof texture) {
          cc.errorID(3401);
          return;
        }
        texture instanceof cc.Texture2D && this._refreshTexture(texture);
        return true;
      },
      ensureLoadTexture: function ensureLoadTexture() {
        if (this._texture && !this._texture.loaded) {
          this._refreshTexture(this._texture);
          cc.assetManager.postLoadNative(this._texture);
        }
      },
      _checkRect: function _checkRect(texture) {
        var rect = this._rect;
        var maxX = rect.x, maxY = rect.y;
        if (this._rotated) {
          maxX += rect.height;
          maxY += rect.width;
        } else {
          maxX += rect.width;
          maxY += rect.height;
        }
        maxX > texture.width && cc.errorID(3300, texture.nativeUrl + "/" + this.name, maxX, texture.width);
        maxY > texture.height && cc.errorID(3400, texture.nativeUrl + "/" + this.name, maxY, texture.height);
      },
      _flipXY: function _flipXY(uvs) {
        if (this._flipX) {
          var tempVal = uvs[0];
          uvs[0] = uvs[1];
          uvs[1] = tempVal;
          tempVal = uvs[2];
          uvs[2] = uvs[3];
          uvs[3] = tempVal;
        }
        if (this._flipY) {
          var _tempVal = uvs[0];
          uvs[0] = uvs[2];
          uvs[2] = _tempVal;
          _tempVal = uvs[1];
          uvs[1] = uvs[3];
          uvs[3] = _tempVal;
        }
      },
      _calculateSlicedUV: function _calculateSlicedUV() {
        var rect = this._rect;
        var atlasWidth = this._texture.width;
        var atlasHeight = this._texture.height;
        var leftWidth = this._capInsets[INSET_LEFT];
        var rightWidth = this._capInsets[INSET_RIGHT];
        var centerWidth = rect.width - leftWidth - rightWidth;
        var topHeight = this._capInsets[INSET_TOP];
        var bottomHeight = this._capInsets[INSET_BOTTOM];
        var centerHeight = rect.height - topHeight - bottomHeight;
        var uvSliced = this.uvSliced;
        uvSliced.length = 0;
        if (this._rotated) {
          temp_uvs[0].u = rect.x / atlasWidth;
          temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;
          temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;
          temp_uvs[3].u = (rect.x + rect.height) / atlasWidth;
          temp_uvs[3].v = rect.y / atlasHeight;
          temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;
          temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;
          temp_uvs[0].v = (rect.y + rect.width) / atlasHeight;
          this._flipXY(temp_uvs);
          for (var row = 0; row < 4; ++row) {
            var rowD = temp_uvs[row];
            for (var col = 0; col < 4; ++col) {
              var colD = temp_uvs[3 - col];
              uvSliced.push({
                u: rowD.u,
                v: colD.v
              });
            }
          }
        } else {
          temp_uvs[0].u = rect.x / atlasWidth;
          temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;
          temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;
          temp_uvs[3].u = (rect.x + rect.width) / atlasWidth;
          temp_uvs[3].v = rect.y / atlasHeight;
          temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;
          temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;
          temp_uvs[0].v = (rect.y + rect.height) / atlasHeight;
          this._flipXY(temp_uvs);
          for (var _row = 0; _row < 4; ++_row) {
            var _rowD = temp_uvs[_row];
            for (var _col = 0; _col < 4; ++_col) {
              var _colD = temp_uvs[_col];
              uvSliced.push({
                u: _colD.u,
                v: _rowD.v
              });
            }
          }
        }
      },
      _setDynamicAtlasFrame: function _setDynamicAtlasFrame(frame) {
        if (!frame) return;
        this._original = {
          _texture: this._texture,
          _x: this._rect.x,
          _y: this._rect.y
        };
        this._texture = frame.texture;
        this._rect.x = frame.x;
        this._rect.y = frame.y;
        this._calculateUV();
      },
      _resetDynamicAtlasFrame: function _resetDynamicAtlasFrame() {
        if (!this._original) return;
        this._rect.x = this._original._x;
        this._rect.y = this._original._y;
        this._texture = this._original._texture;
        this._original = null;
        this._texture.loaded ? this._calculateUV() : this.ensureLoadTexture();
        this.emit("_resetDynamicAtlasFrame");
      },
      _calculateUV: function _calculateUV() {
        var rect = this._rect, texture = this._texture, uv = this.uv, texw = texture.width, texh = texture.height;
        if (this._rotated) {
          var l = 0 === texw ? 0 : rect.x / texw;
          var r = 0 === texw ? 0 : (rect.x + rect.height) / texw;
          var b = 0 === texh ? 0 : (rect.y + rect.width) / texh;
          var t = 0 === texh ? 0 : rect.y / texh;
          uv[0] = l;
          uv[1] = t;
          uv[2] = l;
          uv[3] = b;
          uv[4] = r;
          uv[5] = t;
          uv[6] = r;
          uv[7] = b;
        } else {
          var _l = 0 === texw ? 0 : rect.x / texw;
          var _r = 0 === texw ? 0 : (rect.x + rect.width) / texw;
          var _b = 0 === texh ? 0 : (rect.y + rect.height) / texh;
          var _t = 0 === texh ? 0 : rect.y / texh;
          uv[0] = _l;
          uv[1] = _b;
          uv[2] = _r;
          uv[3] = _b;
          uv[4] = _l;
          uv[5] = _t;
          uv[6] = _r;
          uv[7] = _t;
        }
        if (this._flipX) {
          var tempVal = uv[0];
          uv[0] = uv[2];
          uv[2] = tempVal;
          tempVal = uv[1];
          uv[1] = uv[3];
          uv[3] = tempVal;
          tempVal = uv[4];
          uv[4] = uv[6];
          uv[6] = tempVal;
          tempVal = uv[5];
          uv[5] = uv[7];
          uv[7] = tempVal;
        }
        if (this._flipY) {
          var _tempVal2 = uv[0];
          uv[0] = uv[4];
          uv[4] = _tempVal2;
          _tempVal2 = uv[1];
          uv[1] = uv[5];
          uv[5] = _tempVal2;
          _tempVal2 = uv[2];
          uv[2] = uv[6];
          uv[6] = _tempVal2;
          _tempVal2 = uv[3];
          uv[3] = uv[7];
          uv[7] = _tempVal2;
        }
        var vertices = this.vertices;
        if (vertices) {
          vertices.nu.length = 0;
          vertices.nv.length = 0;
          for (var i = 0; i < vertices.u.length; i++) {
            vertices.nu[i] = vertices.u[i] / texw;
            vertices.nv[i] = vertices.v[i] / texh;
          }
        }
        this._calculateSlicedUV();
      },
      _serialize: (false, false) && function(exporting, ctx) {
        var rect = this._rect;
        var offset = this._offset;
        var size = this._originalSize;
        var uuid;
        var texture = this._texture;
        texture && (uuid = texture._uuid);
        if (!uuid) {
          var url = this._textureFilename;
          url && (uuid = Editor.Utils.UuidCache.urlToUuid(url));
        }
        if (uuid && exporting) {
          uuid = Editor.Utils.UuidUtils.compressUuid(uuid, true);
          ctx.dependsOn("_textureSetter", uuid);
        }
        var vertices;
        this.vertices && (vertices = {
          triangles: this.vertices.triangles,
          x: this.vertices.x,
          y: this.vertices.y,
          u: this.vertices.u,
          v: this.vertices.v
        });
        return {
          name: this._name,
          texture: !exporting && uuid || void 0,
          atlas: exporting ? void 0 : this._atlasUuid,
          rect: rect ? [ rect.x, rect.y, rect.width, rect.height ] : void 0,
          offset: offset ? [ offset.x, offset.y ] : void 0,
          originalSize: size ? [ size.width, size.height ] : void 0,
          rotated: this._rotated ? 1 : void 0,
          capInsets: this._capInsets,
          vertices: vertices
        };
      },
      _deserialize: function _deserialize(data, handle) {
        var rect = data.rect;
        rect && (this._rect = new cc.Rect(rect[0], rect[1], rect[2], rect[3]));
        data.offset && this.setOffset(new cc.Vec2(data.offset[0], data.offset[1]));
        data.originalSize && this.setOriginalSize(new cc.Size(data.originalSize[0], data.originalSize[1]));
        this._rotated = 1 === data.rotated;
        this._name = data.name;
        var capInsets = data.capInsets;
        if (capInsets) {
          this._capInsets[INSET_LEFT] = capInsets[INSET_LEFT];
          this._capInsets[INSET_TOP] = capInsets[INSET_TOP];
          this._capInsets[INSET_RIGHT] = capInsets[INSET_RIGHT];
          this._capInsets[INSET_BOTTOM] = capInsets[INSET_BOTTOM];
        }
        false;
        this.vertices = data.vertices;
        if (this.vertices) {
          this.vertices.nu = [];
          this.vertices.nv = [];
        }
        true;
        var textureUuid = data.texture;
        textureUuid && handle.result.push(this, "_textureSetter", textureUuid);
      },
      destroy: function destroy() {
        cc.dynamicAtlasManager && cc.dynamicAtlasManager.deleteSpriteFrame(this);
        this._super();
      }
    });
    var proto = SpriteFrame.prototype;
    proto.copyWithZone = proto.clone;
    proto.copy = proto.clone;
    proto.initWithTexture = proto.setTexture;
    cc.SpriteFrame = SpriteFrame;
    module.exports = SpriteFrame;
  }), {
    "../assets/CCAsset": 137,
    "../event/event-target": 219
  } ],
  150: [ (function(require, module, exports) {
    "use strict";
    var Font = require("./CCFont");
    var TTFFont = cc.Class({
      name: "cc.TTFFont",
      extends: Font,
      properties: {
        _fontFamily: null,
        _nativeAsset: {
          type: cc.String,
          get: function get() {
            return this._fontFamily;
          },
          set: function set(value) {
            this._fontFamily = value || "Arial";
          },
          override: true
        },
        _nativeDep: {
          get: function get() {
            return {
              uuid: this._uuid,
              __nativeName__: this._native,
              ext: cc.path.extname(this._native),
              __isNative__: true
            };
          },
          override: true
        }
      }
    });
    cc.TTFFont = module.exports = TTFFont;
  }), {
    "./CCFont": 141
  } ],
  151: [ (function(require, module, exports) {
    "use strict";
    var TextAsset = cc.Class({
      name: "cc.TextAsset",
      extends: cc.Asset,
      properties: {
        text: ""
      },
      toString: function toString() {
        return this.text;
      }
    });
    module.exports = cc.TextAsset = TextAsset;
  }), {} ],
  152: [ (function(require, module, exports) {
    "use strict";
    var _gfx = _interopRequireDefault(require("../../renderer/gfx"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EventTarget = require("../event/event-target");
    var renderer = require("../renderer");
    require("../platform/CCClass");
    var GL_NEAREST = 9728;
    var GL_LINEAR = 9729;
    var GL_REPEAT = 10497;
    var GL_CLAMP_TO_EDGE = 33071;
    var GL_MIRRORED_REPEAT = 33648;
    var GL_RGBA = 6408;
    var CHAR_CODE_0 = 48;
    var CHAR_CODE_1 = 49;
    var idGenerater = new (require("../platform/id-generater"))("Tex");
    var CUSTOM_PIXEL_FORMAT = 1024;
    var PixelFormat = cc.Enum({
      RGB565: _gfx["default"].TEXTURE_FMT_R5_G6_B5,
      RGB5A1: _gfx["default"].TEXTURE_FMT_R5_G5_B5_A1,
      RGBA4444: _gfx["default"].TEXTURE_FMT_R4_G4_B4_A4,
      RGB888: _gfx["default"].TEXTURE_FMT_RGB8,
      RGBA8888: _gfx["default"].TEXTURE_FMT_RGBA8,
      RGBA32F: _gfx["default"].TEXTURE_FMT_RGBA32F,
      A8: _gfx["default"].TEXTURE_FMT_A8,
      I8: _gfx["default"].TEXTURE_FMT_L8,
      AI8: _gfx["default"].TEXTURE_FMT_L8_A8,
      RGB_PVRTC_2BPPV1: _gfx["default"].TEXTURE_FMT_RGB_PVRTC_2BPPV1,
      RGBA_PVRTC_2BPPV1: _gfx["default"].TEXTURE_FMT_RGBA_PVRTC_2BPPV1,
      RGB_A_PVRTC_2BPPV1: CUSTOM_PIXEL_FORMAT++,
      RGB_PVRTC_4BPPV1: _gfx["default"].TEXTURE_FMT_RGB_PVRTC_4BPPV1,
      RGBA_PVRTC_4BPPV1: _gfx["default"].TEXTURE_FMT_RGBA_PVRTC_4BPPV1,
      RGB_A_PVRTC_4BPPV1: CUSTOM_PIXEL_FORMAT++,
      RGB_ETC1: _gfx["default"].TEXTURE_FMT_RGB_ETC1,
      RGBA_ETC1: CUSTOM_PIXEL_FORMAT++,
      RGB_ETC2: _gfx["default"].TEXTURE_FMT_RGB_ETC2,
      RGBA_ETC2: _gfx["default"].TEXTURE_FMT_RGBA_ETC2
    });
    var WrapMode = cc.Enum({
      REPEAT: GL_REPEAT,
      CLAMP_TO_EDGE: GL_CLAMP_TO_EDGE,
      MIRRORED_REPEAT: GL_MIRRORED_REPEAT
    });
    var Filter = cc.Enum({
      LINEAR: GL_LINEAR,
      NEAREST: GL_NEAREST
    });
    var FilterIndex = {
      9728: 0,
      9729: 1
    };
    var _images = [];
    var _sharedOpts = {
      width: void 0,
      height: void 0,
      minFilter: void 0,
      magFilter: void 0,
      wrapS: void 0,
      wrapT: void 0,
      format: void 0,
      genMipmaps: void 0,
      images: void 0,
      image: void 0,
      flipY: void 0,
      premultiplyAlpha: void 0
    };
    function _getSharedOptions() {
      for (var key in _sharedOpts) _sharedOpts[key] = void 0;
      _images.length = 0;
      _sharedOpts.images = _images;
      return _sharedOpts;
    }
    var Texture2D = cc.Class({
      name: "cc.Texture2D",
      extends: require("../assets/CCAsset"),
      mixins: [ EventTarget ],
      properties: {
        _nativeAsset: {
          get: function get() {
            return this._image;
          },
          set: function set(data) {
            data._compressed && data._data ? this.initWithData(data._data, this._format, data.width, data.height) : this.initWithElement(data);
          },
          override: true
        },
        _format: PixelFormat.RGBA8888,
        _premultiplyAlpha: false,
        _flipY: false,
        _minFilter: Filter.LINEAR,
        _magFilter: Filter.LINEAR,
        _mipFilter: Filter.LINEAR,
        _wrapS: WrapMode.CLAMP_TO_EDGE,
        _wrapT: WrapMode.CLAMP_TO_EDGE,
        _isAlphaAtlas: false,
        _genMipmaps: false,
        genMipmaps: {
          get: function get() {
            return this._genMipmaps;
          },
          set: function set(genMipmaps) {
            if (this._genMipmaps !== genMipmaps) {
              var opts = _getSharedOptions();
              opts.genMipmaps = genMipmaps;
              this.update(opts);
            }
          }
        },
        _packable: true,
        packable: {
          get: function get() {
            return this._packable;
          },
          set: function set(val) {
            this._packable = val;
          }
        },
        _nativeDep: {
          get: function get() {
            return {
              __isNative__: true,
              uuid: this._uuid,
              ext: this._native,
              __flipY__: this._flipY,
              __premultiplyAlpha__: this._premultiplyAlpha
            };
          },
          override: true
        }
      },
      statics: {
        PixelFormat: PixelFormat,
        WrapMode: WrapMode,
        Filter: Filter,
        _FilterIndex: FilterIndex,
        extnames: [ ".png", ".jpg", ".jpeg", ".bmp", ".webp", ".pvr", ".pkm" ],
        _parseExt: function _parseExt(extIdStr, defaultFormat) {
          var device = cc.renderer.device;
          var extIds = extIdStr.split("_");
          var defaultExt = "";
          var bestExt = "";
          var bestIndex = 999;
          var bestFormat = defaultFormat;
          var SupportTextureFormats = cc.macro.SUPPORT_TEXTURE_FORMATS;
          for (var i = 0; i < extIds.length; i++) {
            var extFormat = extIds[i].split("@");
            var tmpExt = extFormat[0];
            tmpExt = Texture2D.extnames[tmpExt.charCodeAt(0) - CHAR_CODE_0] || tmpExt;
            var index = SupportTextureFormats.indexOf(tmpExt);
            if (-1 !== index && index < bestIndex) {
              var tmpFormat = extFormat[1] ? parseInt(extFormat[1]) : defaultFormat;
              if (".pvr" === tmpExt && !device.ext("WEBGL_compressed_texture_pvrtc")) continue;
              if (!(tmpFormat !== PixelFormat.RGB_ETC1 && tmpFormat !== PixelFormat.RGBA_ETC1 || device.ext("WEBGL_compressed_texture_etc1"))) continue;
              if (!(tmpFormat !== PixelFormat.RGB_ETC2 && tmpFormat !== PixelFormat.RGBA_ETC2 || device.ext("WEBGL_compressed_texture_etc"))) continue;
              if (".webp" === tmpExt && !cc.sys.capabilities.webp) continue;
              bestIndex = index;
              bestExt = tmpExt;
              bestFormat = tmpFormat;
            } else defaultExt || (defaultExt = tmpExt);
          }
          return {
            bestExt: bestExt,
            bestFormat: bestFormat,
            defaultExt: defaultExt
          };
        }
      },
      ctor: function ctor() {
        this._id = idGenerater.getNewId();
        this.loaded = false;
        this.width = 0;
        this.height = 0;
        this._hashDirty = true;
        this._hash = 0;
        this._texture = null;
        false;
        this._multiMaterial = null;
      },
      getImpl: function getImpl() {
        this._texture || (this._texture = new renderer.Texture2D(renderer.device, {}));
        return this._texture;
      },
      getId: function getId() {
        return this._id;
      },
      toString: function toString() {
        return this.nativeUrl || "";
      },
      update: function update(options) {
        if (options) {
          var updateImg = false;
          void 0 !== options.width && (this.width = options.width);
          void 0 !== options.height && (this.height = options.height);
          if (void 0 !== options.minFilter) {
            this._minFilter = options.minFilter;
            options.minFilter = FilterIndex[options.minFilter];
          }
          if (void 0 !== options.magFilter) {
            this._magFilter = options.magFilter;
            options.magFilter = FilterIndex[options.magFilter];
          }
          if (void 0 !== options.mipFilter) {
            this._mipFilter = options.mipFilter;
            options.mipFilter = FilterIndex[options.mipFilter];
          }
          void 0 !== options.wrapS && (this._wrapS = options.wrapS);
          void 0 !== options.wrapT && (this._wrapT = options.wrapT);
          void 0 !== options.format && (this._format = options.format);
          if (void 0 !== options.flipY) {
            this._flipY = options.flipY;
            updateImg = true;
          }
          if (void 0 !== options.premultiplyAlpha) {
            this._premultiplyAlpha = options.premultiplyAlpha;
            updateImg = true;
          }
          void 0 !== options.genMipmaps && (this._genMipmaps = options.genMipmaps);
          cc.sys.capabilities.imageBitmap && this._image instanceof ImageBitmap ? this._checkImageBitmap(this._upload.bind(this, options, updateImg)) : this._upload(options, updateImg);
        }
      },
      _upload: function _upload(options, updateImg) {
        updateImg && this._image && (options.image = this._image);
        if (options.images && options.images.length > 0) this._image = options.images[0]; else if (void 0 !== options.image) {
          this._image = options.image;
          if (!options.images) {
            _images.length = 0;
            options.images = _images;
          }
          options.images.push(options.image);
        }
        this._texture && this._texture.update(options);
        this._hashDirty = true;
      },
      initWithElement: function initWithElement(element) {
        if (!element) return;
        this._image = element;
        if (element.complete || element instanceof HTMLCanvasElement) this.handleLoadedTexture(); else if (cc.sys.capabilities.imageBitmap && element instanceof ImageBitmap) this._checkImageBitmap(this.handleLoadedTexture.bind(this)); else {
          var self = this;
          element.addEventListener("load", (function() {
            self.handleLoadedTexture();
          }));
          element.addEventListener("error", (function(err) {
            cc.warnID(3119, err.message);
          }));
        }
      },
      initWithData: function initWithData(data, pixelFormat, pixelsWidth, pixelsHeight) {
        var opts = _getSharedOptions();
        opts.image = data;
        opts.images = [ opts.image ];
        opts.genMipmaps = this._genMipmaps;
        opts.premultiplyAlpha = this._premultiplyAlpha;
        opts.flipY = this._flipY;
        opts.minFilter = FilterIndex[this._minFilter];
        opts.magFilter = FilterIndex[this._magFilter];
        opts.wrapS = this._wrapS;
        opts.wrapT = this._wrapT;
        opts.format = this._getGFXPixelFormat(pixelFormat);
        opts.width = pixelsWidth;
        opts.height = pixelsHeight;
        this._texture ? this._texture.update(opts) : this._texture = new renderer.Texture2D(renderer.device, opts);
        this.width = pixelsWidth;
        this.height = pixelsHeight;
        this._updateFormat();
        this._checkPackable();
        this.loaded = true;
        this.emit("load");
        return true;
      },
      getHtmlElementObj: function getHtmlElementObj() {
        return this._image;
      },
      destroy: function destroy() {
        cc.sys.capabilities.imageBitmap && this._image instanceof ImageBitmap && this._image.close && this._image.close();
        this._packable && cc.dynamicAtlasManager && cc.dynamicAtlasManager.deleteAtlasTexture(this);
        this.unlinkMaterial();
        this._image = null;
        this._texture && this._texture.destroy();
        this._super();
      },
      getPixelFormat: function getPixelFormat() {
        return this._format;
      },
      hasPremultipliedAlpha: function hasPremultipliedAlpha() {
        return this._premultiplyAlpha || false;
      },
      isAlphaAtlas: function isAlphaAtlas() {
        return this._isAlphaAtlas;
      },
      handleLoadedTexture: function handleLoadedTexture() {
        if (!this._image || !this._image.width || !this._image.height) return;
        this.width = this._image.width;
        this.height = this._image.height;
        var opts = _getSharedOptions();
        opts.image = this._image;
        opts.images = [ opts.image ];
        opts.width = this.width;
        opts.height = this.height;
        opts.genMipmaps = this._genMipmaps;
        opts.format = this._getGFXPixelFormat(this._format);
        opts.premultiplyAlpha = this._premultiplyAlpha;
        opts.flipY = this._flipY;
        opts.minFilter = FilterIndex[this._minFilter];
        opts.magFilter = FilterIndex[this._magFilter];
        opts.wrapS = this._wrapS;
        opts.wrapT = this._wrapT;
        this._texture ? this._texture.update(opts) : this._texture = new renderer.Texture2D(renderer.device, opts);
        this._updateFormat();
        this._checkPackable();
        this.loaded = true;
        this.emit("load");
        cc.macro.CLEANUP_IMAGE_CACHE && this._cleanupImageCache();
      },
      _cleanupImageCache: function _cleanupImageCache() {
        this._image instanceof HTMLImageElement ? this._clearImage() : cc.sys.capabilities.imageBitmap && this._image instanceof ImageBitmap && this._image.close && this._image.close();
      },
      description: function description() {
        return "<cc.Texture2D | Name = " + this.nativeUrl + " | Dimensions = " + this.width + " x " + this.height + ">";
      },
      releaseTexture: function releaseTexture() {
        this._image = null;
        this._texture && this._texture.destroy();
      },
      setWrapMode: function setWrapMode(wrapS, wrapT) {
        if (this._wrapS !== wrapS || this._wrapT !== wrapT) {
          var opts = _getSharedOptions();
          opts.wrapS = wrapS;
          opts.wrapT = wrapT;
          this.update(opts);
        }
      },
      setFilters: function setFilters(minFilter, magFilter) {
        if (this._minFilter !== minFilter || this._magFilter !== magFilter) {
          var opts = _getSharedOptions();
          opts.minFilter = minFilter;
          opts.magFilter = magFilter;
          this.update(opts);
        }
      },
      setFlipY: function setFlipY(flipY) {
        if (this._flipY !== flipY) {
          var opts = _getSharedOptions();
          opts.flipY = flipY;
          opts.premultiplyAlpha = this._premultiplyAlpha;
          this.update(opts);
        }
      },
      setPremultiplyAlpha: function setPremultiplyAlpha(premultiply) {
        if (this._premultiplyAlpha !== premultiply) {
          var opts = _getSharedOptions();
          opts.flipY = this._flipY;
          opts.premultiplyAlpha = premultiply;
          this.update(opts);
        }
      },
      _updateFormat: function _updateFormat() {
        this._isAlphaAtlas = this._format === PixelFormat.RGBA_ETC1 || this._format === PixelFormat.RGB_A_PVRTC_4BPPV1 || this._format === PixelFormat.RGB_A_PVRTC_2BPPV1;
        true;
        this._texture.setAlphaAtlas(this._isAlphaAtlas);
      },
      _checkPackable: function _checkPackable() {
        var dynamicAtlas = cc.dynamicAtlasManager;
        if (!dynamicAtlas) return;
        if (this._isCompressed()) {
          this._packable = false;
          return;
        }
        var w = this.width, h = this.height;
        if (!this._image || w > dynamicAtlas.maxFrameSize || h > dynamicAtlas.maxFrameSize || this._getHash() !== dynamicAtlas.Atlas.DEFAULT_HASH) {
          this._packable = false;
          return;
        }
        this._image && this._image instanceof HTMLCanvasElement && (this._packable = true);
      },
      _getOpts: function _getOpts() {
        var opts = _getSharedOptions();
        opts.width = this.width;
        opts.height = this.height;
        opts.genMipmaps = this._genMipmaps;
        opts.format = this._format;
        opts.premultiplyAlpha = this._premultiplyAlpha;
        opts.anisotropy = this._anisotropy;
        opts.flipY = this._flipY;
        opts.minFilter = FilterIndex[this._minFilter];
        opts.magFilter = FilterIndex[this._magFilter];
        opts.mipFilter = FilterIndex[this._mipFilter];
        opts.wrapS = this._wrapS;
        opts.wrapT = this._wrapT;
        return opts;
      },
      _getGFXPixelFormat: function _getGFXPixelFormat(format) {
        format === PixelFormat.RGBA_ETC1 ? format = PixelFormat.RGB_ETC1 : format === PixelFormat.RGB_A_PVRTC_4BPPV1 ? format = PixelFormat.RGB_PVRTC_4BPPV1 : format === PixelFormat.RGB_A_PVRTC_2BPPV1 && (format = PixelFormat.RGB_PVRTC_2BPPV1);
        return format;
      },
      _resetUnderlyingMipmaps: function _resetUnderlyingMipmaps(mipmapSources) {
        var opts = this._getOpts();
        opts.images = mipmapSources || [ null ];
        this._texture ? this._texture.update(opts) : this._texture = new renderer.Texture2D(renderer.device, opts);
      },
      _serialize: (false, false) && function() {
        var extId = "";
        var exportedExts = this._exportedExts;
        !exportedExts && this._native && (exportedExts = [ this._native ]);
        if (exportedExts) {
          var exts = [];
          for (var i = 0; i < exportedExts.length; i++) {
            var _extId = "";
            var ext = exportedExts[i];
            if (ext) {
              var extFormat = ext.split("@");
              _extId = Texture2D.extnames.indexOf(extFormat[0]);
              _extId < 0 && (_extId = ext);
              extFormat[1] && (_extId += "@" + extFormat[1]);
            }
            exts.push(_extId);
          }
          extId = exts.join("_");
        }
        var asset = extId + "," + this._minFilter + "," + this._magFilter + "," + this._wrapS + "," + this._wrapT + "," + (this._premultiplyAlpha ? 1 : 0) + "," + (this._genMipmaps ? 1 : 0) + "," + (this._packable ? 1 : 0);
        return asset;
      },
      _deserialize: function _deserialize(data) {
        var fields = data.split(",");
        var extIdStr = fields[0];
        if (extIdStr) {
          var result = Texture2D._parseExt(extIdStr, this._format);
          if (result.bestExt) {
            this._setRawAsset(result.bestExt);
            this._format = result.bestFormat;
          } else {
            if (!result.defaultExt) throw new Error(cc.debug.getError(3121));
            this._setRawAsset(result.defaultExt);
            cc.warnID(3120, result.defaultExt, result.defaultExt);
          }
        }
        if (8 === fields.length) {
          this._minFilter = parseInt(fields[1]);
          this._magFilter = parseInt(fields[2]);
          this._wrapS = parseInt(fields[3]);
          this._wrapT = parseInt(fields[4]);
          this._premultiplyAlpha = fields[5].charCodeAt(0) === CHAR_CODE_1;
          this._genMipmaps = fields[6].charCodeAt(0) === CHAR_CODE_1;
          this._packable = fields[7].charCodeAt(0) === CHAR_CODE_1;
        }
      },
      _getHash: function _getHash() {
        if (!this._hashDirty) return this._hash;
        var genMipmaps = this._genMipmaps ? 1 : 0;
        var premultiplyAlpha = this._premultiplyAlpha ? 1 : 0;
        var flipY = this._flipY ? 1 : 0;
        var minFilter = this._minFilter === Filter.LINEAR ? 1 : 2;
        var magFilter = this._magFilter === Filter.LINEAR ? 1 : 2;
        var wrapS = this._wrapS === WrapMode.REPEAT ? 1 : this._wrapS === WrapMode.CLAMP_TO_EDGE ? 2 : 3;
        var wrapT = this._wrapT === WrapMode.REPEAT ? 1 : this._wrapT === WrapMode.CLAMP_TO_EDGE ? 2 : 3;
        var pixelFormat = this._format;
        var image = this._image;
        if (true, image) {
          image._glFormat && image._glFormat !== GL_RGBA && (pixelFormat = 0);
          premultiplyAlpha = image._premultiplyAlpha ? 1 : 0;
        }
        this._hash = Number("" + minFilter + magFilter + pixelFormat + wrapS + wrapT + genMipmaps + premultiplyAlpha + flipY);
        this._hashDirty = false;
        return this._hash;
      },
      _isCompressed: function _isCompressed() {
        return this._format < PixelFormat.A8 || this._format > PixelFormat.RGBA32F;
      },
      _clearImage: function _clearImage() {
        this._image.src = "";
      },
      _checkImageBitmap: function _checkImageBitmap(cb) {
        var _this = this;
        var image = this._image;
        var flipY = this._flipY;
        var premultiplyAlpha = this._premultiplyAlpha;
        this._flipY !== image.flipY || this._premultiplyAlpha !== image.premultiplyAlpha ? createImageBitmap(image, {
          imageOrientation: flipY !== image.flipY ? "flipY" : "none",
          premultiplyAlpha: premultiplyAlpha ? "premultiply" : "none"
        }).then((function(result) {
          image.close && image.close();
          result.flipY = flipY;
          result.premultiplyAlpha = premultiplyAlpha;
          _this._image = result;
          cb();
        }), (function(err) {
          cc.error(err.message);
        })) : cb();
      },
      linkMaterial: function linkMaterial(material, index) {
        var handler = material.getMultiHandler();
        if (handler) {
          if (null == index) {
            if (-1 === handler.autoSetTexture(this)) return false;
          } else handler.setTexture(index, this);
          this.unlinkMaterial();
          this._multiMaterial = material;
          return true;
        }
        return false;
      },
      unlinkMaterial: function unlinkMaterial() {
        if (this._multiMaterial) {
          var handler = this._multiMaterial.getMultiHandler();
          var _texture = this.getImpl();
          handler.removeTexture(_texture);
          this._multiMaterial = null;
        }
      },
      getLinkedMaterial: function getLinkedMaterial() {
        return this._multiMaterial;
      },
      hasLinkedMaterial: function hasLinkedMaterial() {
        return !!this._multiMaterial;
      }
    });
    cc.Texture2D = module.exports = Texture2D;
  }), {
    "../../renderer/gfx": 427,
    "../assets/CCAsset": 137,
    "../event/event-target": 219,
    "../platform/CCClass": 272,
    "../platform/id-generater": 290,
    "../renderer": 322
  } ],
  153: [ (function(require, module, exports) {
    "use strict";
    var Asset = require("./CCAsset");
    var EventTarget = require("../event/event-target");
    var VideoClip = cc.Class({
      name: "cc.VideoClip",
      extends: Asset,
      mixins: [ EventTarget ]
    });
    cc.VideoClip = VideoClip;
    module.exports = VideoClip;
  }), {
    "../event/event-target": 219,
    "./CCAsset": 137
  } ],
  154: [ (function(require, module, exports) {
    "use strict";
    require("./CCAsset");
    require("./CCFont");
    require("./CCPrefab");
    require("./CCAudioClip");
    require("./CCVideoClip");
    require("./CCScripts");
    require("./CCSceneAsset");
    require("./CCSpriteFrame");
    require("./CCTexture2D");
    require("./CCRenderTexture");
    require("./CCTTFFont");
    require("./CCSpriteAtlas");
    require("./CCBitmapFont");
    require("./CCLabelAtlas");
    require("./CCTextAsset");
    require("./CCJsonAsset");
    require("./CCBufferAsset");
    require("./material");
  }), {
    "./CCAsset": 137,
    "./CCAudioClip": 138,
    "./CCBitmapFont": 139,
    "./CCBufferAsset": 140,
    "./CCFont": 141,
    "./CCJsonAsset": 142,
    "./CCLabelAtlas": 143,
    "./CCPrefab": 144,
    "./CCRenderTexture": 145,
    "./CCSceneAsset": 146,
    "./CCScripts": 147,
    "./CCSpriteAtlas": 148,
    "./CCSpriteFrame": 149,
    "./CCTTFFont": 150,
    "./CCTextAsset": 151,
    "./CCTexture2D": 152,
    "./CCVideoClip": 153,
    "./material": 161
  } ],
  155: [ (function(require, module, exports) {
    "use strict";
    var _CCAsset = _interopRequireDefault(require("../CCAsset"));
    var _effectParser = require("./effect-parser");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var EffectAsset = cc.Class({
      name: "cc.EffectAsset",
      extends: _CCAsset["default"],
      ctor: function ctor() {
        this._effect = null;
      },
      properties: {
        properties: Object,
        techniques: [],
        shaders: []
      },
      onLoad: function onLoad() {
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) return;
        var lib = cc.renderer._forward._programLib;
        for (var i = 0; i < this.shaders.length; i++) lib.define(this.shaders[i]);
        this._initEffect();
      },
      _initEffect: function _initEffect() {
        if (this._effect) return;
        this._effect = (0, _effectParser.parseEffect)(this);
        Object.freeze(this._effect);
      },
      getInstantiatedEffect: function getInstantiatedEffect() {
        this._initEffect();
        return this._effect.clone();
      },
      getEffect: function getEffect() {
        this._initEffect();
        return this._effect;
      }
    });
    module.exports = cc.EffectAsset = EffectAsset;
  }), {
    "../CCAsset": 137,
    "./effect-parser": 158
  } ],
  156: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var Asset = require("../CCAsset");
    var Texture = require("../CCTexture2D");
    var PixelFormat = Texture.PixelFormat;
    var EffectAsset = require("./CCEffectAsset");
    var textureUtil = require("../../utils/texture-util");
    var gfx = cc.gfx;
    var BUILTIN_NAME = cc.Enum({
      SPRITE: "2d-sprite",
      GRAY_SPRITE: "2d-gray-sprite",
      UNLIT: "unlit"
    });
    var Material = cc.Class({
      name: "cc.Material",
      extends: Asset,
      ctor: function ctor() {
        this.loaded = false;
        this._manualHash = false;
        this._dirty = true;
        this._effect = null;
        this._multiHandler = null;
      },
      properties: {
        _defines: {
          default: void 0,
          type: Object
        },
        _props: {
          default: void 0,
          type: Object
        },
        _effectAsset: {
          type: EffectAsset,
          default: null
        },
        _techniqueIndex: 0,
        _techniqueData: Object,
        effectName: void 0,
        effectAsset: {
          get: function get() {
            return this._effectAsset;
          },
          set: function set(asset) {
            if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) return;
            this._effectAsset = asset;
            if (!asset) {
              cc.error("Can not set an empty effect asset.");
              return;
            }
            this._effect = this._effectAsset.getInstantiatedEffect();
            this.updateMultiSupport();
          }
        },
        effect: {
          get: function get() {
            return this._effect;
          }
        },
        techniqueIndex: {
          get: function get() {
            return this._techniqueIndex;
          },
          set: function set(v) {
            this._techniqueIndex = v;
            this._effect.switchTechnique(v);
            this.updateMultiSupport();
          }
        }
      },
      statics: {
        getBuiltinMaterial: function getBuiltinMaterial(name) {
          if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) return new cc.Material();
          return cc.assetManager.builtins.getBuiltin("material", "builtin-" + name);
        },
        BUILTIN_NAME: BUILTIN_NAME,
        createWithBuiltin: function createWithBuiltin(effectName, techniqueIndex) {
          void 0 === techniqueIndex && (techniqueIndex = 0);
          var effectAsset = cc.assetManager.builtins.getBuiltin("effect", "builtin-" + effectName);
          return Material.create(effectAsset, techniqueIndex);
        },
        create: function create(effectAsset, techniqueIndex) {
          void 0 === techniqueIndex && (techniqueIndex = 0);
          if (!effectAsset) return null;
          var material = new Material();
          material.effectAsset = effectAsset;
          material.techniqueIndex = techniqueIndex;
          return material;
        }
      },
      setProperty: function setProperty(name, val, passIdx, directly) {
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) return;
        "string" === typeof passIdx && (passIdx = parseInt(passIdx));
        if (val instanceof Texture) {
          var isAlphaAtlas = val.isAlphaAtlas();
          var key = "CC_USE_ALPHA_ATLAS_" + name;
          var def = this.getDefine(key, passIdx);
          (isAlphaAtlas || def) && this.define(key, isAlphaAtlas);
          val.loaded || cc.assetManager.postLoadNative(val);
        }
        this._effect.setProperty(name, val, passIdx, directly);
      },
      getProperty: function getProperty(name, passIdx) {
        "string" === typeof passIdx && (passIdx = parseInt(passIdx));
        return this._effect.getProperty(name, passIdx);
      },
      define: function define(name, val, passIdx, force) {
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) return;
        "string" === typeof passIdx && (passIdx = parseInt(passIdx));
        this._effect.define(name, val, passIdx, force);
      },
      getDefine: function getDefine(name, passIdx) {
        "string" === typeof passIdx && (passIdx = parseInt(passIdx));
        return this._effect.getDefine(name, passIdx);
      },
      setCullMode: function setCullMode(cullMode, passIdx) {
        void 0 === cullMode && (cullMode = gfx.CULL_BACK);
        this._effect.setCullMode(cullMode, passIdx);
      },
      setDepth: function setDepth(depthTest, depthWrite, depthFunc, passIdx) {
        void 0 === depthTest && (depthTest = false);
        void 0 === depthWrite && (depthWrite = false);
        void 0 === depthFunc && (depthFunc = gfx.DS_FUNC_LESS);
        this._effect.setDepth(depthTest, depthWrite, depthFunc, passIdx);
      },
      setBlend: function setBlend(enabled, blendEq, blendSrc, blendDst, blendAlphaEq, blendSrcAlpha, blendDstAlpha, blendColor, passIdx) {
        void 0 === enabled && (enabled = false);
        void 0 === blendEq && (blendEq = gfx.BLEND_FUNC_ADD);
        void 0 === blendSrc && (blendSrc = gfx.BLEND_SRC_ALPHA);
        void 0 === blendDst && (blendDst = gfx.BLEND_ONE_MINUS_SRC_ALPHA);
        void 0 === blendAlphaEq && (blendAlphaEq = gfx.BLEND_FUNC_ADD);
        void 0 === blendSrcAlpha && (blendSrcAlpha = gfx.BLEND_SRC_ALPHA);
        void 0 === blendDstAlpha && (blendDstAlpha = gfx.BLEND_ONE_MINUS_SRC_ALPHA);
        void 0 === blendColor && (blendColor = 4294967295);
        this._effect.setBlend(enabled, blendEq, blendSrc, blendDst, blendAlphaEq, blendSrcAlpha, blendDstAlpha, blendColor, passIdx);
      },
      setStencilEnabled: function setStencilEnabled(stencilTest, passIdx) {
        void 0 === stencilTest && (stencilTest = gfx.STENCIL_INHERIT);
        this._effect.setStencilEnabled(stencilTest, passIdx);
      },
      setStencil: function setStencil(stencilTest, stencilFunc, stencilRef, stencilMask, stencilFailOp, stencilZFailOp, stencilZPassOp, stencilWriteMask, passIdx) {
        void 0 === stencilTest && (stencilTest = gfx.STENCIL_INHERIT);
        void 0 === stencilFunc && (stencilFunc = gfx.DS_FUNC_ALWAYS);
        void 0 === stencilRef && (stencilRef = 0);
        void 0 === stencilMask && (stencilMask = 255);
        void 0 === stencilFailOp && (stencilFailOp = gfx.STENCIL_OP_KEEP);
        void 0 === stencilZFailOp && (stencilZFailOp = gfx.STENCIL_OP_KEEP);
        void 0 === stencilZPassOp && (stencilZPassOp = gfx.STENCIL_OP_KEEP);
        void 0 === stencilWriteMask && (stencilWriteMask = 255);
        this._effect.setStencil(stencilTest, stencilFunc, stencilRef, stencilMask, stencilFailOp, stencilZFailOp, stencilZPassOp, stencilWriteMask, passIdx);
      },
      updateHash: function updateHash(hash) {
        this._manualHash = hash;
        this._effect && this._effect.updateHash(hash);
      },
      getHash: function getHash() {
        return this._manualHash || this._effect && this._effect.getHash();
      },
      onLoad: function onLoad() {
        this.effectAsset = this._effectAsset;
        if (!this._effect) return;
        this._techniqueIndex && this._effect.switchTechnique(this._techniqueIndex);
        this._techniqueData = this._techniqueData || {};
        var passDatas = this._techniqueData;
        for (var index in passDatas) {
          index = parseInt(index);
          var passData = passDatas[index];
          if (!passData) continue;
          for (var def in passData.defines) this.define(def, passData.defines[def], index);
          for (var prop in passData.props) this.setProperty(prop, passData.props[prop], index);
        }
        this.updateMultiSupport();
        this._multiHandler && this._multiHandler.syncTextures();
      },
      updateMultiSupport: function updateMultiSupport() {
        var passes = this._effect.technique.passes;
        passes.length > 0 && passes[0].getDefine("USE_MULTI_TEXTURE") ? this.setMultiSupport(true) : this.setMultiSupport(false);
      },
      isMultiSupport: function isMultiSupport() {
        return !!this._multiHandler;
      },
      setMultiSupport: function setMultiSupport(bool) {
        bool ? this._multiHandler ? this._multiHandler.syncTextures() : this._multiHandler = new cc.sp.MultiHandler(this) : bool || (this._multiHandler = null);
      },
      getMultiHandler: function getMultiHandler() {
        return this._multiHandler;
      }
    });
    var _default = Material;
    exports["default"] = _default;
    cc.Material = Material;
    module.exports = exports["default"];
  }), {
    "../../utils/texture-util": 394,
    "../CCAsset": 137,
    "../CCTexture2D": 152,
    "./CCEffectAsset": 155
  } ],
  157: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _pass = _interopRequireDefault(require("../../../renderer/core/pass"));
    var _enums = _interopRequireDefault(require("../../../renderer/enums"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var gfx = cc.gfx;
    var EffectBase = (function() {
      function EffectBase() {
        this._dirty = true;
        this._name = "";
        this._technique = null;
      }
      var _proto = EffectBase.prototype;
      _proto._createPassProp = function _createPassProp(name, pass) {
        var prop = pass._properties[name];
        if (!prop) return;
        var uniform = Object.create(null);
        uniform.name = name;
        uniform.type = prop.type;
        prop.value instanceof Float32Array ? uniform.value = new Float32Array(prop.value) : prop.value instanceof Float64Array ? uniform.value = new Float64Array(prop.value) : uniform.value = prop.value;
        pass._properties[name] = uniform;
        return uniform;
      };
      _proto._setPassProperty = function _setPassProperty(name, value, pass, directly) {
        var properties = pass._properties;
        properties.hasOwnProperty(name) || this._createPassProp(name, pass);
        var prop = properties[name];
        var compareValue = value;
        prop.type === _enums["default"].PARAM_TEXTURE_2D && (compareValue = value && value.getImpl());
        if (prop.value === compareValue) return true;
        this._dirty = true;
        return _pass["default"].prototype.setProperty.call(pass, name, value, directly);
      };
      _proto.setProperty = function setProperty(name, value, passIdx, directly) {
        var success = false;
        var passes = this.passes;
        var start = 0, end = passes.length;
        void 0 !== passIdx && (start = passIdx, end = passIdx + 1);
        for (var i = start; i < end; i++) this._setPassProperty(name, value, passes[i], directly) && (success = true);
        success || cc.warnID(9103, this.name, name);
      };
      _proto.getProperty = function getProperty(name, passIdx) {
        var passes = this.passes;
        if (passIdx >= passes.length) return;
        var start = 0, end = passes.length;
        void 0 !== passIdx && (start = passIdx, end = passIdx + 1);
        for (var i = start; i < end; i++) {
          var value = passes[i].getProperty(name);
          if (void 0 !== value) return value;
        }
      };
      _proto.define = function define(name, value, passIdx, force) {
        var success = false;
        var passes = this.passes;
        var start = 0, end = passes.length;
        void 0 !== passIdx && (start = passIdx, end = passIdx + 1);
        for (var i = start; i < end; i++) passes[i].define(name, value, force) && (success = true);
        success || cc.warnID(9104, this.name, name);
      };
      _proto.getDefine = function getDefine(name, passIdx) {
        var passes = this.passes;
        if (passIdx >= passes.length) return;
        var start = 0, end = passes.length;
        void 0 !== passIdx && (start = passIdx, end = passIdx + 1);
        for (var i = start; i < end; i++) {
          var value = passes[i].getDefine(name);
          if (void 0 !== value) return value;
        }
      };
      _proto.setCullMode = function setCullMode(cullMode, passIdx) {
        void 0 === cullMode && (cullMode = gfx.CULL_BACK);
        var passes = this.passes;
        var start = 0, end = passes.length;
        void 0 !== passIdx && (start = passIdx, end = passIdx + 1);
        for (var i = start; i < end; i++) passes[i].setCullMode(cullMode);
        this._dirty = true;
      };
      _proto.setDepth = function setDepth(depthTest, depthWrite, depthFunc, passIdx) {
        var passes = this.passes;
        var start = 0, end = passes.length;
        void 0 !== passIdx && (start = passIdx, end = passIdx + 1);
        for (var i = start; i < end; i++) passes[i].setDepth(depthTest, depthWrite, depthFunc);
        this._dirty = true;
      };
      _proto.setBlend = function setBlend(enabled, blendEq, blendSrc, blendDst, blendAlphaEq, blendSrcAlpha, blendDstAlpha, blendColor, passIdx) {
        var passes = this.passes;
        var start = 0, end = passes.length;
        void 0 !== passIdx && (start = passIdx, end = passIdx + 1);
        for (var i = start; i < end; i++) passes[i].setBlend(enabled, blendEq, blendSrc, blendDst, blendAlphaEq, blendSrcAlpha, blendDstAlpha, blendColor);
        this._dirty = true;
      };
      _proto.setStencilEnabled = function setStencilEnabled(stencilTest, passIdx) {
        void 0 === stencilTest && (stencilTest = gfx.STENCIL_INHERIT);
        var passes = this.passes;
        var start = 0, end = passes.length;
        void 0 !== passIdx && (start = passIdx, end = passIdx + 1);
        for (var i = start; i < end; i++) passes[i].setStencilEnabled(stencilTest);
        this._dirty = true;
      };
      _proto.setStencil = function setStencil(enabled, stencilFunc, stencilRef, stencilMask, stencilFailOp, stencilZFailOp, stencilZPassOp, stencilWriteMask, passIdx) {
        var passes = this.passes;
        var start = 0, end = passes.length;
        void 0 !== passIdx && (start = passIdx, end = passIdx + 1);
        for (var i = start; i < end; i++) {
          var pass = passes[i];
          pass.setStencilFront(enabled, stencilFunc, stencilRef, stencilMask, stencilFailOp, stencilZFailOp, stencilZPassOp, stencilWriteMask);
          pass.setStencilBack(enabled, stencilFunc, stencilRef, stencilMask, stencilFailOp, stencilZFailOp, stencilZPassOp, stencilWriteMask);
        }
        this._dirty = true;
      };
      _createClass(EffectBase, [ {
        key: "name",
        get: function get() {
          return this._name;
        }
      }, {
        key: "technique",
        get: function get() {
          return this._technique;
        }
      }, {
        key: "passes",
        get: function get() {
          return [];
        }
      } ]);
      return EffectBase;
    })();
    exports["default"] = EffectBase;
    cc.EffectBase = EffectBase;
    module.exports = exports["default"];
  }), {
    "../../../renderer/core/pass": 424,
    "../../../renderer/enums": 426
  } ],
  158: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.parseEffect = parseEffect;
    var _pass = _interopRequireDefault(require("../../../renderer/core/pass"));
    var _types = require("../../../renderer/types");
    var _enums = _interopRequireDefault(require("../../../renderer/enums"));
    var _effect = _interopRequireDefault(require("./effect"));
    var _technique = _interopRequireDefault(require("../../../renderer/core/technique"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function getInvolvedProgram(programName) {
      var lib = cc.renderer._forward._programLib;
      return lib.getTemplate(programName);
    }
    function parseProperties(effectAsset, passJson) {
      var propertiesJson = passJson.properties || {};
      var program = getInvolvedProgram(passJson.program);
      var _loop = function _loop(prop) {
        var uniformInfo = program.uniforms.find((function(u) {
          return u.name === prop;
        }));
        if (!uniformInfo) {
          cc.warnID(9107, effectAsset.name, prop);
          return "continue";
        }
      };
      for (var prop in propertiesJson) {
        var _ret = _loop(prop);
        if ("continue" === _ret) continue;
      }
      var properties = {};
      program.uniforms.forEach((function(u) {
        var name = u.name, prop = properties[name] = Object.assign({}, u), propInfo = propertiesJson[name];
        var value;
        value = propInfo ? propInfo.type === _enums["default"].PARAM_TEXTURE_2D ? null : propInfo.type === _enums["default"].PARAM_INT || propInfo.type === _enums["default"].PARAM_FLOAT ? Array.isArray(propInfo.value) ? propInfo.value[0] : propInfo.value : new Float32Array(propInfo.value) : _types.enums2default[u.type];
        void 0 === value && (value = null);
        prop.value = value;
      }));
      return properties;
    }
    function passDefines(pass) {
      var defines = {};
      var program = getInvolvedProgram(pass.program);
      program.defines.forEach((function(d) {
        defines[d.name] = _types.enums2default[d.type];
      }));
      return defines;
    }
    function parseTechniques(effectAsset) {
      var techNum = effectAsset.techniques.length;
      var techniques = new Array(techNum);
      for (var j = 0; j < techNum; ++j) {
        var tech = effectAsset.techniques[j];
        var techName = tech.name || j;
        var passNum = tech.passes.length;
        var passes = new Array(passNum);
        for (var k = 0; k < passNum; ++k) {
          var pass = tech.passes[k];
          var passName = pass.name || k;
          var detailName = effectAsset.name + "-" + techName + "-" + passName;
          var stage = pass.stage || "opaque";
          var properties = parseProperties(effectAsset, pass);
          var defines = passDefines(pass);
          var newPass = passes[k] = new _pass["default"](passName, detailName, pass.program, stage, properties, defines);
          pass.rasterizerState && newPass.setCullMode(pass.rasterizerState.cullMode);
          var blendState = pass.blendState && pass.blendState.targets[0];
          blendState && newPass.setBlend(blendState.blend, blendState.blendEq, blendState.blendSrc, blendState.blendDst, blendState.blendAlphaEq, blendState.blendSrcAlpha, blendState.blendDstAlpha, blendState.blendColor);
          var depthStencilState = pass.depthStencilState;
          if (depthStencilState) {
            newPass.setDepth(depthStencilState.depthTest, depthStencilState.depthWrite, depthStencilState.depthFunc);
            newPass.setStencilFront(depthStencilState.stencilTest, depthStencilState.stencilFuncFront, depthStencilState.stencilRefFront, depthStencilState.stencilMaskFront, depthStencilState.stencilFailOpFront, depthStencilState.stencilZFailOpFront, depthStencilState.stencilZPassOpFront, depthStencilState.stencilWriteMaskFront);
            newPass.setStencilBack(depthStencilState.stencilTest, depthStencilState.stencilFuncBack, depthStencilState.stencilRefBack, depthStencilState.stencilMaskBack, depthStencilState.stencilFailOpBack, depthStencilState.stencilZFailOpBack, depthStencilState.stencilZPassOpBack, depthStencilState.stencilWriteMaskBack);
          }
        }
        techniques[j] = new _technique["default"](techName, passes);
      }
      return techniques;
    }
    function parseEffect(effect) {
      var techniques = parseTechniques(effect);
      return new _effect["default"](effect.name, techniques, 0, effect);
    }
    false;
  }), {
    "../../../renderer/core/pass": 424,
    "../../../renderer/core/technique": 425,
    "../../../renderer/enums": 426,
    "../../../renderer/types": 432,
    "./effect": 160
  } ],
  159: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _murmurhash2_gc = _interopRequireDefault(require("../../../renderer/murmurhash2_gc"));
    var _utils = _interopRequireDefault(require("./utils"));
    var _effectBase = _interopRequireDefault(require("./effect-base"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var gfx = cc.gfx;
    var EffectVariant = (function(_EffectBase) {
      _inheritsLoose(EffectVariant, _EffectBase);
      function EffectVariant(effect) {
        var _this;
        _this = _EffectBase.call(this) || this;
        _this._effect = void 0;
        _this._passes = [];
        _this._stagePasses = {};
        _this._hash = 0;
        _this.init(effect);
        return _this;
      }
      var _proto = EffectVariant.prototype;
      _proto._onEffectChanged = function _onEffectChanged() {};
      _proto.init = function init(effect) {
        effect instanceof EffectVariant && (effect = effect.effect);
        this._effect = effect;
        this._dirty = true;
        if (effect) {
          var passes = effect.passes;
          var variantPasses = this._passes;
          variantPasses.length = 0;
          var stagePasses = this._stagePasses = {};
          for (var i = 0; i < passes.length; i++) {
            var variant = variantPasses[i] = Object.setPrototypeOf({}, passes[i]);
            variant._properties = Object.setPrototypeOf({}, passes[i]._properties);
            variant._defines = Object.setPrototypeOf({}, passes[i]._defines);
            stagePasses[variant._stage] || (stagePasses[variant._stage] = []);
            stagePasses[variant._stage].push(variant);
          }
        }
      };
      _proto.updateHash = function updateHash(hash) {};
      _proto.getHash = function getHash() {
        if (!this._dirty) return this._hash;
        this._dirty = false;
        var hash = "";
        hash += _utils["default"].serializePasses(this._passes);
        var effect = this._effect;
        effect && (hash += effect._id);
        this._hash = (0, _murmurhash2_gc["default"])(hash, 666);
        this.updateHash(this._hash);
        return this._hash;
      };
      _createClass(EffectVariant, [ {
        key: "effect",
        get: function get() {
          return this._effect;
        }
      }, {
        key: "name",
        get: function get() {
          return this._effect && this._effect.name + " (variant)";
        }
      }, {
        key: "passes",
        get: function get() {
          return this._passes;
        }
      }, {
        key: "stagePasses",
        get: function get() {
          return this._stagePasses;
        }
      } ]);
      return EffectVariant;
    })(_effectBase["default"]);
    exports["default"] = EffectVariant;
    cc.EffectVariant = EffectVariant;
    module.exports = exports["default"];
  }), {
    "../../../renderer/murmurhash2_gc": 431,
    "./effect-base": 157,
    "./utils": 164
  } ],
  160: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _effectBase = _interopRequireDefault(require("./effect-base"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Effect = (function(_EffectBase) {
      _inheritsLoose(Effect, _EffectBase);
      function Effect(name, techniques, techniqueIndex, asset) {
        var _this;
        _this = _EffectBase.call(this) || this;
        _this._techniques = [];
        _this._asset = null;
        _this._id = "";
        _this.init(name, techniques, techniqueIndex, asset, true);
        _this._id = "|" + Effect.id++;
        return _this;
      }
      var _proto = Effect.prototype;
      _proto.init = function init(name, techniques, techniqueIndex, asset, createNative) {
        this._name = name;
        this._techniques = techniques;
        this._technique = techniques[techniqueIndex];
        this._asset = asset;
      };
      _proto.switchTechnique = function switchTechnique(index) {
        if (index >= this._techniques.length) {
          cc.warn("Can not switch to technique with index [" + index + "]");
          return;
        }
        this._technique = this._techniques[index];
      };
      _proto.clear = function clear() {
        this._techniques = [];
      };
      _proto.clone = function clone() {
        var techniques = [];
        for (var i = 0; i < this._techniques.length; i++) techniques.push(this._techniques[i].clone());
        var techniqueIndex = this._techniques.indexOf(this._technique);
        return new Effect(this._name, techniques, techniqueIndex, this._asset);
      };
      _createClass(Effect, [ {
        key: "technique",
        get: function get() {
          return this._technique;
        }
      }, {
        key: "passes",
        get: function get() {
          return this._technique.passes;
        }
      } ]);
      return Effect;
    })(_effectBase["default"]);
    exports["default"] = Effect;
    Effect.id = 0;
    cc.Effect = Effect;
    module.exports = exports["default"];
  }), {
    "./effect-base": 157
  } ],
  161: [ (function(require, module, exports) {
    "use strict";
    require("./CCEffectAsset");
    require("./CCMaterial");
    require("./material-variant");
  }), {
    "./CCEffectAsset": 155,
    "./CCMaterial": 156,
    "./material-variant": 163
  } ],
  162: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _utils = _interopRequireDefault(require("./utils"));
    var _pool = _interopRequireDefault(require("../../utils/pool"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var MaterialPool = (function(_Pool) {
      _inheritsLoose(MaterialPool, _Pool);
      function MaterialPool() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        _this = _Pool.call.apply(_Pool, [ this ].concat(args)) || this;
        _this.enabled = false;
        _this._pool = {};
        return _this;
      }
      var _proto = MaterialPool.prototype;
      _proto.get = function get(exampleMat, renderComponent) {
        var pool = this._pool;
        if (exampleMat instanceof cc.MaterialVariant) {
          if (!exampleMat._owner) {
            exampleMat._owner = renderComponent;
            return exampleMat;
          }
          if (exampleMat._owner === renderComponent) return exampleMat;
          exampleMat = exampleMat.material;
        }
        var instance;
        if (this.enabled) {
          var uuid = exampleMat.effectAsset._uuid;
          if (pool[uuid]) {
            var key = _utils["default"].serializeDefines(exampleMat._effect._defines) + _utils["default"].serializeTechniques(exampleMat._effect._techniques);
            instance = pool[uuid][key] && pool[uuid][key].pop();
          }
        }
        if (instance) this.count--; else {
          instance = new cc.MaterialVariant(exampleMat);
          instance._name = exampleMat._name + " (Instance)";
          instance._uuid = exampleMat._uuid;
        }
        instance._owner = renderComponent;
        return instance;
      };
      _proto.put = function put(mat) {
        if (!this.enabled || !mat._owner) return;
        var pool = this._pool;
        var uuid = mat.effectAsset._uuid;
        pool[uuid] || (pool[uuid] = {});
        var key = _utils["default"].serializeDefines(mat._effect._defines) + _utils["default"].serializeTechniques(mat._effect._techniques);
        pool[uuid][key] || (pool[uuid][key] = []);
        if (this.count > this.maxSize) return;
        this._clean(mat);
        pool[uuid][key].push(mat);
        this.count++;
      };
      _proto.clear = function clear() {
        this._pool = {};
        this.count = 0;
      };
      _proto._clean = function _clean(mat) {
        mat._owner = null;
      };
      return MaterialPool;
    })(_pool["default"]);
    var materialPool = new MaterialPool();
    _pool["default"].register("material", materialPool);
    var _default = materialPool;
    exports["default"] = _default;
    module.exports = exports["default"];
  }), {
    "../../utils/pool": 388,
    "./utils": 164
  } ],
  163: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _CCMaterial = _interopRequireDefault(require("./CCMaterial"));
    var _effectVariant = _interopRequireDefault(require("./effect-variant"));
    var _materialPool = _interopRequireDefault(require("./material-pool"));
    var _dec, _class;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var ccclass = cc._decorator.ccclass;
    var MaterialVariant = (_dec = ccclass("cc.MaterialVariant"), _dec(_class = (function(_Material) {
      _inheritsLoose(MaterialVariant, _Material);
      MaterialVariant.createWithBuiltin = function createWithBuiltin(materialName, owner) {
        return MaterialVariant.create(_CCMaterial["default"].getBuiltinMaterial(materialName), owner);
      };
      MaterialVariant.create = function create(material, owner) {
        if (!material) return null;
        return _materialPool["default"].get(material, owner);
      };
      function MaterialVariant(material) {
        var _this;
        _this = _Material.call(this) || this;
        _this._owner = null;
        _this._material = null;
        _this.init(material);
        return _this;
      }
      var _proto = MaterialVariant.prototype;
      _proto.init = function init(material) {
        this._effect = new _effectVariant["default"](material.effect);
        this._effectAsset = material._effectAsset;
        this._material = material;
      };
      _createClass(MaterialVariant, [ {
        key: "uuid",
        get: function get() {
          return this._material._uuid;
        }
      }, {
        key: "owner",
        get: function get() {
          return this._owner;
        }
      }, {
        key: "material",
        get: function get() {
          return this._material;
        }
      } ]);
      return MaterialVariant;
    })(_CCMaterial["default"])) || _class);
    exports["default"] = MaterialVariant;
    cc.MaterialVariant = MaterialVariant;
    module.exports = exports["default"];
  }), {
    "./CCMaterial": 156,
    "./effect-variant": 159,
    "./material-pool": 162
  } ],
  164: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _enums = _interopRequireDefault(require("../../../renderer/enums"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var hashArray = [];
    function serializeDefines(defines, names) {
      var i = 0;
      for (var name in defines) if (Object.hasOwnProperty.call(defines, name)) {
        hashArray[i] = name + defines[name];
        i++;
      }
      hashArray.length = i;
      return hashArray.join("");
    }
    function serializePass(pass, excludeProperties) {
      var str = pass._programName + pass._cullMode;
      pass._blend && (str += pass._blendEq + pass._blendAlphaEq + pass._blendSrc + pass._blendDst + pass._blendSrcAlpha + pass._blendDstAlpha + pass._blendColor);
      pass._depthTest && (str += pass._depthWrite + pass._depthFunc);
      pass._stencilTest && (str += pass._stencilFuncFront + pass._stencilRefFront + pass._stencilMaskFront + pass._stencilFailOpFront + pass._stencilZFailOpFront + pass._stencilZPassOpFront + pass._stencilWriteMaskFront + pass._stencilFuncBack + pass._stencilRefBack + pass._stencilMaskBack + pass._stencilFailOpBack + pass._stencilZFailOpBack + pass._stencilZPassOpBack + pass._stencilWriteMaskBack);
      excludeProperties || (str += serializeUniforms(pass._properties, pass._propertyNames));
      str += serializeDefines(pass._defines, pass._defineNames);
      return str;
    }
    function serializePasses(passes) {
      var hashData = "";
      for (var i = 0; i < passes.length; i++) hashData += serializePass(passes[i]);
      return hashData;
    }
    function serializeUniforms(uniforms, names) {
      var index = 0;
      for (var name in uniforms) if (Object.hasOwnProperty.call(uniforms, name)) {
        var param = uniforms[name];
        var prop = param.value;
        if (!prop) continue;
        param.type === _enums["default"].PARAM_TEXTURE_2D || param.type === _enums["default"].PARAM_TEXTURE_CUBE ? hashArray[index] = prop._id : hashArray[index] = prop.toString();
        index++;
      }
      hashArray.length = index;
      return hashArray.join(";");
    }
    var _default = {
      serializeDefines: serializeDefines,
      serializePasses: serializePasses,
      serializeUniforms: serializeUniforms
    };
    exports["default"] = _default;
    module.exports = exports["default"];
  }), {
    "../../../renderer/enums": 426
  } ],
  165: [ (function(require, module, exports) {
    "use strict";
    var Event;
    true;
    Event = require("../CCNode").EventType;
    var TOP = 1;
    var MID = 2;
    var BOT = 4;
    var LEFT = 8;
    var CENTER = 16;
    var RIGHT = 32;
    var HORIZONTAL = LEFT | CENTER | RIGHT;
    var VERTICAL = TOP | MID | BOT;
    var AlignMode = cc.Enum({
      ONCE: 0,
      ON_WINDOW_RESIZE: 1,
      ALWAYS: 2
    });
    function getReadonlyNodeSize(parent) {
      return parent instanceof cc.Scene ? cc.visibleRect : parent._contentSize;
    }
    function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
      var scaleX = widgetNode._parent.scaleX;
      var scaleY = widgetNode._parent.scaleY;
      var translateX = 0;
      var translateY = 0;
      for (var node = widgetNode._parent; ;) {
        translateX += node.x;
        translateY += node.y;
        node = node._parent;
        if (!node) {
          out_inverseTranslate.x = out_inverseTranslate.y = 0;
          out_inverseScale.x = out_inverseScale.y = 1;
          return;
        }
        if (node === target) break;
        var sx = node.scaleX;
        var sy = node.scaleY;
        translateX *= sx;
        translateY *= sy;
        scaleX *= sx;
        scaleY *= sy;
      }
      out_inverseScale.x = 0 !== scaleX ? 1 / scaleX : 1;
      out_inverseScale.y = 0 !== scaleY ? 1 / scaleY : 1;
      out_inverseTranslate.x = -translateX;
      out_inverseTranslate.y = -translateY;
    }
    var tInverseTranslate = cc.Vec2.ZERO;
    var tInverseScale = cc.Vec2.ONE;
    function align(node, widget) {
      var hasTarget = widget._target;
      var target;
      var inverseTranslate, inverseScale;
      if (hasTarget) {
        target = hasTarget;
        inverseTranslate = tInverseTranslate;
        inverseScale = tInverseScale;
        computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
      } else target = node._parent;
      var targetSize = getReadonlyNodeSize(target);
      var targetAnchor = target._anchorPoint;
      var isRoot = (true, target instanceof cc.Scene);
      var x = node.x, y = node.y;
      var anchor = node._anchorPoint;
      if (widget._alignFlags & HORIZONTAL) {
        var localLeft, localRight, targetWidth = targetSize.width;
        if (isRoot) {
          localLeft = cc.visibleRect.left.x;
          localRight = cc.visibleRect.right.x;
        } else {
          localLeft = -targetAnchor.x * targetWidth;
          localRight = localLeft + targetWidth;
        }
        localLeft += widget._isAbsLeft ? widget._left : widget._left * targetWidth;
        localRight -= widget._isAbsRight ? widget._right : widget._right * targetWidth;
        if (hasTarget) {
          localLeft += inverseTranslate.x;
          localLeft *= inverseScale.x;
          localRight += inverseTranslate.x;
          localRight *= inverseScale.x;
        }
        var width, anchorX = anchor.x, scaleX = node.scaleX;
        if (scaleX < 0) {
          anchorX = 1 - anchorX;
          scaleX = -scaleX;
        }
        if (widget.isStretchWidth) {
          width = localRight - localLeft;
          0 !== scaleX && (node.width = width / scaleX);
          x = localLeft + anchorX * width;
        } else {
          width = node.width * scaleX;
          if (widget.isAlignHorizontalCenter) {
            var localHorizontalCenter = widget._isAbsHorizontalCenter ? widget._horizontalCenter : widget._horizontalCenter * targetWidth;
            var targetCenter = (.5 - targetAnchor.x) * targetSize.width;
            if (hasTarget) {
              localHorizontalCenter *= inverseScale.x;
              targetCenter += inverseTranslate.x;
              targetCenter *= inverseScale.x;
            }
            x = targetCenter + (anchorX - .5) * width + localHorizontalCenter;
          } else x = widget.isAlignLeft ? localLeft + anchorX * width : localRight + (anchorX - 1) * width;
        }
      }
      if (widget._alignFlags & VERTICAL) {
        var localTop, localBottom, targetHeight = targetSize.height;
        if (isRoot) {
          localBottom = cc.visibleRect.bottom.y;
          localTop = cc.visibleRect.top.y;
        } else {
          localBottom = -targetAnchor.y * targetHeight;
          localTop = localBottom + targetHeight;
        }
        localBottom += widget._isAbsBottom ? widget._bottom : widget._bottom * targetHeight;
        localTop -= widget._isAbsTop ? widget._top : widget._top * targetHeight;
        if (hasTarget) {
          localBottom += inverseTranslate.y;
          localBottom *= inverseScale.y;
          localTop += inverseTranslate.y;
          localTop *= inverseScale.y;
        }
        var height, anchorY = anchor.y, scaleY = node.scaleY;
        if (scaleY < 0) {
          anchorY = 1 - anchorY;
          scaleY = -scaleY;
        }
        if (widget.isStretchHeight) {
          height = localTop - localBottom;
          0 !== scaleY && (node.height = height / scaleY);
          y = localBottom + anchorY * height;
        } else {
          height = node.height * scaleY;
          if (widget.isAlignVerticalCenter) {
            var localVerticalCenter = widget._isAbsVerticalCenter ? widget._verticalCenter : widget._verticalCenter * targetHeight;
            var targetMiddle = (.5 - targetAnchor.y) * targetSize.height;
            if (hasTarget) {
              localVerticalCenter *= inverseScale.y;
              targetMiddle += inverseTranslate.y;
              targetMiddle *= inverseScale.y;
            }
            y = targetMiddle + (anchorY - .5) * height + localVerticalCenter;
          } else y = widget.isAlignBottom ? localBottom + anchorY * height : localTop + (anchorY - 1) * height;
        }
      }
      node.setPosition(x, y);
    }
    function visitNode(node) {
      var widget = node._widget;
      if (widget) {
        true;
        widget._validateTargetInDEV();
        align(node, widget);
        true, widget.alignMode !== AlignMode.ALWAYS ? widgetManager.remove(widget) : activeWidgets.push(widget);
      }
      var children = node._children;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        child._active && visitNode(child);
      }
    }
    var animationState;
    false;
    function refreshScene() {
      var AnimUtils;
      var EditMode;
      var nowPreviewing;
      var component;
      var animation;
      var _component;
      var _animation;
      false;
      var scene = cc.director.getScene();
      if (scene) {
        widgetManager.isAligning = true;
        if (widgetManager._nodesOrderDirty) {
          activeWidgets.length = 0;
          visitNode(scene);
          widgetManager._nodesOrderDirty = false;
        } else {
          var i, widget, iterator = widgetManager._activeWidgetsIterator;
          var AnimUtils;
          var editingNode;
          var node;
          false;
          for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
            widget = activeWidgets[iterator.i];
            align(widget.node, widget);
          }
        }
        widgetManager.isAligning = false;
      }
      false;
    }
    var adjustWidgetToAllowMovingInEditor = false;
    var adjustWidgetToAllowResizingInEditor = false;
    var activeWidgets = [];
    function updateAlignment(node) {
      var parent = node._parent;
      cc.Node.isNode(parent) && updateAlignment(parent);
      var widget = node._widget || node.getComponent(cc.Widget);
      widget && parent && align(node, widget);
    }
    var widgetManager = cc._widgetManager = module.exports = {
      _AlignFlags: {
        TOP: TOP,
        MID: MID,
        BOT: BOT,
        LEFT: LEFT,
        CENTER: CENTER,
        RIGHT: RIGHT
      },
      isAligning: false,
      _nodesOrderDirty: false,
      _activeWidgetsIterator: new cc.js.array.MutableForwardIterator(activeWidgets),
      init: function init(director) {
        director.on(cc.Director.EVENT_AFTER_UPDATE, refreshScene);
        false;
        var thisOnResized = this.onResized.bind(this);
        cc.view.on("canvas-resize", thisOnResized);
        window.addEventListener("orientationchange", thisOnResized);
      },
      add: function add(widget) {
        widget.node._widget = widget;
        this._nodesOrderDirty = true;
        false;
      },
      remove: function remove(widget) {
        widget.node._widget = null;
        this._activeWidgetsIterator.remove(widget);
        false;
      },
      onResized: function onResized() {
        var scene = cc.director.getScene();
        scene && this.refreshWidgetOnResized(scene);
      },
      refreshWidgetOnResized: function refreshWidgetOnResized(node) {
        var widget = cc.Node.isNode(node) && node.getComponent(cc.Widget);
        widget && widget.enabled && widget.alignMode === AlignMode.ON_WINDOW_RESIZE && this.add(widget);
        var children = node._children;
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          this.refreshWidgetOnResized(child);
        }
      },
      updateAlignment: updateAlignment,
      AlignMode: AlignMode
    };
    false;
  }), {
    "../CCNode": 104
  } ],
  166: [ (function(require, module, exports) {
    "use strict";
    var _valueTypes = require("../value-types");
    var _geomUtils = require("../geom-utils");
    var AffineTrans = require("../utils/affine-transform");
    var renderer = require("../renderer/index");
    var RenderFlow = require("../renderer/render-flow");
    var game = require("../CCGame");
    var RendererCamera = null;
    true, true;
    RendererCamera = window.renderer.Camera;
    var _mat4_temp_1 = cc.mat4();
    var _mat4_temp_2 = cc.mat4();
    var _v3_temp_1 = cc.v3();
    var _v3_temp_2 = cc.v3();
    var _v3_temp_3 = cc.v3();
    var _cameras = [];
    function updateMainCamera() {
      for (var i = 0, minDepth = Number.MAX_VALUE; i < _cameras.length; i++) {
        var camera = _cameras[i];
        if (camera._depth < minDepth) {
          Camera.main = camera;
          minDepth = camera._depth;
        }
      }
    }
    var _debugCamera = null;
    function repositionDebugCamera() {
      if (!_debugCamera) return;
      var node = _debugCamera.getNode();
      var canvas = cc.game.canvas;
      node.z = canvas.height / 1.1566;
      node.x = canvas.width / 2;
      node.y = canvas.height / 2;
    }
    var ClearFlags = cc.Enum({
      COLOR: 1,
      DEPTH: 2,
      STENCIL: 4
    });
    var StageFlags = cc.Enum({
      OPAQUE: 1,
      TRANSPARENT: 2
    });
    var Camera = cc.Class({
      name: "cc.Camera",
      extends: cc.Component,
      ctor: function ctor() {
        if (game.renderType !== game.RENDER_TYPE_CANVAS) {
          var camera = new RendererCamera();
          camera.setStages([ "opaque" ]);
          camera.dirty = true;
          this._inited = false;
          this._camera = camera;
        } else this._inited = true;
      },
      editor: false,
      properties: {
        _cullingMask: 4294967295,
        _clearFlags: ClearFlags.DEPTH | ClearFlags.STENCIL,
        _backgroundColor: cc.color(0, 0, 0, 255),
        _depth: 0,
        _zoomRatio: 1,
        _targetTexture: null,
        _fov: 60,
        _orthoSize: 10,
        _nearClip: 1,
        _farClip: 4096,
        _ortho: true,
        _rect: cc.rect(0, 0, 1, 1),
        _renderStages: 1,
        _alignWithScreen: true,
        zoomRatio: {
          get: function get() {
            return this._zoomRatio;
          },
          set: function set(value) {
            this._zoomRatio = value;
          },
          tooltip: (true, "i18n:COMPONENT.camera.zoomRatio")
        },
        fov: {
          get: function get() {
            return this._fov;
          },
          set: function set(v) {
            this._fov = v;
          },
          tooltip: (true, "i18n:COMPONENT.camera.fov")
        },
        orthoSize: {
          get: function get() {
            return this._orthoSize;
          },
          set: function set(v) {
            this._orthoSize = v;
          },
          tooltip: (true, "i18n:COMPONENT.camera.orthoSize")
        },
        nearClip: {
          get: function get() {
            return this._nearClip;
          },
          set: function set(v) {
            this._nearClip = v;
            this._updateClippingpPlanes();
          },
          tooltip: (true, "i18n:COMPONENT.camera.nearClip")
        },
        farClip: {
          get: function get() {
            return this._farClip;
          },
          set: function set(v) {
            this._farClip = v;
            this._updateClippingpPlanes();
          },
          tooltip: (true, "i18n:COMPONENT.camera.farClip")
        },
        ortho: {
          get: function get() {
            return this._ortho;
          },
          set: function set(v) {
            this._ortho = v;
            this._updateProjection();
          },
          tooltip: (true, "i18n:COMPONENT.camera.ortho")
        },
        rect: {
          get: function get() {
            return this._rect;
          },
          set: function set(v) {
            this._rect = v;
            this._updateRect();
          },
          tooltip: (true, "i18n:COMPONENT.camera.rect")
        },
        cullingMask: {
          get: function get() {
            return this._cullingMask;
          },
          set: function set(value) {
            this._cullingMask = value;
            this._updateCameraMask();
          },
          tooltip: (true, "i18n:COMPONENT.camera.cullingMask")
        },
        clearFlags: {
          get: function get() {
            return this._clearFlags;
          },
          set: function set(value) {
            this._clearFlags = value;
            this._camera && this._camera.setClearFlags(value);
          },
          tooltip: (true, "i18n:COMPONENT.camera.clearFlags")
        },
        backgroundColor: {
          get: function get() {
            return this._backgroundColor;
          },
          set: function set(value) {
            if (!this._backgroundColor.equals(value)) {
              this._backgroundColor.set(value);
              this._updateBackgroundColor();
            }
          },
          tooltip: (true, "i18n:COMPONENT.camera.backgroundColor")
        },
        depth: {
          get: function get() {
            return this._depth;
          },
          set: function set(value) {
            Camera.main === this ? this._depth < value && updateMainCamera() : Camera.main && value < Camera.main._depth && _cameras.includes(this) && (Camera.main = this);
            this._depth = value;
            this._camera && this._camera.setPriority(value);
          },
          tooltip: (true, "i18n:COMPONENT.camera.depth")
        },
        targetTexture: {
          get: function get() {
            return this._targetTexture;
          },
          set: function set(value) {
            this._targetTexture = value;
            this._updateTargetTexture();
          },
          tooltip: (true, "i18n:COMPONENT.camera.targetTexture")
        },
        renderStages: {
          get: function get() {
            return this._renderStages;
          },
          set: function set(val) {
            this._renderStages = val;
            this._updateStages();
          },
          tooltip: (true, "i18n:COMPONENT.camera.renderStages")
        },
        alignWithScreen: {
          get: function get() {
            return this._alignWithScreen;
          },
          set: function set(v) {
            this._alignWithScreen = v;
          }
        },
        _is3D: {
          get: function get() {
            return this.node && this.node._is3DNode;
          }
        }
      },
      statics: {
        main: null,
        cameras: _cameras,
        ClearFlags: ClearFlags,
        findCamera: function findCamera(node) {
          for (var i = 0, l = _cameras.length; i < l; i++) {
            var camera = _cameras[i];
            if (camera.containsNode(node)) return camera;
          }
          return null;
        },
        _findRendererCamera: function _findRendererCamera(node) {
          var cameras = renderer.scene._cameras;
          for (var i = 0; i < cameras._count; i++) if (cameras._data[i]._cullingMask & node._cullingMask) return cameras._data[i];
          return null;
        },
        _setupDebugCamera: function _setupDebugCamera() {
          if (_debugCamera) return;
          if (game.renderType === game.RENDER_TYPE_CANVAS) return;
          var camera = new RendererCamera();
          _debugCamera = camera;
          camera.setStages([ "opaque" ]);
          camera.setFov(60 * Math.PI / 180);
          camera.setNear(.1);
          camera.setFar(4096);
          camera.dirty = true;
          camera.cullingMask = 1 << cc.Node.BuiltinGroupIndex.DEBUG;
          camera.setPriority(cc.macro.MAX_ZINDEX);
          camera.setClearFlags(0);
          camera.setColor(0, 0, 0, 0);
          var node = new cc.Node();
          camera.setNode(node);
          repositionDebugCamera();
          cc.view.on("design-resolution-changed", repositionDebugCamera);
          renderer.scene.addCamera(camera);
        }
      },
      _updateCameraMask: function _updateCameraMask() {
        if (this._camera) {
          var mask = this._cullingMask & ~(1 << cc.Node.BuiltinGroupIndex.DEBUG);
          this._camera.cullingMask = mask;
        }
      },
      _updateBackgroundColor: function _updateBackgroundColor() {
        if (!this._camera) return;
        var color = this._backgroundColor;
        this._camera.setColor(color.r / 255, color.g / 255, color.b / 255, color.a / 255);
      },
      _updateTargetTexture: function _updateTargetTexture() {
        if (!this._camera) return;
        var texture = this._targetTexture;
        this._camera.setFrameBuffer(texture ? texture._framebuffer : null);
      },
      _updateClippingpPlanes: function _updateClippingpPlanes() {
        if (!this._camera) return;
        this._camera.setNear(this._nearClip);
        this._camera.setFar(this._farClip);
      },
      _updateProjection: function _updateProjection() {
        if (!this._camera) return;
        var type = this._ortho ? 1 : 0;
        this._camera.setType(type);
      },
      _updateRect: function _updateRect() {
        if (!this._camera) return;
        var rect = this._rect;
        this._camera.setRect(rect.x, rect.y, rect.width, rect.height);
      },
      _updateStages: function _updateStages() {
        var flags = this._renderStages;
        var stages = [];
        flags & StageFlags.OPAQUE && stages.push("opaque");
        flags & StageFlags.TRANSPARENT && stages.push("transparent");
        this._camera.setStages(stages);
      },
      _init: function _init() {
        if (this._inited) return;
        this._inited = true;
        var camera = this._camera;
        if (!camera) return;
        camera.setNode(this.node);
        camera.setClearFlags(this._clearFlags);
        camera.setPriority(this._depth);
        this._updateBackgroundColor();
        this._updateCameraMask();
        this._updateTargetTexture();
        this._updateClippingpPlanes();
        this._updateProjection();
        this._updateStages();
        this._updateRect();
        true;
        this.beforeDraw();
      },
      __preload: function __preload() {
        this._init();
      },
      onEnable: function onEnable() {
        if (true, game.renderType !== game.RENDER_TYPE_CANVAS) {
          cc.director.on(cc.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
          renderer.scene.addCamera(this._camera);
        }
        _cameras.push(this);
        (!Camera.main || this._depth < Camera.main._depth) && (Camera.main = this);
      },
      onDisable: function onDisable() {
        if (true, game.renderType !== game.RENDER_TYPE_CANVAS) {
          cc.director.off(cc.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
          renderer.scene.removeCamera(this._camera);
        }
        cc.js.array.fastRemove(_cameras, this);
        if (Camera.main === this) {
          Camera.main = null;
          updateMainCamera();
        }
      },
      getScreenToWorldMatrix2D: function getScreenToWorldMatrix2D(out) {
        this.getWorldToScreenMatrix2D(out);
        _valueTypes.Mat4.invert(out, out);
        return out;
      },
      getWorldToScreenMatrix2D: function getWorldToScreenMatrix2D(out) {
        this.node.getWorldRT(_mat4_temp_1);
        var zoomRatio = this.zoomRatio;
        var _mat4_temp_1m = _mat4_temp_1.m;
        _mat4_temp_1m[0] *= zoomRatio;
        _mat4_temp_1m[1] *= zoomRatio;
        _mat4_temp_1m[4] *= zoomRatio;
        _mat4_temp_1m[5] *= zoomRatio;
        var m12 = _mat4_temp_1m[12];
        var m13 = _mat4_temp_1m[13];
        var center = cc.visibleRect.center;
        _mat4_temp_1m[12] = center.x - (_mat4_temp_1m[0] * m12 + _mat4_temp_1m[4] * m13);
        _mat4_temp_1m[13] = center.y - (_mat4_temp_1m[1] * m12 + _mat4_temp_1m[5] * m13);
        out !== _mat4_temp_1 && _valueTypes.Mat4.copy(out, _mat4_temp_1);
        return out;
      },
      getScreenToWorldPoint: function getScreenToWorldPoint(screenPosition, out) {
        if (this.node.is3DNode) {
          out = out || new cc.Vec3();
          this._camera.screenToWorld(out, screenPosition, cc.visibleRect.width, cc.visibleRect.height);
        } else {
          out = out || new cc.Vec2();
          this.getScreenToWorldMatrix2D(_mat4_temp_1);
          _valueTypes.Vec2.transformMat4(out, screenPosition, _mat4_temp_1);
        }
        return out;
      },
      getWorldToScreenPoint: function getWorldToScreenPoint(worldPosition, out) {
        if (this.node.is3DNode) {
          out = out || new cc.Vec3();
          this._camera.worldToScreen(out, worldPosition, cc.visibleRect.width, cc.visibleRect.height);
        } else {
          out = out || new cc.Vec2();
          this.getWorldToScreenMatrix2D(_mat4_temp_1);
          _valueTypes.Vec2.transformMat4(out, worldPosition, _mat4_temp_1);
        }
        return out;
      },
      getRay: function getRay(screenPos) {
        if (!cc.geomUtils) return screenPos;
        _valueTypes.Vec3.set(_v3_temp_3, screenPos.x, screenPos.y, 1);
        this._camera.screenToWorld(_v3_temp_2, _v3_temp_3, cc.visibleRect.width, cc.visibleRect.height);
        if (this.ortho) {
          _valueTypes.Vec3.set(_v3_temp_3, screenPos.x, screenPos.y, -1);
          this._camera.screenToWorld(_v3_temp_1, _v3_temp_3, cc.visibleRect.width, cc.visibleRect.height);
        } else this.node.getWorldPosition(_v3_temp_1);
        return _geomUtils.Ray.fromPoints(new _geomUtils.Ray(), _v3_temp_1, _v3_temp_2);
      },
      containsNode: function containsNode(node) {
        return (node._cullingMask & this.cullingMask) > 0;
      },
      render: function render(rootNode) {
        rootNode = rootNode || cc.director.getScene();
        if (!rootNode) return null;
        this.node.getWorldMatrix(_mat4_temp_1);
        this.beforeDraw();
        RenderFlow.renderCamera(this._camera, rootNode);
      },
      _onAlignWithScreen: function _onAlignWithScreen() {
        var height = cc.game.canvas.height / cc.view._scaleY;
        var targetTexture = this._targetTexture;
        if (targetTexture) {
          false;
          height = cc.visibleRect.height;
        }
        var fov = this._fov * cc.macro.RAD;
        this.node.z = height / (2 * Math.tan(fov / 2));
        fov = 2 * Math.atan(Math.tan(fov / 2) / this.zoomRatio);
        this._camera.setFov(fov);
        this._camera.setOrthoHeight(height / 2 / this.zoomRatio);
        this.node.setRotation(0, 0, 0, 1);
      },
      beforeDraw: function beforeDraw() {
        if (!this._camera) return;
        if (this._alignWithScreen) this._onAlignWithScreen(); else {
          var fov = this._fov * cc.macro.RAD;
          fov = 2 * Math.atan(Math.tan(fov / 2) / this.zoomRatio);
          this._camera.setFov(fov);
          this._camera.setOrthoHeight(this._orthoSize / this.zoomRatio);
        }
        this._camera.dirty = true;
      }
    });
    cc.js.mixin(Camera.prototype, {
      getNodeToCameraTransform: function getNodeToCameraTransform(node) {
        var out = AffineTrans.identity();
        node.getWorldMatrix(_mat4_temp_2);
        if (this.containsNode(node)) {
          this.getWorldToCameraMatrix(_mat4_temp_1);
          _valueTypes.Mat4.mul(_mat4_temp_2, _mat4_temp_2, _mat4_temp_1);
        }
        AffineTrans.fromMat4(out, _mat4_temp_2);
        return out;
      },
      getCameraToWorldPoint: function getCameraToWorldPoint(point, out) {
        return this.getScreenToWorldPoint(point, out);
      },
      getWorldToCameraPoint: function getWorldToCameraPoint(point, out) {
        return this.getWorldToScreenPoint(point, out);
      },
      getCameraToWorldMatrix: function getCameraToWorldMatrix(out) {
        return this.getScreenToWorldMatrix2D(out);
      },
      getWorldToCameraMatrix: function getWorldToCameraMatrix(out) {
        return this.getWorldToScreenMatrix2D(out);
      }
    });
    module.exports = cc.Camera = Camera;
  }), {
    "../../renderer/scene/camera": void 0,
    "../CCGame": 103,
    "../geom-utils": 227,
    "../renderer/index": 322,
    "../renderer/render-flow": 323,
    "../utils/affine-transform": 377,
    "../value-types": 401
  } ],
  167: [ (function(require, module, exports) {
    "use strict";
    cc.Collider.Box = cc.Class({
      properties: {
        _offset: cc.v2(0, 0),
        _size: cc.size(100, 100),
        offset: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.offset"),
          get: function get() {
            return this._offset;
          },
          set: function set(value) {
            this._offset = value;
          },
          type: cc.Vec2
        },
        size: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.size"),
          get: function get() {
            return this._size;
          },
          set: function set(value) {
            this._size.width = value.width < 0 ? 0 : value.width;
            this._size.height = value.height < 0 ? 0 : value.height;
          },
          type: cc.Size
        }
      },
      resetInEditor: false
    });
    var BoxCollider = cc.Class({
      name: "cc.BoxCollider",
      extends: cc.Collider,
      mixins: [ cc.Collider.Box ],
      editor: false
    });
    cc.BoxCollider = module.exports = BoxCollider;
  }), {} ],
  168: [ (function(require, module, exports) {
    "use strict";
    cc.Collider.Circle = cc.Class({
      properties: {
        _offset: cc.v2(0, 0),
        _radius: 50,
        offset: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.offset"),
          get: function get() {
            return this._offset;
          },
          set: function set(value) {
            this._offset = value;
          },
          type: cc.Vec2
        },
        radius: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.radius"),
          get: function get() {
            return this._radius;
          },
          set: function set(value) {
            this._radius = value < 0 ? 0 : value;
          }
        }
      },
      resetInEditor: false
    });
    var CircleCollider = cc.Class({
      name: "cc.CircleCollider",
      extends: cc.Collider,
      mixins: [ cc.Collider.Circle ],
      editor: false
    });
    cc.CircleCollider = module.exports = CircleCollider;
  }), {} ],
  169: [ (function(require, module, exports) {
    "use strict";
    var Collider = cc.Class({
      name: "cc.Collider",
      extends: cc.Component,
      properties: {
        editing: {
          default: false,
          serializable: false,
          tooltip: (true, "i18n:COMPONENT.collider.editing")
        },
        tag: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.tag"),
          default: 0,
          range: [ 0, 1e7 ],
          type: cc.Integer
        }
      },
      onDisable: function onDisable() {
        cc.director.getCollisionManager().removeCollider(this);
      },
      onEnable: function onEnable() {
        cc.director.getCollisionManager().addCollider(this);
      }
    });
    cc.Collider = module.exports = Collider;
  }), {} ],
  170: [ (function(require, module, exports) {
    "use strict";
    var _vec = _interopRequireDefault(require("../value-types/vec2"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Contact = require("./CCContact");
    var CollisionType = Contact.CollisionType;
    var NodeEvent = require("../CCNode").EventType;
    var _vec2 = new _vec["default"]();
    function obbApplyMatrix(rect, mat4, out_bl, out_tl, out_tr, out_br) {
      var x = rect.x;
      var y = rect.y;
      var width = rect.width;
      var height = rect.height;
      var mat4m = mat4.m;
      var m00 = mat4m[0], m01 = mat4m[1], m04 = mat4m[4], m05 = mat4m[5];
      var m12 = mat4m[12], m13 = mat4m[13];
      var tx = m00 * x + m04 * y + m12;
      var ty = m01 * x + m05 * y + m13;
      var xa = m00 * width;
      var xb = m01 * width;
      var yc = m04 * height;
      var yd = m05 * height;
      out_tl.x = tx;
      out_tl.y = ty;
      out_tr.x = xa + tx;
      out_tr.y = xb + ty;
      out_bl.x = yc + tx;
      out_bl.y = yd + ty;
      out_br.x = xa + yc + tx;
      out_br.y = xb + yd + ty;
    }
    var CollisionManager = cc.Class({
      mixins: [ cc.EventTarget ],
      properties: {
        enabled: false,
        enabledDrawBoundingBox: false
      },
      ctor: function ctor() {
        this._contacts = [];
        this._colliders = [];
        this._debugDrawer = null;
        this._enabledDebugDraw = false;
        cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
      },
      update: function update(dt) {
        if (!this.enabled) return;
        var i, l;
        var colliders = this._colliders;
        for (i = 0, l = colliders.length; i < l; i++) this.updateCollider(colliders[i]);
        var contacts = this._contacts;
        var results = [];
        for (i = 0, l = contacts.length; i < l; i++) {
          var collisionType = contacts[i].updateState();
          if (collisionType === CollisionType.None) continue;
          results.push([ collisionType, contacts[i] ]);
        }
        for (i = 0, l = results.length; i < l; i++) {
          var result = results[i];
          this._doCollide(result[0], result[1]);
        }
        this.drawColliders();
      },
      _doCollide: function _doCollide(collisionType, contact) {
        var contactFunc;
        switch (collisionType) {
         case CollisionType.CollisionEnter:
          contactFunc = "onCollisionEnter";
          break;

         case CollisionType.CollisionStay:
          contactFunc = "onCollisionStay";
          break;

         case CollisionType.CollisionExit:
          contactFunc = "onCollisionExit";
        }
        var collider1 = contact.collider1;
        var collider2 = contact.collider2;
        var comps1 = collider1.node._components;
        var comps2 = collider2.node._components;
        var i, l, comp;
        for (i = 0, l = comps1.length; i < l; i++) {
          comp = comps1[i];
          comp[contactFunc] && comp[contactFunc](collider2, collider1);
        }
        for (i = 0, l = comps2.length; i < l; i++) {
          comp = comps2[i];
          comp[contactFunc] && comp[contactFunc](collider1, collider2);
        }
      },
      shouldCollide: function shouldCollide(c1, c2) {
        var node1 = c1.node, node2 = c2.node;
        var collisionMatrix = cc.game.collisionMatrix;
        return node1 !== node2 && collisionMatrix[node1.groupIndex][node2.groupIndex];
      },
      initCollider: function initCollider(collider) {
        if (!collider.world) {
          var world = collider.world = {};
          world.aabb = cc.rect();
          world.preAabb = cc.rect();
          world.matrix = cc.mat4();
          world.radius = 0;
          if (collider instanceof cc.BoxCollider) {
            world.position = null;
            world.points = [ cc.v2(), cc.v2(), cc.v2(), cc.v2() ];
          } else if (collider instanceof cc.PolygonCollider) {
            world.position = null;
            world.points = collider.points.map((function(p) {
              return cc.v2(p.x, p.y);
            }));
          } else if (collider instanceof cc.CircleCollider) {
            world.position = cc.v2();
            world.points = null;
          }
        }
      },
      updateCollider: function updateCollider(collider) {
        var offset = collider.offset;
        var world = collider.world;
        var aabb = world.aabb;
        var m = world.matrix;
        collider.node.getWorldMatrix(m);
        var preAabb = world.preAabb;
        preAabb.x = aabb.x;
        preAabb.y = aabb.y;
        preAabb.width = aabb.width;
        preAabb.height = aabb.height;
        if (collider instanceof cc.BoxCollider) {
          var size = collider.size;
          aabb.x = offset.x - size.width / 2;
          aabb.y = offset.y - size.height / 2;
          aabb.width = size.width;
          aabb.height = size.height;
          var wps = world.points;
          var wp0 = wps[0], wp1 = wps[1], wp2 = wps[2], wp3 = wps[3];
          obbApplyMatrix(aabb, m, wp0, wp1, wp2, wp3);
          var minx = Math.min(wp0.x, wp1.x, wp2.x, wp3.x);
          var miny = Math.min(wp0.y, wp1.y, wp2.y, wp3.y);
          var maxx = Math.max(wp0.x, wp1.x, wp2.x, wp3.x);
          var maxy = Math.max(wp0.y, wp1.y, wp2.y, wp3.y);
          aabb.x = minx;
          aabb.y = miny;
          aabb.width = maxx - minx;
          aabb.height = maxy - miny;
        } else if (collider instanceof cc.CircleCollider) {
          _vec["default"].transformMat4(_vec2, collider.offset, m);
          world.position.x = _vec2.x;
          world.position.y = _vec2.y;
          var mm = m.m;
          var tempx = mm[12], tempy = mm[13];
          mm[12] = mm[13] = 0;
          _vec2.x = collider.radius;
          _vec2.y = 0;
          _vec["default"].transformMat4(_vec2, _vec2, m);
          var d = Math.sqrt(_vec2.x * _vec2.x + _vec2.y * _vec2.y);
          world.radius = d;
          aabb.x = world.position.x - d;
          aabb.y = world.position.y - d;
          aabb.width = 2 * d;
          aabb.height = 2 * d;
          mm[12] = tempx;
          mm[13] = tempy;
        } else if (collider instanceof cc.PolygonCollider) {
          var points = collider.points;
          var worldPoints = world.points;
          worldPoints.length = points.length;
          var _minx = 1e6, _miny = 1e6, _maxx = -1e6, _maxy = -1e6;
          for (var i = 0, l = points.length; i < l; i++) {
            worldPoints[i] || (worldPoints[i] = cc.v2());
            _vec2.x = points[i].x + offset.x;
            _vec2.y = points[i].y + offset.y;
            _vec["default"].transformMat4(_vec2, _vec2, m);
            var x = _vec2.x;
            var y = _vec2.y;
            worldPoints[i].x = x;
            worldPoints[i].y = y;
            x > _maxx && (_maxx = x);
            x < _minx && (_minx = x);
            y > _maxy && (_maxy = y);
            y < _miny && (_miny = y);
          }
          aabb.x = _minx;
          aabb.y = _miny;
          aabb.width = _maxx - _minx;
          aabb.height = _maxy - _miny;
        }
      },
      addCollider: function addCollider(collider) {
        var colliders = this._colliders;
        var index = colliders.indexOf(collider);
        if (-1 === index) {
          for (var i = 0, l = colliders.length; i < l; i++) {
            var other = colliders[i];
            if (this.shouldCollide(collider, other)) {
              var contact = new Contact(collider, other);
              this._contacts.push(contact);
            }
          }
          colliders.push(collider);
          this.initCollider(collider);
        }
        collider.node.on(NodeEvent.GROUP_CHANGED, this.onNodeGroupChanged, this);
      },
      removeCollider: function removeCollider(collider) {
        var colliders = this._colliders;
        var index = colliders.indexOf(collider);
        if (index >= 0) {
          colliders.splice(index, 1);
          var contacts = this._contacts;
          for (var i = contacts.length - 1; i >= 0; i--) {
            var contact = contacts[i];
            if (contact.collider1 === collider || contact.collider2 === collider) {
              contact.touching && this._doCollide(CollisionType.CollisionExit, contact);
              contacts.splice(i, 1);
            }
          }
          collider.node.off(NodeEvent.GROUP_CHANGED, this.onNodeGroupChanged, this);
        } else cc.errorID(6600);
      },
      onNodeGroupChanged: function onNodeGroupChanged(node) {
        var colliders = node.getComponents(cc.Collider);
        for (var i = 0, l = colliders.length; i < l; i++) {
          var collider = colliders[i];
          if (cc.PhysicsCollider && collider instanceof cc.PhysicsCollider) continue;
          this.removeCollider(collider);
          this.addCollider(collider);
        }
      },
      drawColliders: function drawColliders() {
        if (!this._enabledDebugDraw) return;
        this._checkDebugDrawValid();
        var debugDrawer = this._debugDrawer;
        debugDrawer.clear();
        var colliders = this._colliders;
        for (var i = 0, l = colliders.length; i < l; i++) {
          var collider = colliders[i];
          debugDrawer.strokeColor = cc.Color.WHITE;
          if (collider instanceof cc.BoxCollider || collider instanceof cc.PolygonCollider) {
            var ps = collider.world.points;
            if (ps.length > 0) {
              debugDrawer.moveTo(ps[0].x, ps[0].y);
              for (var j = 1; j < ps.length; j++) debugDrawer.lineTo(ps[j].x, ps[j].y);
              debugDrawer.close();
              debugDrawer.stroke();
            }
          } else if (collider instanceof cc.CircleCollider) {
            debugDrawer.circle(collider.world.position.x, collider.world.position.y, collider.world.radius);
            debugDrawer.stroke();
          }
          if (this.enabledDrawBoundingBox) {
            var aabb = collider.world.aabb;
            debugDrawer.strokeColor = cc.Color.BLUE;
            debugDrawer.moveTo(aabb.xMin, aabb.yMin);
            debugDrawer.lineTo(aabb.xMin, aabb.yMax);
            debugDrawer.lineTo(aabb.xMax, aabb.yMax);
            debugDrawer.lineTo(aabb.xMax, aabb.yMin);
            debugDrawer.close();
            debugDrawer.stroke();
          }
        }
      },
      _checkDebugDrawValid: function _checkDebugDrawValid() {
        if (!this._debugDrawer || !this._debugDrawer.isValid) {
          var node = new cc.Node("COLLISION_MANAGER_DEBUG_DRAW");
          node.zIndex = cc.macro.MAX_ZINDEX;
          cc.game.addPersistRootNode(node);
          this._debugDrawer = node.addComponent(cc.Graphics);
        }
      }
    });
    cc.js.getset(CollisionManager.prototype, "enabledDebugDraw", (function() {
      return this._enabledDebugDraw;
    }), (function(value) {
      if (value && !this._enabledDebugDraw) {
        this._checkDebugDrawValid();
        this._debugDrawer.node.active = true;
      } else if (!value && this._enabledDebugDraw) {
        this._debugDrawer.clear(true);
        this._debugDrawer.node.active = false;
      }
      this._enabledDebugDraw = value;
    }));
    cc.CollisionManager = module.exports = CollisionManager;
  }), {
    "../CCNode": 104,
    "../value-types/vec2": 410,
    "./CCContact": 171
  } ],
  171: [ (function(require, module, exports) {
    "use strict";
    var Intersection = require("./CCIntersection");
    var CollisionType = cc.Enum({
      None: 0,
      CollisionEnter: 1,
      CollisionStay: 2,
      CollisionExit: 3
    });
    function Contact(collider1, collider2) {
      this.collider1 = collider1;
      this.collider2 = collider2;
      this.touching = false;
      var isCollider1Polygon = collider1 instanceof cc.BoxCollider || collider1 instanceof cc.PolygonCollider;
      var isCollider2Polygon = collider2 instanceof cc.BoxCollider || collider2 instanceof cc.PolygonCollider;
      var isCollider1Circle = collider1 instanceof cc.CircleCollider;
      var isCollider2Circle = collider2 instanceof cc.CircleCollider;
      if (isCollider1Polygon && isCollider2Polygon) this.testFunc = Intersection.polygonPolygon; else if (isCollider1Circle && isCollider2Circle) this.testFunc = Intersection.circleCircle; else if (isCollider1Polygon && isCollider2Circle) this.testFunc = Intersection.polygonCircle; else if (isCollider1Circle && isCollider2Polygon) {
        this.testFunc = Intersection.polygonCircle;
        this.collider1 = collider2;
        this.collider2 = collider1;
      } else cc.errorID(6601, cc.js.getClassName(collider1), cc.js.getClassName(collider2));
    }
    Contact.prototype.test = function() {
      var world1 = this.collider1.world;
      var world2 = this.collider2.world;
      if (!world1.aabb.intersects(world2.aabb)) return false;
      if (this.testFunc === Intersection.polygonPolygon) return this.testFunc(world1.points, world2.points);
      if (this.testFunc === Intersection.circleCircle) return this.testFunc(world1, world2);
      if (this.testFunc === Intersection.polygonCircle) return this.testFunc(world1.points, world2);
      return false;
    };
    Contact.prototype.updateState = function() {
      var result = this.test();
      var type = CollisionType.None;
      if (result && !this.touching) {
        this.touching = true;
        type = CollisionType.CollisionEnter;
      } else if (result && this.touching) type = CollisionType.CollisionStay; else if (!result && this.touching) {
        this.touching = false;
        type = CollisionType.CollisionExit;
      }
      return type;
    };
    Contact.CollisionType = CollisionType;
    module.exports = Contact;
  }), {
    "./CCIntersection": 172
  } ],
  172: [ (function(require, module, exports) {
    "use strict";
    var Intersection = {};
    function lineLine(a1, a2, b1, b2) {
      var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
      var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
      var u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
      if (0 !== u_b) {
        var ua = ua_t / u_b;
        var ub = ub_t / u_b;
        if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) return true;
      }
      return false;
    }
    Intersection.lineLine = lineLine;
    function lineRect(a1, a2, b) {
      var r0 = new cc.Vec2(b.x, b.y);
      var r1 = new cc.Vec2(b.x, b.yMax);
      var r2 = new cc.Vec2(b.xMax, b.yMax);
      var r3 = new cc.Vec2(b.xMax, b.y);
      if (lineLine(a1, a2, r0, r1)) return true;
      if (lineLine(a1, a2, r1, r2)) return true;
      if (lineLine(a1, a2, r2, r3)) return true;
      if (lineLine(a1, a2, r3, r0)) return true;
      return false;
    }
    Intersection.lineRect = lineRect;
    function linePolygon(a1, a2, b) {
      var length = b.length;
      for (var i = 0; i < length; ++i) {
        var b1 = b[i];
        var b2 = b[(i + 1) % length];
        if (lineLine(a1, a2, b1, b2)) return true;
      }
      return false;
    }
    Intersection.linePolygon = linePolygon;
    function rectRect(a, b) {
      var a_min_x = a.x;
      var a_min_y = a.y;
      var a_max_x = a.x + a.width;
      var a_max_y = a.y + a.height;
      var b_min_x = b.x;
      var b_min_y = b.y;
      var b_max_x = b.x + b.width;
      var b_max_y = b.y + b.height;
      return a_min_x <= b_max_x && a_max_x >= b_min_x && a_min_y <= b_max_y && a_max_y >= b_min_y;
    }
    Intersection.rectRect = rectRect;
    function rectPolygon(a, b) {
      var i, l;
      var r0 = new cc.Vec2(a.x, a.y);
      var r1 = new cc.Vec2(a.x, a.yMax);
      var r2 = new cc.Vec2(a.xMax, a.yMax);
      var r3 = new cc.Vec2(a.xMax, a.y);
      if (linePolygon(r0, r1, b)) return true;
      if (linePolygon(r1, r2, b)) return true;
      if (linePolygon(r2, r3, b)) return true;
      if (linePolygon(r3, r0, b)) return true;
      for (i = 0, l = b.length; i < l; ++i) if (pointInPolygon(b[i], a)) return true;
      if (pointInPolygon(r0, b)) return true;
      if (pointInPolygon(r1, b)) return true;
      if (pointInPolygon(r2, b)) return true;
      if (pointInPolygon(r3, b)) return true;
      return false;
    }
    Intersection.rectPolygon = rectPolygon;
    function polygonPolygon(a, b) {
      var i, l;
      for (i = 0, l = a.length; i < l; ++i) {
        var a1 = a[i];
        var a2 = a[(i + 1) % l];
        if (linePolygon(a1, a2, b)) return true;
      }
      for (i = 0, l = b.length; i < l; ++i) if (pointInPolygon(b[i], a)) return true;
      for (i = 0, l = a.length; i < l; ++i) if (pointInPolygon(a[i], b)) return true;
      return false;
    }
    Intersection.polygonPolygon = polygonPolygon;
    function circleCircle(a, b) {
      var distance = a.position.sub(b.position).mag();
      return distance < a.radius + b.radius;
    }
    Intersection.circleCircle = circleCircle;
    function polygonCircle(polygon, circle) {
      var position = circle.position;
      if (pointInPolygon(position, polygon)) return true;
      for (var i = 0, l = polygon.length; i < l; i++) {
        var start = 0 === i ? polygon[polygon.length - 1] : polygon[i - 1];
        var end = polygon[i];
        if (pointLineDistance(position, start, end, true) < circle.radius) return true;
      }
      return false;
    }
    Intersection.polygonCircle = polygonCircle;
    function pointInPolygon(point, polygon) {
      var inside = false;
      var x = point.x;
      var y = point.y;
      var length = polygon.length;
      for (var i = 0, j = length - 1; i < length; j = i++) {
        var xi = polygon[i].x, yi = polygon[i].y, xj = polygon[j].x, yj = polygon[j].y, intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
        intersect && (inside = !inside);
      }
      return inside;
    }
    Intersection.pointInPolygon = pointInPolygon;
    function pointLineDistance(point, start, end, isSegment) {
      var dx = end.x - start.x;
      var dy = end.y - start.y;
      var d = dx * dx + dy * dy;
      var t = ((point.x - start.x) * dx + (point.y - start.y) * dy) / d;
      var p;
      p = isSegment ? d ? t < 0 ? start : t > 1 ? end : cc.v2(start.x + t * dx, start.y + t * dy) : start : cc.v2(start.x + t * dx, start.y + t * dy);
      dx = point.x - p.x;
      dy = point.y - p.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
    Intersection.pointLineDistance = pointLineDistance;
    cc.Intersection = module.exports = Intersection;
  }), {} ],
  173: [ (function(require, module, exports) {
    "use strict";
    cc.Collider.Polygon = cc.Class({
      properties: {
        threshold: {
          default: 1,
          serializable: false,
          visible: false
        },
        _offset: cc.v2(0, 0),
        offset: {
          get: function get() {
            return this._offset;
          },
          set: function set(value) {
            this._offset = value;
          },
          type: cc.Vec2
        },
        points: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.points"),
          default: function _default() {
            return [ cc.v2(-50, -50), cc.v2(50, -50), cc.v2(50, 50), cc.v2(-50, 50) ];
          },
          type: [ cc.Vec2 ]
        }
      },
      resetPointsByContour: false
    });
    var PolygonCollider = cc.Class({
      name: "cc.PolygonCollider",
      extends: cc.Collider,
      mixins: [ cc.Collider.Polygon ],
      editor: false
    });
    cc.PolygonCollider = module.exports = PolygonCollider;
  }), {} ],
  174: [ (function(require, module, exports) {
    "use strict";
    require("./CCCollisionManager");
    require("./CCCollider");
    require("./CCBoxCollider");
    require("./CCCircleCollider");
    require("./CCPolygonCollider");
  }), {
    "./CCBoxCollider": 167,
    "./CCCircleCollider": 168,
    "./CCCollider": 169,
    "./CCCollisionManager": 170,
    "./CCPolygonCollider": 173
  } ],
  175: [ (function(require, module, exports) {
    "use strict";
    require("./platform/CCClass");
    var Flags = require("./platform/CCObject").Flags;
    var jsArray = require("./platform/js").array;
    var IsStartCalled = Flags.IsStartCalled;
    var IsOnEnableCalled = Flags.IsOnEnableCalled;
    var IsEditorOnEnableCalled = Flags.IsEditorOnEnableCalled;
    var callerFunctor = false;
    var callOnEnableInTryCatch = false;
    var callOnDisableInTryCatch = false;
    function sortedIndex(array, comp) {
      var order = comp.constructor._executionOrder;
      var id = comp._id;
      for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
        var test = array[m];
        var testOrder = test.constructor._executionOrder;
        if (testOrder > order) h = m - 1; else if (testOrder < order) l = m + 1; else {
          var testId = test._id;
          if (testId > id) h = m - 1; else {
            if (!(testId < id)) return m;
            l = m + 1;
          }
        }
      }
      return ~l;
    }
    function stableRemoveInactive(iterator, flagToClear) {
      var array = iterator.array;
      var next = iterator.i + 1;
      while (next < array.length) {
        var comp = array[next];
        if (comp._enabled && comp.node && comp.node._activeInHierarchy) ++next; else {
          iterator.removeAt(next);
          flagToClear && (comp._objFlags &= ~flagToClear);
        }
      }
    }
    var LifeCycleInvoker = cc.Class({
      __ctor__: function __ctor__(invokeFunc) {
        var Iterator = jsArray.MutableForwardIterator;
        this._zero = new Iterator([]);
        this._neg = new Iterator([]);
        this._pos = new Iterator([]);
        false;
        this._invoke = invokeFunc;
      },
      statics: {
        stableRemoveInactive: stableRemoveInactive
      },
      add: null,
      remove: null,
      invoke: null
    });
    function compareOrder(a, b) {
      return a.constructor._executionOrder - b.constructor._executionOrder;
    }
    var OneOffInvoker = cc.Class({
      extends: LifeCycleInvoker,
      add: function add(comp) {
        var order = comp.constructor._executionOrder;
        (0 === order ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
      },
      remove: function remove(comp) {
        var order = comp.constructor._executionOrder;
        (0 === order ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
      },
      cancelInactive: function cancelInactive(flagToClear) {
        stableRemoveInactive(this._zero, flagToClear);
        stableRemoveInactive(this._neg, flagToClear);
        stableRemoveInactive(this._pos, flagToClear);
      },
      invoke: function invoke() {
        var compsNeg = this._neg;
        if (compsNeg.array.length > 0) {
          compsNeg.array.sort(compareOrder);
          this._invoke(compsNeg);
          compsNeg.array.length = 0;
        }
        this._invoke(this._zero);
        this._zero.array.length = 0;
        var compsPos = this._pos;
        if (compsPos.array.length > 0) {
          compsPos.array.sort(compareOrder);
          this._invoke(compsPos);
          compsPos.array.length = 0;
        }
      }
    });
    var ReusableInvoker = cc.Class({
      extends: LifeCycleInvoker,
      add: function add(comp) {
        var order = comp.constructor._executionOrder;
        if (0 === order) this._zero.array.push(comp); else {
          var array = order < 0 ? this._neg.array : this._pos.array;
          var i = sortedIndex(array, comp);
          if (i < 0) array.splice(~i, 0, comp); else {
            true;
            cc.error("component already added");
          }
        }
      },
      remove: function remove(comp) {
        var order = comp.constructor._executionOrder;
        if (0 === order) this._zero.fastRemove(comp); else {
          var iterator = order < 0 ? this._neg : this._pos;
          var i = sortedIndex(iterator.array, comp);
          i >= 0 && iterator.removeAt(i);
        }
      },
      invoke: function invoke(dt) {
        this._neg.array.length > 0 && this._invoke(this._neg, dt);
        this._invoke(this._zero, dt);
        this._pos.array.length > 0 && this._invoke(this._pos, dt);
      }
    });
    function enableInEditor(comp) {
      if (!(comp._objFlags & IsEditorOnEnableCalled)) {
        cc.engine.emit("component-enabled", comp.uuid);
        comp._objFlags |= IsEditorOnEnableCalled;
      }
    }
    function createInvokeImpl(indiePath, useDt, ensureFlag, fastPath) {
      true;
      var body = "var a=it.array;for(it.i=0;it.i<a.length;++it.i){var c=a[it.i];" + indiePath + "}";
      fastPath = useDt ? Function("it", "dt", body) : Function("it", body);
      indiePath = Function("c", "dt", indiePath);
      return function(iterator, dt) {
        try {
          fastPath(iterator, dt);
        } catch (e) {
          cc._throw(e);
          var array = iterator.array;
          ensureFlag && (array[iterator.i]._objFlags |= ensureFlag);
          ++iterator.i;
          for (;iterator.i < array.length; ++iterator.i) try {
            indiePath(array[iterator.i], dt);
          } catch (e) {
            cc._throw(e);
            ensureFlag && (array[iterator.i]._objFlags |= ensureFlag);
          }
        }
      };
    }
    var invokeStart = createInvokeImpl("c.start();c._objFlags|=" + IsStartCalled, false, IsStartCalled);
    var invokeUpdate = createInvokeImpl("c.update(dt)", true);
    var invokeLateUpdate = createInvokeImpl("c.lateUpdate(dt)", true);
    function ctor() {
      this.startInvoker = new OneOffInvoker(invokeStart);
      this.updateInvoker = new ReusableInvoker(invokeUpdate);
      this.lateUpdateInvoker = new ReusableInvoker(invokeLateUpdate);
      this._deferredComps = [];
      this._updating = false;
    }
    var ComponentScheduler = cc.Class({
      ctor: ctor,
      unscheduleAll: ctor,
      statics: {
        LifeCycleInvoker: LifeCycleInvoker,
        OneOffInvoker: OneOffInvoker,
        createInvokeImpl: createInvokeImpl,
        invokeOnEnable: function(iterator) {
          var compScheduler = cc.director._compScheduler;
          var array = iterator.array;
          for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
            var comp = array[iterator.i];
            if (comp._enabled) {
              comp.onEnable();
              var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
              deactivatedDuringOnEnable || compScheduler._onEnabled(comp);
            }
          }
        }
      },
      _onEnabled: function _onEnabled(comp) {
        cc.director.getScheduler().resumeTarget(comp);
        comp._objFlags |= IsOnEnableCalled;
        this._updating ? this._deferredComps.push(comp) : this._scheduleImmediate(comp);
      },
      _onDisabled: function _onDisabled(comp) {
        cc.director.getScheduler().pauseTarget(comp);
        comp._objFlags &= ~IsOnEnableCalled;
        var index = this._deferredComps.indexOf(comp);
        if (index >= 0) {
          jsArray.fastRemoveAt(this._deferredComps, index);
          return;
        }
        !comp.start || comp._objFlags & IsStartCalled || this.startInvoker.remove(comp);
        comp.update && this.updateInvoker.remove(comp);
        comp.lateUpdate && this.lateUpdateInvoker.remove(comp);
      },
      enableComp: function(comp, invoker) {
        if (!(comp._objFlags & IsOnEnableCalled)) {
          if (comp.onEnable) {
            if (invoker) {
              invoker.add(comp);
              return;
            }
            comp.onEnable();
            var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;
            if (deactivatedDuringOnEnable) return;
          }
          this._onEnabled(comp);
        }
      },
      disableComp: function(comp) {
        if (comp._objFlags & IsOnEnableCalled) {
          comp.onDisable && comp.onDisable();
          this._onDisabled(comp);
        }
      },
      _scheduleImmediate: function _scheduleImmediate(comp) {
        "function" !== typeof comp.start || comp._objFlags & IsStartCalled || this.startInvoker.add(comp);
        "function" === typeof comp.update && this.updateInvoker.add(comp);
        "function" === typeof comp.lateUpdate && this.lateUpdateInvoker.add(comp);
      },
      _deferredSchedule: function _deferredSchedule() {
        var comps = this._deferredComps;
        for (var i = 0, len = comps.length; i < len; i++) this._scheduleImmediate(comps[i]);
        comps.length = 0;
      },
      _startForNewComps: function _startForNewComps() {
        if (this._deferredComps.length > 0) {
          this._deferredSchedule();
          this.startInvoker.invoke();
        }
      },
      startPhase: function startPhase() {
        this._updating = true;
        this.startInvoker.invoke();
        this._startForNewComps();
      },
      updatePhase: function updatePhase(dt) {
        this.updateInvoker.invoke(dt);
      },
      lateUpdatePhase: function lateUpdatePhase(dt) {
        this.lateUpdateInvoker.invoke(dt);
        this._updating = false;
        this._startForNewComps();
      }
    });
    module.exports = ComponentScheduler;
  }), {
    "./platform/CCClass": 272,
    "./platform/CCObject": 278,
    "./platform/js": 294,
    "./utils/misc": 386
  } ],
  176: [ (function(require, module, exports) {
    "use strict";
    var AnimationAnimator = require("../../animation/animation-animator");
    var AnimationClip = require("../../animation/animation-clip");
    var EventTarget = require("../event/event-target");
    var js = require("../platform/js");
    var equalClips = function(clip1, clip2) {
      return clip1 === clip2;
    };
    var EventType = cc.Enum({
      PLAY: "play",
      STOP: "stop",
      PAUSE: "pause",
      RESUME: "resume",
      LASTFRAME: "lastframe",
      FINISHED: "finished"
    });
    var Animation = cc.Class({
      name: "cc.Animation",
      extends: require("./CCComponent"),
      mixins: [ EventTarget ],
      editor: false,
      statics: {
        EventType: EventType
      },
      ctor: function ctor() {
        cc.EventTarget.call(this);
        this._animator = null;
        this._nameToState = js.createMap(true);
        this._didInit = false;
        this._currentClip = null;
      },
      properties: {
        _defaultClip: {
          default: null,
          type: AnimationClip
        },
        defaultClip: {
          type: AnimationClip,
          get: function get() {
            return this._defaultClip;
          },
          set: function set(value) {
            true;
            return;
            var contain;
          },
          tooltip: (true, "i18n:COMPONENT.animation.default_clip")
        },
        currentClip: {
          get: function get() {
            return this._currentClip;
          },
          set: function set(value) {
            this._currentClip = value;
          },
          type: AnimationClip,
          visible: false
        },
        _writableClips: {
          get: function get() {
            return this._clips;
          },
          set: function set(val) {
            this._didInit = false;
            this._clips = val;
            this._init();
          },
          type: [ AnimationClip ]
        },
        _clips: {
          default: [],
          type: [ AnimationClip ],
          tooltip: (true, "i18n:COMPONENT.animation.clips"),
          visible: true
        },
        playOnLoad: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.animation.play_on_load")
        }
      },
      start: function start() {
        if ((true, this.playOnLoad) && this._defaultClip) {
          var isPlaying = this._animator && this._animator.isPlaying;
          if (!isPlaying) {
            var state = this.getAnimationState(this._defaultClip.name);
            this._animator.playState(state);
          }
        }
      },
      onEnable: function onEnable() {
        this._animator && this._animator.resume();
      },
      onDisable: function onDisable() {
        this._animator && this._animator.pause();
      },
      onDestroy: function onDestroy() {
        this.stop();
      },
      getClips: function getClips() {
        return this._clips;
      },
      play: function play(name, startTime) {
        var state = this.playAdditive(name, startTime);
        this._animator.stopStatesExcept(state);
        return state;
      },
      playAdditive: function playAdditive(name, startTime) {
        this._init();
        var state = this.getAnimationState(name || this._defaultClip && this._defaultClip.name);
        if (state) {
          this.enabled = true;
          var animator = this._animator;
          if (animator.isPlaying && state.isPlaying) if (state.isPaused) animator.resumeState(state); else {
            animator.stopState(state);
            animator.playState(state, startTime);
          } else animator.playState(state, startTime);
          this.enabledInHierarchy || animator.pause();
          this.currentClip = state.clip;
        }
        return state;
      },
      stop: function stop(name) {
        if (!this._didInit) return;
        if (name) {
          var state = this._nameToState[name];
          state && this._animator.stopState(state);
        } else this._animator.stop();
      },
      pause: function pause(name) {
        if (!this._didInit) return;
        if (name) {
          var state = this._nameToState[name];
          state && this._animator.pauseState(state);
        } else this.enabled = false;
      },
      resume: function resume(name) {
        if (!this._didInit) return;
        if (name) {
          var state = this.getAnimationState(name);
          state && this._animator.resumeState(state);
        } else this.enabled = true;
      },
      setCurrentTime: function setCurrentTime(time, name) {
        this._init();
        if (name) {
          var state = this.getAnimationState(name);
          state && this._animator.setStateTime(state, time);
        } else this._animator.setStateTime(time);
      },
      getAnimationState: function getAnimationState(name) {
        this._init();
        var state = this._nameToState[name];
        false;
        state && !state.curveLoaded && this._animator._reloadClip(state);
        return state || null;
      },
      hasAnimationState: function hasAnimationState(name) {
        this._init();
        return !!this._nameToState[name];
      },
      addClip: function addClip(clip, newName) {
        if (!clip) {
          cc.warnID(3900);
          return;
        }
        this._init();
        cc.js.array.contains(this._clips, clip) || this._clips.push(clip);
        newName = newName || clip.name;
        var oldState = this._nameToState[newName];
        if (oldState) {
          if (oldState.clip === clip) return oldState;
          var index = this._clips.indexOf(oldState.clip);
          -1 !== index && this._clips.splice(index, 1);
        }
        var newState = new cc.AnimationState(clip, newName);
        this._nameToState[newName] = newState;
        return newState;
      },
      removeClip: function removeClip(clip, force) {
        if (!clip) {
          cc.warnID(3901);
          return;
        }
        this._init();
        var state;
        for (var name in this._nameToState) {
          state = this._nameToState[name];
          if (equalClips(state.clip, clip)) break;
        }
        if (clip === this._defaultClip) {
          if (!force) {
            true;
            cc.warnID(3902);
            return;
          }
          this._defaultClip = null;
        }
        if (state && state.isPlaying) {
          if (!force) {
            true;
            cc.warnID(3903);
            return;
          }
          this.stop(state.name);
        }
        this._clips = this._clips.filter((function(item) {
          return !equalClips(item, clip);
        }));
        state && delete this._nameToState[state.name];
      },
      sample: function sample(name) {
        this._init();
        if (name) {
          var state = this.getAnimationState(name);
          state && state.sample();
        } else this._animator.sample();
      },
      on: function on(type, callback, target, useCapture) {
        this._init();
        var ret = this._EventTargetOn(type, callback, target, useCapture);
        if ("lastframe" === type) {
          var states = this._nameToState;
          for (var name in states) states[name]._lastframeEventOn = true;
        }
        return ret;
      },
      off: function off(type, callback, target, useCapture) {
        this._init();
        if ("lastframe" === type) {
          var states = this._nameToState;
          for (var name in states) states[name]._lastframeEventOn = false;
        }
        this._EventTargetOff(type, callback, target, useCapture);
      },
      _init: function _init() {
        if (this._didInit) return;
        this._didInit = true;
        this._animator = new AnimationAnimator(this.node, this);
        this._createStates();
      },
      _createStates: function _createStates() {
        this._nameToState = js.createMap(true);
        var state = null;
        var defaultClipState = false;
        for (var i = 0; i < this._clips.length; ++i) {
          var clip = this._clips[i];
          if (clip) {
            state = new cc.AnimationState(clip);
            false;
            this._nameToState[state.name] = state;
            equalClips(this._defaultClip, clip) && (defaultClipState = state);
          }
        }
        if (this._defaultClip && !defaultClipState) {
          state = new cc.AnimationState(this._defaultClip);
          false;
          this._nameToState[state.name] = state;
        }
      }
    });
    Animation.prototype._EventTargetOn = EventTarget.prototype.on;
    Animation.prototype._EventTargetOff = EventTarget.prototype.off;
    cc.Animation = module.exports = Animation;
  }), {
    "../../animation/animation-animator": 10,
    "../../animation/animation-clip": 11,
    "../event/event-target": 219,
    "../platform/js": 294,
    "./CCComponent": 181
  } ],
  177: [ (function(require, module, exports) {
    "use strict";
    var misc = require("../utils/misc");
    var Component = require("./CCComponent");
    var AudioClip = require("../assets/CCAudioClip");
    var AudioSource = cc.Class({
      name: "cc.AudioSource",
      extends: Component,
      editor: false,
      ctor: function ctor() {
        this.audio = new cc._Audio();
      },
      properties: {
        _clip: {
          default: null,
          type: AudioClip
        },
        _volume: 1,
        _mute: false,
        _loop: false,
        _pausedFlag: {
          default: false,
          serializable: false
        },
        _firstlyEnabled: true,
        isPlaying: {
          get: function get() {
            var state = this.audio.getState();
            return state === cc._Audio.State.PLAYING;
          },
          visible: false
        },
        clip: {
          get: function get() {
            return this._clip;
          },
          set: function set(value) {
            if (value === this._clip) return;
            if (!(value instanceof AudioClip)) return cc.error("Wrong type of AudioClip.");
            this._clip = value;
            this.audio.stop();
            this.audio.src = this._clip;
            this.preload && this._clip._ensureLoaded();
          },
          type: AudioClip,
          tooltip: (true, "i18n:COMPONENT.audio.clip"),
          animatable: false
        },
        volume: {
          get: function get() {
            return this._volume;
          },
          set: function set(value) {
            value = misc.clamp01(value);
            this._volume = value;
            this._mute || this.audio.setVolume(value);
            return value;
          },
          tooltip: (true, "i18n:COMPONENT.audio.volume")
        },
        mute: {
          get: function get() {
            return this._mute;
          },
          set: function set(value) {
            this._mute = value;
            this.audio.setVolume(value ? 0 : this._volume);
            return value;
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.audio.mute")
        },
        loop: {
          get: function get() {
            return this._loop;
          },
          set: function set(value) {
            this._loop = value;
            this.audio.setLoop(value);
            return value;
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.audio.loop")
        },
        playOnLoad: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.audio.play_on_load"),
          animatable: false
        },
        preload: {
          default: false,
          animatable: false
        }
      },
      _pausedCallback: function _pausedCallback() {
        var state = this.audio.getState();
        if (state === cc._Audio.State.PLAYING) {
          this.audio.pause();
          this._pausedFlag = true;
        }
      },
      _restoreCallback: function _restoreCallback() {
        this._pausedFlag && this.audio.resume();
        this._pausedFlag = false;
      },
      onLoad: function onLoad() {
        this.audio.src || (this.audio.src = this._clip);
        this.preload && this._clip._ensureLoaded();
      },
      onEnable: function onEnable() {
        if (this.playOnLoad && this._firstlyEnabled) {
          this._firstlyEnabled = false;
          this.play();
        }
        cc.game.on(cc.game.EVENT_HIDE, this._pausedCallback, this);
        cc.game.on(cc.game.EVENT_SHOW, this._restoreCallback, this);
      },
      onDisable: function onDisable() {
        this.stop();
        cc.game.off(cc.game.EVENT_HIDE, this._pausedCallback, this);
        cc.game.off(cc.game.EVENT_SHOW, this._restoreCallback, this);
      },
      onDestroy: function onDestroy() {
        this.audio.destroy();
      },
      play: function play() {
        if (false, !this._clip) return;
        var audio = this.audio;
        audio.setVolume(this._mute ? 0 : this._volume);
        audio.setLoop(this._loop);
        audio.setCurrentTime(0);
        audio.play();
      },
      stop: function stop() {
        this.audio.stop();
      },
      pause: function pause() {
        this.audio.pause();
      },
      resume: function resume() {
        this.audio.resume();
      },
      rewind: function rewind() {
        this.audio.setCurrentTime(0);
      },
      getCurrentTime: function getCurrentTime() {
        return this.audio.getCurrentTime();
      },
      setCurrentTime: function setCurrentTime(time) {
        this.audio.setCurrentTime(time);
        return time;
      },
      getDuration: function getDuration() {
        return this.audio.getDuration();
      }
    });
    cc.AudioSource = module.exports = AudioSource;
  }), {
    "../assets/CCAudioClip": 138,
    "../utils/misc": 386,
    "./CCComponent": 181
  } ],
  178: [ (function(require, module, exports) {
    "use strict";
    var BlockEvents = [ "touchstart", "touchmove", "touchend", "mousedown", "mousemove", "mouseup", "mouseenter", "mouseleave", "mousewheel" ];
    function stopPropagation(event) {
      event.stopPropagation();
    }
    var BlockInputEvents = cc.Class({
      name: "cc.BlockInputEvents",
      extends: require("./CCComponent"),
      editor: {
        menu: "i18n:MAIN_MENU.component.ui/Block Input Events",
        inspector: "packages://inspector/inspectors/comps/block-input-events.js",
        help: "i18n:COMPONENT.help_url.block_input_events"
      },
      onEnable: function onEnable() {
        for (var i = 0; i < BlockEvents.length; i++) this.node.on(BlockEvents[i], stopPropagation, this);
      },
      onDisable: function onDisable() {
        for (var i = 0; i < BlockEvents.length; i++) this.node.off(BlockEvents[i], stopPropagation, this);
      }
    });
    cc.BlockInputEvents = module.exports = BlockInputEvents;
  }), {
    "./CCComponent": 181
  } ],
  179: [ (function(require, module, exports) {
    "use strict";
    var Component = require("./CCComponent");
    var GraySpriteState = require("../utils/gray-sprite-state");
    var Transition = cc.Enum({
      NONE: 0,
      COLOR: 1,
      SPRITE: 2,
      SCALE: 3
    });
    var State = cc.Enum({
      NORMAL: 0,
      HOVER: 1,
      PRESSED: 2,
      DISABLED: 3
    });
    var Button = cc.Class({
      name: "cc.Button",
      extends: Component,
      mixins: [ GraySpriteState ],
      ctor: function ctor() {
        this._pressed = false;
        this._hovered = false;
        this._fromColor = null;
        this._toColor = null;
        this._time = 0;
        this._transitionFinished = true;
        this._fromScale = cc.Vec2.ZERO;
        this._toScale = cc.Vec2.ZERO;
        this._originalScale = null;
        this._graySpriteMaterial = null;
        this._spriteMaterial = null;
        this._sprite = null;
      },
      editor: false,
      properties: {
        interactable: {
          default: true,
          tooltip: (true, "i18n:COMPONENT.button.interactable"),
          notify: function notify() {
            this._updateState();
            this.interactable || this._resetState();
          },
          animatable: false
        },
        _resizeToTarget: {
          animatable: false,
          set: function set(value) {
            value && this._resizeNodeToTargetNode();
          }
        },
        enableAutoGrayEffect: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.button.auto_gray_effect"),
          notify: function notify() {
            this._updateDisabledState(true);
          }
        },
        transition: {
          default: Transition.NONE,
          tooltip: (true, "i18n:COMPONENT.button.transition"),
          type: Transition,
          animatable: false,
          notify: function notify(oldValue) {
            this._updateTransition(oldValue);
          },
          formerlySerializedAs: "transition"
        },
        normalColor: {
          default: cc.Color.WHITE,
          displayName: "Normal",
          tooltip: (true, "i18n:COMPONENT.button.normal_color"),
          notify: function notify() {
            this.transition === Transition.Color && this._getButtonState() === State.NORMAL && (this._getTarget().opacity = this.normalColor.a);
            this._updateState();
          }
        },
        pressedColor: {
          default: cc.color(211, 211, 211),
          displayName: "Pressed",
          tooltip: (true, "i18n:COMPONENT.button.pressed_color"),
          notify: function notify() {
            this.transition === Transition.Color && this._getButtonState() === State.PRESSED && (this._getTarget().opacity = this.pressedColor.a);
            this._updateState();
          },
          formerlySerializedAs: "pressedColor"
        },
        hoverColor: {
          default: cc.Color.WHITE,
          displayName: "Hover",
          tooltip: (true, "i18n:COMPONENT.button.hover_color"),
          notify: function notify() {
            this.transition === Transition.Color && this._getButtonState() === State.HOVER && (this._getTarget().opacity = this.hoverColor.a);
            this._updateState();
          },
          formerlySerializedAs: "hoverColor"
        },
        disabledColor: {
          default: cc.color(124, 124, 124),
          displayName: "Disabled",
          tooltip: (true, "i18n:COMPONENT.button.disabled_color"),
          notify: function notify() {
            this.transition === Transition.Color && this._getButtonState() === State.DISABLED && (this._getTarget().opacity = this.disabledColor.a);
            this._updateState();
          }
        },
        duration: {
          default: .1,
          range: [ 0, 10 ],
          tooltip: (true, "i18n:COMPONENT.button.duration")
        },
        zoomScale: {
          default: 1.2,
          tooltip: (true, "i18n:COMPONENT.button.zoom_scale")
        },
        normalSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Normal",
          tooltip: (true, "i18n:COMPONENT.button.normal_sprite"),
          notify: function notify() {
            this._updateState();
          }
        },
        pressedSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Pressed",
          tooltip: (true, "i18n:COMPONENT.button.pressed_sprite"),
          formerlySerializedAs: "pressedSprite",
          notify: function notify() {
            this._updateState();
          }
        },
        hoverSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Hover",
          tooltip: (true, "i18n:COMPONENT.button.hover_sprite"),
          formerlySerializedAs: "hoverSprite",
          notify: function notify() {
            this._updateState();
          }
        },
        disabledSprite: {
          default: null,
          type: cc.SpriteFrame,
          displayName: "Disabled",
          tooltip: (true, "i18n:COMPONENT.button.disabled_sprite"),
          notify: function notify() {
            this._updateState();
          }
        },
        target: {
          default: null,
          type: cc.Node,
          tooltip: (true, "i18n:COMPONENT.button.target"),
          notify: function notify(oldValue) {
            this._applyTarget();
            oldValue && this.target !== oldValue && this._unregisterTargetEvent(oldValue);
          }
        },
        clickEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: (true, "i18n:COMPONENT.button.click_events")
        }
      },
      statics: {
        Transition: Transition
      },
      __preload: function __preload() {
        this._applyTarget();
        this._resetState();
      },
      _resetState: function _resetState() {
        this._pressed = false;
        this._hovered = false;
        var target = this._getTarget();
        var transition = this.transition;
        var originalScale = this._originalScale;
        transition === Transition.COLOR && this.interactable ? this._setTargetColor(this.normalColor) : transition === Transition.SCALE && originalScale && target.setScale(originalScale.x, originalScale.y);
        this._transitionFinished = true;
      },
      onEnable: function onEnable() {
        this.normalSprite && this.normalSprite.ensureLoadTexture();
        this.hoverSprite && this.hoverSprite.ensureLoadTexture();
        this.pressedSprite && this.pressedSprite.ensureLoadTexture();
        this.disabledSprite && this.disabledSprite.ensureLoadTexture();
        true;
        this._registerNodeEvent();
        this._updateState();
      },
      onDisable: function onDisable() {
        this._resetState();
        true;
        this._unregisterNodeEvent();
      },
      _getTarget: function _getTarget() {
        return this.target ? this.target : this.node;
      },
      _onTargetSpriteFrameChanged: function _onTargetSpriteFrameChanged(comp) {
        this.transition === Transition.SPRITE && this._setCurrentStateSprite(comp.spriteFrame);
      },
      _onTargetColorChanged: function _onTargetColorChanged(color) {
        this.transition === Transition.COLOR && this._setCurrentStateColor(color);
      },
      _onTargetScaleChanged: function _onTargetScaleChanged() {
        var target = this._getTarget();
        if (this._originalScale && (this.transition !== Transition.SCALE || this._transitionFinished)) {
          this._originalScale.x = target.scaleX;
          this._originalScale.y = target.scaleY;
        }
      },
      _setTargetColor: function _setTargetColor(color) {
        var target = this._getTarget();
        var cloneColor = color.clone();
        target.opacity = cloneColor.a;
        cloneColor.a = 255;
        target.color = cloneColor;
      },
      _getStateColor: function _getStateColor(state) {
        switch (state) {
         case State.NORMAL:
          return this.normalColor;

         case State.HOVER:
          return this.hoverColor;

         case State.PRESSED:
          return this.pressedColor;

         case State.DISABLED:
          return this.disabledColor;
        }
      },
      _getStateSprite: function _getStateSprite(state) {
        switch (state) {
         case State.NORMAL:
          return this.normalSprite;

         case State.HOVER:
          return this.hoverSprite;

         case State.PRESSED:
          return this.pressedSprite;

         case State.DISABLED:
          return this.disabledSprite;
        }
      },
      _setCurrentStateColor: function _setCurrentStateColor(color) {
        switch (this._getButtonState()) {
         case State.NORMAL:
          this.normalColor = color;
          break;

         case State.HOVER:
          this.hoverColor = color;
          break;

         case State.PRESSED:
          this.pressedColor = color;
          break;

         case State.DISABLED:
          this.disabledColor = color;
        }
      },
      _setCurrentStateSprite: function _setCurrentStateSprite(spriteFrame) {
        switch (this._getButtonState()) {
         case State.NORMAL:
          this.normalSprite = spriteFrame;
          break;

         case State.HOVER:
          this.hoverSprite = spriteFrame;
          break;

         case State.PRESSED:
          this.pressedSprite = spriteFrame;
          break;

         case State.DISABLED:
          this.disabledSprite = spriteFrame;
        }
      },
      update: function update(dt) {
        var target = this._getTarget();
        if (this._transitionFinished) return;
        if (this.transition !== Transition.COLOR && this.transition !== Transition.SCALE) return;
        this.time += dt;
        var ratio = 1;
        this.duration > 0 && (ratio = this.time / this.duration);
        ratio >= 1 && (ratio = 1);
        if (this.transition === Transition.COLOR) {
          var color = this._fromColor.lerp(this._toColor, ratio);
          this._setTargetColor(color);
        } else this.transition === Transition.SCALE && this._originalScale && (target.scale = this._fromScale.lerp(this._toScale, ratio));
        1 === ratio && (this._transitionFinished = true);
      },
      _registerNodeEvent: function _registerNodeEvent() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);
        this.node.on(cc.Node.EventType.MOUSE_ENTER, this._onMouseMoveIn, this);
        this.node.on(cc.Node.EventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
      },
      _unregisterNodeEvent: function _unregisterNodeEvent() {
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMove, this);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancel, this);
        this.node.off(cc.Node.EventType.MOUSE_ENTER, this._onMouseMoveIn, this);
        this.node.off(cc.Node.EventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
      },
      _registerTargetEvent: function _registerTargetEvent(target) {
        false;
        target.on(cc.Node.EventType.SCALE_CHANGED, this._onTargetScaleChanged, this);
      },
      _unregisterTargetEvent: function _unregisterTargetEvent(target) {
        false;
        target.off(cc.Node.EventType.SCALE_CHANGED, this._onTargetScaleChanged, this);
      },
      _getTargetSprite: function _getTargetSprite(target) {
        var sprite = null;
        target && (sprite = target.getComponent(cc.Sprite));
        return sprite;
      },
      _applyTarget: function _applyTarget() {
        var target = this._getTarget();
        this._sprite = this._getTargetSprite(target);
        this._originalScale || (this._originalScale = cc.Vec2.ZERO);
        this._originalScale.x = target.scaleX;
        this._originalScale.y = target.scaleY;
        this._registerTargetEvent(target);
      },
      _onTouchBegan: function _onTouchBegan(event) {
        if (!this.interactable || !this.enabledInHierarchy) return;
        this._pressed = true;
        this._updateState();
        event.stopPropagation();
      },
      _onTouchMove: function _onTouchMove(event) {
        if (!this.interactable || !this.enabledInHierarchy || !this._pressed) return;
        var touch = event.touch;
        var hit = this.node._hitTest(touch.getLocation());
        var target = this._getTarget();
        var originalScale = this._originalScale;
        if (this.transition === Transition.SCALE && originalScale) if (hit) {
          this._fromScale.x = originalScale.x;
          this._fromScale.y = originalScale.y;
          this._toScale.x = originalScale.x * this.zoomScale;
          this._toScale.y = originalScale.y * this.zoomScale;
          this._transitionFinished = false;
        } else {
          this.time = 0;
          this._transitionFinished = true;
          target.setScale(originalScale.x, originalScale.y);
        } else {
          var state;
          state = hit ? State.PRESSED : State.NORMAL;
          this._applyTransition(state);
        }
        event.stopPropagation();
      },
      _onTouchEnded: function _onTouchEnded(event) {
        if (!this.interactable || !this.enabledInHierarchy) return;
        if (this._pressed) {
          cc.Component.EventHandler.emitEvents(this.clickEvents, event);
          this.node.emit("click", this);
        }
        this._pressed = false;
        this._updateState();
        event.stopPropagation();
      },
      _onTouchCancel: function _onTouchCancel() {
        if (!this.interactable || !this.enabledInHierarchy) return;
        this._pressed = false;
        this._updateState();
      },
      _onMouseMoveIn: function _onMouseMoveIn() {
        if (this._pressed || !this.interactable || !this.enabledInHierarchy) return;
        if (this.transition === Transition.SPRITE && !this.hoverSprite) return;
        if (!this._hovered) {
          this._hovered = true;
          this._updateState();
        }
      },
      _onMouseMoveOut: function _onMouseMoveOut() {
        if (this._hovered) {
          this._hovered = false;
          this._updateState();
        }
      },
      _updateState: function _updateState() {
        var state = this._getButtonState();
        this._applyTransition(state);
        this._updateDisabledState();
      },
      _getButtonState: function _getButtonState() {
        var state;
        state = this.interactable ? this._pressed ? State.PRESSED : this._hovered ? State.HOVER : State.NORMAL : State.DISABLED;
        return state;
      },
      _updateColorTransitionImmediately: function _updateColorTransitionImmediately(state) {
        var color = this._getStateColor(state);
        this._setTargetColor(color);
        this._fromColor = color.clone();
        this._toColor = color;
      },
      _updateColorTransition: function _updateColorTransition(state) {
        if (false, state === State.DISABLED) this._updateColorTransitionImmediately(state); else {
          var target = this._getTarget();
          var color = this._getStateColor(state);
          this._fromColor = target.color.clone();
          this._toColor = color;
          this.time = 0;
          this._transitionFinished = false;
        }
      },
      _updateSpriteTransition: function _updateSpriteTransition(state) {
        var sprite = this._getStateSprite(state);
        this._sprite && sprite && (this._sprite.spriteFrame = sprite);
      },
      _updateScaleTransition: function _updateScaleTransition(state) {
        state === State.PRESSED ? this._zoomUp() : this._zoomBack();
      },
      _zoomUp: function _zoomUp() {
        if (!this._originalScale) return;
        this._fromScale.x = this._originalScale.x;
        this._fromScale.y = this._originalScale.y;
        this._toScale.x = this._originalScale.x * this.zoomScale;
        this._toScale.y = this._originalScale.y * this.zoomScale;
        this.time = 0;
        this._transitionFinished = false;
      },
      _zoomBack: function _zoomBack() {
        if (!this._originalScale) return;
        var target = this._getTarget();
        this._fromScale.x = target.scaleX;
        this._fromScale.y = target.scaleY;
        this._toScale.x = this._originalScale.x;
        this._toScale.y = this._originalScale.y;
        this.time = 0;
        this._transitionFinished = false;
      },
      _updateTransition: function _updateTransition(oldTransition) {
        oldTransition === Transition.COLOR ? this._updateColorTransitionImmediately(State.NORMAL) : oldTransition === Transition.SPRITE && this._updateSpriteTransition(State.NORMAL);
        this._updateState();
      },
      _applyTransition: function _applyTransition(state) {
        var transition = this.transition;
        transition === Transition.COLOR ? this._updateColorTransition(state) : transition === Transition.SPRITE ? this._updateSpriteTransition(state) : transition === Transition.SCALE && this._updateScaleTransition(state);
      },
      _resizeNodeToTargetNode: false,
      _updateDisabledState: function _updateDisabledState(force) {
        if (!this._sprite) return;
        if (this.enableAutoGrayEffect || force) {
          var useGrayMaterial = false;
          this.transition === Transition.SPRITE && this.disabledSprite || (useGrayMaterial = this.enableAutoGrayEffect && !this.interactable);
          this._switchGrayMaterial(useGrayMaterial, this._sprite);
        }
      }
    });
    cc.Button = module.exports = Button;
  }), {
    "../utils/gray-sprite-state": 383,
    "./CCComponent": 181
  } ],
  180: [ (function(require, module, exports) {
    "use strict";
    var Camera = require("../camera/CCCamera");
    var Component = require("./CCComponent");
    function resetWidgetComponent(canvas) {
      var widget = canvas.node.getComponent(cc.Widget);
      widget || (widget = canvas.node.addComponent(cc.Widget));
      widget.isAlignTop = true;
      widget.isAlignBottom = true;
      widget.isAlignLeft = true;
      widget.isAlignRight = true;
      widget.top = 0;
      widget.bottom = 0;
      widget.left = 0;
      widget.right = 0;
    }
    var Canvas = cc.Class({
      name: "cc.Canvas",
      extends: Component,
      editor: false,
      resetInEditor: false,
      statics: {
        instance: null
      },
      properties: {
        _designResolution: cc.size(960, 640),
        designResolution: {
          get: function get() {
            return cc.size(this._designResolution);
          },
          set: function set(value) {
            this._designResolution.width = value.width;
            this._designResolution.height = value.height;
            this.applySettings();
          },
          tooltip: (true, "i18n:COMPONENT.canvas.design_resolution")
        },
        _fitWidth: false,
        _fitHeight: true,
        fitHeight: {
          get: function get() {
            return this._fitHeight;
          },
          set: function set(value) {
            if (this._fitHeight !== value) {
              this._fitHeight = value;
              this.applySettings();
            }
          },
          tooltip: (true, "i18n:COMPONENT.canvas.fit_height")
        },
        fitWidth: {
          get: function get() {
            return this._fitWidth;
          },
          set: function set(value) {
            if (this._fitWidth !== value) {
              this._fitWidth = value;
              this.applySettings();
            }
          },
          tooltip: (true, "i18n:COMPONENT.canvas.fit_width")
        }
      },
      _fitDesignResolution: false,
      __preload: function __preload() {
        true;
        var Flags = cc.Object.Flags;
        this._objFlags |= Flags.IsPositionLocked | Flags.IsAnchorLocked | Flags.IsSizeLocked;
        if (Canvas.instance) return cc.warnID(6700, this.node.name, Canvas.instance.node.name);
        Canvas.instance = this;
        this.applySettings();
        var widget = this.getComponent(cc.Widget);
        !!widget && widget.updateAlignment();
        false;
      },
      start: function start() {
        if (!Camera.main && cc.game.renderType !== cc.game.RENDER_TYPE_CANVAS) {
          var cameraNode = new cc.Node("Main Camera");
          cameraNode.parent = this.node;
          cameraNode.setSiblingIndex(0);
          var camera = cameraNode.addComponent(Camera);
          var ClearFlags = Camera.ClearFlags;
          camera.clearFlags = ClearFlags.COLOR | ClearFlags.DEPTH | ClearFlags.STENCIL;
          camera.depth = -1;
        }
      },
      onDestroy: function onDestroy() {
        false;
        Canvas.instance === this && (Canvas.instance = null);
      },
      applySettings: function applySettings() {
        var ResolutionPolicy = cc.ResolutionPolicy;
        var policy;
        policy = this.fitHeight && this.fitWidth ? ResolutionPolicy.SHOW_ALL : this.fitHeight || this.fitWidth ? this.fitWidth ? ResolutionPolicy.FIXED_WIDTH : ResolutionPolicy.FIXED_HEIGHT : ResolutionPolicy.NO_BORDER;
        var designRes = this._designResolution;
        false;
        cc.view.setDesignResolutionSize(designRes.width, designRes.height, policy);
      }
    });
    cc.Canvas = module.exports = Canvas;
  }), {
    "../camera/CCCamera": 166,
    "./CCComponent": 181
  } ],
  181: [ (function(require, module, exports) {
    "use strict";
    var CCObject = require("../platform/CCObject");
    var js = require("../platform/js");
    var idGenerater = new (require("../platform/id-generater"))("Comp");
    var IsOnEnableCalled = CCObject.Flags.IsOnEnableCalled;
    var IsOnLoadCalled = CCObject.Flags.IsOnLoadCalled;
    var ActionManagerExist = !!cc.ActionManager;
    var Component = cc.Class({
      name: "cc.Component",
      extends: CCObject,
      ctor: function() {
        this._id = idGenerater.getNewId();
        this.__eventTargets = [];
      },
      properties: {
        node: {
          default: null,
          visible: false
        },
        name: {
          get: function get() {
            if (this._name) return this._name;
            var className = cc.js.getClassName(this);
            var trimLeft = className.lastIndexOf(".");
            trimLeft >= 0 && (className = className.slice(trimLeft + 1));
            return this.node.name + "<" + className + ">";
          },
          set: function set(value) {
            this._name = value;
          },
          visible: false
        },
        uuid: {
          get: function get() {
            return this._id;
          },
          visible: false
        },
        __scriptAsset: false,
        _enabled: true,
        enabled: {
          get: function get() {
            return this._enabled;
          },
          set: function set(value) {
            if (this._enabled !== value) {
              this._enabled = value;
              if (this.node._activeInHierarchy) {
                var compScheduler = cc.director._compScheduler;
                value ? compScheduler.enableComp(this) : compScheduler.disableComp(this);
              }
            }
          },
          visible: false,
          animatable: true
        },
        enabledInHierarchy: {
          get: function get() {
            var _this$node, _this$node2, _this$node2$_parent;
            false;
            return this._enabled && this.node && this.node._activeInHierarchy;
          },
          visible: false
        },
        _isOnLoadCalled: {
          get: function get() {
            return this._objFlags & IsOnLoadCalled;
          }
        }
      },
      update: null,
      lateUpdate: null,
      __preload: null,
      onLoad: null,
      start: null,
      onEnable: null,
      onDisable: null,
      onDestroy: null,
      onFocusInEditor: null,
      onLostFocusInEditor: null,
      resetInEditor: null,
      addComponent: function addComponent(typeOrClassName) {
        return this.node.addComponent(typeOrClassName);
      },
      getComponent: function getComponent(typeOrClassName) {
        return this.node.getComponent(typeOrClassName);
      },
      getComponents: function getComponents(typeOrClassName) {
        return this.node.getComponents(typeOrClassName);
      },
      getComponentInChildren: function getComponentInChildren(typeOrClassName) {
        return this.node.getComponentInChildren(typeOrClassName);
      },
      getComponentsInChildren: function getComponentsInChildren(typeOrClassName) {
        return this.node.getComponentsInChildren(typeOrClassName);
      },
      _getLocalBounds: null,
      onRestore: null,
      destroy: function destroy() {
        var depend;
        false;
        this._super() && this._enabled && this.node._activeInHierarchy && cc.director._compScheduler.disableComp(this);
      },
      _onPreDestroy: function _onPreDestroy() {
        ActionManagerExist && cc.director.getActionManager().removeAllActionsFromTarget(this);
        this.unscheduleAllCallbacks();
        var eventTargets = this.__eventTargets;
        for (var i = eventTargets.length - 1; i >= 0; --i) {
          var target = eventTargets[i];
          target && target.targetOff(this);
        }
        eventTargets.length = 0;
        false;
        cc.director._nodeActivator.destroyComp(this);
        this.node._removeComponent(this);
      },
      _instantiate: function _instantiate(cloned) {
        cloned || (cloned = cc.instantiate._clone(this, this));
        cloned.node = null;
        return cloned;
      },
      schedule: function schedule(callback, interval, repeat, delay) {
        cc.assertID(callback, 1619);
        interval = interval || 0;
        cc.assertID(interval >= 0, 1620);
        repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat;
        delay = delay || 0;
        var scheduler = cc.director.getScheduler();
        var paused = scheduler.isTargetPaused(this);
        scheduler.schedule(callback, this, interval, repeat, delay, paused);
      },
      scheduleOnce: function scheduleOnce(callback, delay) {
        this.schedule(callback, 0, 0, delay);
      },
      unschedule: function unschedule(callback_fn) {
        if (!callback_fn) return;
        cc.director.getScheduler().unschedule(callback_fn, this);
      },
      unscheduleAllCallbacks: function unscheduleAllCallbacks() {
        cc.director.getScheduler().unscheduleAllForTarget(this);
      }
    });
    Component._requireComponent = null;
    Component._executionOrder = 0;
    false;
    false, false;
    js.value(Component, "_registerEditorProps", (function(cls, props) {
      var reqComp = props.requireComponent;
      reqComp && (cls._requireComponent = reqComp);
      var order = props.executionOrder;
      order && "number" === typeof order && (cls._executionOrder = order);
      (false, true) && "disallowMultiple" in props && (cls._disallowMultiple = cls);
      var name;
      var key;
      var val;
      var willExecuteInEditMode;
      false, false;
    }));
    Component.prototype.__scriptUuid = "";
    cc.Component = module.exports = Component;
  }), {
    "../platform/CCObject": 278,
    "../platform/id-generater": 290,
    "../platform/js": 294
  } ],
  182: [ (function(require, module, exports) {
    "use strict";
    cc.Component.EventHandler = cc.Class({
      name: "cc.ClickEvent",
      properties: {
        target: {
          default: null,
          type: cc.Node
        },
        component: "",
        _componentId: "",
        _componentName: {
          get: function get() {
            this._genCompIdIfNeeded();
            return this._compId2Name(this._componentId);
          },
          set: function set(value) {
            this._componentId = this._compName2Id(value);
          }
        },
        handler: {
          default: ""
        },
        customEventData: {
          default: ""
        }
      },
      statics: {
        emitEvents: function emitEvents(events) {
          var args;
          if (arguments.length > 0) {
            args = new Array(arguments.length - 1);
            for (var i = 0, l = args.length; i < l; i++) args[i] = arguments[i + 1];
          }
          for (var _i = 0, _l = events.length; _i < _l; _i++) {
            var event = events[_i];
            if (!(event instanceof cc.Component.EventHandler)) continue;
            event.emit(args);
          }
        }
      },
      emit: function emit(params) {
        var target = this.target;
        if (!cc.isValid(target)) return;
        this._genCompIdIfNeeded();
        var compType = cc.js._getClassById(this._componentId);
        var comp = target.getComponent(compType);
        if (!cc.isValid(comp)) return;
        var handler = comp[this.handler];
        if ("function" !== typeof handler) return;
        if (null != this.customEventData && "" !== this.customEventData) {
          params = params.slice();
          params.push(this.customEventData);
        }
        handler.apply(comp, params);
      },
      _compName2Id: function _compName2Id(compName) {
        var comp = cc.js.getClassByName(compName);
        return cc.js._getClassId(comp);
      },
      _compId2Name: function _compId2Name(compId) {
        var comp = cc.js._getClassById(compId);
        return cc.js.getClassName(comp);
      },
      _genCompIdIfNeeded: function _genCompIdIfNeeded() {
        if (!this._componentId) {
          this._componentName = this.component;
          this.component = "";
        }
      }
    });
  }), {} ],
  183: [ (function(require, module, exports) {
    "use strict";
    var macro = require("../platform/CCMacro");
    var RenderComponent = require("./CCRenderComponent");
    var Material = require("../assets/material/CCMaterial");
    var LabelFrame = require("../renderer/utils/label/label-frame");
    var BlendFunc = require("../utils/blend-func");
    var deleteFromDynamicAtlas = require("../renderer/utils/utils").deleteFromDynamicAtlas;
    var HorizontalAlign = macro.TextAlignment;
    var VerticalAlign = macro.VerticalTextAlignment;
    var Overflow = cc.Enum({
      NONE: 0,
      CLAMP: 1,
      SHRINK: 2,
      RESIZE_HEIGHT: 3
    });
    var CacheMode = cc.Enum({
      NONE: 0,
      BITMAP: 1,
      CHAR: 2
    });
    var BOLD_FLAG = 1;
    var ITALIC_FLAG = 2;
    var UNDERLINE_FLAG = 4;
    var Label = cc.Class({
      name: "cc.Label",
      extends: RenderComponent,
      mixins: [ BlendFunc ],
      ctor: function ctor() {
        false;
        this._actualFontSize = 0;
        this._assemblerData = null;
        this._frame = null;
        this._ttfTexture = null;
        this._letterTexture = null;
        cc.game.renderType === cc.game.RENDER_TYPE_CANVAS ? this._updateMaterial = this._updateMaterialCanvas : this._updateMaterial = this._updateMaterialWebgl;
      },
      editor: false,
      properties: {
        _string: {
          default: "",
          formerlySerializedAs: "_N$string"
        },
        string: {
          get: function get() {
            return this._string;
          },
          set: function set(value) {
            var oldValue = this._string;
            this._string = "" + value;
            this.string !== oldValue && this.setVertsDirty();
            this._checkStringEmpty();
          },
          multiline: true,
          tooltip: (true, "i18n:COMPONENT.label.string")
        },
        horizontalAlign: {
          default: HorizontalAlign.LEFT,
          type: HorizontalAlign,
          tooltip: (true, "i18n:COMPONENT.label.horizontal_align"),
          notify: function notify(oldValue) {
            if (this.horizontalAlign === oldValue) return;
            this.setVertsDirty();
          },
          animatable: false
        },
        verticalAlign: {
          default: VerticalAlign.TOP,
          type: VerticalAlign,
          tooltip: (true, "i18n:COMPONENT.label.vertical_align"),
          notify: function notify(oldValue) {
            if (this.verticalAlign === oldValue) return;
            this.setVertsDirty();
          },
          animatable: false
        },
        actualFontSize: {
          displayName: "Actual Font Size",
          animatable: false,
          readonly: true,
          get: function get() {
            return this._actualFontSize;
          },
          tooltip: (true, "i18n:COMPONENT.label.actualFontSize")
        },
        _fontSize: 40,
        fontSize: {
          get: function get() {
            return this._fontSize;
          },
          set: function set(value) {
            if (this._fontSize === value) return;
            this._fontSize = value;
            this.setVertsDirty();
          },
          range: [ 0, 512 ],
          tooltip: (true, "i18n:COMPONENT.label.font_size")
        },
        fontFamily: {
          default: "Arial",
          tooltip: (true, "i18n:COMPONENT.label.font_family"),
          notify: function notify(oldValue) {
            if (this.fontFamily === oldValue) return;
            this.setVertsDirty();
          },
          animatable: false
        },
        _lineHeight: 40,
        lineHeight: {
          get: function get() {
            return this._lineHeight;
          },
          set: function set(value) {
            if (this._lineHeight === value) return;
            this._lineHeight = value;
            this.setVertsDirty();
          },
          tooltip: (true, "i18n:COMPONENT.label.line_height")
        },
        overflow: {
          default: Overflow.NONE,
          type: Overflow,
          tooltip: (true, "i18n:COMPONENT.label.overflow"),
          notify: function notify(oldValue) {
            if (this.overflow === oldValue) return;
            this.setVertsDirty();
          },
          animatable: false
        },
        _enableWrapText: true,
        enableWrapText: {
          get: function get() {
            return this._enableWrapText;
          },
          set: function set(value) {
            if (this._enableWrapText === value) return;
            this._enableWrapText = value;
            this.setVertsDirty();
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.label.wrap")
        },
        _N$file: null,
        font: {
          get: function get() {
            return this._N$file;
          },
          set: function set(value) {
            if (this.font === value) return;
            value || (this._isSystemFontUsed = true);
            false;
            this._N$file = value;
            value && this._isSystemFontUsed && (this._isSystemFontUsed = false);
            if (!this.enabledInHierarchy) return;
            this._forceUpdateRenderData();
          },
          type: cc.Font,
          tooltip: (true, "i18n:COMPONENT.label.font"),
          animatable: false
        },
        _isSystemFontUsed: true,
        useSystemFont: {
          get: function get() {
            return this._isSystemFontUsed;
          },
          set: function set(value) {
            if (this._isSystemFontUsed === value) return;
            this._isSystemFontUsed = !!value;
            false;
            if (value) {
              this.font = null;
              if (!this.enabledInHierarchy) return;
              this._forceUpdateRenderData();
            }
            this.markForValidate();
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.label.system_font")
        },
        _bmFontOriginalSize: {
          displayName: "BMFont Original Size",
          get: function get() {
            return this._N$file instanceof cc.BitmapFont ? this._N$file.fontSize : -1;
          },
          visible: true,
          animatable: false
        },
        _spacingX: 0,
        spacingX: {
          get: function get() {
            return this._spacingX;
          },
          set: function set(value) {
            this._spacingX = value;
            this.setVertsDirty();
          },
          tooltip: (true, "i18n:COMPONENT.label.spacingX")
        },
        _batchAsBitmap: false,
        cacheMode: {
          default: CacheMode.NONE,
          type: CacheMode,
          tooltip: (true, "i18n:COMPONENT.label.cacheMode"),
          notify: function notify(oldValue) {
            if (this.cacheMode === oldValue) return;
            oldValue !== CacheMode.BITMAP || this.font instanceof cc.BitmapFont || deleteFromDynamicAtlas(this, this._frame);
            if (oldValue === CacheMode.CHAR) {
              this._ttfTexture = null;
              var material = this._materials[0];
              material && material.material && cc.Label._shareAtlas.material === material.material && this.setMaterial(0, this._getDefaultMaterial());
            }
            if (!this.enabledInHierarchy) return;
            this._forceUpdateRenderData();
          },
          animatable: false
        },
        _styleFlags: 0,
        enableBold: {
          get: function get() {
            return !!(this._styleFlags & BOLD_FLAG);
          },
          set: function set(value) {
            value ? this._styleFlags |= BOLD_FLAG : this._styleFlags &= ~BOLD_FLAG;
            this.setVertsDirty();
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.label.bold")
        },
        enableItalic: {
          get: function get() {
            return !!(this._styleFlags & ITALIC_FLAG);
          },
          set: function set(value) {
            value ? this._styleFlags |= ITALIC_FLAG : this._styleFlags &= ~ITALIC_FLAG;
            this.setVertsDirty();
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.label.italic")
        },
        enableUnderline: {
          get: function get() {
            return !!(this._styleFlags & UNDERLINE_FLAG);
          },
          set: function set(value) {
            value ? this._styleFlags |= UNDERLINE_FLAG : this._styleFlags &= ~UNDERLINE_FLAG;
            this.setVertsDirty();
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.label.underline")
        },
        _underlineHeight: 0,
        underlineHeight: {
          get: function get() {
            return this._underlineHeight;
          },
          set: function set(value) {
            if (this._underlineHeight === value) return;
            this._underlineHeight = value;
            this.setVertsDirty();
          },
          tooltip: (true, "i18n:COMPONENT.label.underline_height")
        },
        autoSwitchMaterial: {
          type: RenderComponent.EnableType,
          default: RenderComponent.EnableType.GLOBAL,
          notify: function notify(oldValue) {
            if (this.autoSwitchMaterial === oldValue) return;
            this.setVertsDirty();
          }
        },
        allowDynamicAtlas: {
          type: RenderComponent.EnableType,
          default: RenderComponent.EnableType.GLOBAL,
          notify: function notify(oldValue) {
            if (this.allowDynamicAtlas === oldValue) return;
            this.setVertsDirty();
          }
        },
        enableRetina: {
          type: RenderComponent.EnableType,
          default: RenderComponent.EnableType.GLOBAL,
          notify: function notify(oldValue) {
            if (this.enableRetina === oldValue) return;
            this.setVertsDirty();
          }
        }
      },
      statics: {
        HorizontalAlign: HorizontalAlign,
        VerticalAlign: VerticalAlign,
        Overflow: Overflow,
        CacheMode: CacheMode,
        _shareAtlas: null,
        clearCharCache: function clearCharCache() {
          Label._shareAtlas && Label._shareAtlas.clearAllCache();
        }
      },
      onLoad: function onLoad() {
        if (this._batchAsBitmap && this.cacheMode === CacheMode.NONE) {
          this.cacheMode = CacheMode.BITMAP;
          this._batchAsBitmap = false;
        }
        cc.game.renderType === cc.game.RENDER_TYPE_CANVAS && (this.cacheMode = CacheMode.NONE);
      },
      onEnable: function onEnable() {
        this._super();
        this.node.on(cc.Node.EventType.SIZE_CHANGED, this._nodeSizeChanged, this);
        this.node.on(cc.Node.EventType.ANCHOR_CHANGED, this.setVertsDirty, this);
        this.node.on(cc.Node.EventType.COLOR_CHANGED, this._nodeColorChanged, this);
        this._forceUpdateRenderData();
      },
      onDisable: function onDisable() {
        this._super();
        this.node.off(cc.Node.EventType.SIZE_CHANGED, this._nodeSizeChanged, this);
        this.node.off(cc.Node.EventType.ANCHOR_CHANGED, this.setVertsDirty, this);
        this.node.off(cc.Node.EventType.COLOR_CHANGED, this._nodeColorChanged, this);
      },
      onDestroy: function onDestroy() {
        this._assembler && this._assembler._resetAssemblerData && this._assembler._resetAssemblerData(this._assemblerData);
        this._assemblerData = null;
        this._letterTexture = null;
        if (this._ttfTexture) {
          this._ttfTexture._packable = false;
          this._ttfTexture.destroy();
          this._ttfTexture = null;
        }
        this._resetFrame();
        this._super();
      },
      _nodeSizeChanged: function _nodeSizeChanged() {
        (false, this.overflow !== Overflow.NONE) && this.setVertsDirty();
      },
      _nodeColorChanged: function _nodeColorChanged() {
        this.font instanceof cc.BitmapFont || this.setVertsDirty();
      },
      setVertsDirty: function setVertsDirty() {
        (true, this._nativeTTF()) && this._assembler && this._assembler.updateRenderData(this);
        this._super();
      },
      _updateColor: function _updateColor() {
        this.font instanceof cc.BitmapFont || this._srcBlendFactor === cc.macro.BlendFactor.SRC_ALPHA && this.node._renderFlag & cc.RenderFlow.FLAG_OPACITY || this.setVertsDirty();
        RenderComponent.prototype._updateColor.call(this);
      },
      _validateRender: function _validateRender() {
        if (!this.string) {
          this.disableRender();
          return;
        }
        if (this._materials[0]) {
          var font = this.font;
          if (!(font instanceof cc.BitmapFont)) return;
          var spriteFrame = font.spriteFrame;
          if (spriteFrame && spriteFrame.textureLoaded() && font._fntConfig) return;
        }
        this.disableRender();
      },
      _resetAssembler: function _resetAssembler() {
        this._resetFrame();
        RenderComponent.prototype._resetAssembler.call(this);
      },
      _resetFrame: function _resetFrame() {
        if (this._frame && !(this.font instanceof cc.BitmapFont)) {
          deleteFromDynamicAtlas(this, this._frame);
          this._frame = null;
        }
      },
      _checkStringEmpty: function _checkStringEmpty() {
        this.markForRender(!!this.string);
      },
      _on3DNodeChanged: function _on3DNodeChanged() {
        this._resetAssembler();
        this._applyFontTexture();
      },
      _onBMFontTextureLoaded: function _onBMFontTextureLoaded() {
        this._frame._texture = this.font.spriteFrame._texture;
        this.markForRender(true);
        this._updateMaterial();
        this._assembler && this._assembler.updateRenderData(this);
      },
      _onBlendChanged: function _onBlendChanged() {
        if (!this.useSystemFont || !this.enabledInHierarchy) return;
        this._forceUpdateRenderData();
      },
      _applyFontTexture: function _applyFontTexture() {
        var font = this.font;
        if (font instanceof cc.BitmapFont) {
          var spriteFrame = font.spriteFrame;
          this._frame = spriteFrame;
          spriteFrame && spriteFrame.onTextureLoaded(this._onBMFontTextureLoaded, this);
        } else {
          if (!this._nativeTTF()) {
            this._frame || (this._frame = new LabelFrame());
            if (this.cacheMode === CacheMode.CHAR) {
              this._letterTexture = this._assembler._getAssemblerData();
              this._frame._refreshTexture(this._letterTexture);
            } else if (!this._ttfTexture) {
              this._ttfTexture = new cc.Texture2D();
              this._assemblerData = this._assembler._getAssemblerData();
              this._ttfTexture.initWithElement(this._assemblerData.canvas);
            }
            if (this.cacheMode !== CacheMode.CHAR) {
              deleteFromDynamicAtlas(this, this._frame);
              this._frame._refreshTexture(this._ttfTexture);
              this._srcBlendFactor === cc.macro.BlendFactor.ONE && false;
            }
            this._updateMaterial();
          }
          this._assembler && this._assembler.updateRenderData(this);
        }
        this.markForValidate();
      },
      _updateMaterialCanvas: function _updateMaterialCanvas() {
        if (!this._frame) return;
        this._frame._texture._nativeUrl = this.uuid + "_texture";
      },
      _updateMaterialWebgl: function _updateMaterialWebgl() {
        var material = this.getMaterial(0);
        if (this._nativeTTF()) {
          material && this._assembler._updateTTFMaterial(this);
          return;
        }
        if (!this._frame) return;
        if (material) {
          var isMultiMaterial = material.material.isMultiSupport();
          isMultiMaterial ? this._texIdDirty = true : material.setProperty("texture", this._frame._texture);
          this._assembler && (isMultiMaterial && !this._assembler.isMulti || !isMultiMaterial && this._assembler.isMulti) && RenderComponent.prototype._resetAssembler.call(this);
        }
        BlendFunc.prototype._updateMaterial.call(this);
      },
      _forceUseCanvas: false,
      _useNativeTTF: function _useNativeTTF() {
        return cc.macro.ENABLE_NATIVE_TTF_RENDERER && !this._forceUseCanvas;
      },
      _nativeTTF: function _nativeTTF() {
        return this._useNativeTTF() && !!this._assembler && !!this._assembler._updateTTFMaterial;
      },
      _forceUpdateRenderData: function _forceUpdateRenderData() {
        this.setVertsDirty();
        this._resetAssembler();
        this._applyFontTexture();
      },
      _enableBold: function _enableBold(enabled) {
        true;
        cc.warn("`label._enableBold` is deprecated, use `label.enableBold = true` instead please");
        this.enableBold = !!enabled;
      },
      _enableItalics: function _enableItalics(enabled) {
        true;
        cc.warn("`label._enableItalics` is deprecated, use `label.enableItalics = true` instead please");
        this.enableItalic = !!enabled;
      },
      _enableUnderline: function _enableUnderline(enabled) {
        true;
        cc.warn("`label._enableUnderline` is deprecated, use `label.enableUnderline = true` instead please");
        this.enableUnderline = !!enabled;
      }
    });
    cc.Label = module.exports = Label;
  }), {
    "../assets/material/CCMaterial": 156,
    "../platform/CCMacro": 277,
    "../renderer/utils/label/label-frame": 327,
    "../renderer/utils/utils": 330,
    "../utils/blend-func": 380,
    "./CCRenderComponent": 192
  } ],
  184: [ (function(require, module, exports) {
    "use strict";
    var LabelOutline = cc.Class({
      name: "cc.LabelOutline",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _color: cc.Color.WHITE,
        _width: 1,
        color: {
          tooltip: (true, "i18n:COMPONENT.outline.color"),
          get: function get() {
            return this._color.clone();
          },
          set: function set(value) {
            this._color.equals(value) || this._color.set(value);
            this._updateRenderData();
          }
        },
        width: {
          tooltip: (true, "i18n:COMPONENT.outline.width"),
          get: function get() {
            return this._width;
          },
          set: function set(value) {
            if (this._width === value) return;
            this._width = value;
            this._updateRenderData();
          },
          range: [ 0, 512 ]
        }
      },
      onEnable: function onEnable() {
        this._updateRenderData();
      },
      onDisable: function onDisable() {
        this._updateRenderData();
      },
      _updateRenderData: function _updateRenderData() {
        var label = this.node.getComponent(cc.Label);
        label && label.setVertsDirty();
      }
    });
    cc.LabelOutline = module.exports = LabelOutline;
  }), {
    "./CCComponent": 181
  } ],
  185: [ (function(require, module, exports) {
    "use strict";
    var LabelShadow = cc.Class({
      name: "cc.LabelShadow",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _color: cc.Color.WHITE,
        _offset: cc.v2(2, 2),
        _blur: 2,
        color: {
          tooltip: (true, "i18n:COMPONENT.shadow.color"),
          get: function get() {
            return this._color.clone();
          },
          set: function set(value) {
            this._color.equals(value) || this._color.set(value);
            this._updateRenderData();
          }
        },
        offset: {
          tooltip: (true, "i18n:COMPONENT.shadow.offset"),
          get: function get() {
            return this._offset;
          },
          set: function set(value) {
            this._offset = value;
            this._updateRenderData();
          }
        },
        blur: {
          tooltip: (true, "i18n:COMPONENT.shadow.blur"),
          get: function get() {
            return this._blur;
          },
          set: function set(value) {
            this._blur = value;
            this._updateRenderData();
          },
          range: [ 0, 1024 ]
        }
      },
      onEnable: function onEnable() {
        this._updateRenderData();
      },
      onDisable: function onDisable() {
        this._updateRenderData();
      },
      _updateRenderData: function _updateRenderData() {
        var label = this.node.getComponent(cc.Label);
        label && label.setVertsDirty();
      }
    });
    cc.LabelShadow = module.exports = LabelShadow;
  }), {
    "./CCComponent": 181
  } ],
  186: [ (function(require, module, exports) {
    "use strict";
    var NodeEvent = require("../CCNode").EventType;
    var Type = cc.Enum({
      NONE: 0,
      HORIZONTAL: 1,
      VERTICAL: 2,
      GRID: 3
    });
    var ResizeMode = cc.Enum({
      NONE: 0,
      CONTAINER: 1,
      CHILDREN: 2
    });
    var AxisDirection = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1
    });
    var VerticalDirection = cc.Enum({
      BOTTOM_TO_TOP: 0,
      TOP_TO_BOTTOM: 1
    });
    var HorizontalDirection = cc.Enum({
      LEFT_TO_RIGHT: 0,
      RIGHT_TO_LEFT: 1
    });
    var Layout = cc.Class({
      name: "cc.Layout",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _layoutSize: cc.size(300, 200),
        _layoutDirty: {
          default: true,
          serializable: false
        },
        _resize: ResizeMode.NONE,
        _N$layoutType: Type.NONE,
        type: {
          type: Type,
          get: function get() {
            return this._N$layoutType;
          },
          set: function set(value) {
            this._N$layoutType = value;
            var reLayouted;
            false;
            this._doLayoutDirty();
          },
          tooltip: (true, "i18n:COMPONENT.layout.layout_type"),
          animatable: false
        },
        resizeMode: {
          type: ResizeMode,
          tooltip: (true, "i18n:COMPONENT.layout.resize_mode"),
          animatable: false,
          get: function get() {
            return this._resize;
          },
          set: function set(value) {
            if (this.type === Type.NONE && value === ResizeMode.CHILDREN) return;
            this._resize = value;
            var reLayouted;
            false;
            this._doLayoutDirty();
          }
        },
        cellSize: {
          default: cc.size(40, 40),
          tooltip: (true, "i18n:COMPONENT.layout.cell_size"),
          type: cc.Size,
          notify: function notify() {
            this._doLayoutDirty();
          }
        },
        startAxis: {
          default: AxisDirection.HORIZONTAL,
          tooltip: (true, "i18n:COMPONENT.layout.start_axis"),
          type: AxisDirection,
          notify: function notify() {
            var reLayouted;
            false;
            this._doLayoutDirty();
          },
          animatable: false
        },
        paddingLeft: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.layout.padding_left"),
          notify: function notify() {
            this._doLayoutDirty();
          }
        },
        paddingRight: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.layout.padding_right"),
          notify: function notify() {
            this._doLayoutDirty();
          }
        },
        paddingTop: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.layout.padding_top"),
          notify: function notify() {
            this._doLayoutDirty();
          }
        },
        paddingBottom: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.layout.padding_bottom"),
          notify: function notify() {
            this._doLayoutDirty();
          }
        },
        spacingX: {
          default: 0,
          notify: function notify() {
            this._doLayoutDirty();
          },
          tooltip: (true, "i18n:COMPONENT.layout.space_x")
        },
        spacingY: {
          default: 0,
          notify: function notify() {
            this._doLayoutDirty();
          },
          tooltip: (true, "i18n:COMPONENT.layout.space_y")
        },
        verticalDirection: {
          default: VerticalDirection.TOP_TO_BOTTOM,
          type: VerticalDirection,
          notify: function notify() {
            this._doLayoutDirty();
          },
          tooltip: (true, "i18n:COMPONENT.layout.vertical_direction"),
          animatable: false
        },
        horizontalDirection: {
          default: HorizontalDirection.LEFT_TO_RIGHT,
          type: HorizontalDirection,
          notify: function notify() {
            this._doLayoutDirty();
          },
          tooltip: (true, "i18n:COMPONENT.layout.horizontal_direction"),
          animatable: false
        },
        affectedByScale: {
          default: false,
          notify: function notify() {
            this._doLayoutDirty();
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.layout.affected_by_scale")
        }
      },
      statics: {
        Type: Type,
        VerticalDirection: VerticalDirection,
        HorizontalDirection: HorizontalDirection,
        ResizeMode: ResizeMode,
        AxisDirection: AxisDirection
      },
      onEnable: function onEnable() {
        this._addEventListeners();
        this.node.getContentSize().equals(cc.size(0, 0)) && this.node.setContentSize(this._layoutSize);
        this._doLayoutDirty();
      },
      onDisable: function onDisable() {
        this._removeEventListeners();
      },
      _doLayoutDirty: function _doLayoutDirty() {
        this._layoutDirty = true;
      },
      _doScaleDirty: function _doScaleDirty() {
        this._layoutDirty = this._layoutDirty || this.affectedByScale;
      },
      _addEventListeners: function _addEventListeners() {
        cc.director.on(cc.Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
        this.node.on(NodeEvent.SIZE_CHANGED, this._resized, this);
        this.node.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
        this.node.on(NodeEvent.CHILD_ADDED, this._childAdded, this);
        this.node.on(NodeEvent.CHILD_REMOVED, this._childRemoved, this);
        this.node.on(NodeEvent.CHILD_REORDER, this._doLayoutDirty, this);
        this._addChildrenEventListeners();
      },
      _removeEventListeners: function _removeEventListeners() {
        cc.director.off(cc.Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
        this.node.off(NodeEvent.SIZE_CHANGED, this._resized, this);
        this.node.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
        this.node.off(NodeEvent.CHILD_ADDED, this._childAdded, this);
        this.node.off(NodeEvent.CHILD_REMOVED, this._childRemoved, this);
        this.node.off(NodeEvent.CHILD_REORDER, this._doLayoutDirty, this);
        this._removeChildrenEventListeners();
      },
      _addChildrenEventListeners: function _addChildrenEventListeners() {
        var children = this.node.children;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.on(NodeEvent.SCALE_CHANGED, this._doScaleDirty, this);
          child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEvent.POSITION_CHANGED, this._doLayoutDirty, this);
          child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
        }
      },
      _removeChildrenEventListeners: function _removeChildrenEventListeners() {
        var children = this.node.children;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.off(NodeEvent.SCALE_CHANGED, this._doScaleDirty, this);
          child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEvent.POSITION_CHANGED, this._doLayoutDirty, this);
          child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
          child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
        }
      },
      _childAdded: function _childAdded(child) {
        child.on(NodeEvent.SCALE_CHANGED, this._doScaleDirty, this);
        child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
        child.on(NodeEvent.POSITION_CHANGED, this._doLayoutDirty, this);
        child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
        child.on("active-in-hierarchy-changed", this._doLayoutDirty, this);
        this._doLayoutDirty();
      },
      _childRemoved: function _childRemoved(child) {
        child.off(NodeEvent.SCALE_CHANGED, this._doScaleDirty, this);
        child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
        child.off(NodeEvent.POSITION_CHANGED, this._doLayoutDirty, this);
        child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
        child.off("active-in-hierarchy-changed", this._doLayoutDirty, this);
        this._doLayoutDirty();
      },
      _resized: function _resized() {
        this._layoutSize = this.node.getContentSize();
        this._doLayoutDirty();
      },
      _doLayoutHorizontally: function _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
        var layoutAnchor = this.node.getAnchorPoint();
        var children = this.node.children;
        var sign = 1;
        var paddingX = this.paddingLeft;
        var leftBoundaryOfLayout = -layoutAnchor.x * baseWidth;
        if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
          sign = -1;
          leftBoundaryOfLayout = (1 - layoutAnchor.x) * baseWidth;
          paddingX = this.paddingRight;
        }
        var nextX = leftBoundaryOfLayout + sign * paddingX - sign * this.spacingX;
        var rowMaxHeight = 0;
        var tempMaxHeight = 0;
        var secondMaxHeight = 0;
        var row = 0;
        var containerResizeBoundary = 0;
        var maxHeightChildAnchorY = 0;
        var activeChildCount = 0;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.activeInHierarchy && activeChildCount++;
        }
        var newChildWidth = this.cellSize.width;
        this.type !== Type.GRID && this.resizeMode === ResizeMode.CHILDREN && (newChildWidth = (baseWidth - (this.paddingLeft + this.paddingRight) - (activeChildCount - 1) * this.spacingX) / activeChildCount);
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          var childScaleX = this._getUsedScaleValue(child.scaleX);
          var childScaleY = this._getUsedScaleValue(child.scaleY);
          if (!child.activeInHierarchy) continue;
          if (this._resize === ResizeMode.CHILDREN) {
            child.width = newChildWidth / childScaleX;
            this.type === Type.GRID && (child.height = this.cellSize.height / childScaleY);
          }
          var anchorX = child.anchorX;
          var childBoundingBoxWidth = child.width * childScaleX;
          var childBoundingBoxHeight = child.height * childScaleY;
          secondMaxHeight > tempMaxHeight && (tempMaxHeight = secondMaxHeight);
          if (childBoundingBoxHeight >= tempMaxHeight) {
            secondMaxHeight = tempMaxHeight;
            tempMaxHeight = childBoundingBoxHeight;
            maxHeightChildAnchorY = child.getAnchorPoint().y;
          }
          this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && (anchorX = 1 - child.anchorX);
          nextX = nextX + sign * anchorX * childBoundingBoxWidth + sign * this.spacingX;
          var rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;
          if (rowBreak) {
            var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this.paddingRight : this.paddingLeft);
            var leftToRightRowBreak = this.horizontalDirection === HorizontalDirection.LEFT_TO_RIGHT && rowBreakBoundary > (1 - layoutAnchor.x) * baseWidth;
            var rightToLeftRowBreak = this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT && rowBreakBoundary < -layoutAnchor.x * baseWidth;
            if (leftToRightRowBreak || rightToLeftRowBreak) {
              if (childBoundingBoxHeight >= tempMaxHeight) {
                0 === secondMaxHeight && (secondMaxHeight = tempMaxHeight);
                rowMaxHeight += secondMaxHeight;
                secondMaxHeight = tempMaxHeight;
              } else {
                rowMaxHeight += tempMaxHeight;
                secondMaxHeight = childBoundingBoxHeight;
                tempMaxHeight = 0;
              }
              nextX = leftBoundaryOfLayout + sign * (paddingX + anchorX * childBoundingBoxWidth);
              row++;
            }
          }
          var finalPositionY = fnPositionY(child, rowMaxHeight, row);
          baseWidth >= childBoundingBoxWidth + this.paddingLeft + this.paddingRight && applyChildren && child.setPosition(cc.v2(nextX, finalPositionY));
          var signX = 1;
          var tempFinalPositionY;
          var topMarign = 0 === tempMaxHeight ? childBoundingBoxHeight : tempMaxHeight;
          if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            containerResizeBoundary = containerResizeBoundary || this.node._contentSize.height;
            signX = -1;
            tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this.paddingBottom);
            tempFinalPositionY < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY);
          } else {
            containerResizeBoundary = containerResizeBoundary || -this.node._contentSize.height;
            tempFinalPositionY = finalPositionY + signX * (topMarign * maxHeightChildAnchorY + this.paddingTop);
            tempFinalPositionY > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionY);
          }
          nextX += rightBoundaryOfChild;
        }
        return containerResizeBoundary;
      },
      _getVerticalBaseHeight: function _getVerticalBaseHeight(children) {
        var newHeight = 0;
        var activeChildCount = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            if (child.activeInHierarchy) {
              activeChildCount++;
              newHeight += child.height * this._getUsedScaleValue(child.scaleY);
            }
          }
          newHeight += (activeChildCount - 1) * this.spacingY + this.paddingBottom + this.paddingTop;
        } else newHeight = this.node.getContentSize().height;
        return newHeight;
      },
      _doLayoutVertically: function _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
        var layoutAnchor = this.node.getAnchorPoint();
        var children = this.node.children;
        var sign = 1;
        var paddingY = this.paddingBottom;
        var bottomBoundaryOfLayout = -layoutAnchor.y * baseHeight;
        if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
          sign = -1;
          bottomBoundaryOfLayout = (1 - layoutAnchor.y) * baseHeight;
          paddingY = this.paddingTop;
        }
        var nextY = bottomBoundaryOfLayout + sign * paddingY - sign * this.spacingY;
        var columnMaxWidth = 0;
        var tempMaxWidth = 0;
        var secondMaxWidth = 0;
        var column = 0;
        var containerResizeBoundary = 0;
        var maxWidthChildAnchorX = 0;
        var activeChildCount = 0;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.activeInHierarchy && activeChildCount++;
        }
        var newChildHeight = this.cellSize.height;
        this.type !== Type.GRID && this.resizeMode === ResizeMode.CHILDREN && (newChildHeight = (baseHeight - (this.paddingTop + this.paddingBottom) - (activeChildCount - 1) * this.spacingY) / activeChildCount);
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          var childScaleX = this._getUsedScaleValue(child.scaleX);
          var childScaleY = this._getUsedScaleValue(child.scaleY);
          if (!child.activeInHierarchy) continue;
          if (this.resizeMode === ResizeMode.CHILDREN) {
            child.height = newChildHeight / childScaleY;
            this.type === Type.GRID && (child.width = this.cellSize.width / childScaleX);
          }
          var anchorY = child.anchorY;
          var childBoundingBoxWidth = child.width * childScaleX;
          var childBoundingBoxHeight = child.height * childScaleY;
          secondMaxWidth > tempMaxWidth && (tempMaxWidth = secondMaxWidth);
          if (childBoundingBoxWidth >= tempMaxWidth) {
            secondMaxWidth = tempMaxWidth;
            tempMaxWidth = childBoundingBoxWidth;
            maxWidthChildAnchorX = child.getAnchorPoint().x;
          }
          this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM && (anchorY = 1 - child.anchorY);
          nextY = nextY + sign * anchorY * childBoundingBoxHeight + sign * this.spacingY;
          var topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;
          if (columnBreak) {
            var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this.paddingTop : this.paddingBottom);
            var bottomToTopColumnBreak = this.verticalDirection === VerticalDirection.BOTTOM_TO_TOP && columnBreakBoundary > (1 - layoutAnchor.y) * baseHeight;
            var topToBottomColumnBreak = this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM && columnBreakBoundary < -layoutAnchor.y * baseHeight;
            if (bottomToTopColumnBreak || topToBottomColumnBreak) {
              if (childBoundingBoxWidth >= tempMaxWidth) {
                0 === secondMaxWidth && (secondMaxWidth = tempMaxWidth);
                columnMaxWidth += secondMaxWidth;
                secondMaxWidth = tempMaxWidth;
              } else {
                columnMaxWidth += tempMaxWidth;
                secondMaxWidth = childBoundingBoxWidth;
                tempMaxWidth = 0;
              }
              nextY = bottomBoundaryOfLayout + sign * (paddingY + anchorY * childBoundingBoxHeight);
              column++;
            }
          }
          var finalPositionX = fnPositionX(child, columnMaxWidth, column);
          baseHeight >= childBoundingBoxHeight + (this.paddingTop + this.paddingBottom) && applyChildren && child.setPosition(cc.v2(finalPositionX, nextY));
          var signX = 1;
          var tempFinalPositionX;
          var rightMarign = 0 === tempMaxWidth ? childBoundingBoxWidth : tempMaxWidth;
          if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            signX = -1;
            containerResizeBoundary = containerResizeBoundary || this.node._contentSize.width;
            tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this.paddingLeft);
            tempFinalPositionX < containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX);
          } else {
            containerResizeBoundary = containerResizeBoundary || -this.node._contentSize.width;
            tempFinalPositionX = finalPositionX + signX * (rightMarign * maxWidthChildAnchorX + this.paddingRight);
            tempFinalPositionX > containerResizeBoundary && (containerResizeBoundary = tempFinalPositionX);
          }
          nextY += topBoundaryOfChild;
        }
        return containerResizeBoundary;
      },
      _doLayoutBasic: function _doLayoutBasic() {
        var children = this.node.children;
        var allChildrenBoundingBox = null;
        for (var i = 0; i < children.length; ++i) {
          var child = children[i];
          child.activeInHierarchy && (allChildrenBoundingBox ? allChildrenBoundingBox.union(allChildrenBoundingBox, child.getBoundingBoxToWorld()) : allChildrenBoundingBox = child.getBoundingBoxToWorld());
        }
        if (allChildrenBoundingBox) {
          var leftBottomSpace = this.node.convertToNodeSpaceAR(cc.v2(allChildrenBoundingBox.x, allChildrenBoundingBox.y));
          leftBottomSpace = cc.v2(leftBottomSpace.x - this.paddingLeft, leftBottomSpace.y - this.paddingBottom);
          var rightTopSpace = this.node.convertToNodeSpaceAR(cc.v2(allChildrenBoundingBox.xMax, allChildrenBoundingBox.yMax));
          rightTopSpace = cc.v2(rightTopSpace.x + this.paddingRight, rightTopSpace.y + this.paddingTop);
          var newSize = rightTopSpace.sub(leftBottomSpace);
          newSize = cc.size(parseFloat(newSize.x.toFixed(2)), parseFloat(newSize.y.toFixed(2)));
          if (0 !== newSize.width) {
            var newAnchorX = -leftBottomSpace.x / newSize.width;
            this.node.anchorX = parseFloat(newAnchorX.toFixed(2));
          }
          if (0 !== newSize.height) {
            var newAnchorY = -leftBottomSpace.y / newSize.height;
            this.node.anchorY = parseFloat(newAnchorY.toFixed(2));
          }
          this.node.setContentSize(newSize);
        }
      },
      _doLayoutGridAxisHorizontal: function _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
        var baseWidth = layoutSize.width;
        var sign = 1;
        var bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
        var paddingY = this.paddingBottom;
        if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
          sign = -1;
          bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
          paddingY = this.paddingTop;
        }
        var fnPositionY = function(child, topOffset, row) {
          return bottomBoundaryOfLayout + sign * (topOffset + child.anchorY * child.height * this._getUsedScaleValue(child.scaleY) + paddingY + row * this.spacingY);
        }.bind(this);
        var newHeight = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          var boundary = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
          newHeight = bottomBoundaryOfLayout - boundary;
          newHeight < 0 && (newHeight *= -1);
          bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;
          if (this.verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
            sign = -1;
            bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
          }
        }
        this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);
        this.resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(baseWidth, newHeight);
      },
      _doLayoutGridAxisVertical: function _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
        var baseHeight = layoutSize.height;
        var sign = 1;
        var leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
        var paddingX = this.paddingLeft;
        if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
          sign = -1;
          leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
          paddingX = this.paddingRight;
        }
        var fnPositionX = function(child, leftOffset, column) {
          return leftBoundaryOfLayout + sign * (leftOffset + child.anchorX * child.width * this._getUsedScaleValue(child.scaleX) + paddingX + column * this.spacingX);
        }.bind(this);
        var newWidth = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          var boundary = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
          newWidth = leftBoundaryOfLayout - boundary;
          newWidth < 0 && (newWidth *= -1);
          leftBoundaryOfLayout = -layoutAnchor.x * newWidth;
          if (this.horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
            sign = -1;
            leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
          }
        }
        this._doLayoutVertically(baseHeight, true, fnPositionX, true);
        this.resizeMode === ResizeMode.CONTAINER && this.node.setContentSize(newWidth, baseHeight);
      },
      _doLayoutGrid: function _doLayoutGrid() {
        var layoutAnchor = this.node.getAnchorPoint();
        var layoutSize = this.node.getContentSize();
        this.startAxis === AxisDirection.HORIZONTAL ? this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) : this.startAxis === AxisDirection.VERTICAL && this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
      },
      _getHorizontalBaseWidth: function _getHorizontalBaseWidth(children) {
        var newWidth = 0;
        var activeChildCount = 0;
        if (this.resizeMode === ResizeMode.CONTAINER) {
          for (var i = 0; i < children.length; ++i) {
            var child = children[i];
            if (child.activeInHierarchy) {
              activeChildCount++;
              newWidth += child.width * this._getUsedScaleValue(child.scaleX);
            }
          }
          newWidth += (activeChildCount - 1) * this.spacingX + this.paddingLeft + this.paddingRight;
        } else newWidth = this.node.getContentSize().width;
        return newWidth;
      },
      _doLayout: function _doLayout() {
        if (this.type === Type.HORIZONTAL) {
          var newWidth = this._getHorizontalBaseWidth(this.node.children);
          var fnPositionY = function fnPositionY(child) {
            return child.y;
          };
          this._doLayoutHorizontally(newWidth, false, fnPositionY, true);
          this.node.width = newWidth;
        } else if (this.type === Type.VERTICAL) {
          var newHeight = this._getVerticalBaseHeight(this.node.children);
          var fnPositionX = function fnPositionX(child) {
            return child.x;
          };
          this._doLayoutVertically(newHeight, false, fnPositionX, true);
          this.node.height = newHeight;
        } else this.type === Type.NONE ? this.resizeMode === ResizeMode.CONTAINER && this._doLayoutBasic() : this.type === Type.GRID && this._doLayoutGrid();
      },
      _getUsedScaleValue: function _getUsedScaleValue(value) {
        return this.affectedByScale ? Math.abs(value) : 1;
      },
      updateLayout: function updateLayout() {
        if (this._layoutDirty && this.node.children.length > 0) {
          var activeChild = this.node.children.find((function(node) {
            return node.activeInHierarchy;
          }));
          if (activeChild) {
            this._doLayout();
            this._layoutDirty = false;
          }
        }
      }
    });
    cc.Layout = module.exports = Layout;
  }), {
    "../CCNode": 104,
    "./CCComponent": 181
  } ],
  187: [ (function(require, module, exports) {
    "use strict";
    var _gfx = _interopRequireDefault(require("../../renderer/gfx"));
    var _mat = _interopRequireDefault(require("../value-types/mat4"));
    var _vec = _interopRequireDefault(require("../value-types/vec2"));
    var _materialVariant = _interopRequireDefault(require("../assets/material/material-variant"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var misc = require("../utils/misc");
    var RenderComponent = require("./CCRenderComponent");
    var RenderFlow = require("../renderer/render-flow");
    var Graphics = require("../graphics/graphics");
    var _vec2_temp = new _vec["default"]();
    var _mat4_temp = new _mat["default"]();
    var _circlepoints = [];
    function _calculateCircle(center, radius, segements) {
      _circlepoints.length = 0;
      var anglePerStep = 2 * Math.PI / segements;
      for (var step = 0; step < segements; ++step) _circlepoints.push(cc.v2(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y));
      return _circlepoints;
    }
    var MaskType = cc.Enum({
      RECT: 0,
      ELLIPSE: 1,
      IMAGE_STENCIL: 2
    });
    var SEGEMENTS_MIN = 3;
    var SEGEMENTS_MAX = 1e4;
    var Mask = cc.Class({
      name: "cc.Mask",
      extends: RenderComponent,
      editor: false,
      ctor: function ctor() {
        this._graphics = null;
        this._enableMaterial = null;
        this._exitMaterial = null;
        this._clearMaterial = null;
      },
      properties: {
        _spriteFrame: {
          default: null,
          type: cc.SpriteFrame
        },
        _type: MaskType.RECT,
        type: {
          get: function get() {
            return this._type;
          },
          set: function set(value) {
            this._type !== value && this._resetAssembler();
            this._type = value;
            if (this._type !== MaskType.IMAGE_STENCIL) {
              this.spriteFrame = null;
              this.alphaThreshold = 0;
              this._updateGraphics();
            }
            this._activateMaterial();
          },
          type: MaskType,
          tooltip: (true, "i18n:COMPONENT.mask.type")
        },
        spriteFrame: {
          type: cc.SpriteFrame,
          tooltip: (true, "i18n:COMPONENT.mask.spriteFrame"),
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(value) {
            var lastSprite = this._spriteFrame;
            false;
            if (lastSprite === value) return;
            lastSprite && lastSprite.off("load", this.setVertsDirty, this);
            this._spriteFrame = value;
            this.setVertsDirty();
            this._updateMaterial();
          }
        },
        alphaThreshold: {
          default: .1,
          type: cc.Float,
          range: [ 0, 1, .1 ],
          slide: true,
          tooltip: (true, "i18n:COMPONENT.mask.alphaThreshold"),
          notify: function notify() {
            if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
              cc.warnID(4201);
              return;
            }
            this._updateMaterial();
          }
        },
        inverted: {
          default: false,
          type: cc.Boolean,
          tooltip: (true, "i18n:COMPONENT.mask.inverted"),
          notify: function notify() {
            cc.game.renderType === cc.game.RENDER_TYPE_CANVAS && cc.warnID(4202);
          }
        },
        _segments: 64,
        segements: {
          get: function get() {
            return this._segments;
          },
          set: function set(value) {
            this._segments = misc.clampf(value, SEGEMENTS_MIN, SEGEMENTS_MAX);
            this._updateGraphics();
          },
          type: cc.Integer,
          tooltip: (true, "i18n:COMPONENT.mask.segements")
        },
        _resizeToTarget: {
          animatable: false,
          set: function set(value) {
            value && this._resizeNodeToTargetNode();
          }
        }
      },
      statics: {
        Type: MaskType
      },
      onRestore: function onRestore() {
        this._activateMaterial();
      },
      onEnable: function onEnable() {
        this._super();
        this._type !== MaskType.IMAGE_STENCIL ? this._updateGraphics() : this._spriteFrame && this._spriteFrame.once("load", this.setVertsDirty, this);
        this.node.on(cc.Node.EventType.POSITION_CHANGED, this._updateGraphics, this);
        this.node.on(cc.Node.EventType.ROTATION_CHANGED, this._updateGraphics, this);
        this.node.on(cc.Node.EventType.SCALE_CHANGED, this._updateGraphics, this);
        this.node.on(cc.Node.EventType.SIZE_CHANGED, this._updateGraphics, this);
        this.node.on(cc.Node.EventType.ANCHOR_CHANGED, this._updateGraphics, this);
      },
      onDisable: function onDisable() {
        this._super();
        this.node.off(cc.Node.EventType.POSITION_CHANGED, this._updateGraphics, this);
        this.node.off(cc.Node.EventType.ROTATION_CHANGED, this._updateGraphics, this);
        this.node.off(cc.Node.EventType.SCALE_CHANGED, this._updateGraphics, this);
        this.node.off(cc.Node.EventType.SIZE_CHANGED, this._updateGraphics, this);
        this.node.off(cc.Node.EventType.ANCHOR_CHANGED, this._updateGraphics, this);
        this.node._renderFlag &= ~RenderFlow.FLAG_POST_RENDER;
      },
      onDestroy: function onDestroy() {
        this._super();
        this._removeGraphics();
        this._spriteFrame && this._spriteFrame.off("load", this.setVertsDirty, this);
      },
      _resizeNodeToTargetNode: false,
      _validateRender: function _validateRender() {
        if (this._type !== MaskType.IMAGE_STENCIL) return;
        var spriteFrame = this._spriteFrame;
        if (spriteFrame && spriteFrame.textureLoaded()) return;
        this.disableRender();
      },
      _activateMaterial: function _activateMaterial() {
        this._createGraphics();
        var material = this._materials[0];
        material = material ? _materialVariant["default"].create(material, this) : _materialVariant["default"].createWithBuiltin("2d-sprite", this);
        material.define("USE_ALPHA_TEST", true);
        if (this._type === MaskType.IMAGE_STENCIL) {
          material.define("CC_USE_MODEL", false);
          material.define("USE_TEXTURE", true);
        } else {
          material.define("CC_USE_MODEL", true);
          material.define("USE_TEXTURE", false);
        }
        this._enableMaterial || (this._enableMaterial = _materialVariant["default"].createWithBuiltin("2d-sprite", this));
        if (!this._exitMaterial) {
          this._exitMaterial = _materialVariant["default"].createWithBuiltin("2d-sprite", this);
          this._exitMaterial.setStencilEnabled(_gfx["default"].STENCIL_DISABLE);
        }
        this._clearMaterial || (this._clearMaterial = _materialVariant["default"].createWithBuiltin("clear-stencil", this));
        this.setMaterial(0, material);
        this._graphics._materials[0] = material;
        this._updateMaterial();
      },
      _updateMaterial: function _updateMaterial() {
        var material = this._materials[0];
        if (!material) return;
        if (this._type === MaskType.IMAGE_STENCIL && this.spriteFrame) {
          var texture = this.spriteFrame.getTexture();
          material.setProperty("texture", texture);
        }
        material.setProperty("alphaThreshold", this.alphaThreshold);
      },
      _createGraphics: function _createGraphics() {
        if (!this._graphics) {
          this._graphics = new Graphics();
          cc.Assembler.init(this._graphics);
          this._graphics.node = this.node;
          this._graphics.lineWidth = 0;
          this._graphics.strokeColor = cc.color(0, 0, 0, 0);
        }
      },
      _updateGraphics: function _updateGraphics() {
        if (!this.enabledInHierarchy) return;
        var node = this.node;
        var graphics = this._graphics;
        graphics.clear(false);
        var width = node._contentSize.width;
        var height = node._contentSize.height;
        var x = -width * node._anchorPoint.x;
        var y = -height * node._anchorPoint.y;
        if (this._type === MaskType.RECT) graphics.rect(x, y, width, height); else if (this._type === MaskType.ELLIPSE) {
          var center = cc.v2(x + width / 2, y + height / 2);
          var radius = {
            x: width / 2,
            y: height / 2
          };
          var points = _calculateCircle(center, radius, this._segments);
          for (var i = 0; i < points.length; ++i) {
            var point = points[i];
            0 === i ? graphics.moveTo(point.x, point.y) : graphics.lineTo(point.x, point.y);
          }
          graphics.close();
        }
        cc.game.renderType === cc.game.RENDER_TYPE_CANVAS ? graphics.stroke() : graphics.fill();
        this.setVertsDirty();
      },
      _removeGraphics: function _removeGraphics() {
        if (this._graphics) {
          this._graphics.destroy();
          this._graphics._destroyImmediate();
          this._graphics = null;
        }
      },
      _hitTest: function _hitTest(cameraPt) {
        var node = this.node;
        var size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp;
        node._updateWorldMatrix();
        if (!_mat["default"].invert(_mat4_temp, node._worldMatrix)) return false;
        _vec["default"].transformMat4(testPt, cameraPt, _mat4_temp);
        testPt.x += node._anchorPoint.x * w;
        testPt.y += node._anchorPoint.y * h;
        var result = false;
        if (this.type === MaskType.RECT || this.type === MaskType.IMAGE_STENCIL) result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h; else if (this.type === MaskType.ELLIPSE) {
          var rx = w / 2, ry = h / 2;
          var px = testPt.x - .5 * w, py = testPt.y - .5 * h;
          result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
        }
        this.inverted && (result = !result);
        return result;
      },
      markForRender: function markForRender(enable) {
        var flag = RenderFlow.FLAG_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA | RenderFlow.FLAG_POST_RENDER;
        if (enable) {
          this.node._renderFlag |= flag;
          this.markForValidate();
        } else enable || (this.node._renderFlag &= ~flag);
      },
      disableRender: function disableRender() {
        this.node._renderFlag &= ~(RenderFlow.FLAG_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA | RenderFlow.FLAG_POST_RENDER);
      }
    });
    cc.Mask = module.exports = Mask;
  }), {
    "../../renderer/gfx": 427,
    "../assets/material/material-variant": 163,
    "../graphics/graphics": 235,
    "../renderer/render-flow": 323,
    "../utils/misc": 386,
    "../value-types/mat4": 403,
    "../value-types/vec2": 410,
    "./CCRenderComponent": 192
  } ],
  188: [ (function(require, module, exports) {
    "use strict";
    var RenderComponent = require("../components/CCRenderComponent");
    var BlendFunc = require("../../core/utils/blend-func");
    var MotionStreak = cc.Class({
      name: "cc.MotionStreak",
      extends: RenderComponent,
      mixins: [ BlendFunc ],
      editor: false,
      ctor: function ctor() {
        this._points = [];
        this._lastWPos = new cc.Vec2();
      },
      properties: {
        preview: {
          default: false,
          editorOnly: true,
          notify: false,
          animatable: false
        },
        _fadeTime: 1,
        fadeTime: {
          get: function get() {
            return this._fadeTime;
          },
          set: function set(value) {
            this._fadeTime = value;
            this.reset();
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.motionStreak.fadeTime")
        },
        _minSeg: 1,
        minSeg: {
          get: function get() {
            return this._minSeg;
          },
          set: function set(value) {
            this._minSeg = value;
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.motionStreak.minSeg")
        },
        _stroke: 64,
        stroke: {
          get: function get() {
            return this._stroke;
          },
          set: function set(value) {
            this._stroke = value;
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.motionStreak.stroke")
        },
        _texture: {
          default: null,
          type: cc.Texture2D
        },
        texture: {
          get: function get() {
            return this._texture;
          },
          set: function set(value) {
            if (this._texture === value) return;
            this._texture = value;
            this._checkSwitchMaterial();
            this._updateMaterial();
          },
          type: cc.Texture2D,
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.motionStreak.texture")
        },
        _color: cc.Color.WHITE,
        color: {
          get: function get() {
            return this._color.clone();
          },
          set: function set(value) {
            this._color.equals(value) || this._color.set(value);
          },
          type: cc.Color,
          tooltip: (true, "i18n:COMPONENT.motionStreak.color")
        },
        _fastMode: false,
        fastMode: {
          get: function get() {
            return this._fastMode;
          },
          set: function set(value) {
            this._fastMode = value;
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.motionStreak.fastMode")
        },
        autoSwitchMaterial: {
          type: RenderComponent.EnableType,
          default: RenderComponent.EnableType.GLOBAL,
          notify: function notify(oldValue) {
            if (this.autoSwitchMaterial === oldValue) return;
            this.setVertsDirty();
          }
        }
      },
      setVertsDirty: function setVertsDirty() {
        this._checkSwitchMaterial();
        this._updateMaterial();
        this._super();
      },
      __preload: function __preload() {
        this._super();
        this._checkSwitchMaterial();
      },
      _checkSwitchMaterial: function _checkSwitchMaterial() {
        if (this._assembler) {
          var material = this._materials[0];
          if (!material) return;
          if (!this._texture) return;
          this._assembler.checkAndSwitchMaterial(this, this._texture, material);
        }
      },
      onEnable: function onEnable() {
        this._super();
        this.reset();
      },
      _updateMaterial: function _updateMaterial() {
        var material = this.getMaterial(0);
        if (!material) return;
        var isMultiMaterial = material.material.isMultiSupport();
        if (isMultiMaterial) {
          if (!this._texture) return;
          this._updateMultiTexId(material, this._texture);
        } else {
          var textureImpl = this._texture && this._texture.getImpl();
          material.getProperty("texture") !== textureImpl && material.setProperty("texture", this._texture);
        }
        this._assembler && (isMultiMaterial && !this._assembler.isMulti || !isMultiMaterial && this._assembler.isMulti) && this._resetAssembler();
        if (isMultiMaterial && this._texIdDirty && this._assembler) {
          if (!this._texture) return;
          this._assembler.updateTexId(this);
          this._texIdDirty = false;
        }
        BlendFunc.prototype._updateMaterial.call(this);
      },
      onFocusInEditor: false,
      onLostFocusInEditor: false,
      reset: function reset() {
        this._points.length = 0;
        this._assembler && this._assembler._renderData.clear();
        this._lastWPos.x = 0;
        this._lastWPos.y = 0;
        false;
      },
      lateUpdate: function lateUpdate(dt) {
        this._assembler && this._assembler.update(this, dt);
      }
    });
    cc.MotionStreak = module.exports = MotionStreak;
  }), {
    "../../core/utils/blend-func": 380,
    "../components/CCRenderComponent": 192
  } ],
  189: [ (function(require, module, exports) {
    "use strict";
    var SizeMode = cc.Enum({
      Unified: 0,
      Free: 1
    });
    var Direction = cc.Enum({
      Horizontal: 0,
      Vertical: 1
    });
    var EventType = cc.Enum({
      PAGE_TURNING: 0
    });
    var PageView = cc.Class({
      name: "cc.PageView",
      extends: cc.ScrollView,
      editor: false,
      ctor: function ctor() {
        this._curPageIdx = 0;
        this._lastPageIdx = 0;
        this._pages = [];
        this._initContentPos = cc.v2();
        this._scrollCenterOffsetX = [];
        this._scrollCenterOffsetY = [];
      },
      properties: {
        sizeMode: {
          default: SizeMode.Unified,
          type: SizeMode,
          tooltip: (true, "i18n:COMPONENT.pageview.sizeMode"),
          notify: function notify() {
            this._syncSizeMode();
          }
        },
        direction: {
          default: Direction.Horizontal,
          type: Direction,
          tooltip: (true, "i18n:COMPONENT.pageview.direction"),
          notify: function notify() {
            this._syncScrollDirection();
          }
        },
        scrollThreshold: {
          default: .5,
          type: cc.Float,
          slide: true,
          range: [ 0, 1, .01 ],
          tooltip: (true, "i18n:COMPONENT.pageview.scrollThreshold")
        },
        autoPageTurningThreshold: {
          default: 100,
          type: cc.Float,
          tooltip: (true, "i18n:COMPONENT.pageview.autoPageTurningThreshold")
        },
        pageTurningEventTiming: {
          default: .1,
          type: cc.Float,
          range: [ 0, 1, .01 ],
          tooltip: (true, "i18n:COMPONENT.pageview.pageTurningEventTiming")
        },
        indicator: {
          default: null,
          type: cc.PageViewIndicator,
          tooltip: (true, "i18n:COMPONENT.pageview.indicator"),
          notify: function notify() {
            this.indicator && this.indicator.setPageView(this);
          }
        },
        pageTurningSpeed: {
          default: .3,
          type: cc.Float,
          tooltip: (true, "i18n:COMPONENT.pageview.pageTurningSpeed")
        },
        pageEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: (true, "i18n:COMPONENT.pageview.pageEvents")
        }
      },
      statics: {
        SizeMode: SizeMode,
        Direction: Direction,
        EventType: EventType
      },
      onEnable: function onEnable() {
        this._super();
        this.node.on(cc.Node.EventType.SIZE_CHANGED, this._updateAllPagesSize, this);
        true;
        this.node.on("scroll-ended-with-threshold", this._dispatchPageTurningEvent, this);
      },
      onDisable: function onDisable() {
        this._super();
        this.node.off(cc.Node.EventType.SIZE_CHANGED, this._updateAllPagesSize, this);
        true;
        this.node.off("scroll-ended-with-threshold", this._dispatchPageTurningEvent, this);
      },
      onLoad: function onLoad() {
        this._initPages();
        this.indicator && this.indicator.setPageView(this);
      },
      getCurrentPageIndex: function getCurrentPageIndex() {
        return this._curPageIdx;
      },
      setCurrentPageIndex: function setCurrentPageIndex(index) {
        this.scrollToPage(index, true);
      },
      getPages: function getPages() {
        return this._pages;
      },
      addPage: function addPage(page) {
        if (!page || -1 !== this._pages.indexOf(page) || !this.content) return;
        this.content.addChild(page);
        this._pages.push(page);
        this._updatePageView();
      },
      insertPage: function insertPage(page, index) {
        if (index < 0 || !page || -1 !== this._pages.indexOf(page) || !this.content) return;
        var pageCount = this._pages.length;
        if (index >= pageCount) this.addPage(page); else {
          this._pages.splice(index, 0, page);
          this.content.addChild(page);
          this._updatePageView();
        }
      },
      removePage: function removePage(page) {
        if (!page || !this.content) return;
        var index = this._pages.indexOf(page);
        if (-1 === index) {
          cc.warnID(4300, page.name);
          return;
        }
        this.removePageAtIndex(index);
      },
      removePageAtIndex: function removePageAtIndex(index) {
        var pageList = this._pages;
        if (index < 0 || index >= pageList.length) return;
        var page = pageList[index];
        if (!page) return;
        this.content.removeChild(page);
        pageList.splice(index, 1);
        this._updatePageView();
      },
      removeAllPages: function removeAllPages() {
        if (!this.content) return;
        var locPages = this._pages;
        for (var i = 0, len = locPages.length; i < len; i++) this.content.removeChild(locPages[i]);
        this._pages.length = 0;
        this._updatePageView();
      },
      scrollToPage: function scrollToPage(idx, timeInSecond) {
        if (idx < 0 || idx >= this._pages.length) return;
        timeInSecond = void 0 !== timeInSecond ? timeInSecond : .3;
        this._curPageIdx = idx;
        this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, true);
        this.indicator && this.indicator._changedState();
      },
      getScrollEndedEventTiming: function getScrollEndedEventTiming() {
        return this.pageTurningEventTiming;
      },
      _syncScrollDirection: function _syncScrollDirection() {
        this.horizontal = this.direction === Direction.Horizontal;
        this.vertical = this.direction === Direction.Vertical;
      },
      _syncSizeMode: function _syncSizeMode() {
        if (!this.content) return;
        var layout = this.content.getComponent(cc.Layout);
        if (layout) {
          if (this.sizeMode === SizeMode.Free && this._pages.length > 0) {
            var lastPage = this._pages[this._pages.length - 1];
            if (this.direction === Direction.Horizontal) {
              layout.paddingLeft = (this._view.width - this._pages[0].width) / 2;
              layout.paddingRight = (this._view.width - lastPage.width) / 2;
            } else if (this.direction === Direction.Vertical) {
              layout.paddingTop = (this._view.height - this._pages[0].height) / 2;
              layout.paddingBottom = (this._view.height - lastPage.height) / 2;
            }
          }
          layout.updateLayout();
        }
      },
      _updatePageView: function _updatePageView() {
        var layout = this.content.getComponent(cc.Layout);
        layout && layout.enabled && layout.updateLayout();
        var pageCount = this._pages.length;
        if (this._curPageIdx >= pageCount) {
          this._curPageIdx = 0 === pageCount ? 0 : pageCount - 1;
          this._lastPageIdx = this._curPageIdx;
        }
        var contentPos = this._initContentPos;
        for (var i = 0; i < pageCount; ++i) {
          var page = this._pages[i];
          page.setSiblingIndex(i);
          this.direction === Direction.Horizontal ? this._scrollCenterOffsetX[i] = Math.abs(contentPos.x + page.x) : this._scrollCenterOffsetY[i] = Math.abs(contentPos.y + page.y);
        }
        this.indicator && this.indicator._refresh();
      },
      _updateAllPagesSize: function _updateAllPagesSize() {
        if (this.sizeMode !== SizeMode.Unified || !this._view) return;
        var locPages = this._pages;
        var selfSize = this._view.getContentSize();
        for (var i = 0, len = locPages.length; i < len; i++) locPages[i].setContentSize(selfSize);
      },
      _initPages: function _initPages() {
        if (!this.content) return;
        this._initContentPos = this.content.position;
        var children = this.content.children;
        for (var i = 0; i < children.length; ++i) {
          var page = children[i];
          if (this._pages.indexOf(page) >= 0) continue;
          this._pages.push(page);
        }
        this._syncScrollDirection();
        this._syncSizeMode();
        this._updatePageView();
      },
      _dispatchPageTurningEvent: function _dispatchPageTurningEvent() {
        if (this._lastPageIdx === this._curPageIdx) return;
        this._lastPageIdx = this._curPageIdx;
        cc.Component.EventHandler.emitEvents(this.pageEvents, this, EventType.PAGE_TURNING);
        this.node.emit("page-turning", this);
      },
      _isScrollable: function _isScrollable(offset, index, nextIndex) {
        if (this.sizeMode === SizeMode.Free) {
          var curPageCenter, nextPageCenter;
          if (this.direction === Direction.Horizontal) {
            curPageCenter = this._scrollCenterOffsetX[index];
            nextPageCenter = this._scrollCenterOffsetX[nextIndex];
            return Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
          }
          if (this.direction === Direction.Vertical) {
            curPageCenter = this._scrollCenterOffsetY[index];
            nextPageCenter = this._scrollCenterOffsetY[nextIndex];
            return Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
          }
        } else {
          if (this.direction === Direction.Horizontal) return Math.abs(offset.x) >= this._view.width * this.scrollThreshold;
          if (this.direction === Direction.Vertical) return Math.abs(offset.y) >= this._view.height * this.scrollThreshold;
        }
      },
      _isQuicklyScrollable: function _isQuicklyScrollable(touchMoveVelocity) {
        if (this.direction === Direction.Horizontal) {
          if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) return true;
        } else if (this.direction === Direction.Vertical && Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) return true;
        return false;
      },
      _moveOffsetValue: function _moveOffsetValue(idx) {
        var offset = cc.v2(0, 0);
        this.sizeMode === SizeMode.Free ? this.direction === Direction.Horizontal ? offset.x = this._scrollCenterOffsetX[idx] : this.direction === Direction.Vertical && (offset.y = this._scrollCenterOffsetY[idx]) : this.direction === Direction.Horizontal ? offset.x = idx * this._view.width : this.direction === Direction.Vertical && (offset.y = idx * this._view.height);
        return offset;
      },
      _getDragDirection: function _getDragDirection(moveOffset) {
        if (this.direction === Direction.Horizontal) {
          if (0 === moveOffset.x) return 0;
          return moveOffset.x > 0 ? 1 : -1;
        }
        if (this.direction === Direction.Vertical) {
          if (0 === moveOffset.y) return 0;
          return moveOffset.y < 0 ? 1 : -1;
        }
      },
      _handleReleaseLogic: function _handleReleaseLogic(touch) {
        this._autoScrollToPage();
        if (this._scrolling) {
          this._scrolling = false;
          this._autoScrolling || this._dispatchEvent("scroll-ended");
        }
      },
      _autoScrollToPage: function _autoScrollToPage() {
        var bounceBackStarted = this._startBounceBackIfNeeded();
        if (bounceBackStarted) {
          var bounceBackAmount = this._getHowMuchOutOfBoundary();
          bounceBackAmount = this._clampDelta(bounceBackAmount);
          (bounceBackAmount.x > 0 || bounceBackAmount.y < 0) && (this._curPageIdx = 0 === this._pages.length ? 0 : this._pages.length - 1);
          (bounceBackAmount.x < 0 || bounceBackAmount.y > 0) && (this._curPageIdx = 0);
          this.indicator && this.indicator._changedState();
        } else {
          var moveOffset = this._touchBeganPosition.sub(this._touchEndPosition);
          var index = this._curPageIdx, nextIndex = index + this._getDragDirection(moveOffset);
          var timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);
          if (nextIndex < this._pages.length) {
            if (this._isScrollable(moveOffset, index, nextIndex)) {
              this.scrollToPage(nextIndex, timeInSecond);
              return;
            }
            var touchMoveVelocity = this._calculateTouchMoveVelocity();
            if (this._isQuicklyScrollable(touchMoveVelocity)) {
              this.scrollToPage(nextIndex, timeInSecond);
              return;
            }
          }
          this.scrollToPage(index, timeInSecond);
        }
      },
      _onTouchBegan: function _onTouchBegan(event, captureListeners) {
        this._touchBeganPosition = event.touch.getLocation();
        this._super(event, captureListeners);
      },
      _onTouchMoved: function _onTouchMoved(event, captureListeners) {
        this._super(event, captureListeners);
      },
      _onTouchEnded: function _onTouchEnded(event, captureListeners) {
        this._touchEndPosition = event.touch.getLocation();
        this._super(event, captureListeners);
      },
      _onTouchCancelled: function _onTouchCancelled(event, captureListeners) {
        this._touchEndPosition = event.touch.getLocation();
        this._super(event, captureListeners);
      },
      _onMouseWheel: function _onMouseWheel() {}
    });
    cc.PageView = module.exports = PageView;
  }), {} ],
  190: [ (function(require, module, exports) {
    "use strict";
    var Direction = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1
    });
    var PageViewIndicator = cc.Class({
      name: "cc.PageViewIndicator",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _layout: null,
        _pageView: null,
        _indicators: [],
        spriteFrame: {
          default: null,
          type: cc.SpriteFrame,
          tooltip: (true, "i18n:COMPONENT.pageview_indicator.spriteFrame")
        },
        direction: {
          default: Direction.HORIZONTAL,
          type: Direction,
          tooltip: (true, "i18n:COMPONENT.pageview_indicator.direction")
        },
        cellSize: {
          default: cc.size(20, 20),
          tooltip: (true, "i18n:COMPONENT.pageview_indicator.cell_size")
        },
        spacing: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.pageview_indicator.spacing")
        }
      },
      statics: {
        Direction: Direction
      },
      onLoad: function onLoad() {
        this._updateLayout();
      },
      setPageView: function setPageView(target) {
        this._pageView = target;
        this._refresh();
      },
      _updateLayout: function _updateLayout() {
        this._layout = this.getComponent(cc.Layout);
        this._layout || (this._layout = this.addComponent(cc.Layout));
        if (this.direction === Direction.HORIZONTAL) {
          this._layout.type = cc.Layout.Type.HORIZONTAL;
          this._layout.spacingX = this.spacing;
        } else if (this.direction === Direction.VERTICAL) {
          this._layout.type = cc.Layout.Type.VERTICAL;
          this._layout.spacingY = this.spacing;
        }
        this._layout.resizeMode = cc.Layout.ResizeMode.CONTAINER;
      },
      _createIndicator: function _createIndicator() {
        var node = new cc.Node();
        var sprite = node.addComponent(cc.Sprite);
        sprite.spriteFrame = this.spriteFrame;
        sprite.sizeMode = cc.Sprite.SizeMode.CUSTOM;
        node.parent = this.node;
        node.width = this.cellSize.width;
        node.height = this.cellSize.height;
        return node;
      },
      _changedState: function _changedState() {
        var indicators = this._indicators;
        if (0 === indicators.length) return;
        var idx = this._pageView._curPageIdx;
        if (idx >= indicators.length) return;
        for (var i = 0; i < indicators.length; ++i) {
          var node = indicators[i];
          node.opacity = 127.5;
        }
        indicators[idx].opacity = 255;
      },
      _refresh: function _refresh() {
        if (!this._pageView) return;
        var indicators = this._indicators;
        var pages = this._pageView.getPages();
        if (pages.length === indicators.length) return;
        var i = 0;
        if (pages.length > indicators.length) for (i = 0; i < pages.length; ++i) indicators[i] || (indicators[i] = this._createIndicator()); else {
          var count = indicators.length - pages.length;
          for (i = count; i > 0; --i) {
            var node = indicators[i - 1];
            this.node.removeChild(node);
            indicators.splice(i - 1, 1);
          }
        }
        this._layout && this._layout.enabledInHierarchy && this._layout.updateLayout();
        this._changedState();
      }
    });
    cc.PageViewIndicator = module.exports = PageViewIndicator;
  }), {
    "./CCComponent": 181
  } ],
  191: [ (function(require, module, exports) {
    "use strict";
    var misc = require("../utils/misc");
    var Component = require("./CCComponent");
    var Mode = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1,
      FILLED: 2
    });
    var ProgressBar = cc.Class({
      name: "cc.ProgressBar",
      extends: Component,
      editor: false,
      _initBarSprite: function _initBarSprite() {
        if (this.barSprite) {
          var entity = this.barSprite.node;
          if (!entity) return;
          var nodeSize = this.node.getContentSize();
          var nodeAnchor = this.node.getAnchorPoint();
          var entitySize = entity.getContentSize();
          entity.parent === this.node && this.node.setContentSize(entitySize);
          this.barSprite.fillType === cc.Sprite.FillType.RADIAL && (this.mode = Mode.FILLED);
          var barSpriteSize = entity.getContentSize();
          this.mode === Mode.HORIZONTAL ? this.totalLength = barSpriteSize.width : this.mode === Mode.VERTICAL ? this.totalLength = barSpriteSize.height : this.totalLength = this.barSprite.fillRange;
          if (entity.parent === this.node) {
            var x = -nodeSize.width * nodeAnchor.x;
            var y = 0;
            entity.setPosition(cc.v2(x, y));
          }
        }
      },
      _updateBarStatus: function _updateBarStatus() {
        if (this.barSprite) {
          var entity = this.barSprite.node;
          if (!entity) return;
          var entityAnchorPoint = entity.getAnchorPoint();
          var entitySize = entity.getContentSize();
          var entityPosition = entity.getPosition();
          var anchorPoint = cc.v2(0, .5);
          var progress = misc.clamp01(this.progress);
          var actualLenth = this.totalLength * progress;
          var finalContentSize;
          var totalWidth;
          var totalHeight;
          switch (this.mode) {
           case Mode.HORIZONTAL:
            this.reverse && (anchorPoint = cc.v2(1, .5));
            finalContentSize = cc.size(actualLenth, entitySize.height);
            totalWidth = this.totalLength;
            totalHeight = entitySize.height;
            break;

           case Mode.VERTICAL:
            anchorPoint = this.reverse ? cc.v2(.5, 1) : cc.v2(.5, 0);
            finalContentSize = cc.size(entitySize.width, actualLenth);
            totalWidth = entitySize.width;
            totalHeight = this.totalLength;
          }
          if (this.mode === Mode.FILLED) if (this.barSprite.type !== cc.Sprite.Type.FILLED) cc.warn("ProgressBar FILLED mode only works when barSprite's Type is FILLED!"); else {
            this.reverse && (actualLenth *= -1);
            this.barSprite.fillRange = actualLenth;
          } else if (this.barSprite.type !== cc.Sprite.Type.FILLED) {
            var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
            var anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
            var finalPosition = cc.v2(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY);
            entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y);
            entity.setAnchorPoint(anchorPoint);
            entity.setContentSize(finalContentSize);
          } else cc.warn("ProgressBar non-FILLED mode only works when barSprite's Type is non-FILLED!");
        }
      },
      properties: {
        barSprite: {
          default: null,
          type: cc.Sprite,
          tooltip: (true, "i18n:COMPONENT.progress.bar_sprite"),
          notify: function notify() {
            this._initBarSprite();
          },
          animatable: false
        },
        mode: {
          default: Mode.HORIZONTAL,
          type: Mode,
          tooltip: (true, "i18n:COMPONENT.progress.mode"),
          notify: function notify() {
            if (this.barSprite) {
              var entity = this.barSprite.node;
              if (!entity) return;
              var entitySize = entity.getContentSize();
              this.mode === Mode.HORIZONTAL ? this.totalLength = entitySize.width : this.mode === Mode.VERTICAL ? this.totalLength = entitySize.height : this.mode === Mode.FILLED && (this.totalLength = this.barSprite.fillRange);
            }
          },
          animatable: false
        },
        _N$totalLength: 1,
        totalLength: {
          range: [ 0, Number.MAX_VALUE ],
          tooltip: (true, "i18n:COMPONENT.progress.total_length"),
          get: function get() {
            return this._N$totalLength;
          },
          set: function set(value) {
            this.mode === Mode.FILLED && (value = misc.clamp01(value));
            this._N$totalLength = value;
            this._updateBarStatus();
          }
        },
        progress: {
          default: 1,
          type: cc.Float,
          range: [ 0, 1, .1 ],
          slide: true,
          tooltip: (true, "i18n:COMPONENT.progress.progress"),
          notify: function notify() {
            this._updateBarStatus();
          }
        },
        reverse: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.progress.reverse"),
          notify: function notify() {
            this.barSprite && (this.barSprite.fillStart = 1 - this.barSprite.fillStart);
            this._updateBarStatus();
          },
          animatable: false
        }
      },
      statics: {
        Mode: Mode
      }
    });
    cc.ProgressBar = module.exports = ProgressBar;
  }), {
    "../utils/misc": 386,
    "./CCComponent": 181
  } ],
  192: [ (function(require, module, exports) {
    "use strict";
    var _assembler = _interopRequireDefault(require("../renderer/assembler"));
    var _materialVariant = _interopRequireDefault(require("../assets/material/material-variant"));
    var _valueTypes = require("../value-types");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Component = require("./CCComponent");
    var RenderFlow = require("../renderer/render-flow");
    var Material = require("../assets/material/CCMaterial");
    var _temp_color = new _valueTypes.Color();
    var EnableType = cc.Enum({
      GLOBAL: 0,
      ENABLE: 1,
      DISABLE: 2
    });
    var RenderComponent = cc.Class({
      name: "RenderComponent",
      extends: Component,
      editor: false,
      statics: {
        EnableType: EnableType
      },
      properties: {
        _materials: {
          default: [],
          type: Material
        },
        materials: {
          get: function get() {
            return this._materials;
          },
          set: function set(val) {
            this._materials = val;
            this._activateMaterial();
          },
          type: [ Material ],
          displayName: "Materials",
          animatable: false
        }
      },
      ctor: function ctor() {
        this._vertsDirty = true;
        this._texIdDirty = true;
        this._texId = 0;
        this._assembler = null;
      },
      _resetAssembler: function _resetAssembler() {
        _assembler["default"].init(this);
        this._updateColor();
        this._texId = 0;
        this.setVertsDirty();
      },
      __preload: function __preload() {
        this._resetAssembler();
        this._activateMaterial();
      },
      onEnable: function onEnable() {
        this.node._renderComponent && (this.node._renderComponent.enabled = false);
        this.node._renderComponent = this;
        this.node._renderFlag |= RenderFlow.FLAG_OPACITY_COLOR;
        this.setVertsDirty();
      },
      onDisable: function onDisable() {
        this.node._renderComponent = null;
        this.disableRender();
      },
      onDestroy: function onDestroy() {
        var materials = this._materials;
        for (var i = 0; i < materials.length; i++) cc.pool.material.put(materials[i]);
        materials.length = 0;
        cc.pool.assembler.put(this._assembler);
        this.disableRender();
      },
      setVertsDirty: function setVertsDirty() {
        this._vertsDirty = true;
        this.markForRender(true);
      },
      _on3DNodeChanged: function _on3DNodeChanged() {
        this._resetAssembler();
      },
      _validateRender: function _validateRender() {},
      markForValidate: function markForValidate() {
        cc.RenderFlow.registerValidate(this);
      },
      markForRender: function markForRender(enable) {
        var flag = RenderFlow.FLAG_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA;
        if (enable) {
          this.node._renderFlag |= flag;
          this.markForValidate();
        } else this.node._renderFlag &= ~flag;
      },
      disableRender: function disableRender() {
        this.node._renderFlag &= ~(RenderFlow.FLAG_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA);
      },
      getMaterial: function getMaterial(index) {
        if (index < 0 || index >= this._materials.length) return null;
        var material = this._materials[index];
        if (!material) return null;
        var instantiated = _materialVariant["default"].create(material, this);
        instantiated !== material && this.setMaterial(index, instantiated);
        return instantiated;
      },
      getMaterials: function getMaterials() {
        var materials = this._materials;
        for (var i = 0; i < materials.length; i++) materials[i] = _materialVariant["default"].create(materials[i], this);
        return materials;
      },
      setMaterial: function setMaterial(index, material) {
        if (material !== this._materials[index]) {
          material = _materialVariant["default"].create(material, this);
          this._materials[index] = material;
        }
        this._updateMaterial();
        this.markForRender(true);
        return material;
      },
      _getDefaultMaterial: function _getDefaultMaterial() {
        return Material.getBuiltinMaterial("2d-sprite");
      },
      _activateMaterial: function _activateMaterial() {
        var materials = this._materials;
        if (!materials[0]) {
          var material = this._getDefaultMaterial();
          materials[0] = material;
        }
        for (var i = 0; i < materials.length; i++) materials[i] = _materialVariant["default"].create(materials[i], this);
        this._updateMaterial();
      },
      _updateMaterial: function _updateMaterial() {},
      _updateColor: function _updateColor() {
        if (this._assembler.updateColor) {
          var premultiply = this.srcBlendFactor === cc.macro.BlendFactor.ONE;
          premultiply && _valueTypes.Color.premultiplyAlpha(_temp_color, this.node._color);
          var color = premultiply ? _temp_color._val : null;
          this._assembler.updateColor(this, color);
        }
      },
      _checkBacth: function _checkBacth(renderer, cullingMask) {
        var material = this._materials[0];
        if (material && material.getHash() !== renderer.material.getHash() || renderer.cullingMask !== cullingMask) {
          renderer._flush();
          renderer.node = material.getDefine("CC_USE_MODEL") ? this.node : renderer._dummyNode;
          renderer.material = material;
          renderer.cullingMask = cullingMask;
        }
      },
      _updateMultiTexId: function _updateMultiTexId(material, texture) {
        var multi = material.material.getMultiHandler();
        var spTexture = texture;
        var nSpTexture = spTexture.getImpl();
        var same = 0 === this._texId ? material.getProperty("texture") !== nSpTexture : multi.getTexture(this._texId) !== nSpTexture;
        if (same) {
          var isChanged = Object.prototype.hasOwnProperty.call(material._effect._passes["0"]._properties, "texture");
          var texId = isChanged ? -1 : multi.getIndex(nSpTexture);
          if (-1 !== texId) {
            this._texId = texId;
            this._texIdDirty = true;
          } else {
            material.setProperty("texture", spTexture);
            if (0 !== this._texId) {
              this._texId = 0;
              this._texIdDirty = true;
            }
          }
        } else this._texIdDirty = false;
      }
    });
    cc.RenderComponent = module.exports = RenderComponent;
  }), {
    "../assets/material/CCMaterial": 156,
    "../assets/material/material-variant": 163,
    "../renderer/assembler": 302,
    "../renderer/render-flow": 323,
    "../value-types": 401,
    "./CCComponent": 181
  } ],
  193: [ (function(require, module, exports) {
    "use strict";
    var _materialVariant = _interopRequireDefault(require("../assets/material/material-variant"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var js = require("../platform/js");
    var macro = require("../platform/CCMacro");
    var textUtils = require("../utils/text-utils");
    var HtmlTextParser = require("../utils/html-text-parser");
    var _htmlTextParser = new HtmlTextParser();
    var HorizontalAlign = macro.TextAlignment;
    var VerticalAlign = macro.VerticalTextAlignment;
    var RichTextChildName = "RICHTEXT_CHILD";
    var RichTextChildImageName = "RICHTEXT_Image_CHILD";
    var CacheMode = cc.Label.CacheMode;
    var RenderComponent = require("./CCRenderComponent");
    function debounce(func, wait, immediate) {
      var timeout;
      return function() {
        var context = this;
        var later = function later() {
          timeout = null;
          immediate || func.apply(context, arguments);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        callNow && func.apply(context, arguments);
      };
    }
    var pool = new js.Pool(function(node) {
      false;
      true;
      cc.assert(!node._parent, "Recycling node's parent should be null!");
      if (!cc.isValid(node)) return false;
      var outline = node.getComponent(cc.LabelOutline);
      outline && (outline.width = 0);
      return true;
    }, 20);
    pool.get = function(string, richtext) {
      var labelNode = this._get();
      if (!labelNode) {
        labelNode = new cc.PrivateNode(RichTextChildName);
        labelNode._objFlags |= cc.Object.Flags.DontSave;
      }
      labelNode.setPosition(0, 0);
      labelNode.setAnchorPoint(.5, .5);
      labelNode.skewX = 0;
      var labelComponent = labelNode.getComponent(cc.Label);
      labelComponent || (labelComponent = labelNode.addComponent(cc.Label));
      labelComponent.string = "";
      labelComponent.horizontalAlign = HorizontalAlign.LEFT;
      labelComponent.verticalAlign = VerticalAlign.CENTER;
      labelComponent._forceUseCanvas = true;
      return labelNode;
    };
    var RichText = cc.Class({
      name: "cc.RichText",
      extends: cc.Component,
      ctor: function ctor() {
        this._textArray = null;
        this._labelSegments = [];
        this._labelSegmentsCache = [];
        this._linesWidth = [];
        false;
        this._updateRichTextStatus = this._updateRichText;
      },
      editor: false,
      properties: {
        string: {
          default: "<color=#00ff00>Rich</c><color=#0fffff>Text</color>",
          multiline: true,
          tooltip: (true, "i18n:COMPONENT.richtext.string"),
          notify: function notify() {
            this._updateRichTextStatus();
          }
        },
        horizontalAlign: {
          default: HorizontalAlign.LEFT,
          type: HorizontalAlign,
          tooltip: (true, "i18n:COMPONENT.richtext.horizontal_align"),
          animatable: false,
          notify: function notify(oldValue) {
            if (this.horizontalAlign === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        fontSize: {
          default: 40,
          tooltip: (true, "i18n:COMPONENT.richtext.font_size"),
          notify: function notify(oldValue) {
            if (this.fontSize === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        _fontFamily: "Arial",
        fontFamily: {
          tooltip: (true, "i18n:COMPONENT.richtext.font_family"),
          get: function get() {
            return this._fontFamily;
          },
          set: function set(value) {
            if (this._fontFamily === value) return;
            this._fontFamily = value;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          },
          animatable: false
        },
        font: {
          default: null,
          type: cc.TTFFont,
          tooltip: (true, "i18n:COMPONENT.richtext.font"),
          notify: function notify(oldValue) {
            if (this.font === oldValue) return;
            this._layoutDirty = true;
            if (this.font) {
              false;
              this.useSystemFont = false;
              this._onTTFLoaded();
            } else this.useSystemFont = true;
            this._updateRichTextStatus();
          }
        },
        _isSystemFontUsed: true,
        useSystemFont: {
          get: function get() {
            return this._isSystemFontUsed;
          },
          set: function set(value) {
            if (this._isSystemFontUsed === value) return;
            this._isSystemFontUsed = value;
            false;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.richtext.system_font")
        },
        cacheMode: {
          default: CacheMode.NONE,
          type: CacheMode,
          tooltip: (true, "i18n:COMPONENT.label.cacheMode"),
          notify: function notify(oldValue) {
            if (this.cacheMode === oldValue) return;
            this._updateRichTextStatus();
          },
          animatable: false
        },
        maxWidth: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.richtext.max_width"),
          notify: function notify(oldValue) {
            if (this.maxWidth === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        lineHeight: {
          default: 40,
          tooltip: (true, "i18n:COMPONENT.richtext.line_height"),
          notify: function notify(oldValue) {
            if (this.lineHeight === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        imageAtlas: {
          default: null,
          type: cc.SpriteAtlas,
          tooltip: (true, "i18n:COMPONENT.richtext.image_atlas"),
          notify: function notify(oldValue) {
            if (this.imageAtlas === oldValue) return;
            this._layoutDirty = true;
            this._updateRichTextStatus();
          }
        },
        handleTouchEvent: {
          default: true,
          tooltip: (true, "i18n:COMPONENT.richtext.handleTouchEvent"),
          notify: function notify(oldValue) {
            if (this.handleTouchEvent === oldValue) return;
            this.enabledInHierarchy && (this.handleTouchEvent ? this._addEventListeners() : this._removeEventListeners());
          }
        },
        customMaterial: {
          default: null,
          type: cc.Material,
          notify: function notify(oldValue) {
            if (this.customMaterial === oldValue) return;
            var material = null == this.customMaterial ? this._getDefaultMaterial() : this.customMaterial;
            for (var i = 0; i < this._labelSegments.length; i++) {
              var labelComponent = this._labelSegments[i].getComponent(cc.Label);
              labelComponent && (0 === labelComponent._materials.length ? labelComponent._materials[0] = _materialVariant["default"].create(material, labelComponent) : labelComponent.setMaterial(0, material));
              var spriteComponent = this._labelSegments[i].getComponent(cc.Sprite);
              spriteComponent && (0 === spriteComponent._materials.length ? spriteComponent._materials[0] = _materialVariant["default"].create(material, spriteComponent) : spriteComponent.setMaterial(0, material));
            }
            for (var _i = 0; _i < this._labelSegmentsCache.length; _i++) {
              var _labelComponent = this._labelSegmentsCache[_i].getComponent(cc.Label);
              _labelComponent && (0 === _labelComponent._materials.length ? _labelComponent._materials[0] = _materialVariant["default"].create(material, _labelComponent) : _labelComponent.setMaterial(0, material));
            }
          }
        },
        autoSwitchMaterial: {
          type: RenderComponent.EnableType,
          default: RenderComponent.EnableType.GLOBAL,
          notify: function notify(oldValue) {
            if (this.autoSwitchMaterial === oldValue) return;
            for (var i = 0; i < this._labelSegments.length; i++) {
              var labelComponent = this._labelSegments[i].getComponent(cc.Label);
              labelComponent && (labelComponent.autoSwitchMaterial = this.autoSwitchMaterial);
              var spriteComponent = this._labelSegments[i].getComponent(cc.Sprite);
              spriteComponent && (spriteComponent.autoSwitchMaterial = this.autoSwitchMaterial);
            }
            for (var _i2 = 0; _i2 < this._labelSegmentsCache.length; _i2++) {
              var _labelComponent2 = this._labelSegmentsCache[_i2].getComponent(cc.Label);
              _labelComponent2 && (_labelComponent2.autoSwitchMaterial = this.autoSwitchMaterial);
            }
          }
        },
        allowDynamicAtlas: {
          type: RenderComponent.EnableType,
          default: RenderComponent.EnableType.GLOBAL,
          notify: function notify(oldValue) {
            if (this.allowDynamicAtlas === oldValue) return;
            for (var i = 0; i < this._labelSegments.length; i++) {
              var labelComponent = this._labelSegments[i].getComponent(cc.Label);
              labelComponent && (labelComponent.allowDynamicAtlas = this.allowDynamicAtlas);
              var spriteComponent = this._labelSegments[i].getComponent(cc.Sprite);
              spriteComponent && (spriteComponent.allowDynamicAtlas = this.allowDynamicAtlas);
            }
            for (var _i3 = 0; _i3 < this._labelSegmentsCache.length; _i3++) {
              var _labelComponent3 = this._labelSegmentsCache[_i3].getComponent(cc.Label);
              _labelComponent3 && (_labelComponent3.allowDynamicAtlas = this.allowDynamicAtlas);
            }
          }
        },
        enableRetina: {
          type: RenderComponent.EnableType,
          default: RenderComponent.EnableType.GLOBAL,
          notify: function notify(oldValue) {
            if (this.enableRetina === oldValue) return;
            for (var i = 0; i < this._labelSegments.length; i++) {
              var labelComponent = this._labelSegments[i].getComponent(cc.Label);
              labelComponent && (labelComponent.enableRetina = this.enableRetina);
            }
            for (var _i4 = 0; _i4 < this._labelSegmentsCache.length; _i4++) {
              var _labelComponent4 = this._labelSegmentsCache[_i4].getComponent(cc.Label);
              _labelComponent4 && (_labelComponent4.enableRetina = this.enableRetina);
            }
          }
        }
      },
      statics: {
        HorizontalAlign: HorizontalAlign,
        VerticalAlign: VerticalAlign
      },
      onEnable: function onEnable() {
        this.handleTouchEvent && this._addEventListeners();
        this._onTTFLoaded();
        this._activateChildren(true);
      },
      onDisable: function onDisable() {
        this.handleTouchEvent && this._removeEventListeners();
        this._activateChildren(false);
      },
      _onColorChanged: function _onColorChanged(parentColor) {
        var children = this.node.children;
        children.forEach((function(childNode) {
          childNode.color = parentColor;
        }));
      },
      _addEventListeners: function _addEventListeners() {
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.on(cc.Node.EventType.COLOR_CHANGED, this._onColorChanged, this);
      },
      _removeEventListeners: function _removeEventListeners() {
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.off(cc.Node.EventType.COLOR_CHANGED, this._onColorChanged, this);
      },
      _updateLabelSegmentTextAttributes: function _updateLabelSegmentTextAttributes() {
        this._labelSegments.forEach(function(item) {
          this._applyTextAttribute(item, null, true);
        }.bind(this));
      },
      _createFontLabel: function _createFontLabel(string) {
        return pool.get(string, this);
      },
      _onTTFLoaded: function _onTTFLoaded() {
        if (this.font instanceof cc.TTFFont) if (this.font._nativeAsset) {
          this._layoutDirty = true;
          this._updateRichTextStatus();
        } else {
          var self = this;
          cc.assetManager.postLoadNative(this.font, (function(err) {
            self._layoutDirty = true;
            self._updateRichTextStatus();
          }));
        } else {
          this._layoutDirty = true;
          this._updateRichTextStatus();
        }
      },
      _measureText: function _measureText(styleIndex, string) {
        var self = this;
        var func = function func(string) {
          var label;
          if (0 === self._labelSegmentsCache.length) {
            label = self._createFontLabel(string);
            self._labelSegmentsCache.push(label);
          } else label = self._labelSegmentsCache[0];
          label._styleIndex = styleIndex;
          self._applyTextAttribute(label, string, true);
          var labelSize = label.getContentSize();
          return labelSize.width;
        };
        return string ? func(string) : func;
      },
      _onTouchEnded: function _onTouchEnded(event) {
        var _this = this;
        var components = this.node.getComponents(cc.Component);
        var _loop = function _loop(i) {
          var labelSegment = _this._labelSegments[i];
          var clickHandler = labelSegment._clickHandler;
          var clickParam = labelSegment._clickParam;
          if (clickHandler && _this._containsTouchLocation(labelSegment, event.touch.getLocation())) {
            components.forEach((function(component) {
              component.enabledInHierarchy && component[clickHandler] && component[clickHandler](event, clickParam);
            }));
            event.stopPropagation();
          }
        };
        for (var i = 0; i < this._labelSegments.length; ++i) _loop(i);
      },
      _containsTouchLocation: function _containsTouchLocation(label, point) {
        var myRect = label.getBoundingBoxToWorld();
        return myRect.contains(point);
      },
      _resetState: function _resetState() {
        var children = this.node.children;
        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];
          if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
            child.parent === this.node ? child.parent = null : children.splice(i, 1);
            child.name === RichTextChildName && pool.put(child);
          }
        }
        this._labelSegments.length = 0;
        this._labelSegmentsCache.length = 0;
        this._linesWidth.length = 0;
        this._lineOffsetX = 0;
        this._lineCount = 1;
        this._labelWidth = 0;
        this._labelHeight = 0;
        this._layoutDirty = true;
      },
      onRestore: false,
      _activateChildren: function _activateChildren(active) {
        for (var i = this.node.children.length - 1; i >= 0; i--) {
          var child = this.node.children[i];
          child.name !== RichTextChildName && child.name !== RichTextChildImageName || (child.active = active);
        }
      },
      _addLabelSegment: function _addLabelSegment(stringToken, styleIndex) {
        var labelSegment;
        labelSegment = 0 === this._labelSegmentsCache.length ? this._createFontLabel(stringToken) : this._labelSegmentsCache.pop();
        labelSegment._styleIndex = styleIndex;
        labelSegment._lineCount = this._lineCount;
        labelSegment.active = this.node.active;
        labelSegment.setAnchorPoint(0, 0);
        this._applyTextAttribute(labelSegment, stringToken, false);
        this.node.addChild(labelSegment);
        this._labelSegments.push(labelSegment);
        return labelSegment;
      },
      _updateRichTextWithMaxWidth: function _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
        var fragmentWidth = labelWidth;
        var labelSegment;
        if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this.maxWidth) {
          var checkStartIndex = 0;
          while (this._lineOffsetX <= this.maxWidth) {
            var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length);
            var checkString = labelString.substr(checkStartIndex, checkEndIndex);
            var checkStringWidth = this._measureText(styleIndex, checkString);
            if (!(this._lineOffsetX + checkStringWidth <= this.maxWidth)) {
              if (checkStartIndex > 0) {
                var remainingString = labelString.substr(0, checkStartIndex);
                this._addLabelSegment(remainingString, styleIndex);
                labelString = labelString.substr(checkStartIndex, labelString.length);
                fragmentWidth = this._measureText(styleIndex, labelString);
              }
              this._updateLineInfo();
              break;
            }
            this._lineOffsetX += checkStringWidth;
            checkStartIndex += checkEndIndex;
          }
        }
        if (fragmentWidth > this.maxWidth) {
          var fragments = textUtils.fragmentText(labelString, fragmentWidth, this.maxWidth, this._measureText(styleIndex));
          for (var k = 0; k < fragments.length; ++k) {
            var splitString = fragments[k];
            labelSegment = this._addLabelSegment(splitString, styleIndex);
            var labelSize = labelSegment.getContentSize();
            this._lineOffsetX += labelSize.width;
            fragments.length > 1 && k < fragments.length - 1 && this._updateLineInfo();
          }
        } else {
          this._lineOffsetX += fragmentWidth;
          this._addLabelSegment(labelString, styleIndex);
        }
      },
      _isLastComponentCR: function _isLastComponentCR(stringToken) {
        return stringToken.length - 1 === stringToken.lastIndexOf("\n");
      },
      _updateLineInfo: function _updateLineInfo() {
        this._linesWidth.push(this._lineOffsetX);
        this._lineOffsetX = 0;
        this._lineCount++;
      },
      _needsUpdateTextLayout: function _needsUpdateTextLayout(newTextArray) {
        if (this._layoutDirty || !this._textArray || !newTextArray) return true;
        if (this._textArray.length !== newTextArray.length) return true;
        for (var i = 0; i < this._textArray.length; ++i) {
          var oldItem = this._textArray[i];
          var newItem = newTextArray[i];
          if (oldItem.text !== newItem.text) return true;
          var oldStyle = oldItem.style, newStyle = newItem.style;
          if (oldStyle) {
            if (newStyle) {
              if (!oldStyle.outline !== !newStyle.outline) return true;
              if (oldStyle.size !== newStyle.size || !oldStyle.italic !== !newStyle.italic || oldStyle.isImage !== newStyle.isImage) return true;
              if (oldStyle.src !== newStyle.src || oldStyle.imageAlign !== newStyle.imageAlign || oldStyle.imageHeight !== newStyle.imageHeight || oldStyle.imageWidth !== newStyle.imageWidth || oldStyle.imageOffset !== newStyle.imageOffset) return true;
            } else if (oldStyle.size || oldStyle.italic || oldStyle.isImage || oldStyle.outline) return true;
          } else if (newStyle && (newStyle.size || newStyle.italic || newStyle.isImage || newStyle.outline)) return true;
        }
        return false;
      },
      _addRichTextImageElement: function _addRichTextImageElement(richTextElement) {
        var spriteFrameName = richTextElement.style.src;
        var spriteFrame = this.imageAtlas.getSpriteFrame(spriteFrameName);
        if (spriteFrame) {
          var spriteNode = new cc.PrivateNode(RichTextChildImageName);
          spriteNode._objFlags |= cc.Object.Flags.DontSave;
          var spriteComponent = spriteNode.addComponent(cc.Sprite);
          spriteComponent.autoSwitchMaterial = this.autoSwitchMaterial;
          spriteComponent.allowDynamicAtlas = this.allowDynamicAtlas;
          this.customMaterial && (0 === spriteComponent._materials.length ? spriteComponent._materials[0] = _materialVariant["default"].create(this.customMaterial, spriteComponent) : spriteComponent._materials[0].material !== this.customMaterial && spriteComponent.setMaterial(0, this.customMaterial));
          switch (richTextElement.style.imageAlign) {
           case "top":
            spriteNode.setAnchorPoint(0, 1);
            break;

           case "center":
            spriteNode.setAnchorPoint(0, .5);
            break;

           default:
            spriteNode.setAnchorPoint(0, 0);
          }
          richTextElement.style.imageOffset && (spriteNode._imageOffset = richTextElement.style.imageOffset);
          spriteComponent.type = cc.Sprite.Type.SLICED;
          spriteComponent.sizeMode = cc.Sprite.SizeMode.CUSTOM;
          this.node.addChild(spriteNode);
          this._labelSegments.push(spriteNode);
          var spriteRect = spriteFrame.getRect();
          var scaleFactor = 1;
          var spriteWidth = spriteRect.width;
          var spriteHeight = spriteRect.height;
          var expectWidth = richTextElement.style.imageWidth;
          var expectHeight = richTextElement.style.imageHeight;
          if (expectHeight > 0) {
            scaleFactor = expectHeight / spriteHeight;
            spriteWidth *= scaleFactor;
            spriteHeight *= scaleFactor;
          } else {
            scaleFactor = this.lineHeight / spriteHeight;
            spriteWidth *= scaleFactor;
            spriteHeight *= scaleFactor;
          }
          expectWidth > 0 && (spriteWidth = expectWidth);
          if (this.maxWidth > 0) {
            this._lineOffsetX + spriteWidth > this.maxWidth && this._updateLineInfo();
            this._lineOffsetX += spriteWidth;
          } else {
            this._lineOffsetX += spriteWidth;
            this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX);
          }
          spriteComponent.spriteFrame = spriteFrame;
          spriteNode.setContentSize(spriteWidth, spriteHeight);
          spriteNode._lineCount = this._lineCount;
          if (richTextElement.style.event) {
            richTextElement.style.event.click && (spriteNode._clickHandler = richTextElement.style.event.click);
            richTextElement.style.event.param ? spriteNode._clickParam = richTextElement.style.event.param : spriteNode._clickParam = "";
          } else spriteNode._clickHandler = null;
        } else cc.warnID(4400);
      },
      _updateRichText: function _updateRichText() {
        if (!this.enabledInHierarchy) return;
        var newTextArray = _htmlTextParser.parse(this.string);
        if (!this._needsUpdateTextLayout(newTextArray)) {
          this._textArray = newTextArray;
          this._updateLabelSegmentTextAttributes();
          return;
        }
        this._textArray = newTextArray;
        this._resetState();
        var lastEmptyLine = false;
        var label;
        var labelSize;
        for (var i = 0; i < this._textArray.length; ++i) {
          var richTextElement = this._textArray[i];
          var text = richTextElement.text;
          if ("" === text) {
            if (richTextElement.style && richTextElement.style.newline) {
              this._updateLineInfo();
              continue;
            }
            if (richTextElement.style && richTextElement.style.isImage && this.imageAtlas) {
              this._addRichTextImageElement(richTextElement);
              continue;
            }
          }
          var multilineTexts = text.split("\n");
          for (var j = 0; j < multilineTexts.length; ++j) {
            var labelString = multilineTexts[j];
            if ("" === labelString) {
              if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) continue;
              this._updateLineInfo();
              lastEmptyLine = true;
              continue;
            }
            lastEmptyLine = false;
            if (this.maxWidth > 0) {
              var labelWidth = this._measureText(i, labelString);
              this._updateRichTextWithMaxWidth(labelString, labelWidth, i);
              multilineTexts.length > 1 && j < multilineTexts.length - 1 && this._updateLineInfo();
            } else {
              label = this._addLabelSegment(labelString, i);
              labelSize = label.getContentSize();
              this._lineOffsetX += labelSize.width;
              this._lineOffsetX > this._labelWidth && (this._labelWidth = this._lineOffsetX);
              multilineTexts.length > 1 && j < multilineTexts.length - 1 && this._updateLineInfo();
            }
          }
        }
        lastEmptyLine || this._linesWidth.push(this._lineOffsetX);
        this.maxWidth > 0 && (this._labelWidth = this.maxWidth);
        this._labelHeight = (this._lineCount + textUtils.BASELINE_RATIO) * this.lineHeight;
        this.node.setContentSize(this._labelWidth, this._labelHeight);
        this._updateRichTextPosition();
        this._layoutDirty = false;
      },
      _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
        var character = text.charAt(startIndex);
        if (textUtils.isUnicodeCJK(character) || textUtils.isUnicodeSpace(character)) return 1;
        var len = 1;
        for (var index = startIndex + 1; index < textLen; ++index) {
          character = text.charAt(index);
          if (textUtils.isUnicodeSpace(character) || textUtils.isUnicodeCJK(character)) break;
          len++;
        }
        return len;
      },
      _updateRichTextPosition: function _updateRichTextPosition() {
        var nextTokenX = 0;
        var nextLineIndex = 1;
        var totalLineCount = this._lineCount;
        for (var i = 0; i < this._labelSegments.length; ++i) {
          var label = this._labelSegments[i];
          var lineCount = label._lineCount;
          if (lineCount > nextLineIndex) {
            nextTokenX = 0;
            nextLineIndex = lineCount;
          }
          var lineOffsetX = 0;
          switch (this.horizontalAlign) {
           case HorizontalAlign.LEFT:
            lineOffsetX = -this._labelWidth / 2;
            break;

           case HorizontalAlign.CENTER:
            lineOffsetX = -this._linesWidth[lineCount - 1] / 2;
            break;

           case HorizontalAlign.RIGHT:
            lineOffsetX = this._labelWidth / 2 - this._linesWidth[lineCount - 1];
          }
          label.x = nextTokenX + lineOffsetX;
          var labelSize = label.getContentSize();
          label.y = this.lineHeight * (totalLineCount - lineCount) - this._labelHeight / 2;
          lineCount === nextLineIndex && (nextTokenX += labelSize.width);
          var sprite = label.getComponent(cc.Sprite);
          if (sprite) {
            var lineHeightSet = this.lineHeight;
            var lineHeightReal = this.lineHeight * (1 + textUtils.BASELINE_RATIO);
            switch (label.anchorY) {
             case 1:
              label.y += lineHeightSet + (lineHeightReal - lineHeightSet) / 2;
              break;

             case .5:
              label.y += lineHeightReal / 2;
              break;

             default:
              label.y += (lineHeightReal - lineHeightSet) / 2;
            }
            if (label._imageOffset) {
              var offsets = label._imageOffset.split(",");
              if (1 === offsets.length && offsets[0]) {
                var offsetY = parseFloat(offsets[0]);
                Number.isInteger(offsetY) && (label.y += offsetY);
              } else if (2 === offsets.length) {
                var offsetX = parseFloat(offsets[0]);
                var _offsetY = parseFloat(offsets[1]);
                Number.isInteger(offsetX) && (label.x += offsetX);
                Number.isInteger(_offsetY) && (label.y += _offsetY);
              }
            }
          }
          var outline = label.getComponent(cc.LabelOutline);
          outline && outline.width && (label.y = label.y - outline.width);
        }
      },
      _convertLiteralColorValue: function _convertLiteralColorValue(color) {
        var colorValue = color.toUpperCase();
        if (cc.Color[colorValue]) return cc.Color[colorValue];
        var out = cc.color();
        return out.fromHEX(color);
      },
      _applyTextAttribute: function _applyTextAttribute(labelNode, string, force) {
        var labelComponent = labelNode.getComponent(cc.Label);
        if (!labelComponent) return;
        var index = labelNode._styleIndex;
        var textStyle = null;
        this._textArray[index] && (textStyle = this._textArray[index].style);
        textStyle && textStyle.color ? labelNode.color = this._convertLiteralColorValue(textStyle.color) : labelNode.color = this.node.color;
        labelComponent.cacheMode = this.cacheMode;
        labelComponent.autoSwitchMaterial = this.autoSwitchMaterial;
        labelComponent.allowDynamicAtlas = this.allowDynamicAtlas;
        labelComponent.enableRetina = this.enableRetina;
        this.customMaterial && (0 === labelComponent._materials.length ? labelComponent._materials[0] = _materialVariant["default"].create(this.customMaterial, labelComponent) : labelComponent._materials[0].material !== this.customMaterial && labelComponent.setMaterial(0, this.customMaterial));
        var isAsset = this.font instanceof cc.Font;
        isAsset && !this._isSystemFontUsed ? labelComponent.font = this.font : labelComponent.fontFamily = this.fontFamily;
        labelComponent.useSystemFont = this._isSystemFontUsed;
        labelComponent.lineHeight = this.lineHeight;
        labelComponent.enableBold = textStyle && textStyle.bold;
        labelComponent.enableItalics = textStyle && textStyle.italic;
        textStyle && textStyle.italic && (labelNode.skewX = 12);
        labelComponent.enableUnderline = textStyle && textStyle.underline;
        if (textStyle && textStyle.outline) {
          var labelOutlineComponent = labelNode.getComponent(cc.LabelOutline);
          labelOutlineComponent || (labelOutlineComponent = labelNode.addComponent(cc.LabelOutline));
          labelOutlineComponent.color = this._convertLiteralColorValue(textStyle.outline.color);
          labelOutlineComponent.width = textStyle.outline.width;
        }
        textStyle && textStyle.size ? labelComponent.fontSize = textStyle.size : labelComponent.fontSize = this.fontSize;
        if (null !== string) {
          "string" !== typeof string && (string = "" + string);
          labelComponent.string = string;
        }
        force && labelComponent._forceUpdateRenderData();
        if (textStyle && textStyle.event) {
          textStyle.event.click && (labelNode._clickHandler = textStyle.event.click);
          textStyle.event.param ? labelNode._clickParam = textStyle.event.param : labelNode._clickParam = "";
        } else labelNode._clickHandler = null;
      },
      onDestroy: function onDestroy() {
        for (var i = 0; i < this._labelSegments.length; ++i) {
          this._labelSegments[i].removeFromParent();
          pool.put(this._labelSegments[i]);
        }
      }
    });
    cc.RichText = module.exports = RichText;
  }), {
    "../assets/material/material-variant": 163,
    "../platform/CCMacro": 277,
    "../platform/js": 294,
    "../utils/html-text-parser": 384,
    "../utils/text-utils": 393,
    "./CCRenderComponent": 192
  } ],
  194: [ (function(require, module, exports) {
    "use strict";
    var Widget = require("./CCWidget");
    var WidgetManager = require("../base-ui/CCWidgetManager");
    var SafeArea = cc.Class({
      name: "cc.SafeArea",
      extends: require("./CCComponent"),
      editor: false,
      onEnable: function onEnable() {
        this.updateArea();
        cc.view.on("canvas-resize", this.updateArea, this);
      },
      onDisable: function onDisable() {
        cc.view.off("canvas-resize", this.updateArea, this);
      },
      updateArea: function updateArea() {
        var widget = this.node.getComponent(Widget);
        if (!widget) return;
        false;
        widget.updateAlignment();
        var lastPos = this.node.position;
        var lastAnchorPoint = this.node.getAnchorPoint();
        widget.isAlignTop = widget.isAlignBottom = widget.isAlignLeft = widget.isAlignRight = true;
        var screenWidth = cc.winSize.width, screenHeight = cc.winSize.height;
        var safeArea = cc.sys.getSafeAreaRect();
        widget.top = screenHeight - safeArea.y - safeArea.height;
        widget.bottom = safeArea.y;
        widget.left = safeArea.x;
        widget.right = screenWidth - safeArea.x - safeArea.width;
        widget.updateAlignment();
        var curPos = this.node.position;
        var anchorX = lastAnchorPoint.x - (curPos.x - lastPos.x) / this.node.width;
        var anchorY = lastAnchorPoint.y - (curPos.y - lastPos.y) / this.node.height;
        this.node.setAnchorPoint(anchorX, anchorY);
        WidgetManager.add(widget);
      }
    });
    cc.SafeArea = module.exports = SafeArea;
  }), {
    "../base-ui/CCWidgetManager": 165,
    "./CCComponent": 181,
    "./CCWidget": 204
  } ],
  195: [ (function(require, module, exports) {
    "use strict";
    var misc = require("../utils/misc");
    var Component = require("./CCComponent");
    var GETTINGSHORTERFACTOR = 20;
    var Direction = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1
    });
    var Scrollbar = cc.Class({
      name: "cc.Scrollbar",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        _scrollView: null,
        _touching: false,
        _autoHideRemainingTime: {
          default: 0,
          serializable: false
        },
        _opacity: 255,
        handle: {
          default: null,
          type: cc.Sprite,
          tooltip: (true, "i18n:COMPONENT.scrollbar.handle"),
          notify: function notify() {
            this._onScroll(cc.v2(0, 0));
          },
          animatable: false
        },
        direction: {
          default: Direction.HORIZONTAL,
          type: Direction,
          tooltip: (true, "i18n:COMPONENT.scrollbar.direction"),
          notify: function notify() {
            this._onScroll(cc.v2(0, 0));
          },
          animatable: false
        },
        enableAutoHide: {
          default: true,
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.scrollbar.auto_hide")
        },
        autoHideTime: {
          default: 1,
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.scrollbar.auto_hide_time")
        }
      },
      statics: {
        Direction: Direction
      },
      setTargetScrollView: function setTargetScrollView(scrollView) {
        this._scrollView = scrollView;
      },
      _convertToScrollViewSpace: function _convertToScrollViewSpace(content) {
        var scrollViewNode = this._scrollView.node;
        var worldSpacePos = content.convertToWorldSpaceAR(cc.v2(-content.anchorX * content.width, -content.anchorY * content.height));
        var scrollViewSpacePos = scrollViewNode.convertToNodeSpaceAR(worldSpacePos);
        scrollViewSpacePos.x += scrollViewNode.anchorX * scrollViewNode.width;
        scrollViewSpacePos.y += scrollViewNode.anchorY * scrollViewNode.height;
        return scrollViewSpacePos;
      },
      _setOpacity: function _setOpacity(opacity) {
        if (this.handle) {
          this.node.opacity = opacity;
          this.handle.node.opacity = opacity;
        }
      },
      _onScroll: function _onScroll(outOfBoundary) {
        if (this._scrollView) {
          var content = this._scrollView.content;
          if (content) {
            var contentSize = content.getContentSize();
            var scrollViewSize = this._scrollView.node.getContentSize();
            var handleNodeSize = this.node.getContentSize();
            if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) return;
            if (this.enableAutoHide) {
              this._autoHideRemainingTime = this.autoHideTime;
              this._setOpacity(this._opacity);
            }
            var contentMeasure = 0;
            var scrollViewMeasure = 0;
            var outOfBoundaryValue = 0;
            var contentPosition = 0;
            var handleNodeMeasure = 0;
            if (this.direction === Direction.HORIZONTAL) {
              contentMeasure = contentSize.width;
              scrollViewMeasure = scrollViewSize.width;
              handleNodeMeasure = handleNodeSize.width;
              outOfBoundaryValue = outOfBoundary.x;
              contentPosition = -this._convertToScrollViewSpace(content).x;
            } else if (this.direction === Direction.VERTICAL) {
              contentMeasure = contentSize.height;
              scrollViewMeasure = scrollViewSize.height;
              handleNodeMeasure = handleNodeSize.height;
              outOfBoundaryValue = outOfBoundary.y;
              contentPosition = -this._convertToScrollViewSpace(content).y;
            }
            var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue);
            var position = this._calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);
            this._updateLength(length);
            this._updateHanlderPosition(position);
          }
        }
      },
      _updateHanlderPosition: function _updateHanlderPosition(position) {
        if (this.handle) {
          var oldPosition = this._fixupHandlerPosition();
          this.handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y);
        }
      },
      _fixupHandlerPosition: function _fixupHandlerPosition() {
        var barSize = this.node.getContentSize();
        var barAnchor = this.node.getAnchorPoint();
        var handleSize = this.handle.node.getContentSize();
        var handleParent = this.handle.node.parent;
        var leftBottomWorldPosition = this.node.convertToWorldSpaceAR(cc.v2(-barSize.width * barAnchor.x, -barSize.height * barAnchor.y));
        var fixupPosition = handleParent.convertToNodeSpaceAR(leftBottomWorldPosition);
        this.direction === Direction.HORIZONTAL ? fixupPosition = cc.v2(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2) : this.direction === Direction.VERTICAL && (fixupPosition = cc.v2(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y));
        this.handle.node.setPosition(fixupPosition);
        return fixupPosition;
      },
      _onTouchBegan: function _onTouchBegan() {
        if (!this.enableAutoHide) return;
        this._touching = true;
      },
      _conditionalDisableScrollBar: function _conditionalDisableScrollBar(contentSize, scrollViewSize) {
        if (contentSize.width <= scrollViewSize.width && this.direction === Direction.HORIZONTAL) return true;
        if (contentSize.height <= scrollViewSize.height && this.direction === Direction.VERTICAL) return true;
        return false;
      },
      _onTouchEnded: function _onTouchEnded() {
        if (!this.enableAutoHide) return;
        this._touching = false;
        if (this.autoHideTime <= 0) return;
        if (this._scrollView) {
          var content = this._scrollView.content;
          if (content) {
            var contentSize = content.getContentSize();
            var scrollViewSize = this._scrollView.node.getContentSize();
            if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) return;
          }
        }
        this._autoHideRemainingTime = this.autoHideTime;
      },
      _calculateLength: function _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
        var denominatorValue = contentMeasure;
        outOfBoundary && (denominatorValue += (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary) * GETTINGSHORTERFACTOR);
        var lengthRation = scrollViewMeasure / denominatorValue;
        return handleNodeMeasure * lengthRation;
      },
      _calculatePosition: function _calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
        var denominatorValue = contentMeasure - scrollViewMeasure;
        outOfBoundary && (denominatorValue += Math.abs(outOfBoundary));
        var positionRatio = 0;
        if (denominatorValue) {
          positionRatio = contentPosition / denominatorValue;
          positionRatio = misc.clamp01(positionRatio);
        }
        var position = (handleNodeMeasure - actualLenth) * positionRatio;
        return this.direction === Direction.VERTICAL ? cc.v2(0, position) : cc.v2(position, 0);
      },
      _updateLength: function _updateLength(length) {
        if (this.handle) {
          var handleNode = this.handle.node;
          var handleNodeSize = handleNode.getContentSize();
          handleNode.setAnchorPoint(cc.v2(0, 0));
          this.direction === Direction.HORIZONTAL ? handleNode.setContentSize(length, handleNodeSize.height) : handleNode.setContentSize(handleNodeSize.width, length);
        }
      },
      _processAutoHide: function _processAutoHide(deltaTime) {
        if (!this.enableAutoHide || this._autoHideRemainingTime <= 0) return;
        if (this._touching) return;
        this._autoHideRemainingTime -= deltaTime;
        if (this._autoHideRemainingTime <= this.autoHideTime) {
          this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
          var opacity = this._opacity * (this._autoHideRemainingTime / this.autoHideTime);
          this._setOpacity(opacity);
        }
      },
      start: function start() {
        this.enableAutoHide && this._setOpacity(0);
      },
      hide: function hide() {
        this._autoHideRemainingTime = 0;
        this._setOpacity(0);
      },
      show: function show() {
        this._autoHideRemainingTime = this.autoHideTime;
        this._setOpacity(this._opacity);
      },
      update: function update(dt) {
        this._processAutoHide(dt);
      }
    });
    cc.Scrollbar = module.exports = Scrollbar;
  }), {
    "../utils/misc": 386,
    "./CCComponent": 181
  } ],
  196: [ (function(require, module, exports) {
    "use strict";
    var NodeEvent = require("../CCNode").EventType;
    var NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
    var OUT_OF_BOUNDARY_BREAKING_FACTOR = .05;
    var EPSILON = 1e-4;
    var MOVEMENT_FACTOR = .7;
    var _tempPoint = cc.v2();
    var _tempPrevPoint = cc.v2();
    var quintEaseOut = function quintEaseOut(time) {
      time -= 1;
      return time * time * time * time * time + 1;
    };
    var getTimeInMilliseconds = function getTimeInMilliseconds() {
      var currentTime = new Date();
      return currentTime.getMilliseconds();
    };
    var EventType = cc.Enum({
      SCROLL_TO_TOP: 0,
      SCROLL_TO_BOTTOM: 1,
      SCROLL_TO_LEFT: 2,
      SCROLL_TO_RIGHT: 3,
      SCROLLING: 4,
      BOUNCE_TOP: 5,
      BOUNCE_BOTTOM: 6,
      BOUNCE_LEFT: 7,
      BOUNCE_RIGHT: 8,
      SCROLL_ENDED: 9,
      TOUCH_UP: 10,
      AUTOSCROLL_ENDED_WITH_THRESHOLD: 11,
      SCROLL_BEGAN: 12
    });
    var eventMap = {
      "scroll-to-top": EventType.SCROLL_TO_TOP,
      "scroll-to-bottom": EventType.SCROLL_TO_BOTTOM,
      "scroll-to-left": EventType.SCROLL_TO_LEFT,
      "scroll-to-right": EventType.SCROLL_TO_RIGHT,
      scrolling: EventType.SCROLLING,
      "bounce-bottom": EventType.BOUNCE_BOTTOM,
      "bounce-left": EventType.BOUNCE_LEFT,
      "bounce-right": EventType.BOUNCE_RIGHT,
      "bounce-top": EventType.BOUNCE_TOP,
      "scroll-ended": EventType.SCROLL_ENDED,
      "touch-up": EventType.TOUCH_UP,
      "scroll-ended-with-threshold": EventType.AUTOSCROLL_ENDED_WITH_THRESHOLD,
      "scroll-began": EventType.SCROLL_BEGAN
    };
    var ScrollView = cc.Class({
      name: "cc.ScrollView",
      extends: require("./CCViewGroup"),
      editor: false,
      ctor: function ctor() {
        this._topBoundary = 0;
        this._bottomBoundary = 0;
        this._leftBoundary = 0;
        this._rightBoundary = 0;
        this._touchMoveDisplacements = [];
        this._touchMoveTimeDeltas = [];
        this._touchMovePreviousTimestamp = 0;
        this._touchMoved = false;
        this._autoScrolling = false;
        this._autoScrollAttenuate = false;
        this._autoScrollStartPosition = cc.v2(0, 0);
        this._autoScrollTargetDelta = cc.v2(0, 0);
        this._autoScrollTotalTime = 0;
        this._autoScrollAccumulatedTime = 0;
        this._autoScrollCurrentlyOutOfBoundary = false;
        this._autoScrollBraking = false;
        this._autoScrollBrakingStartPosition = cc.v2(0, 0);
        this._outOfBoundaryAmount = cc.v2(0, 0);
        this._outOfBoundaryAmountDirty = true;
        this._stopMouseWheel = false;
        this._mouseWheelEventElapsedTime = 0;
        this._isScrollEndedWithThresholdEventFired = false;
        this._scrollEventEmitMask = 0;
        this._isBouncing = false;
        this._scrolling = false;
      },
      properties: {
        content: {
          default: void 0,
          type: cc.Node,
          tooltip: (true, "i18n:COMPONENT.scrollview.content"),
          formerlySerializedAs: "content",
          notify: function notify(oldValue) {
            this._calculateBoundary();
          }
        },
        horizontal: {
          default: true,
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.scrollview.horizontal")
        },
        vertical: {
          default: true,
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.scrollview.vertical")
        },
        inertia: {
          default: true,
          tooltip: (true, "i18n:COMPONENT.scrollview.inertia")
        },
        brake: {
          default: .5,
          type: cc.Float,
          range: [ 0, 1, .1 ],
          tooltip: (true, "i18n:COMPONENT.scrollview.brake")
        },
        elastic: {
          default: true,
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.scrollview.elastic")
        },
        bounceDuration: {
          default: 1,
          range: [ 0, 10 ],
          tooltip: (true, "i18n:COMPONENT.scrollview.bounceDuration")
        },
        horizontalScrollBar: {
          default: void 0,
          type: cc.Scrollbar,
          tooltip: (true, "i18n:COMPONENT.scrollview.horizontal_bar"),
          notify: function notify() {
            if (this.horizontalScrollBar) {
              this.horizontalScrollBar.setTargetScrollView(this);
              this._updateScrollBar(0);
            }
          },
          animatable: false
        },
        verticalScrollBar: {
          default: void 0,
          type: cc.Scrollbar,
          tooltip: (true, "i18n:COMPONENT.scrollview.vertical_bar"),
          notify: function notify() {
            if (this.verticalScrollBar) {
              this.verticalScrollBar.setTargetScrollView(this);
              this._updateScrollBar(0);
            }
          },
          animatable: false
        },
        scrollEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: (true, "i18n:COMPONENT.scrollview.scrollEvents")
        },
        cancelInnerEvents: {
          default: true,
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.scrollview.cancelInnerEvents")
        },
        _view: {
          get: function get() {
            if (this.content) return this.content.parent;
          }
        }
      },
      statics: {
        EventType: EventType
      },
      scrollToBottom: function scrollToBottom(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 0),
          applyToHorizontal: false,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta, true);
      },
      scrollToTop: function scrollToTop(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 1),
          applyToHorizontal: false,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToLeft: function scrollToLeft(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 0),
          applyToHorizontal: true,
          applyToVertical: false
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToRight: function scrollToRight(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(1, 0),
          applyToHorizontal: true,
          applyToVertical: false
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToTopLeft: function scrollToTopLeft(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 1),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToTopRight: function scrollToTopRight(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(1, 1),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToBottomLeft: function scrollToBottomLeft(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, 0),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToBottomRight: function scrollToBottomRight(timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(1, 0),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToOffset: function scrollToOffset(offset, timeInSecond, attenuated) {
        var maxScrollOffset = this.getMaxScrollOffset();
        var anchor = cc.v2(0, 0);
        0 === maxScrollOffset.x ? anchor.x = 0 : anchor.x = offset.x / maxScrollOffset.x;
        0 === maxScrollOffset.y ? anchor.y = 1 : anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y;
        this.scrollTo(anchor, timeInSecond, attenuated);
      },
      getScrollOffset: function getScrollOffset() {
        var topDelta = this._getContentTopBoundary() - this._topBoundary;
        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
        return cc.v2(leftDeta, topDelta);
      },
      getMaxScrollOffset: function getMaxScrollOffset() {
        var viewSize = this._view.getContentSize();
        var contentSize = this.content.getContentSize();
        var horizontalMaximizeOffset = contentSize.width - viewSize.width;
        var verticalMaximizeOffset = contentSize.height - viewSize.height;
        horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0;
        verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0;
        return cc.v2(horizontalMaximizeOffset, verticalMaximizeOffset);
      },
      scrollToPercentHorizontal: function scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(percent, 0),
          applyToHorizontal: true,
          applyToVertical: false
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollTo: function scrollTo(anchor, timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(anchor),
          applyToHorizontal: true,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      scrollToPercentVertical: function scrollToPercentVertical(percent, timeInSecond, attenuated) {
        var moveDelta = this._calculateMovePercentDelta({
          anchor: cc.v2(0, percent),
          applyToHorizontal: false,
          applyToVertical: true
        });
        timeInSecond ? this._startAutoScroll(moveDelta, timeInSecond, false !== attenuated) : this._moveContent(moveDelta);
      },
      stopAutoScroll: function stopAutoScroll() {
        this._autoScrolling = false;
        this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
      },
      setContentPosition: function setContentPosition(position) {
        if (position.fuzzyEquals(this.getContentPosition(), EPSILON)) return;
        this.content.setPosition(position);
        this._outOfBoundaryAmountDirty = true;
      },
      getContentPosition: function getContentPosition() {
        return this.content.getPosition();
      },
      isScrolling: function isScrolling() {
        return this._scrolling;
      },
      isAutoScrolling: function isAutoScrolling() {
        return this._autoScrolling;
      },
      _registerEvent: function _registerEvent() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this, true);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, true);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this, true);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
        this.node.on(cc.Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
      },
      _unregisterEvent: function _unregisterEvent() {
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this, true);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, true);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this, true);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
        this.node.off(cc.Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
      },
      _onMouseWheel: function _onMouseWheel(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this.hasNestedViewGroup(event, captureListeners)) return;
        var deltaMove = cc.v2(0, 0);
        var wheelPrecision = -.1;
        cc.sys.os === cc.sys.OS_WINDOWS && cc.sys.browserType === cc.sys.BROWSER_TYPE_FIREFOX && (wheelPrecision = -.1 / 3);
        true;
        wheelPrecision = -7;
        this.vertical ? deltaMove = cc.v2(0, event.getScrollY() * wheelPrecision) : this.horizontal && (deltaMove = cc.v2(event.getScrollY() * wheelPrecision, 0));
        this._mouseWheelEventElapsedTime = 0;
        this._processDeltaMove(deltaMove);
        if (!this._stopMouseWheel) {
          this._handlePressLogic();
          this.schedule(this._checkMouseWheel, 1 / 60);
          this._stopMouseWheel = true;
        }
        this._stopPropagationIfTargetIsMe(event);
      },
      _checkMouseWheel: function _checkMouseWheel(dt) {
        var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
        var maxElapsedTime = .1;
        if (!currentOutOfBoundary.fuzzyEquals(cc.v2(0, 0), EPSILON)) {
          this._processInertiaScroll();
          this.unschedule(this._checkMouseWheel);
          this._dispatchEvent("scroll-ended");
          this._stopMouseWheel = false;
          return;
        }
        this._mouseWheelEventElapsedTime += dt;
        if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
          this._onScrollBarTouchEnded();
          this.unschedule(this._checkMouseWheel);
          this._dispatchEvent("scroll-ended");
          this._stopMouseWheel = false;
        }
      },
      _calculateMovePercentDelta: function _calculateMovePercentDelta(options) {
        var anchor = options.anchor;
        var applyToHorizontal = options.applyToHorizontal;
        var applyToVertical = options.applyToVertical;
        this._calculateBoundary();
        anchor = anchor.clampf(cc.v2(0, 0), cc.v2(1, 1));
        var scrollSize = this._view.getContentSize();
        var contentSize = this.content.getContentSize();
        var bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
        bottomDeta = -bottomDeta;
        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
        leftDeta = -leftDeta;
        var moveDelta = cc.v2(0, 0);
        var totalScrollDelta = 0;
        if (applyToHorizontal) {
          totalScrollDelta = contentSize.width - scrollSize.width;
          moveDelta.x = leftDeta - totalScrollDelta * anchor.x;
        }
        if (applyToVertical) {
          totalScrollDelta = contentSize.height - scrollSize.height;
          moveDelta.y = bottomDeta - totalScrollDelta * anchor.y;
        }
        return moveDelta;
      },
      _moveContentToTopLeft: function _moveContentToTopLeft(scrollViewSize) {
        var contentSize = this.content.getContentSize();
        var bottomDeta = this._getContentBottomBoundary() - this._bottomBoundary;
        bottomDeta = -bottomDeta;
        var moveDelta = cc.v2(0, 0);
        var totalScrollDelta = 0;
        var leftDeta = this._getContentLeftBoundary() - this._leftBoundary;
        leftDeta = -leftDeta;
        if (contentSize.height < scrollViewSize.height) {
          totalScrollDelta = contentSize.height - scrollViewSize.height;
          moveDelta.y = bottomDeta - totalScrollDelta;
        }
        if (contentSize.width < scrollViewSize.width) {
          totalScrollDelta = contentSize.width - scrollViewSize.width;
          moveDelta.x = leftDeta;
        }
        this._updateScrollBarState();
        this._moveContent(moveDelta);
        this._adjustContentOutOfBoundary();
      },
      _calculateBoundary: function _calculateBoundary() {
        if (this.content) {
          var layout = this.content.getComponent(cc.Layout);
          layout && layout.enabledInHierarchy && layout.updateLayout();
          var viewSize = this._view.getContentSize();
          var anchorX = viewSize.width * this._view.anchorX;
          var anchorY = viewSize.height * this._view.anchorY;
          this._leftBoundary = -anchorX;
          this._bottomBoundary = -anchorY;
          this._rightBoundary = this._leftBoundary + viewSize.width;
          this._topBoundary = this._bottomBoundary + viewSize.height;
          this._moveContentToTopLeft(viewSize);
        }
      },
      hasNestedViewGroup: function hasNestedViewGroup(event, captureListeners) {
        if (event.eventPhase !== cc.Event.CAPTURING_PHASE) return;
        if (captureListeners) for (var i = 0; i < captureListeners.length; ++i) {
          var item = captureListeners[i];
          if (this.node === item) {
            if (event.target.getComponent(cc.ViewGroup)) return true;
            return false;
          }
          if (item.getComponent(cc.ViewGroup)) return true;
        }
        return false;
      },
      _stopPropagationIfTargetIsMe: function _stopPropagationIfTargetIsMe(event) {
        event.eventPhase === cc.Event.AT_TARGET && event.target === this.node && event.stopPropagation();
      },
      _onTouchBegan: function _onTouchBegan(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this.hasNestedViewGroup(event, captureListeners)) return;
        var touch = event.touch;
        this.content && this._handlePressLogic(touch);
        this._touchMoved = false;
        this._stopPropagationIfTargetIsMe(event);
      },
      _onTouchMoved: function _onTouchMoved(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this.hasNestedViewGroup(event, captureListeners)) return;
        var touch = event.touch;
        this.content && this._handleMoveLogic(touch);
        if (!this.cancelInnerEvents) return;
        var deltaMove = touch.getLocation().sub(touch.getStartLocation());
        if (deltaMove.mag() > 7 && !this._touchMoved && event.target !== this.node) {
          var cancelEvent = new cc.Event.EventTouch(event.getTouches(), event.bubbles);
          cancelEvent.type = cc.Node.EventType.TOUCH_CANCEL;
          cancelEvent.touch = event.touch;
          cancelEvent.simulate = true;
          event.target.dispatchEvent(cancelEvent);
          this._touchMoved = true;
        }
        this._stopPropagationIfTargetIsMe(event);
      },
      _onTouchEnded: function _onTouchEnded(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this.hasNestedViewGroup(event, captureListeners)) return;
        this._dispatchEvent("touch-up");
        var touch = event.touch;
        this.content && this._handleReleaseLogic(touch);
        this._touchMoved ? event.stopPropagation() : this._stopPropagationIfTargetIsMe(event);
      },
      _onTouchCancelled: function _onTouchCancelled(event, captureListeners) {
        if (!this.enabledInHierarchy) return;
        if (this.hasNestedViewGroup(event, captureListeners)) return;
        if (!event.simulate) {
          var touch = event.touch;
          this.content && this._handleReleaseLogic(touch);
        }
        this._stopPropagationIfTargetIsMe(event);
      },
      _processDeltaMove: function _processDeltaMove(deltaMove) {
        this._scrollChildren(deltaMove);
        this._gatherTouchMove(deltaMove);
      },
      _getLocalAxisAlignDelta: function _getLocalAxisAlignDelta(touch) {
        this.node.convertToNodeSpaceAR(touch.getLocation(), _tempPoint);
        this.node.convertToNodeSpaceAR(touch.getPreviousLocation(), _tempPrevPoint);
        return _tempPoint.sub(_tempPrevPoint);
      },
      _handleMoveLogic: function _handleMoveLogic(touch) {
        var deltaMove = this._getLocalAxisAlignDelta(touch);
        this._processDeltaMove(deltaMove);
      },
      _scrollChildren: function _scrollChildren(deltaMove) {
        deltaMove = this._clampDelta(deltaMove);
        var realMove = deltaMove;
        var outOfBoundary;
        if (this.elastic) {
          outOfBoundary = this._getHowMuchOutOfBoundary();
          realMove.x *= 0 === outOfBoundary.x ? 1 : .5;
          realMove.y *= 0 === outOfBoundary.y ? 1 : .5;
        }
        if (!this.elastic) {
          outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
          realMove = realMove.add(outOfBoundary);
        }
        var vertical_scrollEventType = "";
        var horizontal_scrollEventType = "";
        if (this.vertical) if (realMove.y > 0) {
          var icBottomPos = this.content.y - this.content.anchorY * this.content.height;
          icBottomPos + realMove.y >= this._bottomBoundary && (vertical_scrollEventType = "scroll-to-bottom");
        } else if (realMove.y < 0) {
          var icTopPos = this.content.y - this.content.anchorY * this.content.height + this.content.height;
          icTopPos + realMove.y <= this._topBoundary && (vertical_scrollEventType = "scroll-to-top");
        }
        if (this.horizontal) if (realMove.x < 0) {
          var icRightPos = this.content.x - this.content.anchorX * this.content.width + this.content.width;
          icRightPos + realMove.x <= this._rightBoundary && (horizontal_scrollEventType = "scroll-to-right");
        } else if (realMove.x > 0) {
          var icLeftPos = this.content.x - this.content.anchorX * this.content.width;
          icLeftPos + realMove.x >= this._leftBoundary && (horizontal_scrollEventType = "scroll-to-left");
        }
        this._moveContent(realMove, false);
        if (this.horizontal && 0 !== realMove.x || this.vertical && 0 !== realMove.y) {
          if (!this._scrolling) {
            this._scrolling = true;
            this._dispatchEvent("scroll-began");
          }
          this._dispatchEvent("scrolling");
        }
        "" !== vertical_scrollEventType && this._dispatchEvent(vertical_scrollEventType);
        "" !== horizontal_scrollEventType && this._dispatchEvent(horizontal_scrollEventType);
      },
      _handlePressLogic: function _handlePressLogic() {
        this._autoScrolling && this._dispatchEvent("scroll-ended");
        this._autoScrolling = false;
        this._isBouncing = false;
        this._touchMovePreviousTimestamp = getTimeInMilliseconds();
        this._touchMoveDisplacements.length = 0;
        this._touchMoveTimeDeltas.length = 0;
        this._onScrollBarTouchBegan();
      },
      _clampDelta: function _clampDelta(delta) {
        var contentSize = this.content.getContentSize();
        var scrollViewSize = this._view.getContentSize();
        contentSize.width < scrollViewSize.width && (delta.x = 0);
        contentSize.height < scrollViewSize.height && (delta.y = 0);
        return delta;
      },
      _gatherTouchMove: function _gatherTouchMove(delta) {
        delta = this._clampDelta(delta);
        while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
          this._touchMoveDisplacements.shift();
          this._touchMoveTimeDeltas.shift();
        }
        this._touchMoveDisplacements.push(delta);
        var timeStamp = getTimeInMilliseconds();
        this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1e3);
        this._touchMovePreviousTimestamp = timeStamp;
      },
      _startBounceBackIfNeeded: function _startBounceBackIfNeeded() {
        if (!this.elastic) return false;
        var bounceBackAmount = this._getHowMuchOutOfBoundary();
        bounceBackAmount = this._clampDelta(bounceBackAmount);
        if (bounceBackAmount.fuzzyEquals(cc.v2(0, 0), EPSILON)) return false;
        var bounceBackTime = Math.max(this.bounceDuration, 0);
        this._startAutoScroll(bounceBackAmount, bounceBackTime, true);
        if (!this._isBouncing) {
          bounceBackAmount.y > 0 && this._dispatchEvent("bounce-top");
          bounceBackAmount.y < 0 && this._dispatchEvent("bounce-bottom");
          bounceBackAmount.x > 0 && this._dispatchEvent("bounce-right");
          bounceBackAmount.x < 0 && this._dispatchEvent("bounce-left");
          this._isBouncing = true;
        }
        return true;
      },
      _processInertiaScroll: function _processInertiaScroll() {
        var bounceBackStarted = this._startBounceBackIfNeeded();
        if (!bounceBackStarted && this.inertia) {
          var touchMoveVelocity = this._calculateTouchMoveVelocity();
          !touchMoveVelocity.fuzzyEquals(cc.v2(0, 0), EPSILON) && this.brake < 1 && this._startInertiaScroll(touchMoveVelocity);
        }
        this._onScrollBarTouchEnded();
      },
      _handleReleaseLogic: function _handleReleaseLogic(touch) {
        var delta = this._getLocalAxisAlignDelta(touch);
        this._gatherTouchMove(delta);
        this._processInertiaScroll();
        if (this._scrolling) {
          this._scrolling = false;
          this._autoScrolling || this._dispatchEvent("scroll-ended");
        }
      },
      _isOutOfBoundary: function _isOutOfBoundary() {
        var outOfBoundary = this._getHowMuchOutOfBoundary();
        return !outOfBoundary.fuzzyEquals(cc.v2(0, 0), EPSILON);
      },
      _isNecessaryAutoScrollBrake: function _isNecessaryAutoScrollBrake() {
        if (this._autoScrollBraking) return true;
        if (this._isOutOfBoundary()) {
          if (!this._autoScrollCurrentlyOutOfBoundary) {
            this._autoScrollCurrentlyOutOfBoundary = true;
            this._autoScrollBraking = true;
            this._autoScrollBrakingStartPosition = this.getContentPosition();
            return true;
          }
        } else this._autoScrollCurrentlyOutOfBoundary = false;
        return false;
      },
      getScrollEndedEventTiming: function getScrollEndedEventTiming() {
        return EPSILON;
      },
      _processAutoScrolling: function _processAutoScrolling(dt) {
        var isAutoScrollBrake = this._isNecessaryAutoScrollBrake();
        var brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
        this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
        var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);
        this._autoScrollAttenuate && (percentage = quintEaseOut(percentage));
        var newPosition = this._autoScrollStartPosition.add(this._autoScrollTargetDelta.mul(percentage));
        var reachedEnd = Math.abs(percentage - 1) <= EPSILON;
        var fireEvent = Math.abs(percentage - 1) <= this.getScrollEndedEventTiming();
        if (fireEvent && !this._isScrollEndedWithThresholdEventFired) {
          this._dispatchEvent("scroll-ended-with-threshold");
          this._isScrollEndedWithThresholdEventFired = true;
        }
        if (this.elastic) {
          var brakeOffsetPosition = newPosition.sub(this._autoScrollBrakingStartPosition);
          isAutoScrollBrake && (brakeOffsetPosition = brakeOffsetPosition.mul(brakingFactor));
          newPosition = this._autoScrollBrakingStartPosition.add(brakeOffsetPosition);
        } else {
          var moveDelta = newPosition.sub(this.getContentPosition());
          var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);
          if (!outOfBoundary.fuzzyEquals(cc.v2(0, 0), EPSILON)) {
            newPosition = newPosition.add(outOfBoundary);
            reachedEnd = true;
          }
        }
        reachedEnd && (this._autoScrolling = false);
        var deltaMove = newPosition.sub(this.getContentPosition());
        this._moveContent(this._clampDelta(deltaMove), reachedEnd);
        this._dispatchEvent("scrolling");
        if (!this._autoScrolling) {
          this._isBouncing = false;
          this._scrolling = false;
          this._dispatchEvent("scroll-ended");
        }
      },
      _startInertiaScroll: function _startInertiaScroll(touchMoveVelocity) {
        var inertiaTotalMovement = touchMoveVelocity.mul(MOVEMENT_FACTOR);
        this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
      },
      _calculateAttenuatedFactor: function _calculateAttenuatedFactor(distance) {
        if (this.brake <= 0) return 1 - this.brake;
        return (1 - this.brake) * (1 / (1 + 14e-6 * distance + distance * distance * 8e-9));
      },
      _startAttenuatingAutoScroll: function _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
        var time = this._calculateAutoScrollTimeByInitalSpeed(initialVelocity.mag());
        var targetDelta = deltaMove.normalize();
        var contentSize = this.content.getContentSize();
        var scrollviewSize = this._view.getContentSize();
        var totalMoveWidth = contentSize.width - scrollviewSize.width;
        var totalMoveHeight = contentSize.height - scrollviewSize.height;
        var attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);
        var attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);
        targetDelta = cc.v2(targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX, targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake));
        var originalMoveLength = deltaMove.mag();
        var factor = targetDelta.mag() / originalMoveLength;
        targetDelta = targetDelta.add(deltaMove);
        if (this.brake > 0 && factor > 7) {
          factor = Math.sqrt(factor);
          targetDelta = deltaMove.mul(factor).add(deltaMove);
        }
        if (this.brake > 0 && factor > 3) {
          factor = 3;
          time *= factor;
        }
        0 === this.brake && factor > 1 && (time *= factor);
        this._startAutoScroll(targetDelta, time, true);
      },
      _calculateAutoScrollTimeByInitalSpeed: function _calculateAutoScrollTimeByInitalSpeed(initalSpeed) {
        return Math.sqrt(Math.sqrt(initalSpeed / 5));
      },
      _startAutoScroll: function _startAutoScroll(deltaMove, timeInSecond, attenuated) {
        var adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);
        this._autoScrolling = true;
        this._autoScrollTargetDelta = adjustedDeltaMove;
        this._autoScrollAttenuate = attenuated;
        this._autoScrollStartPosition = this.getContentPosition();
        this._autoScrollTotalTime = timeInSecond;
        this._autoScrollAccumulatedTime = 0;
        this._autoScrollBraking = false;
        this._isScrollEndedWithThresholdEventFired = false;
        this._autoScrollBrakingStartPosition = cc.v2(0, 0);
        var currentOutOfBoundary = this._getHowMuchOutOfBoundary();
        currentOutOfBoundary.fuzzyEquals(cc.v2(0, 0), EPSILON) || (this._autoScrollCurrentlyOutOfBoundary = true);
      },
      _calculateTouchMoveVelocity: function _calculateTouchMoveVelocity() {
        var totalTime = 0;
        totalTime = this._touchMoveTimeDeltas.reduce((function(a, b) {
          return a + b;
        }), totalTime);
        if (totalTime <= 0 || totalTime >= .5) return cc.v2(0, 0);
        var totalMovement = cc.v2(0, 0);
        totalMovement = this._touchMoveDisplacements.reduce((function(a, b) {
          return a.add(b);
        }), totalMovement);
        return cc.v2(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime);
      },
      _flattenVectorByDirection: function _flattenVectorByDirection(vector) {
        var result = vector;
        result.x = this.horizontal ? result.x : 0;
        result.y = this.vertical ? result.y : 0;
        return result;
      },
      _moveContent: function _moveContent(deltaMove, canStartBounceBack) {
        var adjustedMove = this._flattenVectorByDirection(deltaMove);
        var newPosition = this.getContentPosition().add(adjustedMove);
        this.setContentPosition(newPosition);
        var outOfBoundary = this._getHowMuchOutOfBoundary();
        this._updateScrollBar(outOfBoundary);
        this.elastic && canStartBounceBack && this._startBounceBackIfNeeded();
      },
      _getContentLeftBoundary: function _getContentLeftBoundary() {
        var contentPos = this.getContentPosition();
        return contentPos.x - this.content.getAnchorPoint().x * this.content.getContentSize().width;
      },
      _getContentRightBoundary: function _getContentRightBoundary() {
        var contentSize = this.content.getContentSize();
        return this._getContentLeftBoundary() + contentSize.width;
      },
      _getContentTopBoundary: function _getContentTopBoundary() {
        var contentSize = this.content.getContentSize();
        return this._getContentBottomBoundary() + contentSize.height;
      },
      _getContentBottomBoundary: function _getContentBottomBoundary() {
        var contentPos = this.getContentPosition();
        return contentPos.y - this.content.getAnchorPoint().y * this.content.getContentSize().height;
      },
      _getHowMuchOutOfBoundary: function _getHowMuchOutOfBoundary(addition) {
        addition = addition || cc.v2(0, 0);
        if (addition.fuzzyEquals(cc.v2(0, 0), EPSILON) && !this._outOfBoundaryAmountDirty) return this._outOfBoundaryAmount;
        var outOfBoundaryAmount = cc.v2(0, 0);
        this._getContentLeftBoundary() + addition.x > this._leftBoundary ? outOfBoundaryAmount.x = this._leftBoundary - (this._getContentLeftBoundary() + addition.x) : this._getContentRightBoundary() + addition.x < this._rightBoundary && (outOfBoundaryAmount.x = this._rightBoundary - (this._getContentRightBoundary() + addition.x));
        this._getContentTopBoundary() + addition.y < this._topBoundary ? outOfBoundaryAmount.y = this._topBoundary - (this._getContentTopBoundary() + addition.y) : this._getContentBottomBoundary() + addition.y > this._bottomBoundary && (outOfBoundaryAmount.y = this._bottomBoundary - (this._getContentBottomBoundary() + addition.y));
        if (addition.fuzzyEquals(cc.v2(0, 0), EPSILON)) {
          this._outOfBoundaryAmount = outOfBoundaryAmount;
          this._outOfBoundaryAmountDirty = false;
        }
        outOfBoundaryAmount = this._clampDelta(outOfBoundaryAmount);
        return outOfBoundaryAmount;
      },
      _updateScrollBarState: function _updateScrollBarState() {
        if (!this.content) return;
        var contentSize = this.content.getContentSize();
        var scrollViewSize = this._view.getContentSize();
        this.verticalScrollBar && (contentSize.height < scrollViewSize.height ? this.verticalScrollBar.hide() : this.verticalScrollBar.show());
        this.horizontalScrollBar && (contentSize.width < scrollViewSize.width ? this.horizontalScrollBar.hide() : this.horizontalScrollBar.show());
      },
      _updateScrollBar: function _updateScrollBar(outOfBoundary) {
        this.horizontalScrollBar && this.horizontalScrollBar._onScroll(outOfBoundary);
        this.verticalScrollBar && this.verticalScrollBar._onScroll(outOfBoundary);
      },
      _onScrollBarTouchBegan: function _onScrollBarTouchBegan() {
        this.horizontalScrollBar && this.horizontalScrollBar._onTouchBegan();
        this.verticalScrollBar && this.verticalScrollBar._onTouchBegan();
      },
      _onScrollBarTouchEnded: function _onScrollBarTouchEnded() {
        this.horizontalScrollBar && this.horizontalScrollBar._onTouchEnded();
        this.verticalScrollBar && this.verticalScrollBar._onTouchEnded();
      },
      _dispatchEvent: function _dispatchEvent(event) {
        if ("scroll-ended" === event) this._scrollEventEmitMask = 0; else if ("scroll-to-top" === event || "scroll-to-bottom" === event || "scroll-to-left" === event || "scroll-to-right" === event) {
          var flag = 1 << eventMap[event];
          if (this._scrollEventEmitMask & flag) return;
          this._scrollEventEmitMask |= flag;
        }
        cc.Component.EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]);
        this.node.emit(event, this);
      },
      _adjustContentOutOfBoundary: function _adjustContentOutOfBoundary() {
        this._outOfBoundaryAmountDirty = true;
        if (this._isOutOfBoundary()) {
          var outOfBoundary = this._getHowMuchOutOfBoundary(cc.v2(0, 0));
          var newPosition = this.getContentPosition().add(outOfBoundary);
          if (this.content) {
            this.content.setPosition(newPosition);
            this._updateScrollBar(0);
          }
        }
      },
      start: function start() {
        this._calculateBoundary();
        this.content && cc.director.once(cc.Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
      },
      _hideScrollbar: function _hideScrollbar() {
        this.horizontalScrollBar && this.horizontalScrollBar.hide();
        this.verticalScrollBar && this.verticalScrollBar.hide();
      },
      onDisable: function onDisable() {
        true;
        this._unregisterEvent();
        if (this.content) {
          this.content.off(NodeEvent.SIZE_CHANGED, this._calculateBoundary, this);
          this.content.off(NodeEvent.SCALE_CHANGED, this._calculateBoundary, this);
          if (this._view) {
            this._view.off(NodeEvent.POSITION_CHANGED, this._calculateBoundary, this);
            this._view.off(NodeEvent.SCALE_CHANGED, this._calculateBoundary, this);
            this._view.off(NodeEvent.SIZE_CHANGED, this._calculateBoundary, this);
          }
        }
        this._hideScrollbar();
        this.stopAutoScroll();
      },
      onEnable: function onEnable() {
        true;
        this._registerEvent();
        if (this.content) {
          this.content.on(NodeEvent.SIZE_CHANGED, this._calculateBoundary, this);
          this.content.on(NodeEvent.SCALE_CHANGED, this._calculateBoundary, this);
          if (this._view) {
            this._view.on(NodeEvent.POSITION_CHANGED, this._calculateBoundary, this);
            this._view.on(NodeEvent.SCALE_CHANGED, this._calculateBoundary, this);
            this._view.on(NodeEvent.SIZE_CHANGED, this._calculateBoundary, this);
          }
        }
        this._updateScrollBarState();
      },
      update: function update(dt) {
        this._autoScrolling && this._processAutoScrolling(dt);
      }
    });
    cc.ScrollView = module.exports = ScrollView;
  }), {
    "../CCNode": 104,
    "./CCViewGroup": 203
  } ],
  197: [ (function(require, module, exports) {
    "use strict";
    var misc = require("../utils/misc");
    var Component = require("./CCComponent");
    var Direction = cc.Enum({
      Horizontal: 0,
      Vertical: 1
    });
    var Slider = cc.Class({
      name: "cc.Slider",
      extends: Component,
      editor: false,
      ctor: function ctor() {
        this._offset = cc.v2();
        this._touchHandle = false;
        this._dragging = false;
      },
      properties: {
        handle: {
          default: null,
          type: cc.Button,
          tooltip: (true, "i18n:COMPONENT.slider.handle"),
          notify: function notify() {
            false;
          }
        },
        direction: {
          default: Direction.Horizontal,
          type: Direction,
          tooltip: (true, "i18n:COMPONENT.slider.direction")
        },
        progress: {
          default: .5,
          type: cc.Float,
          range: [ 0, 1, .1 ],
          slide: true,
          tooltip: (true, "i18n:COMPONENT.slider.progress"),
          notify: function notify() {
            this._updateHandlePosition();
          }
        },
        slideEvents: {
          default: [],
          type: cc.Component.EventHandler,
          tooltip: (true, "i18n:COMPONENT.slider.slideEvents")
        }
      },
      statics: {
        Direction: Direction
      },
      __preload: function __preload() {
        this._updateHandlePosition();
      },
      onEnable: function onEnable() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this);
        if (this.handle && this.handle.isValid) {
          this.handle.node.on(cc.Node.EventType.TOUCH_START, this._onHandleDragStart, this);
          this.handle.node.on(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.handle.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        }
      },
      onDisable: function onDisable() {
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this);
        if (this.handle && this.handle.isValid) {
          this.handle.node.off(cc.Node.EventType.TOUCH_START, this._onHandleDragStart, this);
          this.handle.node.off(cc.Node.EventType.TOUCH_MOVE, this._onTouchMoved, this);
          this.handle.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
        }
      },
      _onHandleDragStart: function _onHandleDragStart(event) {
        this._dragging = true;
        this._touchHandle = true;
        this._offset = this.handle.node.convertToNodeSpaceAR(event.touch.getLocation());
        event.stopPropagation();
      },
      _onTouchBegan: function _onTouchBegan(event) {
        if (!this.handle) return;
        this._dragging = true;
        this._touchHandle || this._handleSliderLogic(event.touch);
        event.stopPropagation();
      },
      _onTouchMoved: function _onTouchMoved(event) {
        if (!this._dragging) return;
        this._handleSliderLogic(event.touch);
        event.stopPropagation();
      },
      _onTouchEnded: function _onTouchEnded(event) {
        this._dragging = false;
        this._touchHandle = false;
        this._offset = cc.v2();
        event.stopPropagation();
      },
      _onTouchCancelled: function _onTouchCancelled(event) {
        this._dragging = false;
        event.stopPropagation();
      },
      _handleSliderLogic: function _handleSliderLogic(touch) {
        this._updateProgress(touch);
        this._emitSlideEvent();
      },
      _emitSlideEvent: function _emitSlideEvent() {
        cc.Component.EventHandler.emitEvents(this.slideEvents, this);
        this.node.emit("slide", this);
      },
      _updateProgress: function _updateProgress(touch) {
        if (!this.handle) return;
        var node = this.node;
        var localTouchPos = node.convertToNodeSpaceAR(touch.getLocation());
        this.direction === Direction.Horizontal ? this.progress = misc.clamp01((localTouchPos.x - this._offset.x + node.anchorX * node.width) / node.width) : this.progress = misc.clamp01((localTouchPos.y - this._offset.y + node.anchorY * node.height) / node.height);
      },
      _updateHandlePosition: function _updateHandlePosition() {
        if (!this.handle) return;
        var handlelocalPos;
        handlelocalPos = this.direction === Direction.Horizontal ? cc.v2(-this.node.width * this.node.anchorX + this.progress * this.node.width, 0) : cc.v2(0, -this.node.height * this.node.anchorY + this.progress * this.node.height);
        var worldSpacePos = this.node.convertToWorldSpaceAR(handlelocalPos);
        this.handle.node.position = this.handle.node.parent.convertToNodeSpaceAR(worldSpacePos);
      }
    });
    cc.Slider = module.exports = Slider;
  }), {
    "../utils/misc": 386,
    "./CCComponent": 181
  } ],
  198: [ (function(require, module, exports) {
    "use strict";
    var misc = require("../utils/misc");
    var NodeEvent = require("../CCNode").EventType;
    var RenderComponent = require("./CCRenderComponent");
    var BlendFunc = require("../utils/blend-func");
    var SpriteType = cc.Enum({
      SIMPLE: 0,
      SLICED: 1,
      TILED: 2,
      FILLED: 3,
      MESH: 4
    });
    var FillType = cc.Enum({
      HORIZONTAL: 0,
      VERTICAL: 1,
      RADIAL: 2
    });
    var SizeMode = cc.Enum({
      CUSTOM: 0,
      TRIMMED: 1,
      RAW: 2
    });
    var State = cc.Enum({
      NORMAL: 0,
      GRAY: 1
    });
    var Sprite = cc.Class({
      name: "cc.Sprite",
      extends: RenderComponent,
      mixins: [ BlendFunc ],
      editor: false,
      properties: {
        _spriteFrame: {
          default: null,
          type: cc.SpriteFrame
        },
        _type: SpriteType.SIMPLE,
        _sizeMode: SizeMode.TRIMMED,
        _fillType: 0,
        _fillCenter: cc.v2(0, 0),
        _fillStart: 0,
        _fillRange: 0,
        _isTrimmedMode: true,
        _atlas: {
          default: null,
          type: cc.SpriteAtlas,
          tooltip: (true, "i18n:COMPONENT.sprite.atlas"),
          editorOnly: true,
          visible: true,
          animatable: false
        },
        spriteFrame: {
          get: function get() {
            return this._spriteFrame;
          },
          set: function set(value, force) {
            var lastSprite = this._spriteFrame;
            false;
            if (lastSprite === value) return;
            this._spriteFrame = value;
            this._applySpriteFrame(lastSprite);
            false;
          },
          type: cc.SpriteFrame
        },
        type: {
          get: function get() {
            return this._type;
          },
          set: function set(value) {
            if (this._type !== value) {
              this._type = value;
              this.setVertsDirty();
              this._resetAssembler();
            }
          },
          type: SpriteType,
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.sprite.type")
        },
        fillType: {
          get: function get() {
            return this._fillType;
          },
          set: function set(value) {
            if (value !== this._fillType) {
              this._fillType = value;
              this.setVertsDirty();
              this._resetAssembler();
            }
          },
          type: FillType,
          tooltip: (true, "i18n:COMPONENT.sprite.fill_type")
        },
        fillCenter: {
          get: function get() {
            return this._fillCenter;
          },
          set: function set(value) {
            this._fillCenter.x = value.x;
            this._fillCenter.y = value.y;
            this._type === SpriteType.FILLED && this.setVertsDirty();
          },
          tooltip: (true, "i18n:COMPONENT.sprite.fill_center")
        },
        fillStart: {
          get: function get() {
            return this._fillStart;
          },
          set: function set(value) {
            this._fillStart = misc.clampf(value, -1, 1);
            this._type === SpriteType.FILLED && this.setVertsDirty();
          },
          tooltip: (true, "i18n:COMPONENT.sprite.fill_start")
        },
        fillRange: {
          get: function get() {
            return this._fillRange;
          },
          set: function set(value) {
            this._fillRange = misc.clampf(value, -1, 1);
            this._type === SpriteType.FILLED && this.setVertsDirty();
          },
          tooltip: (true, "i18n:COMPONENT.sprite.fill_range")
        },
        trim: {
          get: function get() {
            return this._isTrimmedMode;
          },
          set: function set(value) {
            if (this._isTrimmedMode !== value) {
              this._isTrimmedMode = value;
              this._type !== SpriteType.SIMPLE && this._type !== SpriteType.MESH || this.setVertsDirty();
              false;
            }
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.sprite.trim")
        },
        sizeMode: {
          get: function get() {
            return this._sizeMode;
          },
          set: function set(value) {
            this._sizeMode = value;
            value !== SizeMode.CUSTOM && this._applySpriteSize();
          },
          animatable: false,
          type: SizeMode,
          tooltip: (true, "i18n:COMPONENT.sprite.size_mode")
        },
        autoSwitchMaterial: {
          type: RenderComponent.EnableType,
          default: RenderComponent.EnableType.GLOBAL,
          notify: function notify(oldValue) {
            if (this.autoSwitchMaterial === oldValue) return;
            this.setVertsDirty();
          }
        },
        allowDynamicAtlas: {
          type: RenderComponent.EnableType,
          default: RenderComponent.EnableType.GLOBAL,
          notify: function notify(oldValue) {
            if (this.allowDynamicAtlas === oldValue) return;
            this.setVertsDirty();
          }
        }
      },
      statics: {
        FillType: FillType,
        Type: SpriteType,
        SizeMode: SizeMode,
        State: State
      },
      setVisible: function setVisible(visible) {
        this.enabled = visible;
      },
      setState: function setState() {},
      getState: function getState() {},
      __preload: function __preload() {
        this._super();
        false;
        this._applySpriteFrame();
      },
      onEnable: function onEnable() {
        this._super();
        this._spriteFrame && this._spriteFrame.isValid && this._spriteFrame.ensureLoadTexture();
        this.node.on(cc.Node.EventType.SIZE_CHANGED, this.setVertsDirty, this);
        this.node.on(cc.Node.EventType.ANCHOR_CHANGED, this.setVertsDirty, this);
      },
      onDisable: function onDisable() {
        this._super();
        this.node.off(cc.Node.EventType.SIZE_CHANGED, this.setVertsDirty, this);
        this.node.off(cc.Node.EventType.ANCHOR_CHANGED, this.setVertsDirty, this);
      },
      onRestore: false,
      _updateMaterial: function _updateMaterial() {
        var texture = null;
        this._spriteFrame && (texture = this._spriteFrame.getTexture());
        var material = this.getMaterial(0);
        if (material) {
          var oldDefine = material.getDefine("USE_TEXTURE");
          void 0 === oldDefine || oldDefine || material.define("USE_TEXTURE", true);
          var isMultiMaterial = material.material.isMultiSupport();
          if (isMultiMaterial) this._texIdDirty = true; else {
            var textureImpl = texture && texture.getImpl();
            material.getProperty("texture") !== textureImpl && material.setProperty("texture", texture);
          }
          this._assembler && (isMultiMaterial && !this._assembler.isMulti || !isMultiMaterial && this._assembler.isMulti) && this._resetAssembler();
        }
        BlendFunc.prototype._updateMaterial.call(this);
      },
      _applyAtlas: false,
      _validateRender: function _validateRender() {
        var spriteFrame = this._spriteFrame;
        if (this._materials[0] && spriteFrame && spriteFrame.textureLoaded()) return;
        this.disableRender();
      },
      _applySpriteSize: function _applySpriteSize() {
        if (!this.isValid || !this._spriteFrame || !this._spriteFrame.isValid) return;
        if (SizeMode.RAW === this._sizeMode) {
          var size = this._spriteFrame._originalSize;
          this.node.setContentSize(size);
        } else if (SizeMode.TRIMMED === this._sizeMode) {
          var rect = this._spriteFrame._rect;
          this.node.setContentSize(rect.width, rect.height);
        }
        this.setVertsDirty();
      },
      _applySpriteFrame: function _applySpriteFrame(oldFrame) {
        if (!this.isValid) return;
        var oldTexture = oldFrame && oldFrame.isValid && oldFrame.getTexture();
        oldTexture && !oldTexture.loaded && oldFrame.off("load", this._applySpriteSize, this);
        var spriteFrame = this._spriteFrame;
        var frameValid = spriteFrame && spriteFrame.isValid;
        var newTexture = frameValid && spriteFrame.getTexture();
        oldTexture !== newTexture && this._updateMaterial();
        if (newTexture && newTexture.loaded) this._applySpriteSize(); else {
          this.disableRender();
          frameValid && spriteFrame.once("load", this._applySpriteSize, this);
        }
        false;
      }
    });
    false;
    cc.Sprite = module.exports = Sprite;
  }), {
    "../CCNode": 104,
    "../utils/blend-func": 380,
    "../utils/misc": 386,
    "./CCRenderComponent": 192
  } ],
  199: [ (function(require, module, exports) {
    "use strict";
    var ComponentType = cc.Enum({
      NONE: 0,
      CHECKBOX: 1,
      TEXT_ATLAS: 2,
      SLIDER_BAR: 3,
      LIST_VIEW: 4,
      PAGE_VIEW: 5
    });
    var ListDirection = cc.Enum({
      VERTICAL: 0,
      HORIZONTAL: 1
    });
    var VerticalAlign = cc.Enum({
      TOP: 0,
      CENTER: 1,
      BOTTOM: 2
    });
    var HorizontalAlign = cc.Enum({
      LEFT: 0,
      CENTER: 1,
      RIGHT: 2
    });
    var StudioComponent = cc.Class({
      name: "cc.StudioComponent",
      extends: cc.Component,
      editor: false,
      properties: false,
      statics: {
        ComponentType: ComponentType,
        ListDirection: ListDirection,
        VerticalAlign: VerticalAlign,
        HorizontalAlign: HorizontalAlign
      }
    });
    cc.StudioComponent = module.exports = StudioComponent;
    var StudioWidget = cc.Class({
      name: "cc.StudioWidget",
      extends: cc.Widget,
      editor: false,
      _validateTargetInDEV: function _validateTargetInDEV() {}
    });
    cc.StudioWidget = module.exports = StudioWidget;
  }), {} ],
  200: [ (function(require, module, exports) {
    "use strict";
    var GraySpriteState = require("../utils/gray-sprite-state");
    var Toggle = cc.Class({
      name: "cc.Toggle",
      extends: require("./CCButton"),
      mixins: [ GraySpriteState ],
      editor: false,
      properties: {
        _N$isChecked: true,
        isChecked: {
          get: function get() {
            return this._N$isChecked;
          },
          set: function set(value) {
            if (value === this._N$isChecked) return;
            var group = this.toggleGroup || this._toggleContainer;
            if (group && group.enabled && this._N$isChecked && !group.allowSwitchOff) return;
            this._N$isChecked = value;
            this._updateCheckMark();
            group && group.enabled && group.updateToggles(this);
            cc.Toggle._triggerEventInScript_isChecked && this._emitToggleEvents();
          },
          tooltip: (true, "i18n:COMPONENT.toggle.isChecked")
        },
        toggleGroup: {
          default: null,
          tooltip: (true, "i18n:COMPONENT.toggle.toggleGroup"),
          type: require("./CCToggleGroup")
        },
        checkMark: {
          default: null,
          type: cc.Sprite,
          tooltip: (true, "i18n:COMPONENT.toggle.checkMark")
        },
        checkEvents: {
          default: [],
          type: cc.Component.EventHandler
        },
        _resizeToTarget: {
          animatable: false,
          set: function set(value) {
            value && this._resizeNodeToTargetNode();
          }
        }
      },
      statics: {
        _triggerEventInScript_check: false,
        _triggerEventInScript_isChecked: false
      },
      onEnable: function onEnable() {
        this._super();
        true;
        this._registerToggleEvent();
        this.toggleGroup && this.toggleGroup.enabledInHierarchy && this.toggleGroup.addToggle(this);
      },
      onDisable: function onDisable() {
        this._super();
        true;
        this._unregisterToggleEvent();
        this.toggleGroup && this.toggleGroup.enabledInHierarchy && this.toggleGroup.removeToggle(this);
      },
      _hideCheckMark: function _hideCheckMark() {
        this._N$isChecked = false;
        this._updateCheckMark();
      },
      toggle: function toggle(event) {
        this.isChecked = !this.isChecked;
        cc.Toggle._triggerEventInScript_isChecked || !cc.Toggle._triggerEventInScript_check && !event || this._emitToggleEvents();
      },
      check: function check() {
        this.isChecked = true;
        !cc.Toggle._triggerEventInScript_isChecked && cc.Toggle._triggerEventInScript_check && this._emitToggleEvents();
      },
      uncheck: function uncheck() {
        this.isChecked = false;
        !cc.Toggle._triggerEventInScript_isChecked && cc.Toggle._triggerEventInScript_check && this._emitToggleEvents();
      },
      _updateCheckMark: function _updateCheckMark() {
        this.checkMark && (this.checkMark.node.active = !!this.isChecked);
      },
      _updateDisabledState: function _updateDisabledState() {
        this._super();
        if (this.enableAutoGrayEffect && this.checkMark) {
          var useGrayMaterial = !this.interactable;
          this._switchGrayMaterial(useGrayMaterial, this.checkMark);
        }
      },
      _registerToggleEvent: function _registerToggleEvent() {
        this.node.on("click", this.toggle, this);
      },
      _unregisterToggleEvent: function _unregisterToggleEvent() {
        this.node.off("click", this.toggle, this);
      },
      _emitToggleEvents: function _emitToggleEvents() {
        this.node.emit("toggle", this);
        this.checkEvents && cc.Component.EventHandler.emitEvents(this.checkEvents, this);
      }
    });
    cc.Toggle = module.exports = Toggle;
    var js = require("../platform/js");
    js.get(Toggle.prototype, "_toggleContainer", (function() {
      var parent = this.node.parent;
      if (cc.Node.isNode(parent)) return parent.getComponent(cc.ToggleContainer);
      return null;
    }));
  }), {
    "../platform/js": 294,
    "../utils/gray-sprite-state": 383,
    "./CCButton": 179,
    "./CCToggleGroup": 202
  } ],
  201: [ (function(require, module, exports) {
    "use strict";
    var ToggleContainer = cc.Class({
      name: "cc.ToggleContainer",
      extends: cc.Component,
      editor: false,
      properties: {
        allowSwitchOff: {
          tooltip: (true, "i18n:COMPONENT.toggle_group.allowSwitchOff"),
          default: false
        },
        checkEvents: {
          default: [],
          type: cc.Component.EventHandler
        }
      },
      updateToggles: function updateToggles(toggle) {
        if (!this.enabledInHierarchy) return;
        if (toggle.isChecked) {
          this.toggleItems.forEach((function(item) {
            item !== toggle && item.isChecked && item.enabled && item._hideCheckMark();
          }));
          this.checkEvents && cc.Component.EventHandler.emitEvents(this.checkEvents, toggle);
        }
      },
      _allowOnlyOneToggleChecked: function _allowOnlyOneToggleChecked() {
        var isChecked = false;
        this.toggleItems.forEach((function(item) {
          isChecked ? item._hideCheckMark() : item.isChecked && (isChecked = true);
        }));
        return isChecked;
      },
      _makeAtLeastOneToggleChecked: function _makeAtLeastOneToggleChecked() {
        var isChecked = this._allowOnlyOneToggleChecked();
        if (!isChecked && !this.allowSwitchOff) {
          var toggleItems = this.toggleItems;
          toggleItems.length > 0 && toggleItems[0].check();
        }
      },
      onEnable: function onEnable() {
        this._makeAtLeastOneToggleChecked();
        this.node.on("child-added", this._allowOnlyOneToggleChecked, this);
        this.node.on("child-removed", this._makeAtLeastOneToggleChecked, this);
      },
      onDisable: function onDisable() {
        this.node.off("child-added", this._allowOnlyOneToggleChecked, this);
        this.node.off("child-removed", this._makeAtLeastOneToggleChecked, this);
      }
    });
    var js = require("../platform/js");
    js.get(ToggleContainer.prototype, "toggleItems", (function() {
      return this.node._children.map((function(item) {
        return item.getComponent(cc.Toggle);
      })).filter(Boolean);
    }));
    cc.ToggleContainer = module.exports = ToggleContainer;
  }), {
    "../platform/js": 294
  } ],
  202: [ (function(require, module, exports) {
    "use strict";
    var ToggleGroup = cc.Class({
      name: "cc.ToggleGroup",
      extends: cc.Component,
      ctor: function ctor() {
        this._toggleItems = [];
      },
      editor: false,
      properties: {
        allowSwitchOff: {
          tooltip: (true, "i18n:COMPONENT.toggle_group.allowSwitchOff"),
          default: false
        },
        toggleItems: {
          get: function get() {
            return this._toggleItems;
          }
        }
      },
      updateToggles: function updateToggles(toggle) {
        if (!this.enabledInHierarchy) return;
        this._toggleItems.forEach((function(item) {
          toggle.isChecked && item !== toggle && item.isChecked && item.enabled && item._hideCheckMark();
        }));
      },
      addToggle: function addToggle(toggle) {
        var index = this._toggleItems.indexOf(toggle);
        -1 === index && this._toggleItems.push(toggle);
        this._allowOnlyOneToggleChecked();
      },
      removeToggle: function removeToggle(toggle) {
        var index = this._toggleItems.indexOf(toggle);
        index > -1 && this._toggleItems.splice(index, 1);
        this._makeAtLeastOneToggleChecked();
      },
      _allowOnlyOneToggleChecked: function _allowOnlyOneToggleChecked() {
        var isChecked = false;
        this._toggleItems.forEach((function(item) {
          isChecked && item.enabled && item._hideCheckMark();
          item.isChecked && item.enabled && (isChecked = true);
        }));
        return isChecked;
      },
      _makeAtLeastOneToggleChecked: function _makeAtLeastOneToggleChecked() {
        var isChecked = this._allowOnlyOneToggleChecked();
        isChecked || this.allowSwitchOff || this._toggleItems.length > 0 && (this._toggleItems[0].isChecked = true);
      },
      start: function start() {
        this._makeAtLeastOneToggleChecked();
      }
    });
    var js = require("../platform/js");
    var showed = false;
    js.get(cc, "ToggleGroup", (function() {
      if (!showed) {
        cc.errorID(1405, "cc.ToggleGroup", "cc.ToggleContainer");
        showed = true;
      }
      return ToggleGroup;
    }));
    module.exports = ToggleGroup;
  }), {
    "../platform/js": 294
  } ],
  203: [ (function(require, module, exports) {
    "use strict";
    var ViewGroup = cc.Class({
      name: "cc.ViewGroup",
      extends: require("./CCComponent")
    });
    cc.ViewGroup = module.exports = ViewGroup;
  }), {
    "./CCComponent": 181
  } ],
  204: [ (function(require, module, exports) {
    "use strict";
    var WidgetManager = require("../base-ui/CCWidgetManager");
    var AlignMode = WidgetManager.AlignMode;
    var AlignFlags = WidgetManager._AlignFlags;
    var TOP = AlignFlags.TOP;
    var MID = AlignFlags.MID;
    var BOT = AlignFlags.BOT;
    var LEFT = AlignFlags.LEFT;
    var CENTER = AlignFlags.CENTER;
    var RIGHT = AlignFlags.RIGHT;
    var TOP_BOT = TOP | BOT;
    var LEFT_RIGHT = LEFT | RIGHT;
    var Widget = cc.Class({
      name: "cc.Widget",
      extends: require("./CCComponent"),
      editor: false,
      properties: {
        target: {
          get: function get() {
            return this._target;
          },
          set: function set(value) {
            this._target = value;
            false;
          },
          type: cc.Node,
          tooltip: (true, "i18n:COMPONENT.widget.target")
        },
        isAlignTop: {
          get: function get() {
            return (this._alignFlags & TOP) > 0;
          },
          set: function set(value) {
            this._setAlign(TOP, value);
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.widget.align_top")
        },
        isAlignVerticalCenter: {
          get: function get() {
            return (this._alignFlags & MID) > 0;
          },
          set: function set(value) {
            if (value) {
              this.isAlignTop = false;
              this.isAlignBottom = false;
              this._alignFlags |= MID;
            } else this._alignFlags &= ~MID;
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.widget.align_v_center")
        },
        isAlignBottom: {
          get: function get() {
            return (this._alignFlags & BOT) > 0;
          },
          set: function set(value) {
            this._setAlign(BOT, value);
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.widget.align_bottom")
        },
        isAlignLeft: {
          get: function get() {
            return (this._alignFlags & LEFT) > 0;
          },
          set: function set(value) {
            this._setAlign(LEFT, value);
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.widget.align_left")
        },
        isAlignHorizontalCenter: {
          get: function get() {
            return (this._alignFlags & CENTER) > 0;
          },
          set: function set(value) {
            if (value) {
              this.isAlignLeft = false;
              this.isAlignRight = false;
              this._alignFlags |= CENTER;
            } else this._alignFlags &= ~CENTER;
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.widget.align_h_center")
        },
        isAlignRight: {
          get: function get() {
            return (this._alignFlags & RIGHT) > 0;
          },
          set: function set(value) {
            this._setAlign(RIGHT, value);
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.widget.align_right")
        },
        isStretchWidth: {
          get: function get() {
            return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
          },
          visible: false
        },
        isStretchHeight: {
          get: function get() {
            return (this._alignFlags & TOP_BOT) === TOP_BOT;
          },
          visible: false
        },
        top: {
          get: function get() {
            return this._top;
          },
          set: function set(value) {
            this._top = value;
          },
          tooltip: (true, "i18n:COMPONENT.widget.top")
        },
        bottom: {
          get: function get() {
            return this._bottom;
          },
          set: function set(value) {
            this._bottom = value;
          },
          tooltip: (true, "i18n:COMPONENT.widget.bottom")
        },
        left: {
          get: function get() {
            return this._left;
          },
          set: function set(value) {
            this._left = value;
          },
          tooltip: (true, "i18n:COMPONENT.widget.left")
        },
        right: {
          get: function get() {
            return this._right;
          },
          set: function set(value) {
            this._right = value;
          },
          tooltip: (true, "i18n:COMPONENT.widget.right")
        },
        horizontalCenter: {
          get: function get() {
            return this._horizontalCenter;
          },
          set: function set(value) {
            this._horizontalCenter = value;
          },
          tooltip: (true, "i18n:COMPONENT.widget.horizontal_center")
        },
        verticalCenter: {
          get: function get() {
            return this._verticalCenter;
          },
          set: function set(value) {
            this._verticalCenter = value;
          },
          tooltip: (true, "i18n:COMPONENT.widget.vertical_center")
        },
        isAbsoluteHorizontalCenter: {
          get: function get() {
            return this._isAbsHorizontalCenter;
          },
          set: function set(value) {
            this._isAbsHorizontalCenter = value;
          },
          animatable: false
        },
        isAbsoluteVerticalCenter: {
          get: function get() {
            return this._isAbsVerticalCenter;
          },
          set: function set(value) {
            this._isAbsVerticalCenter = value;
          },
          animatable: false
        },
        isAbsoluteTop: {
          get: function get() {
            return this._isAbsTop;
          },
          set: function set(value) {
            this._isAbsTop = value;
          },
          animatable: false
        },
        isAbsoluteBottom: {
          get: function get() {
            return this._isAbsBottom;
          },
          set: function set(value) {
            this._isAbsBottom = value;
          },
          animatable: false
        },
        isAbsoluteLeft: {
          get: function get() {
            return this._isAbsLeft;
          },
          set: function set(value) {
            this._isAbsLeft = value;
          },
          animatable: false
        },
        isAbsoluteRight: {
          get: function get() {
            return this._isAbsRight;
          },
          set: function set(value) {
            this._isAbsRight = value;
          },
          animatable: false
        },
        alignMode: {
          default: AlignMode.ON_WINDOW_RESIZE,
          type: AlignMode,
          tooltip: (true, "i18n:COMPONENT.widget.align_mode")
        },
        _wasAlignOnce: {
          default: void 0,
          formerlySerializedAs: "isAlignOnce"
        },
        _target: null,
        _alignFlags: 0,
        _left: 0,
        _right: 0,
        _top: 0,
        _bottom: 0,
        _verticalCenter: 0,
        _horizontalCenter: 0,
        _isAbsLeft: true,
        _isAbsRight: true,
        _isAbsTop: true,
        _isAbsBottom: true,
        _isAbsHorizontalCenter: true,
        _isAbsVerticalCenter: true,
        _originalWidth: 0,
        _originalHeight: 0
      },
      statics: {
        AlignMode: AlignMode
      },
      onLoad: function onLoad() {
        if (void 0 !== this._wasAlignOnce) {
          this.alignMode = this._wasAlignOnce ? AlignMode.ONCE : AlignMode.ALWAYS;
          this._wasAlignOnce = void 0;
        }
      },
      onEnable: function onEnable() {
        WidgetManager.add(this);
      },
      onDisable: function onDisable() {
        WidgetManager.remove(this);
      },
      _validateTargetInDEV: (true, function() {
        var target = this._target;
        if (target) {
          var isParent = this.node !== target && this.node.isChildOf(target);
          if (!isParent) {
            cc.errorID(6500);
            this._target = null;
          }
        }
      }),
      _setAlign: function _setAlign(flag, isAlign) {
        var current = (this._alignFlags & flag) > 0;
        if (isAlign === current) return;
        var isHorizontal = (flag & LEFT_RIGHT) > 0;
        if (isAlign) {
          this._alignFlags |= flag;
          if (isHorizontal) {
            this.isAlignHorizontalCenter = false;
            if (this.isStretchWidth) {
              this._originalWidth = this.node.width;
              false;
            }
          } else {
            this.isAlignVerticalCenter = false;
            if (this.isStretchHeight) {
              this._originalHeight = this.node.height;
              false;
            }
          }
          false;
        } else {
          isHorizontal ? this.isStretchWidth && (this.node.width = this._originalWidth) : this.isStretchHeight && (this.node.height = this._originalHeight);
          this._alignFlags &= ~flag;
        }
      },
      updateAlignment: function updateAlignment() {
        WidgetManager.updateAlignment(this.node);
      }
    });
    Object.defineProperty(Widget.prototype, "isAlignOnce", {
      get: function get() {
        true;
        cc.warn("`widget.isAlignOnce` is deprecated, use `widget.alignMode === cc.Widget.AlignMode.ONCE` instead please.");
        return this.alignMode === AlignMode.ONCE;
      },
      set: function set(value) {
        true;
        cc.warn("`widget.isAlignOnce` is deprecated, use `widget.alignMode = cc.Widget.AlignMode.*` instead please.");
        this.alignMode = value ? AlignMode.ONCE : AlignMode.ALWAYS;
      }
    });
    cc.Widget = module.exports = Widget;
  }), {
    "../base-ui/CCWidgetManager": 165,
    "./CCComponent": 181
  } ],
  205: [ (function(require, module, exports) {
    "use strict";
    var Component = require("./CCComponent");
    var SubContextView = cc.Class({
      name: "cc.SubContextView",
      extends: Component,
      editor: false,
      properties: {
        _firstlyEnabled: true,
        _fps: 60,
        fps: {
          get: function get() {
            return this._fps;
          },
          set: function set(value) {
            if (this._fps === value) return;
            this._fps = value;
            this._updateInterval = 1 / value;
            this._updateSubContextFrameRate();
          },
          tooltip: (true, "i18n:COMPONENT.subcontext_view.fps")
        }
      },
      ctor: function ctor() {
        this._sprite = null;
        this._tex = new cc.Texture2D();
        this._tex._packable = false;
        this._context = null;
        this._updatedTime = performance.now();
        this._updateInterval = 0;
      },
      onLoad: function onLoad() {
        if (window.__globalAdapter && __globalAdapter.getOpenDataContext) {
          this._updateInterval = 1e3 / this._fps;
          this._context = __globalAdapter.getOpenDataContext();
          this.reset();
          var sharedCanvas = this._context.canvas;
          this._tex.setPremultiplyAlpha(true);
          this._tex.initWithElement(sharedCanvas);
          this._tex._packable = false;
          this._sprite = this.node.getComponent(cc.Sprite);
          if (!this._sprite) {
            this._sprite = this.node.addComponent(cc.Sprite);
            this._sprite.srcBlendFactor = cc.macro.BlendFactor.ONE;
          }
          this._sprite.spriteFrame = new cc.SpriteFrame(this._tex);
        } else this.enabled = false;
      },
      reset: function reset() {
        if (this._context) {
          this.updateSubContextViewport();
          var sharedCanvas = this._context.canvas;
          if (sharedCanvas) {
            sharedCanvas.width = this.node.width;
            sharedCanvas.height = this.node.height;
          }
        }
      },
      onEnable: function onEnable() {
        if (this._firstlyEnabled && this._context) {
          this._context.postMessage({
            fromEngine: true,
            event: "boot"
          });
          this._firstlyEnabled = false;
        } else this._runSubContextMainLoop();
        this._registerNodeEvent();
        this._updateSubContextFrameRate();
        this.updateSubContextViewport();
      },
      onDisable: function onDisable() {
        this._unregisterNodeEvent();
        this._stopSubContextMainLoop();
      },
      update: function update(dt) {
        var calledUpdateMannually = void 0 === dt;
        if (calledUpdateMannually) {
          this._context && this._context.postMessage({
            fromEngine: true,
            event: "step"
          });
          this._updateSubContextTexture();
          return;
        }
        var now = performance.now();
        var deltaTime = now - this._updatedTime;
        if (deltaTime >= this._updateInterval) {
          this._updatedTime += this._updateInterval;
          this._updateSubContextTexture();
        }
      },
      _updateSubContextTexture: function _updateSubContextTexture() {
        if (!this._tex || !this._context) return;
        this._tex.initWithElement(this._context.canvas);
        this._tex._packable = false;
        this._sprite._activateMaterial();
      },
      updateSubContextViewport: function updateSubContextViewport() {
        if (this._context) {
          var box = this.node.getBoundingBoxToWorld();
          var sx = cc.view._scaleX;
          var sy = cc.view._scaleY;
          this._context.postMessage({
            fromEngine: true,
            event: "viewport",
            x: box.x * sx + cc.view._viewportRect.x,
            y: box.y * sy + cc.view._viewportRect.y,
            width: box.width * sx,
            height: box.height * sy
          });
        }
      },
      _registerNodeEvent: function _registerNodeEvent() {
        this.node.on("position-changed", this.updateSubContextViewport, this);
        this.node.on("scale-changed", this.updateSubContextViewport, this);
        this.node.on("size-changed", this.updateSubContextViewport, this);
      },
      _unregisterNodeEvent: function _unregisterNodeEvent() {
        this.node.off("position-changed", this.updateSubContextViewport, this);
        this.node.off("scale-changed", this.updateSubContextViewport, this);
        this.node.off("size-changed", this.updateSubContextViewport, this);
      },
      _runSubContextMainLoop: function _runSubContextMainLoop() {
        this._context && this._context.postMessage({
          fromEngine: true,
          event: "mainLoop",
          value: true
        });
      },
      _stopSubContextMainLoop: function _stopSubContextMainLoop() {
        this._context && this._context.postMessage({
          fromEngine: true,
          event: "mainLoop",
          value: false
        });
      },
      _updateSubContextFrameRate: function _updateSubContextFrameRate() {
        this._context && this._context.postMessage({
          fromEngine: true,
          event: "frameRate",
          value: this._fps
        });
      }
    });
    cc.SubContextView = module.exports = SubContextView;
    cc.WXSubContextView = SubContextView;
    cc.SwanSubContextView = SubContextView;
  }), {
    "./CCComponent": 181
  } ],
  206: [ (function(require, module, exports) {
    "use strict";
    var macro = require("../../platform/CCMacro");
    var EditBoxImplBase = require("../editbox/EditBoxImplBase");
    var Label = require("../CCLabel");
    var Types = require("./types");
    var InputMode = Types.InputMode;
    var InputFlag = Types.InputFlag;
    var KeyboardReturnType = Types.KeyboardReturnType;
    function capitalize(string) {
      return string.replace(/(?:^|\s)\S/g, (function(a) {
        return a.toUpperCase();
      }));
    }
    function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    var EditBox = cc.Class({
      name: "cc.EditBox",
      extends: cc.Component,
      editor: false,
      properties: {
        _string: "",
        string: {
          tooltip: (true, "i18n:COMPONENT.editbox.string"),
          get: function get() {
            return this._string;
          },
          set: function set(value) {
            value = "" + value;
            this.maxLength >= 0 && value.length >= this.maxLength && (value = value.slice(0, this.maxLength));
            this._string = value;
            this._updateString(value);
          }
        },
        textLabel: {
          tooltip: (true, "i18n:COMPONENT.editbox.textLabel"),
          default: null,
          type: Label,
          notify: function notify(oldValue) {
            if (this.textLabel && this.textLabel !== oldValue) {
              this._updateTextLabel();
              this._updateLabels();
            }
          }
        },
        placeholderLabel: {
          tooltip: (true, "i18n:COMPONENT.editbox.placeholderLabel"),
          default: null,
          type: Label,
          notify: function notify(oldValue) {
            if (this.placeholderLabel && this.placeholderLabel !== oldValue) {
              this._updatePlaceholderLabel();
              this._updateLabels();
            }
          }
        },
        background: {
          tooltip: (true, "i18n:COMPONENT.editbox.background"),
          default: null,
          type: cc.Sprite,
          notify: function notify(oldValue) {
            this.background && this.background !== oldValue && this._updateBackgroundSprite();
          }
        },
        _N$backgroundImage: {
          default: void 0,
          type: cc.SpriteFrame
        },
        backgroundImage: {
          get: function get() {
            if (!this.background) return null;
            return this.background.spriteFrame;
          },
          set: function set(value) {
            this.background && (this.background.spriteFrame = value);
          }
        },
        returnType: {
          default: KeyboardReturnType.DEFAULT,
          tooltip: (true, "i18n:COMPONENT.editbox.returnType"),
          displayName: "KeyboardReturnType",
          type: KeyboardReturnType
        },
        _N$returnType: {
          default: void 0,
          type: cc.Float
        },
        inputFlag: {
          tooltip: (true, "i18n:COMPONENT.editbox.input_flag"),
          default: InputFlag.DEFAULT,
          type: InputFlag,
          notify: function notify() {
            this._updateString(this._string);
          }
        },
        inputMode: {
          tooltip: (true, "i18n:COMPONENT.editbox.input_mode"),
          default: InputMode.ANY,
          type: InputMode,
          notify: function notify(oldValue) {
            if (this.inputMode !== oldValue) {
              this._updateTextLabel();
              this._updatePlaceholderLabel();
            }
          }
        },
        fontSize: {
          get: function get() {
            if (!this.textLabel) return 0;
            return this.textLabel.fontSize;
          },
          set: function set(value) {
            this.textLabel && (this.textLabel.fontSize = value);
          }
        },
        _N$fontSize: {
          default: void 0,
          type: cc.Float
        },
        lineHeight: {
          get: function get() {
            if (!this.textLabel) return 0;
            return this.textLabel.lineHeight;
          },
          set: function set(value) {
            this.textLabel && (this.textLabel.lineHeight = value);
          }
        },
        _N$lineHeight: {
          default: void 0,
          type: cc.Float
        },
        fontColor: {
          get: function get() {
            if (!this.textLabel) return cc.Color.BLACK;
            return this.textLabel.node.color;
          },
          set: function set(value) {
            if (this.textLabel) {
              this.textLabel.node.color = value;
              this.textLabel.node.opacity = value.a;
            }
          }
        },
        _N$fontColor: void 0,
        placeholder: {
          tooltip: (true, "i18n:COMPONENT.editbox.placeholder"),
          get: function get() {
            if (!this.placeholderLabel) return "";
            return this.placeholderLabel.string;
          },
          set: function set(value) {
            this.placeholderLabel && (this.placeholderLabel.string = value);
          }
        },
        _N$placeholder: {
          default: void 0,
          type: cc.String
        },
        placeholderFontSize: {
          get: function get() {
            if (!this.placeholderLabel) return 0;
            return this.placeholderLabel.fontSize;
          },
          set: function set(value) {
            this.placeholderLabel && (this.placeholderLabel.fontSize = value);
          }
        },
        _N$placeholderFontSize: {
          default: void 0,
          type: cc.Float
        },
        placeholderFontColor: {
          get: function get() {
            if (!this.placeholderLabel) return cc.Color.BLACK;
            return this.placeholderLabel.node.color;
          },
          set: function set(value) {
            if (this.placeholderLabel) {
              this.placeholderLabel.node.color = value;
              this.placeholderLabel.node.opacity = value.a;
            }
          }
        },
        _N$placeholderFontColor: void 0,
        maxLength: {
          tooltip: (true, "i18n:COMPONENT.editbox.max_length"),
          default: 20
        },
        _N$maxLength: {
          default: void 0,
          type: cc.Float
        },
        stayOnTop: {
          default: false,
          notify: function notify() {
            cc.warn("editBox.stayOnTop is removed since v2.1.");
          }
        },
        _tabIndex: 0,
        tabIndex: {
          tooltip: (true, "i18n:COMPONENT.editbox.tab_index"),
          get: function get() {
            return this._tabIndex;
          },
          set: function set(value) {
            if (this._tabIndex !== value) {
              this._tabIndex = value;
              this._impl && this._impl.setTabIndex(value);
            }
          }
        },
        editingDidBegan: {
          default: [],
          type: cc.Component.EventHandler
        },
        textChanged: {
          default: [],
          type: cc.Component.EventHandler
        },
        editingDidEnded: {
          default: [],
          type: cc.Component.EventHandler
        },
        editingReturn: {
          default: [],
          type: cc.Component.EventHandler
        }
      },
      statics: {
        _ImplClass: EditBoxImplBase,
        KeyboardReturnType: KeyboardReturnType,
        InputFlag: InputFlag,
        InputMode: InputMode
      },
      _init: function _init() {
        this._upgradeComp();
        this._isLabelVisible = true;
        this.node.on(cc.Node.EventType.SIZE_CHANGED, this._syncSize, this);
        var impl = this._impl = new EditBox._ImplClass();
        impl.init(this);
        this._updateString(this._string);
        this._syncSize();
      },
      _updateBackgroundSprite: function _updateBackgroundSprite() {
        var background = this.background;
        if (!background) {
          var node = this.node.getChildByName("BACKGROUND_SPRITE");
          node || (node = new cc.Node("BACKGROUND_SPRITE"));
          background = node.getComponent(cc.Sprite);
          background || (background = node.addComponent(cc.Sprite));
          node.parent = this.node;
          this.background = background;
        }
        background.type = cc.Sprite.Type.SLICED;
        if (void 0 !== this._N$backgroundImage) {
          background.spriteFrame = this._N$backgroundImage;
          this._N$backgroundImage = void 0;
        }
      },
      _updateTextLabel: function _updateTextLabel() {
        var textLabel = this.textLabel;
        if (!textLabel) {
          var node = this.node.getChildByName("TEXT_LABEL");
          node || (node = new cc.Node("TEXT_LABEL"));
          textLabel = node.getComponent(Label);
          textLabel || (textLabel = node.addComponent(Label));
          node.parent = this.node;
          this.textLabel = textLabel;
        }
        textLabel.node.setAnchorPoint(0, 1);
        textLabel.overflow = Label.Overflow.CLAMP;
        if (this.inputMode === InputMode.ANY) {
          textLabel.verticalAlign = macro.VerticalTextAlignment.TOP;
          textLabel.enableWrapText = true;
        } else {
          textLabel.verticalAlign = macro.VerticalTextAlignment.CENTER;
          textLabel.enableWrapText = false;
        }
        textLabel.string = this._updateLabelStringStyle(this._string);
        if (void 0 !== this._N$fontColor) {
          textLabel.node.color = this._N$fontColor;
          textLabel.node.opacity = this._N$fontColor.a;
          this._N$fontColor = void 0;
        }
        if (void 0 !== this._N$fontSize) {
          textLabel.fontSize = this._N$fontSize;
          this._N$fontSize = void 0;
        }
        if (void 0 !== this._N$lineHeight) {
          textLabel.lineHeight = this._N$lineHeight;
          this._N$lineHeight = void 0;
        }
      },
      _updatePlaceholderLabel: function _updatePlaceholderLabel() {
        var placeholderLabel = this.placeholderLabel;
        if (!placeholderLabel) {
          var node = this.node.getChildByName("PLACEHOLDER_LABEL");
          node || (node = new cc.Node("PLACEHOLDER_LABEL"));
          placeholderLabel = node.getComponent(Label);
          placeholderLabel || (placeholderLabel = node.addComponent(Label));
          node.parent = this.node;
          this.placeholderLabel = placeholderLabel;
        }
        placeholderLabel.node.setAnchorPoint(0, 1);
        placeholderLabel.overflow = Label.Overflow.CLAMP;
        if (this.inputMode === InputMode.ANY) {
          placeholderLabel.verticalAlign = macro.VerticalTextAlignment.TOP;
          placeholderLabel.enableWrapText = true;
        } else {
          placeholderLabel.verticalAlign = macro.VerticalTextAlignment.CENTER;
          placeholderLabel.enableWrapText = false;
        }
        placeholderLabel.string = this.placeholder;
        if (void 0 !== this._N$placeholderFontColor) {
          placeholderLabel.node.color = this._N$placeholderFontColor;
          placeholderLabel.node.opacity = this._N$placeholderFontColor.a;
          this._N$placeholderFontColor = void 0;
        }
        if (void 0 !== this._N$placeholderFontSize) {
          placeholderLabel.fontSize = this._N$placeholderFontSize;
          this._N$placeholderFontSize = void 0;
        }
      },
      _upgradeComp: function _upgradeComp() {
        if (void 0 !== this._N$returnType) {
          this.returnType = this._N$returnType;
          this._N$returnType = void 0;
        }
        if (void 0 !== this._N$maxLength) {
          this.maxLength = this._N$maxLength;
          this._N$maxLength = void 0;
        }
        void 0 !== this._N$backgroundImage && this._updateBackgroundSprite();
        void 0 === this._N$fontColor && void 0 === this._N$fontSize && void 0 === this._N$lineHeight || this._updateTextLabel();
        void 0 === this._N$placeholderFontColor && void 0 === this._N$placeholderFontSize || this._updatePlaceholderLabel();
        if (void 0 !== this._N$placeholder) {
          this.placeholder = this._N$placeholder;
          this._N$placeholder = void 0;
        }
      },
      _syncSize: function _syncSize() {
        if (this._impl) {
          var size = this.node.getContentSize();
          this._impl.setSize(size.width, size.height);
        }
      },
      _showLabels: function _showLabels() {
        this._isLabelVisible = true;
        this._updateLabels();
      },
      _hideLabels: function _hideLabels() {
        this._isLabelVisible = false;
        this.textLabel && (this.textLabel.node.active = false);
        this.placeholderLabel && (this.placeholderLabel.node.active = false);
      },
      _updateLabels: function _updateLabels() {
        if (this._isLabelVisible) {
          var content = this._string;
          this.textLabel && (this.textLabel.node.active = "" !== content);
          this.placeholderLabel && (this.placeholderLabel.node.active = "" === content);
        }
      },
      _updateString: function _updateString(text) {
        var textLabel = this.textLabel;
        if (!textLabel) return;
        var displayText = text;
        displayText && (displayText = this._updateLabelStringStyle(displayText));
        textLabel.string = displayText;
        this._updateLabels();
      },
      _updateLabelStringStyle: function _updateLabelStringStyle(text, ignorePassword) {
        var inputFlag = this.inputFlag;
        if (ignorePassword || inputFlag !== InputFlag.PASSWORD) inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? text = text.toUpperCase() : inputFlag === InputFlag.INITIAL_CAPS_WORD ? text = capitalize(text) : inputFlag === InputFlag.INITIAL_CAPS_SENTENCE && (text = capitalizeFirstLetter(text)); else {
          var passwordString = "";
          var len = text.length;
          for (var i = 0; i < len; ++i) passwordString += "\u25cf";
          text = passwordString;
        }
        return text;
      },
      editBoxEditingDidBegan: function editBoxEditingDidBegan() {
        cc.Component.EventHandler.emitEvents(this.editingDidBegan, this);
        this.node.emit("editing-did-began", this);
      },
      editBoxEditingDidEnded: function editBoxEditingDidEnded() {
        cc.Component.EventHandler.emitEvents(this.editingDidEnded, this);
        this.node.emit("editing-did-ended", this);
      },
      editBoxTextChanged: function editBoxTextChanged(text) {
        text = this._updateLabelStringStyle(text, true);
        this.string = text;
        cc.Component.EventHandler.emitEvents(this.textChanged, text, this);
        this.node.emit("text-changed", this);
      },
      editBoxEditingReturn: function editBoxEditingReturn() {
        cc.Component.EventHandler.emitEvents(this.editingReturn, this);
        this.node.emit("editing-return", this);
      },
      onEnable: function onEnable() {
        true;
        this._registerEvent();
        this._impl && this._impl.enable();
      },
      onDisable: function onDisable() {
        true;
        this._unregisterEvent();
        this._impl && this._impl.disable();
      },
      onDestroy: function onDestroy() {
        this._impl && this._impl.clear();
      },
      __preload: function __preload() {
        this._init();
      },
      _registerEvent: function _registerEvent() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
      },
      _unregisterEvent: function _unregisterEvent() {
        this.node.off(cc.Node.EventType.TOUCH_START, this._onTouchBegan, this);
        this.node.off(cc.Node.EventType.TOUCH_END, this._onTouchEnded, this);
      },
      _onTouchBegan: function _onTouchBegan(event) {
        event.stopPropagation();
      },
      _onTouchCancel: function _onTouchCancel(event) {
        event.stopPropagation();
      },
      _onTouchEnded: function _onTouchEnded(event) {
        this._impl && this._impl.beginEditing();
        event.stopPropagation();
      },
      setFocus: function setFocus() {
        cc.errorID(1400, "setFocus()", "focus()");
        this._impl && this._impl.setFocus(true);
      },
      focus: function focus() {
        this._impl && this._impl.setFocus(true);
      },
      blur: function blur() {
        this._impl && this._impl.setFocus(false);
      },
      isFocused: function isFocused() {
        return !!this._impl && this._impl.isFocused();
      },
      update: function update() {
        this._impl && this._impl.update();
      }
    });
    cc.EditBox = module.exports = EditBox;
    cc.sys.isBrowser && require("./WebEditBoxImpl");
  }), {
    "../../platform/CCMacro": 277,
    "../CCLabel": 183,
    "../editbox/EditBoxImplBase": 207,
    "./WebEditBoxImpl": 208,
    "./types": 210
  } ],
  207: [ (function(require, module, exports) {
    "use strict";
    var EditBoxImplBase = cc.Class({
      ctor: function ctor() {
        this._delegate = null;
        this._editing = false;
      },
      init: function init(delegate) {},
      enable: function enable() {},
      disable: function disable() {
        this._editing && this.endEditing();
      },
      clear: function clear() {},
      update: function update() {},
      setTabIndex: function setTabIndex(index) {},
      setSize: function setSize(width, height) {},
      setFocus: function setFocus(value) {
        value ? this.beginEditing() : this.endEditing();
      },
      isFocused: function isFocused() {
        return this._editing;
      },
      beginEditing: function beginEditing() {},
      endEditing: function endEditing() {}
    });
    module.exports = EditBoxImplBase;
  }), {} ],
  208: [ (function(require, module, exports) {
    "use strict";
    var _mat = _interopRequireDefault(require("../../value-types/mat4"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var utils = require("../../platform/utils");
    var macro = require("../../platform/CCMacro");
    var Types = require("./types");
    var Label = require("../CCLabel");
    var tabIndexUtil = require("./tabIndexUtil");
    var EditBox = cc.EditBox;
    var js = cc.js;
    var InputMode = Types.InputMode;
    var InputFlag = Types.InputFlag;
    var KeyboardReturnType = Types.KeyboardReturnType;
    var polyfill = {
      zoomInvalid: false
    };
    cc.sys.OS_ANDROID !== cc.sys.os || cc.sys.browserType !== cc.sys.BROWSER_TYPE_SOUGOU && cc.sys.browserType !== cc.sys.BROWSER_TYPE_360 || (polyfill.zoomInvalid = true);
    var DELAY_TIME = 800;
    var SCROLLY = 100;
    var LEFT_PADDING = 2;
    var _domCount = 0;
    var _vec3 = cc.v3();
    var _currentEditBoxImpl = null;
    var _fullscreen = false;
    var _autoResize = false;
    var BaseClass = EditBox._ImplClass;
    function WebEditBoxImpl() {
      BaseClass.call(this);
      this._domId = "EditBoxId_" + ++_domCount;
      this._placeholderStyleSheet = null;
      this._elem = null;
      this._isTextArea = false;
      this._worldMat = new _mat["default"]();
      this._cameraMat = new _mat["default"]();
      this._m00 = 0;
      this._m01 = 0;
      this._m04 = 0;
      this._m05 = 0;
      this._m12 = 0;
      this._m13 = 0;
      this._w = 0;
      this._h = 0;
      this._cacheViewportRect = cc.rect(0, 0, 0, 0);
      this._inputMode = null;
      this._inputFlag = null;
      this._returnType = null;
      this._eventListeners = {};
      this._textLabelFont = null;
      this._textLabelFontSize = null;
      this._textLabelFontColor = null;
      this._textLabelAlign = null;
      this._placeholderLabelFont = null;
      this._placeholderLabelFontSize = null;
      this._placeholderLabelFontColor = null;
      this._placeholderLabelAlign = null;
      this._placeholderLineHeight = null;
    }
    js.extend(WebEditBoxImpl, BaseClass);
    EditBox._ImplClass = WebEditBoxImpl;
    Object.assign(WebEditBoxImpl.prototype, {
      init: function init(delegate) {
        if (!delegate) return;
        this._delegate = delegate;
        delegate.inputMode === InputMode.ANY ? this._createTextArea() : this._createInput();
        tabIndexUtil.add(this);
        this.setTabIndex(delegate.tabIndex);
        this._initStyleSheet();
        this._registerEventListeners();
        this._addDomToGameContainer();
        _fullscreen = cc.view.isAutoFullScreenEnabled();
        _autoResize = cc.view._resizeWithBrowserSize;
      },
      clear: function clear() {
        this._removeEventListeners();
        this._removeDomFromGameContainer();
        tabIndexUtil.remove(this);
        _currentEditBoxImpl === this && (_currentEditBoxImpl = null);
      },
      update: function update() {
        this._updateMatrix();
      },
      setTabIndex: function setTabIndex(index) {
        this._elem.tabIndex = index;
        tabIndexUtil.resort();
      },
      setSize: function setSize(width, height) {
        var elem = this._elem;
        elem.style.width = width + "px";
        elem.style.height = height + "px";
      },
      beginEditing: function beginEditing() {
        _currentEditBoxImpl && _currentEditBoxImpl !== this && _currentEditBoxImpl.setFocus(false);
        this._editing = true;
        _currentEditBoxImpl = this;
        this._delegate.editBoxEditingDidBegan();
        this._showDom();
        this._elem.focus();
      },
      endEditing: function endEditing() {
        this._elem && this._elem.blur();
      },
      _createInput: function _createInput() {
        this._isTextArea = false;
        this._elem = document.createElement("input");
      },
      _createTextArea: function _createTextArea() {
        this._isTextArea = true;
        this._elem = document.createElement("textarea");
      },
      _addDomToGameContainer: function _addDomToGameContainer() {
        cc.game.container.appendChild(this._elem);
        document.head.appendChild(this._placeholderStyleSheet);
      },
      _removeDomFromGameContainer: function _removeDomFromGameContainer() {
        var hasElem = utils.contains(cc.game.container, this._elem);
        hasElem && cc.game.container.removeChild(this._elem);
        var hasStyleSheet = utils.contains(document.head, this._placeholderStyleSheet);
        hasStyleSheet && document.head.removeChild(this._placeholderStyleSheet);
        delete this._elem;
        delete this._placeholderStyleSheet;
      },
      _showDom: function _showDom() {
        this._updateMaxLength();
        this._updateInputType();
        this._updateStyleSheet();
        this._elem.style.display = "";
        this._delegate._hideLabels();
        cc.sys.isMobile && this._showDomOnMobile();
      },
      _hideDom: function _hideDom() {
        var elem = this._elem;
        elem.style.display = "none";
        this._delegate._showLabels();
        cc.sys.isMobile && this._hideDomOnMobile();
      },
      _showDomOnMobile: function _showDomOnMobile() {
        if (cc.sys.os !== cc.sys.OS_ANDROID) return;
        if (_fullscreen) {
          cc.view.enableAutoFullScreen(false);
          cc.screen.exitFullScreen();
        }
        _autoResize && cc.view.resizeWithBrowserSize(false);
        this._adjustWindowScroll();
      },
      _hideDomOnMobile: function _hideDomOnMobile() {
        if (cc.sys.os === cc.sys.OS_ANDROID) {
          _autoResize && cc.view.resizeWithBrowserSize(true);
          setTimeout((function() {
            _currentEditBoxImpl || _fullscreen && cc.view.enableAutoFullScreen(true);
          }), DELAY_TIME);
        }
      },
      _adjustWindowScroll: function _adjustWindowScroll() {
        var self = this;
        setTimeout((function() {
          window.scrollY < SCROLLY && self._elem.scrollIntoView({
            block: "start",
            inline: "nearest",
            behavior: "smooth"
          });
        }), DELAY_TIME);
      },
      _scrollBackWindow: function _scrollBackWindow() {
        setTimeout((function() {
          var sys = cc.sys;
          if (sys.browserType === sys.BROWSER_TYPE_WECHAT && sys.os === sys.OS_IOS) {
            window.top && window.top.scrollTo(0, 0);
            return;
          }
          window.scrollTo(0, 0);
        }), DELAY_TIME);
      },
      _updateCameraMatrix: function _updateCameraMatrix() {
        var node = this._delegate.node;
        node.getWorldMatrix(this._worldMat);
        var worldMat = this._worldMat;
        var nodeContentSize = node._contentSize, nodeAnchorPoint = node._anchorPoint;
        _vec3.x = -nodeAnchorPoint.x * nodeContentSize.width;
        _vec3.y = -nodeAnchorPoint.y * nodeContentSize.height;
        _mat["default"].transform(worldMat, worldMat, _vec3);
        false;
        var camera = cc.Camera.findCamera(node);
        if (!camera) return false;
        camera.getWorldToScreenMatrix2D(this._cameraMat);
        _mat["default"].mul(this._cameraMat, this._cameraMat, worldMat);
        return true;
      },
      _updateMatrix: function _updateMatrix() {
        if (false, !this._updateCameraMatrix()) return;
        var cameraMatm = this._cameraMat.m;
        var node = this._delegate.node;
        var localView = cc.view;
        if (this._m00 === cameraMatm[0] && this._m01 === cameraMatm[1] && this._m04 === cameraMatm[4] && this._m05 === cameraMatm[5] && this._m12 === cameraMatm[12] && this._m13 === cameraMatm[13] && this._w === node._contentSize.width && this._h === node._contentSize.height && this._cacheViewportRect.equals(localView._viewportRect)) return;
        this._m00 = cameraMatm[0];
        this._m01 = cameraMatm[1];
        this._m04 = cameraMatm[4];
        this._m05 = cameraMatm[5];
        this._m12 = cameraMatm[12];
        this._m13 = cameraMatm[13];
        this._w = node._contentSize.width;
        this._h = node._contentSize.height;
        this._cacheViewportRect.set(localView._viewportRect);
        var scaleX = localView._scaleX, scaleY = localView._scaleY, viewport = localView._viewportRect, dpr = localView._devicePixelRatio;
        scaleX /= dpr;
        scaleY /= dpr;
        var container = cc.game.container;
        var a = cameraMatm[0] * scaleX, b = cameraMatm[1], c = cameraMatm[4], d = cameraMatm[5] * scaleY;
        var offsetX = container && container.style.paddingLeft && parseInt(container.style.paddingLeft);
        offsetX += viewport.x / dpr;
        var offsetY = container && container.style.paddingBottom && parseInt(container.style.paddingBottom);
        offsetY += viewport.y / dpr;
        var tx = cameraMatm[12] * scaleX + offsetX, ty = cameraMatm[13] * scaleY + offsetY;
        if (polyfill.zoomInvalid) {
          this.setSize(node.width * a, node.height * d);
          a = 1;
          d = 1;
        }
        var elem = this._elem;
        var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
        elem.style["transform"] = matrix;
        elem.style["-webkit-transform"] = matrix;
        elem.style["transform-origin"] = "0px 100% 0px";
        elem.style["-webkit-transform-origin"] = "0px 100% 0px";
      },
      _updateInputType: function _updateInputType() {
        var delegate = this._delegate, inputMode = delegate.inputMode, inputFlag = delegate.inputFlag, returnType = delegate.returnType, elem = this._elem;
        if (this._inputMode === inputMode && this._inputFlag === inputFlag && this._returnType === returnType) return;
        this._inputMode = inputMode;
        this._inputFlag = inputFlag;
        this._returnType = returnType;
        if (this._isTextArea) {
          var _textTransform = "none";
          inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? _textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (_textTransform = "capitalize");
          elem.style.textTransform = _textTransform;
          return;
        }
        if (inputFlag === InputFlag.PASSWORD) {
          elem.type = "password";
          elem.style.textTransform = "none";
          return;
        }
        var type = elem.type;
        if (inputMode === InputMode.EMAIL_ADDR) type = "email"; else if (inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL) type = "number"; else if (inputMode === InputMode.PHONE_NUMBER) {
          type = "number";
          elem.pattern = "[0-9]*";
          elem.onmousewheel = function() {
            return false;
          };
        } else if (inputMode === InputMode.URL) type = "url"; else {
          type = "text";
          returnType === KeyboardReturnType.SEARCH && (type = "search");
        }
        elem.type = type;
        var textTransform = "none";
        inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS ? textTransform = "uppercase" : inputFlag === InputFlag.INITIAL_CAPS_WORD && (textTransform = "capitalize");
        elem.style.textTransform = textTransform;
      },
      _updateMaxLength: function _updateMaxLength() {
        var maxLength = this._delegate.maxLength;
        maxLength < 0 && (maxLength = 65535);
        this._elem.maxLength = maxLength;
      },
      _initStyleSheet: function _initStyleSheet() {
        var elem = this._elem;
        elem.style.display = "none";
        elem.style.border = 0;
        elem.style.background = "transparent";
        elem.style.width = "100%";
        elem.style.height = "100%";
        elem.style.active = 0;
        elem.style.outline = "medium";
        elem.style.padding = "0";
        elem.style.textTransform = "none";
        elem.style.position = "absolute";
        elem.style.bottom = "0px";
        elem.style.left = LEFT_PADDING + "px";
        elem.className = "cocosEditBox";
        elem.id = this._domId;
        if (this._isTextArea) {
          elem.style.resize = "none";
          elem.style.overflow_y = "scroll";
        } else {
          elem.type = "text";
          elem.style["-moz-appearance"] = "textfield";
        }
        this._placeholderStyleSheet = document.createElement("style");
      },
      _updateStyleSheet: function _updateStyleSheet() {
        var delegate = this._delegate, elem = this._elem;
        elem.value = delegate.string;
        elem.placeholder = delegate.placeholder;
        this._updateTextLabel(delegate.textLabel);
        this._updatePlaceholderLabel(delegate.placeholderLabel);
      },
      _updateTextLabel: function _updateTextLabel(textLabel) {
        if (!textLabel) return;
        var font = textLabel.font;
        font = !font || font instanceof cc.BitmapFont ? textLabel.fontFamily : font._fontFamily;
        var fontSize = textLabel.fontSize * textLabel.node.scaleY;
        if (this._textLabelFont === font && this._textLabelFontSize === fontSize && this._textLabelFontColor === textLabel.fontColor && this._textLabelAlign === textLabel.horizontalAlign) return;
        this._textLabelFont = font;
        this._textLabelFontSize = fontSize;
        this._textLabelFontColor = textLabel.fontColor;
        this._textLabelAlign = textLabel.horizontalAlign;
        var elem = this._elem;
        elem.style.fontSize = fontSize + "px";
        elem.style.color = textLabel.node.color.toCSS();
        elem.style.fontFamily = font;
        switch (textLabel.horizontalAlign) {
         case Label.HorizontalAlign.LEFT:
          elem.style.textAlign = "left";
          break;

         case Label.HorizontalAlign.CENTER:
          elem.style.textAlign = "center";
          break;

         case Label.HorizontalAlign.RIGHT:
          elem.style.textAlign = "right";
        }
      },
      _updatePlaceholderLabel: function _updatePlaceholderLabel(placeholderLabel) {
        if (!placeholderLabel) return;
        var font = placeholderLabel.font;
        font = !font || font instanceof cc.BitmapFont ? placeholderLabel.fontFamily : placeholderLabel.font._fontFamily;
        var fontSize = placeholderLabel.fontSize * placeholderLabel.node.scaleY;
        if (this._placeholderLabelFont === font && this._placeholderLabelFontSize === fontSize && this._placeholderLabelFontColor === placeholderLabel.fontColor && this._placeholderLabelAlign === placeholderLabel.horizontalAlign && this._placeholderLineHeight === placeholderLabel.fontSize) return;
        this._placeholderLabelFont = font;
        this._placeholderLabelFontSize = fontSize;
        this._placeholderLabelFontColor = placeholderLabel.fontColor;
        this._placeholderLabelAlign = placeholderLabel.horizontalAlign;
        this._placeholderLineHeight = placeholderLabel.fontSize;
        var styleEl = this._placeholderStyleSheet;
        var fontColor = placeholderLabel.node.color.toCSS();
        var lineHeight = placeholderLabel.fontSize;
        var horizontalAlign;
        switch (placeholderLabel.horizontalAlign) {
         case Label.HorizontalAlign.LEFT:
          horizontalAlign = "left";
          break;

         case Label.HorizontalAlign.CENTER:
          horizontalAlign = "center";
          break;

         case Label.HorizontalAlign.RIGHT:
          horizontalAlign = "right";
        }
        styleEl.innerHTML = "#" + this._domId + "::-webkit-input-placeholder,#" + this._domId + "::-moz-placeholder,#" + this._domId + ":-ms-input-placeholder{text-transform: initial; font-family: " + font + "; font-size: " + fontSize + "px; color: " + fontColor + "; line-height: " + lineHeight + "px; text-align: " + horizontalAlign + ";}";
        cc.sys.browserType === cc.sys.BROWSER_TYPE_EDGE && (styleEl.innerHTML += "#" + this._domId + "::-ms-clear{display: none;}");
      },
      _registerEventListeners: function _registerEventListeners() {
        var impl = this, elem = this._elem, inputLock = false, cbs = this._eventListeners;
        cbs.compositionStart = function() {
          inputLock = true;
        };
        cbs.compositionEnd = function() {
          inputLock = false;
          impl._delegate.editBoxTextChanged(elem.value);
        };
        cbs.onInput = function() {
          if (inputLock) return;
          var maxLength = impl._delegate.maxLength;
          maxLength >= 0 && (elem.value = elem.value.slice(0, maxLength));
          impl._delegate.editBoxTextChanged(elem.value);
        };
        cbs.onClick = function(e) {
          impl._editing && cc.sys.isMobile && impl._adjustWindowScroll();
        };
        cbs.onKeydown = function(e) {
          if (e.keyCode === macro.KEY.enter) {
            e.stopPropagation();
            impl._delegate.editBoxEditingReturn();
            impl._isTextArea || elem.blur();
          } else if (e.keyCode === macro.KEY.tab) {
            e.stopPropagation();
            e.preventDefault();
            tabIndexUtil.next(impl);
          }
        };
        cbs.onBlur = function() {
          cc.sys.isMobile && inputLock && cbs.compositionEnd();
          impl._editing = false;
          _currentEditBoxImpl = null;
          impl._hideDom();
          impl._delegate.editBoxEditingDidEnded();
        };
        elem.addEventListener("compositionstart", cbs.compositionStart);
        elem.addEventListener("compositionend", cbs.compositionEnd);
        elem.addEventListener("input", cbs.onInput);
        elem.addEventListener("keydown", cbs.onKeydown);
        elem.addEventListener("blur", cbs.onBlur);
        elem.addEventListener("touchstart", cbs.onClick);
      },
      _removeEventListeners: function _removeEventListeners() {
        var elem = this._elem, cbs = this._eventListeners;
        elem.removeEventListener("compositionstart", cbs.compositionStart);
        elem.removeEventListener("compositionend", cbs.compositionEnd);
        elem.removeEventListener("input", cbs.onInput);
        elem.removeEventListener("keydown", cbs.onKeydown);
        elem.removeEventListener("blur", cbs.onBlur);
        elem.removeEventListener("touchstart", cbs.onClick);
        cbs.compositionStart = null;
        cbs.compositionEnd = null;
        cbs.onInput = null;
        cbs.onKeydown = null;
        cbs.onBlur = null;
        cbs.onClick = null;
      }
    });
  }), {
    "../../platform/CCMacro": 277,
    "../../platform/utils": 297,
    "../../value-types/mat4": 403,
    "../CCLabel": 183,
    "./tabIndexUtil": 209,
    "./types": 210
  } ],
  209: [ (function(require, module, exports) {
    "use strict";
    var tabIndexUtil = {
      _tabIndexList: [],
      add: function add(editBoxImpl) {
        var list = this._tabIndexList;
        var index = list.indexOf(editBoxImpl);
        -1 === index && list.push(editBoxImpl);
      },
      remove: function remove(editBoxImpl) {
        var list = this._tabIndexList;
        var index = list.indexOf(editBoxImpl);
        -1 !== index && list.splice(index, 1);
      },
      resort: function resort() {
        this._tabIndexList.sort((function(a, b) {
          return a._delegate._tabIndex - b._delegate._tabIndex;
        }));
      },
      next: function next(editBoxImpl) {
        var list = this._tabIndexList;
        var index = list.indexOf(editBoxImpl);
        editBoxImpl.setFocus(false);
        if (-1 !== index) {
          var nextImpl = list[index + 1];
          nextImpl && nextImpl._delegate._tabIndex >= 0 && nextImpl.setFocus(true);
        }
      }
    };
    module.exports = tabIndexUtil;
  }), {} ],
  210: [ (function(require, module, exports) {
    "use strict";
    var KeyboardReturnType = cc.Enum({
      DEFAULT: 0,
      DONE: 1,
      SEND: 2,
      SEARCH: 3,
      GO: 4,
      NEXT: 5
    });
    var InputMode = cc.Enum({
      ANY: 0,
      EMAIL_ADDR: 1,
      NUMERIC: 2,
      PHONE_NUMBER: 3,
      URL: 4,
      DECIMAL: 5,
      SINGLE_LINE: 6
    });
    var InputFlag = cc.Enum({
      PASSWORD: 0,
      SENSITIVE: 1,
      INITIAL_CAPS_WORD: 2,
      INITIAL_CAPS_SENTENCE: 3,
      INITIAL_CAPS_ALL_CHARACTERS: 4,
      DEFAULT: 5
    });
    module.exports = {
      KeyboardReturnType: KeyboardReturnType,
      InputMode: InputMode,
      InputFlag: InputFlag
    };
  }), {} ],
  211: [ (function(require, module, exports) {
    "use strict";
    require("./CCComponent");
    require("./CCComponentEventHandler");
    require("./missing-script");
    var SubContextView = require("./SubContextView");
    if (!SubContextView) {
      SubContextView = cc.Class({
        name: "cc.SubContextView",
        extends: cc.Component
      });
      cc.SubContextView = cc.WXSubContextView = cc.SwanSubContextView = SubContextView;
    }
    var components = [ require("./CCSprite"), require("./CCWidget"), require("./CCCanvas"), require("./CCAudioSource"), require("./CCAnimation"), require("./CCButton"), require("./CCLabel"), require("./CCProgressBar"), require("./CCMask"), require("./CCScrollBar"), require("./CCScrollView"), require("./CCPageViewIndicator"), require("./CCPageView"), require("./CCSlider"), require("./CCLayout"), require("./editbox/CCEditBox"), require("./CCLabelOutline"), require("./CCLabelShadow"), require("./CCRichText"), require("./CCToggleContainer"), require("./CCToggleGroup"), require("./CCToggle"), require("./CCBlockInputEvents"), require("./CCMotionStreak"), require("./CCSafeArea"), SubContextView ];
    module.exports = components;
  }), {
    "./CCAnimation": 176,
    "./CCAudioSource": 177,
    "./CCBlockInputEvents": 178,
    "./CCButton": 179,
    "./CCCanvas": 180,
    "./CCComponent": 181,
    "./CCComponentEventHandler": 182,
    "./CCLabel": 183,
    "./CCLabelOutline": 184,
    "./CCLabelShadow": 185,
    "./CCLayout": 186,
    "./CCMask": 187,
    "./CCMotionStreak": 188,
    "./CCPageView": 189,
    "./CCPageViewIndicator": 190,
    "./CCProgressBar": 191,
    "./CCRichText": 193,
    "./CCSafeArea": 194,
    "./CCScrollBar": 195,
    "./CCScrollView": 196,
    "./CCSlider": 197,
    "./CCSprite": 198,
    "./CCToggle": 200,
    "./CCToggleContainer": 201,
    "./CCToggleGroup": 202,
    "./CCWidget": 204,
    "./SubContextView": 205,
    "./editbox/CCEditBox": 206,
    "./missing-script": 212
  } ],
  212: [ (function(require, module, exports) {
    "use strict";
    var js = cc.js;
    var MissingScript = cc.Class({
      name: "cc.MissingScript",
      extends: cc.Component,
      editor: {
        inspector: "packages://inspector/inspectors/comps/missing-script.js"
      },
      properties: {
        compiled: {
          default: false,
          serializable: false
        },
        _$erialized: {
          default: null,
          visible: false,
          editorOnly: true
        }
      },
      ctor: false,
      statics: {
        safeFindClass: function safeFindClass(id) {
          var cls = js._getClassById(id);
          if (cls) return cls;
          cc.deserialize.reportMissingClass(id);
          return MissingScript;
        }
      },
      onLoad: function onLoad() {
        cc.warnID(4600, this.node.name);
      }
    });
    cc._MissingScript = module.exports = MissingScript;
  }), {} ],
  213: [ (function(require, module, exports) {
    "use strict";
    var js = cc.js;
    require("../event/event");
    var EventMouse = function EventMouse(eventType, bubbles) {
      cc.Event.call(this, cc.Event.MOUSE, bubbles);
      this._eventType = eventType;
      this._button = 0;
      this._x = 0;
      this._y = 0;
      this._prevX = 0;
      this._prevY = 0;
      this._scrollX = 0;
      this._scrollY = 0;
    };
    js.extend(EventMouse, cc.Event);
    var proto = EventMouse.prototype;
    proto.setScrollData = function(scrollX, scrollY) {
      this._scrollX = scrollX;
      this._scrollY = scrollY;
    };
    proto.getScrollX = function() {
      return this._scrollX;
    };
    proto.getScrollY = function() {
      return this._scrollY;
    };
    proto.setLocation = function(x, y) {
      this._x = x;
      this._y = y;
    };
    proto.getLocation = function() {
      return cc.v2(this._x, this._y);
    };
    proto.getLocationInView = function() {
      return cc.v2(this._x, cc.view._designResolutionSize.height - this._y);
    };
    proto._setPrevCursor = function(x, y) {
      this._prevX = x;
      this._prevY = y;
    };
    proto.getPreviousLocation = function() {
      return cc.v2(this._prevX, this._prevY);
    };
    proto.getDelta = function() {
      return cc.v2(this._x - this._prevX, this._y - this._prevY);
    };
    proto.getDeltaX = function() {
      return this._x - this._prevX;
    };
    proto.getDeltaY = function() {
      return this._y - this._prevY;
    };
    proto.setButton = function(button) {
      this._button = button;
    };
    proto.getButton = function() {
      return this._button;
    };
    proto.getLocationX = function() {
      return this._x;
    };
    proto.getLocationY = function() {
      return this._y;
    };
    EventMouse.NONE = 0;
    EventMouse.DOWN = 1;
    EventMouse.UP = 2;
    EventMouse.MOVE = 3;
    EventMouse.SCROLL = 4;
    EventMouse.BUTTON_LEFT = 0;
    EventMouse.BUTTON_RIGHT = 2;
    EventMouse.BUTTON_MIDDLE = 1;
    EventMouse.BUTTON_4 = 3;
    EventMouse.BUTTON_5 = 4;
    EventMouse.BUTTON_6 = 5;
    EventMouse.BUTTON_7 = 6;
    EventMouse.BUTTON_8 = 7;
    var EventTouch = function EventTouch(touchArr, bubbles) {
      cc.Event.call(this, cc.Event.TOUCH, bubbles);
      this._eventCode = 0;
      this._touches = touchArr || [];
      this.touch = null;
      this.currentTouch = null;
    };
    js.extend(EventTouch, cc.Event);
    proto = EventTouch.prototype;
    proto.getEventCode = function() {
      return this._eventCode;
    };
    proto.getTouches = function() {
      return this._touches;
    };
    proto._setEventCode = function(eventCode) {
      this._eventCode = eventCode;
    };
    proto._setTouches = function(touches) {
      this._touches = touches;
    };
    proto.setLocation = function(x, y) {
      this.touch && this.touch.setTouchInfo(this.touch.getID(), x, y);
    };
    proto.getLocation = function() {
      return this.touch ? this.touch.getLocation() : cc.v2();
    };
    proto.getLocationInView = function() {
      return this.touch ? this.touch.getLocationInView() : cc.v2();
    };
    proto.getPreviousLocation = function() {
      return this.touch ? this.touch.getPreviousLocation() : cc.v2();
    };
    proto.getStartLocation = function() {
      return this.touch ? this.touch.getStartLocation() : cc.v2();
    };
    proto.getID = function() {
      return this.touch ? this.touch.getID() : null;
    };
    proto.getDelta = function() {
      return this.touch ? this.touch.getDelta() : cc.v2();
    };
    proto.getDeltaX = function() {
      return this.touch ? this.touch.getDelta().x : 0;
    };
    proto.getDeltaY = function() {
      return this.touch ? this.touch.getDelta().y : 0;
    };
    proto.getLocationX = function() {
      return this.touch ? this.touch.getLocationX() : 0;
    };
    proto.getLocationY = function() {
      return this.touch ? this.touch.getLocationY() : 0;
    };
    EventTouch.MAX_TOUCHES = 5;
    EventTouch.BEGAN = 0;
    EventTouch.MOVED = 1;
    EventTouch.ENDED = 2;
    EventTouch.CANCELED = 3;
    var EventAcceleration = function EventAcceleration(acc, bubbles) {
      cc.Event.call(this, cc.Event.ACCELERATION, bubbles);
      this.acc = acc;
    };
    js.extend(EventAcceleration, cc.Event);
    var EventKeyboard = function EventKeyboard(keyCode, isPressed, bubbles) {
      cc.Event.call(this, cc.Event.KEYBOARD, bubbles);
      this.keyCode = keyCode;
      this.isPressed = isPressed;
    };
    js.extend(EventKeyboard, cc.Event);
    cc.Event.EventMouse = EventMouse;
    cc.Event.EventTouch = EventTouch;
    cc.Event.EventAcceleration = EventAcceleration;
    cc.Event.EventKeyboard = EventKeyboard;
    module.exports = cc.Event;
  }), {
    "../event/event": 220
  } ],
  214: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    cc.EventListener = function(type, listenerID, callback) {
      this._onEvent = callback;
      this._type = type || 0;
      this._listenerID = listenerID || "";
      this._registered = false;
      this._fixedPriority = 0;
      this._node = null;
      this._target = null;
      this._paused = true;
      this._isEnabled = true;
    };
    cc.EventListener.prototype = {
      constructor: cc.EventListener,
      _setPaused: function _setPaused(paused) {
        this._paused = paused;
      },
      _isPaused: function _isPaused() {
        return this._paused;
      },
      _setRegistered: function _setRegistered(registered) {
        this._registered = registered;
      },
      _isRegistered: function _isRegistered() {
        return this._registered;
      },
      _getType: function _getType() {
        return this._type;
      },
      _getListenerID: function _getListenerID() {
        return this._listenerID;
      },
      _setFixedPriority: function _setFixedPriority(fixedPriority) {
        this._fixedPriority = fixedPriority;
      },
      _getFixedPriority: function _getFixedPriority() {
        return this._fixedPriority;
      },
      _setSceneGraphPriority: function _setSceneGraphPriority(node) {
        this._target = node;
        this._node = node;
      },
      _getSceneGraphPriority: function _getSceneGraphPriority() {
        return this._node;
      },
      checkAvailable: function checkAvailable() {
        return null !== this._onEvent;
      },
      clone: function clone() {
        return null;
      },
      setEnabled: function setEnabled(enabled) {
        this._isEnabled = enabled;
      },
      isEnabled: function isEnabled() {
        return this._isEnabled;
      },
      retain: function retain() {},
      release: function release() {}
    };
    cc.EventListener.UNKNOWN = 0;
    cc.EventListener.TOUCH_ONE_BY_ONE = 1;
    cc.EventListener.TOUCH_ALL_AT_ONCE = 2;
    cc.EventListener.KEYBOARD = 3;
    cc.EventListener.MOUSE = 4;
    cc.EventListener.ACCELERATION = 6;
    cc.EventListener.CUSTOM = 8;
    var ListenerID = cc.EventListener.ListenerID = {
      MOUSE: "__cc_mouse",
      TOUCH_ONE_BY_ONE: "__cc_touch_one_by_one",
      TOUCH_ALL_AT_ONCE: "__cc_touch_all_at_once",
      KEYBOARD: "__cc_keyboard",
      ACCELERATION: "__cc_acceleration"
    };
    var Custom = function Custom(listenerId, callback) {
      this._onCustomEvent = callback;
      cc.EventListener.call(this, cc.EventListener.CUSTOM, listenerId, this._callback);
    };
    js.extend(Custom, cc.EventListener);
    js.mixin(Custom.prototype, {
      _onCustomEvent: null,
      _callback: function _callback(event) {
        null !== this._onCustomEvent && this._onCustomEvent(event);
      },
      checkAvailable: function checkAvailable() {
        return cc.EventListener.prototype.checkAvailable.call(this) && null !== this._onCustomEvent;
      },
      clone: function clone() {
        return new Custom(this._listenerID, this._onCustomEvent);
      }
    });
    var Mouse = function Mouse() {
      cc.EventListener.call(this, cc.EventListener.MOUSE, ListenerID.MOUSE, this._callback);
    };
    js.extend(Mouse, cc.EventListener);
    js.mixin(Mouse.prototype, {
      onMouseDown: null,
      onMouseUp: null,
      onMouseMove: null,
      onMouseScroll: null,
      _callback: function _callback(event) {
        var eventType = cc.Event.EventMouse;
        switch (event._eventType) {
         case eventType.DOWN:
          this.onMouseDown && this.onMouseDown(event);
          break;

         case eventType.UP:
          this.onMouseUp && this.onMouseUp(event);
          break;

         case eventType.MOVE:
          this.onMouseMove && this.onMouseMove(event);
          break;

         case eventType.SCROLL:
          this.onMouseScroll && this.onMouseScroll(event);
        }
      },
      clone: function clone() {
        var eventListener = new Mouse();
        eventListener.onMouseDown = this.onMouseDown;
        eventListener.onMouseUp = this.onMouseUp;
        eventListener.onMouseMove = this.onMouseMove;
        eventListener.onMouseScroll = this.onMouseScroll;
        return eventListener;
      },
      checkAvailable: function checkAvailable() {
        return true;
      }
    });
    var TouchOneByOne = function TouchOneByOne() {
      cc.EventListener.call(this, cc.EventListener.TOUCH_ONE_BY_ONE, ListenerID.TOUCH_ONE_BY_ONE, null);
      this._claimedTouches = [];
    };
    js.extend(TouchOneByOne, cc.EventListener);
    js.mixin(TouchOneByOne.prototype, {
      constructor: TouchOneByOne,
      _claimedTouches: null,
      swallowTouches: false,
      onTouchBegan: null,
      onTouchMoved: null,
      onTouchEnded: null,
      onTouchCancelled: null,
      setSwallowTouches: function setSwallowTouches(needSwallow) {
        this.swallowTouches = needSwallow;
      },
      isSwallowTouches: function isSwallowTouches() {
        return this.swallowTouches;
      },
      clone: function clone() {
        var eventListener = new TouchOneByOne();
        eventListener.onTouchBegan = this.onTouchBegan;
        eventListener.onTouchMoved = this.onTouchMoved;
        eventListener.onTouchEnded = this.onTouchEnded;
        eventListener.onTouchCancelled = this.onTouchCancelled;
        eventListener.swallowTouches = this.swallowTouches;
        return eventListener;
      },
      checkAvailable: function checkAvailable() {
        if (!this.onTouchBegan) {
          cc.logID(1801);
          return false;
        }
        return true;
      }
    });
    var TouchAllAtOnce = function TouchAllAtOnce() {
      cc.EventListener.call(this, cc.EventListener.TOUCH_ALL_AT_ONCE, ListenerID.TOUCH_ALL_AT_ONCE, null);
    };
    js.extend(TouchAllAtOnce, cc.EventListener);
    js.mixin(TouchAllAtOnce.prototype, {
      constructor: TouchAllAtOnce,
      onTouchesBegan: null,
      onTouchesMoved: null,
      onTouchesEnded: null,
      onTouchesCancelled: null,
      clone: function clone() {
        var eventListener = new TouchAllAtOnce();
        eventListener.onTouchesBegan = this.onTouchesBegan;
        eventListener.onTouchesMoved = this.onTouchesMoved;
        eventListener.onTouchesEnded = this.onTouchesEnded;
        eventListener.onTouchesCancelled = this.onTouchesCancelled;
        return eventListener;
      },
      checkAvailable: function checkAvailable() {
        if (null === this.onTouchesBegan && null === this.onTouchesMoved && null === this.onTouchesEnded && null === this.onTouchesCancelled) {
          cc.logID(1802);
          return false;
        }
        return true;
      }
    });
    var Acceleration = function Acceleration(callback) {
      this._onAccelerationEvent = callback;
      cc.EventListener.call(this, cc.EventListener.ACCELERATION, ListenerID.ACCELERATION, this._callback);
    };
    js.extend(Acceleration, cc.EventListener);
    js.mixin(Acceleration.prototype, {
      constructor: Acceleration,
      _onAccelerationEvent: null,
      _callback: function _callback(event) {
        this._onAccelerationEvent(event.acc, event);
      },
      checkAvailable: function checkAvailable() {
        cc.assertID(this._onAccelerationEvent, 1803);
        return true;
      },
      clone: function clone() {
        return new Acceleration(this._onAccelerationEvent);
      }
    });
    var Keyboard = function Keyboard() {
      cc.EventListener.call(this, cc.EventListener.KEYBOARD, ListenerID.KEYBOARD, this._callback);
    };
    js.extend(Keyboard, cc.EventListener);
    js.mixin(Keyboard.prototype, {
      constructor: Keyboard,
      onKeyPressed: null,
      onKeyReleased: null,
      _callback: function _callback(event) {
        event.isPressed ? this.onKeyPressed && this.onKeyPressed(event.keyCode, event) : this.onKeyReleased && this.onKeyReleased(event.keyCode, event);
      },
      clone: function clone() {
        var eventListener = new Keyboard();
        eventListener.onKeyPressed = this.onKeyPressed;
        eventListener.onKeyReleased = this.onKeyReleased;
        return eventListener;
      },
      checkAvailable: function checkAvailable() {
        if (null === this.onKeyPressed && null === this.onKeyReleased) {
          cc.logID(1800);
          return false;
        }
        return true;
      }
    });
    cc.EventListener.create = function(argObj) {
      cc.assertID(argObj && argObj.event, 1900);
      var listenerType = argObj.event;
      delete argObj.event;
      var listener = null;
      if (listenerType === cc.EventListener.TOUCH_ONE_BY_ONE) listener = new TouchOneByOne(); else if (listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE) listener = new TouchAllAtOnce(); else if (listenerType === cc.EventListener.MOUSE) listener = new Mouse(); else if (listenerType === cc.EventListener.CUSTOM) {
        listener = new Custom(argObj.eventName, argObj.callback);
        delete argObj.eventName;
        delete argObj.callback;
      } else if (listenerType === cc.EventListener.KEYBOARD) listener = new Keyboard(); else if (listenerType === cc.EventListener.ACCELERATION) {
        listener = new Acceleration(argObj.callback);
        delete argObj.callback;
      }
      for (var key in argObj) listener[key] = argObj[key];
      return listener;
    };
    module.exports = cc.EventListener;
  }), {
    "../platform/js": 294
  } ],
  215: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    require("./CCEventListener");
    var ListenerID = cc.EventListener.ListenerID;
    var _EventListenerVector = function _EventListenerVector() {
      this._fixedListeners = [];
      this._sceneGraphListeners = [];
      this.gt0Index = 0;
    };
    _EventListenerVector.prototype = {
      constructor: _EventListenerVector,
      size: function size() {
        return this._fixedListeners.length + this._sceneGraphListeners.length;
      },
      empty: function empty() {
        return 0 === this._fixedListeners.length && 0 === this._sceneGraphListeners.length;
      },
      push: function push(listener) {
        0 === listener._getFixedPriority() ? this._sceneGraphListeners.push(listener) : this._fixedListeners.push(listener);
      },
      clearSceneGraphListeners: function clearSceneGraphListeners() {
        this._sceneGraphListeners.length = 0;
      },
      clearFixedListeners: function clearFixedListeners() {
        this._fixedListeners.length = 0;
      },
      clear: function clear() {
        this._sceneGraphListeners.length = 0;
        this._fixedListeners.length = 0;
      },
      getFixedPriorityListeners: function getFixedPriorityListeners() {
        return this._fixedListeners;
      },
      getSceneGraphPriorityListeners: function getSceneGraphPriorityListeners() {
        return this._sceneGraphListeners;
      }
    };
    var __getListenerID = function __getListenerID(event) {
      var eventType = cc.Event, type = event.type;
      if (type === eventType.ACCELERATION) return ListenerID.ACCELERATION;
      if (type === eventType.KEYBOARD) return ListenerID.KEYBOARD;
      if (type.startsWith(eventType.MOUSE)) return ListenerID.MOUSE;
      type.startsWith(eventType.TOUCH) && cc.logID(2e3);
      return "";
    };
    var eventManager = {
      DIRTY_NONE: 0,
      DIRTY_FIXED_PRIORITY: 1,
      DIRTY_SCENE_GRAPH_PRIORITY: 2,
      DIRTY_ALL: 3,
      _listenersMap: {},
      _priorityDirtyFlagMap: {},
      _nodeListenersMap: {},
      _toAddedListeners: [],
      _toRemovedListeners: [],
      _dirtyListeners: {},
      _inDispatch: 0,
      _isEnabled: false,
      _currentTouch: null,
      _currentTouchListener: null,
      _internalCustomListenerIDs: [],
      _setDirtyForNode: function _setDirtyForNode(node) {
        var selListeners = this._nodeListenersMap[node._id];
        if (selListeners) for (var j = 0, len = selListeners.length; j < len; j++) {
          var selListener = selListeners[j];
          var listenerID = selListener._getListenerID();
          null == this._dirtyListeners[listenerID] && (this._dirtyListeners[listenerID] = true);
        }
        if (node.childrenCount > 0) {
          var children = node._children;
          for (var i = 0, _len = children.length; i < _len; i++) this._setDirtyForNode(children[i]);
        }
      },
      pauseTarget: function pauseTarget(node, recursive) {
        if (!(node instanceof cc._BaseNode)) {
          cc.warnID(3506);
          return;
        }
        var listeners = this._nodeListenersMap[node._id], i, len;
        if (listeners) for (i = 0, len = listeners.length; i < len; i++) {
          var listener = listeners[i];
          listener._setPaused(true);
          listener._claimedTouches && listener._claimedTouches.includes(this._currentTouch) && this._clearCurTouch();
        }
        if (true === recursive) {
          var locChildren = node._children;
          for (i = 0, len = locChildren ? locChildren.length : 0; i < len; i++) this.pauseTarget(locChildren[i], true);
        }
      },
      resumeTarget: function resumeTarget(node, recursive) {
        if (!(node instanceof cc._BaseNode)) {
          cc.warnID(3506);
          return;
        }
        var listeners = this._nodeListenersMap[node._id], i, len;
        if (listeners) for (i = 0, len = listeners.length; i < len; i++) listeners[i]._setPaused(false);
        this._setDirtyForNode(node);
        if (true === recursive) {
          var locChildren = node._children;
          for (i = 0, len = locChildren ? locChildren.length : 0; i < len; i++) this.resumeTarget(locChildren[i], true);
        }
      },
      _addListener: function _addListener(listener) {
        0 === this._inDispatch ? this._forceAddEventListener(listener) : this._toAddedListeners.push(listener);
      },
      _forceAddEventListener: function _forceAddEventListener(listener) {
        var listenerID = listener._getListenerID();
        var listeners = this._listenersMap[listenerID];
        if (!listeners) {
          listeners = new _EventListenerVector();
          this._listenersMap[listenerID] = listeners;
        }
        listeners.push(listener);
        if (0 === listener._getFixedPriority()) {
          this._setDirty(listenerID, this.DIRTY_SCENE_GRAPH_PRIORITY);
          var node = listener._getSceneGraphPriority();
          null === node && cc.logID(3507);
          this._associateNodeAndEventListener(node, listener);
          node.activeInHierarchy && this.resumeTarget(node);
        } else this._setDirty(listenerID, this.DIRTY_FIXED_PRIORITY);
      },
      _getListeners: function _getListeners(listenerID) {
        return this._listenersMap[listenerID];
      },
      _updateDirtyFlagForSceneGraph: function _updateDirtyFlagForSceneGraph() {
        var locDirtyListeners = this._dirtyListeners;
        for (var selKey in locDirtyListeners) this._setDirty(selKey, this.DIRTY_SCENE_GRAPH_PRIORITY);
        this._dirtyListeners = {};
      },
      _removeAllListenersInVector: function _removeAllListenersInVector(listenerVector) {
        if (!listenerVector) return;
        var selListener;
        for (var i = listenerVector.length - 1; i >= 0; i--) {
          selListener = listenerVector[i];
          selListener._setRegistered(false);
          if (null != selListener._getSceneGraphPriority()) {
            this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
            selListener._setSceneGraphPriority(null);
          }
          0 === this._inDispatch && cc.js.array.removeAt(listenerVector, i);
        }
      },
      _removeListenersForListenerID: function _removeListenersForListenerID(listenerID) {
        var listeners = this._listenersMap[listenerID], i;
        if (listeners) {
          var fixedPriorityListeners = listeners.getFixedPriorityListeners();
          var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
          this._removeAllListenersInVector(sceneGraphPriorityListeners);
          this._removeAllListenersInVector(fixedPriorityListeners);
          delete this._priorityDirtyFlagMap[listenerID];
          if (!this._inDispatch) {
            listeners.clear();
            delete this._listenersMap[listenerID];
          }
        }
        var locToAddedListeners = this._toAddedListeners, listener;
        for (i = locToAddedListeners.length - 1; i >= 0; i--) {
          listener = locToAddedListeners[i];
          listener && listener._getListenerID() === listenerID && cc.js.array.removeAt(locToAddedListeners, i);
        }
      },
      _sortEventListeners: function _sortEventListeners(listenerID) {
        var dirtyFlag = this.DIRTY_NONE, locFlagMap = this._priorityDirtyFlagMap;
        locFlagMap[listenerID] && (dirtyFlag = locFlagMap[listenerID]);
        if (dirtyFlag !== this.DIRTY_NONE) {
          locFlagMap[listenerID] = this.DIRTY_NONE;
          dirtyFlag & this.DIRTY_FIXED_PRIORITY && this._sortListenersOfFixedPriority(listenerID);
          if (dirtyFlag & this.DIRTY_SCENE_GRAPH_PRIORITY) {
            var rootEntity = cc.director.getScene();
            rootEntity && this._sortListenersOfSceneGraphPriority(listenerID);
          }
        }
      },
      _sortListenersOfSceneGraphPriority: function _sortListenersOfSceneGraphPriority(listenerID) {
        var listeners = this._getListeners(listenerID);
        if (!listeners) return;
        var sceneGraphListener = listeners.getSceneGraphPriorityListeners();
        if (!sceneGraphListener || 0 === sceneGraphListener.length) return;
        listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
      },
      _sortEventListenersOfSceneGraphPriorityDes: function _sortEventListenersOfSceneGraphPriorityDes(l1, l2) {
        var node1 = l1._getSceneGraphPriority(), node2 = l2._getSceneGraphPriority();
        if (!(l2 && node2 && node2._activeInHierarchy && null !== node2._parent)) return -1;
        if (!l1 || !node1 || !node1._activeInHierarchy || null === node1._parent) return 1;
        var p1 = node1, p2 = node2, ex = false;
        while (p1._parent._id !== p2._parent._id) {
          p1 = null === p1._parent._parent ? (ex = true) && node2 : p1._parent;
          p2 = null === p2._parent._parent ? (ex = true) && node1 : p2._parent;
        }
        if (p1._id === p2._id) {
          if (p1._id === node2._id) return -1;
          if (p1._id === node1._id) return 1;
        }
        return ex ? p1._localZOrder - p2._localZOrder : p2._localZOrder - p1._localZOrder;
      },
      _sortListenersOfFixedPriority: function _sortListenersOfFixedPriority(listenerID) {
        var listeners = this._listenersMap[listenerID];
        if (!listeners) return;
        var fixedListeners = listeners.getFixedPriorityListeners();
        if (!fixedListeners || 0 === fixedListeners.length) return;
        fixedListeners.sort(this._sortListenersOfFixedPriorityAsc);
        var index = 0;
        for (var len = fixedListeners.length; index < len; ) {
          if (fixedListeners[index]._getFixedPriority() >= 0) break;
          ++index;
        }
        listeners.gt0Index = index;
      },
      _sortListenersOfFixedPriorityAsc: function _sortListenersOfFixedPriorityAsc(l1, l2) {
        return l1._getFixedPriority() - l2._getFixedPriority();
      },
      _onUpdateListeners: function _onUpdateListeners(listeners) {
        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
        var i, selListener, idx, toRemovedListeners = this._toRemovedListeners;
        if (sceneGraphPriorityListeners) for (i = sceneGraphPriorityListeners.length - 1; i >= 0; i--) {
          selListener = sceneGraphPriorityListeners[i];
          if (!selListener._isRegistered()) {
            cc.js.array.removeAt(sceneGraphPriorityListeners, i);
            idx = toRemovedListeners.indexOf(selListener);
            -1 !== idx && toRemovedListeners.splice(idx, 1);
          }
        }
        if (fixedPriorityListeners) for (i = fixedPriorityListeners.length - 1; i >= 0; i--) {
          selListener = fixedPriorityListeners[i];
          if (!selListener._isRegistered()) {
            cc.js.array.removeAt(fixedPriorityListeners, i);
            idx = toRemovedListeners.indexOf(selListener);
            -1 !== idx && toRemovedListeners.splice(idx, 1);
          }
        }
        sceneGraphPriorityListeners && 0 === sceneGraphPriorityListeners.length && listeners.clearSceneGraphListeners();
        fixedPriorityListeners && 0 === fixedPriorityListeners.length && listeners.clearFixedListeners();
      },
      frameUpdateListeners: function frameUpdateListeners() {
        var locListenersMap = this._listenersMap, locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;
        for (var selKey in locListenersMap) if (locListenersMap[selKey].empty()) {
          delete locPriorityDirtyFlagMap[selKey];
          delete locListenersMap[selKey];
        }
        var locToAddedListeners = this._toAddedListeners;
        if (0 !== locToAddedListeners.length) {
          for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
          locToAddedListeners.length = 0;
        }
        0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
      },
      _updateTouchListeners: function _updateTouchListeners(event) {
        var locInDispatch = this._inDispatch;
        cc.assertID(locInDispatch > 0, 3508);
        if (locInDispatch > 1) return;
        var listeners;
        listeners = this._listenersMap[ListenerID.TOUCH_ONE_BY_ONE];
        listeners && this._onUpdateListeners(listeners);
        listeners = this._listenersMap[ListenerID.TOUCH_ALL_AT_ONCE];
        listeners && this._onUpdateListeners(listeners);
        cc.assertID(1 === locInDispatch, 3509);
        var locToAddedListeners = this._toAddedListeners;
        if (0 !== locToAddedListeners.length) {
          for (var i = 0, len = locToAddedListeners.length; i < len; i++) this._forceAddEventListener(locToAddedListeners[i]);
          this._toAddedListeners.length = 0;
        }
        0 !== this._toRemovedListeners.length && this._cleanToRemovedListeners();
      },
      _cleanToRemovedListeners: function _cleanToRemovedListeners() {
        var toRemovedListeners = this._toRemovedListeners;
        for (var i = 0; i < toRemovedListeners.length; i++) {
          var selListener = toRemovedListeners[i];
          var listeners = this._listenersMap[selListener._getListenerID()];
          if (!listeners) continue;
          var idx, fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
          if (sceneGraphPriorityListeners) {
            idx = sceneGraphPriorityListeners.indexOf(selListener);
            -1 !== idx && sceneGraphPriorityListeners.splice(idx, 1);
          }
          if (fixedPriorityListeners) {
            idx = fixedPriorityListeners.indexOf(selListener);
            -1 !== idx && fixedPriorityListeners.splice(idx, 1);
          }
        }
        toRemovedListeners.length = 0;
      },
      _onTouchEventCallback: function _onTouchEventCallback(listener, argsObj) {
        if (!listener._isRegistered()) return false;
        var event = argsObj.event, selTouch = event.currentTouch;
        event.currentTarget = listener._node;
        var isClaimed = false, removedIdx;
        var getCode = event.getEventCode(), EventTouch = cc.Event.EventTouch;
        if (getCode === EventTouch.BEGAN) {
          if (!cc.macro.ENABLE_MULTI_TOUCH && eventManager._currentTouch) {
            var node = eventManager._currentTouchListener._node;
            if (node && node.activeInHierarchy) return false;
          }
          if (listener.onTouchBegan) {
            isClaimed = listener.onTouchBegan(selTouch, event);
            if (isClaimed && listener._registered) {
              listener._claimedTouches.push(selTouch);
              eventManager._currentTouchListener = listener;
              eventManager._currentTouch = selTouch;
            }
          }
        } else if (listener._claimedTouches.length > 0 && -1 !== (removedIdx = listener._claimedTouches.indexOf(selTouch))) {
          isClaimed = true;
          if (!cc.macro.ENABLE_MULTI_TOUCH && eventManager._currentTouch && eventManager._currentTouch !== selTouch) return false;
          if (getCode === EventTouch.MOVED && listener.onTouchMoved) listener.onTouchMoved(selTouch, event); else if (getCode === EventTouch.ENDED) {
            listener.onTouchEnded && listener.onTouchEnded(selTouch, event);
            listener._registered && listener._claimedTouches.splice(removedIdx, 1);
            eventManager._clearCurTouch();
          } else if (getCode === EventTouch.CANCELED) {
            listener.onTouchCancelled && listener.onTouchCancelled(selTouch, event);
            listener._registered && listener._claimedTouches.splice(removedIdx, 1);
            eventManager._clearCurTouch();
          }
        }
        if (event.isStopped()) {
          eventManager._updateTouchListeners(event);
          return true;
        }
        if (isClaimed && listener.swallowTouches) {
          argsObj.needsMutableSet && argsObj.touches.splice(selTouch, 1);
          return true;
        }
        return false;
      },
      _dispatchTouchEvent: function _dispatchTouchEvent(event) {
        this._sortEventListeners(ListenerID.TOUCH_ONE_BY_ONE);
        this._sortEventListeners(ListenerID.TOUCH_ALL_AT_ONCE);
        var oneByOneListeners = this._getListeners(ListenerID.TOUCH_ONE_BY_ONE);
        var allAtOnceListeners = this._getListeners(ListenerID.TOUCH_ALL_AT_ONCE);
        if (null === oneByOneListeners && null === allAtOnceListeners) return;
        var originalTouches = event.getTouches(), mutableTouches = cc.js.array.copy(originalTouches);
        var oneByOneArgsObj = {
          event: event,
          needsMutableSet: oneByOneListeners && allAtOnceListeners,
          touches: mutableTouches,
          selTouch: null
        };
        if (oneByOneListeners) for (var i = 0; i < originalTouches.length; i++) {
          event.currentTouch = originalTouches[i];
          event._propagationStopped = event._propagationImmediateStopped = false;
          this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
        }
        if (allAtOnceListeners && mutableTouches.length > 0) {
          this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
            event: event,
            touches: mutableTouches
          });
          if (event.isStopped()) return;
        }
        this._updateTouchListeners(event);
      },
      _onTouchesEventCallback: function _onTouchesEventCallback(listener, callbackParams) {
        if (!listener._registered) return false;
        var EventTouch = cc.Event.EventTouch, event = callbackParams.event, touches = callbackParams.touches, getCode = event.getEventCode();
        event.currentTarget = listener._node;
        getCode === EventTouch.BEGAN && listener.onTouchesBegan ? listener.onTouchesBegan(touches, event) : getCode === EventTouch.MOVED && listener.onTouchesMoved ? listener.onTouchesMoved(touches, event) : getCode === EventTouch.ENDED && listener.onTouchesEnded ? listener.onTouchesEnded(touches, event) : getCode === EventTouch.CANCELED && listener.onTouchesCancelled && listener.onTouchesCancelled(touches, event);
        if (event.isStopped()) {
          eventManager._updateTouchListeners(event);
          return true;
        }
        return false;
      },
      _associateNodeAndEventListener: function _associateNodeAndEventListener(node, listener) {
        var listeners = this._nodeListenersMap[node._id];
        if (!listeners) {
          listeners = [];
          this._nodeListenersMap[node._id] = listeners;
        }
        listeners.push(listener);
      },
      _dissociateNodeAndEventListener: function _dissociateNodeAndEventListener(node, listener) {
        var listeners = this._nodeListenersMap[node._id];
        if (listeners) {
          cc.js.array.remove(listeners, listener);
          0 === listeners.length && delete this._nodeListenersMap[node._id];
        }
      },
      _dispatchEventToListeners: function _dispatchEventToListeners(listeners, onEvent, eventOrArgs) {
        var shouldStopPropagation = false;
        var fixedPriorityListeners = listeners.getFixedPriorityListeners();
        var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
        var i = 0, j, selListener;
        if (fixedPriorityListeners && 0 !== fixedPriorityListeners.length) for (;i < listeners.gt0Index; ++i) {
          selListener = fixedPriorityListeners[i];
          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
        if (sceneGraphPriorityListeners && !shouldStopPropagation) for (j = 0; j < sceneGraphPriorityListeners.length; j++) {
          selListener = sceneGraphPriorityListeners[j];
          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
        if (fixedPriorityListeners && !shouldStopPropagation) for (;i < fixedPriorityListeners.length; ++i) {
          selListener = fixedPriorityListeners[i];
          if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
            shouldStopPropagation = true;
            break;
          }
        }
      },
      _setDirty: function _setDirty(listenerID, flag) {
        var locDirtyFlagMap = this._priorityDirtyFlagMap;
        null == locDirtyFlagMap[listenerID] ? locDirtyFlagMap[listenerID] = flag : locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
      },
      _sortNumberAsc: function _sortNumberAsc(a, b) {
        return a - b;
      },
      hasEventListener: function hasEventListener(listenerID) {
        return !!this._getListeners(listenerID);
      },
      addListener: function addListener(listener, nodeOrPriority) {
        cc.assertID(listener && nodeOrPriority, 3503);
        if (!(cc.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof cc._BaseNode)) {
          cc.warnID(3506);
          return;
        }
        if (listener instanceof cc.EventListener) {
          if (listener._isRegistered()) {
            cc.logID(3505);
            return;
          }
        } else {
          cc.assertID(!cc.js.isNumber(nodeOrPriority), 3504);
          listener = cc.EventListener.create(listener);
        }
        if (!listener.checkAvailable()) return;
        if (cc.js.isNumber(nodeOrPriority)) {
          if (0 === nodeOrPriority) {
            cc.logID(3500);
            return;
          }
          listener._setSceneGraphPriority(null);
          listener._setFixedPriority(nodeOrPriority);
          listener._setRegistered(true);
          listener._setPaused(false);
          this._addListener(listener);
        } else {
          listener._setSceneGraphPriority(nodeOrPriority);
          listener._setFixedPriority(0);
          listener._setRegistered(true);
          this._addListener(listener);
        }
        return listener;
      },
      addCustomListener: function addCustomListener(eventName, callback) {
        var listener = new cc.EventListener.create({
          event: cc.EventListener.CUSTOM,
          eventName: eventName,
          callback: callback
        });
        this.addListener(listener, 1);
        return listener;
      },
      removeListener: function removeListener(listener) {
        if (null == listener) return;
        var isFound, locListener = this._listenersMap;
        for (var selKey in locListener) {
          var listeners = locListener[selKey];
          var fixedPriorityListeners = listeners.getFixedPriorityListeners(), sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
          isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener);
          if (isFound) this._setDirty(listener._getListenerID(), this.DIRTY_SCENE_GRAPH_PRIORITY); else {
            isFound = this._removeListenerInVector(fixedPriorityListeners, listener);
            isFound && this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
          }
          if (listeners.empty()) {
            delete this._priorityDirtyFlagMap[listener._getListenerID()];
            delete locListener[selKey];
          }
          if (isFound) break;
        }
        if (!isFound) {
          var locToAddedListeners = this._toAddedListeners;
          for (var i = locToAddedListeners.length - 1; i >= 0; i--) {
            var selListener = locToAddedListeners[i];
            if (selListener === listener) {
              cc.js.array.removeAt(locToAddedListeners, i);
              selListener._setRegistered(false);
              break;
            }
          }
        }
        this._currentTouchListener === listener && this._clearCurTouch();
      },
      _clearCurTouch: function _clearCurTouch() {
        this._currentTouchListener = null;
        this._currentTouch = null;
      },
      _removeListenerInCallback: function _removeListenerInCallback(listeners, callback) {
        if (null == listeners) return false;
        for (var i = listeners.length - 1; i >= 0; i--) {
          var selListener = listeners[i];
          if (selListener._onCustomEvent === callback || selListener._onEvent === callback) {
            selListener._setRegistered(false);
            if (null != selListener._getSceneGraphPriority()) {
              this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
              selListener._setSceneGraphPriority(null);
            }
            0 === this._inDispatch ? cc.js.array.removeAt(listeners, i) : this._toRemovedListeners.push(selListener);
            return true;
          }
        }
        return false;
      },
      _removeListenerInVector: function _removeListenerInVector(listeners, listener) {
        if (null == listeners) return false;
        for (var i = listeners.length - 1; i >= 0; i--) {
          var selListener = listeners[i];
          if (selListener === listener) {
            selListener._setRegistered(false);
            if (null != selListener._getSceneGraphPriority()) {
              this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);
              selListener._setSceneGraphPriority(null);
            }
            0 === this._inDispatch ? cc.js.array.removeAt(listeners, i) : this._toRemovedListeners.push(selListener);
            return true;
          }
        }
        return false;
      },
      removeListeners: function removeListeners(listenerType, recursive) {
        var i, _t = this;
        if (!(cc.js.isNumber(listenerType) || listenerType instanceof cc._BaseNode)) {
          cc.warnID(3506);
          return;
        }
        if (void 0 !== listenerType._id) {
          var listeners = _t._nodeListenersMap[listenerType._id], i;
          if (listeners) {
            var listenersCopy = cc.js.array.copy(listeners);
            for (i = 0; i < listenersCopy.length; i++) _t.removeListener(listenersCopy[i]);
            delete _t._nodeListenersMap[listenerType._id];
          }
          var locToAddedListeners = _t._toAddedListeners;
          for (i = 0; i < locToAddedListeners.length; ) {
            var listener = locToAddedListeners[i];
            if (listener._getSceneGraphPriority() === listenerType) {
              listener._setSceneGraphPriority(null);
              listener._setRegistered(false);
              locToAddedListeners.splice(i, 1);
            } else ++i;
          }
          if (true === recursive) {
            var locChildren = listenerType.children, len;
            for (i = 0, len = locChildren.length; i < len; i++) _t.removeListeners(locChildren[i], true);
          }
        } else listenerType === cc.EventListener.TOUCH_ONE_BY_ONE ? _t._removeListenersForListenerID(ListenerID.TOUCH_ONE_BY_ONE) : listenerType === cc.EventListener.TOUCH_ALL_AT_ONCE ? _t._removeListenersForListenerID(ListenerID.TOUCH_ALL_AT_ONCE) : listenerType === cc.EventListener.MOUSE ? _t._removeListenersForListenerID(ListenerID.MOUSE) : listenerType === cc.EventListener.ACCELERATION ? _t._removeListenersForListenerID(ListenerID.ACCELERATION) : listenerType === cc.EventListener.KEYBOARD ? _t._removeListenersForListenerID(ListenerID.KEYBOARD) : cc.logID(3501);
      },
      removeCustomListeners: function removeCustomListeners(customEventName) {
        this._removeListenersForListenerID(customEventName);
      },
      removeAllListeners: function removeAllListeners() {
        var locListeners = this._listenersMap, locInternalCustomEventIDs = this._internalCustomListenerIDs;
        for (var selKey in locListeners) -1 === locInternalCustomEventIDs.indexOf(selKey) && this._removeListenersForListenerID(selKey);
      },
      setPriority: function setPriority(listener, fixedPriority) {
        if (null == listener) return;
        var locListeners = this._listenersMap;
        for (var selKey in locListeners) {
          var selListeners = locListeners[selKey];
          var fixedPriorityListeners = selListeners.getFixedPriorityListeners();
          if (fixedPriorityListeners) {
            var found = fixedPriorityListeners.indexOf(listener);
            if (-1 !== found) {
              null != listener._getSceneGraphPriority() && cc.logID(3502);
              if (listener._getFixedPriority() !== fixedPriority) {
                listener._setFixedPriority(fixedPriority);
                this._setDirty(listener._getListenerID(), this.DIRTY_FIXED_PRIORITY);
              }
              return;
            }
          }
        }
      },
      setEnabled: function setEnabled(enabled) {
        this._isEnabled = enabled;
      },
      isEnabled: function isEnabled() {
        return this._isEnabled;
      },
      dispatchEvent: function dispatchEvent(event) {
        if (!this._isEnabled) return;
        this._updateDirtyFlagForSceneGraph();
        this._inDispatch++;
        if (!event || !event.getType) {
          cc.errorID(3511);
          return;
        }
        if (event.getType().startsWith(cc.Event.TOUCH)) {
          this._dispatchTouchEvent(event);
          this._inDispatch--;
          return;
        }
        var listenerID = __getListenerID(event);
        this._sortEventListeners(listenerID);
        var selListeners = this._listenersMap[listenerID];
        if (null != selListeners) {
          this._dispatchEventToListeners(selListeners, this._onListenerCallback, event);
          this._onUpdateListeners(selListeners);
        }
        this._inDispatch--;
      },
      _onListenerCallback: function _onListenerCallback(listener, event) {
        event.currentTarget = listener._target;
        listener._onEvent(event);
        return event.isStopped();
      },
      dispatchCustomEvent: function dispatchCustomEvent(eventName, optionalUserData) {
        var ev = new cc.Event.EventCustom(eventName);
        ev.setUserData(optionalUserData);
        this.dispatchEvent(ev);
      }
    };
    js.get(cc, "eventManager", (function() {
      cc.errorID(1405, "cc.eventManager", "cc.EventTarget or cc.systemEvent");
      return eventManager;
    }));
    module.exports = cc.internal.eventManager = eventManager;
  }), {
    "../platform/js": 294,
    "./CCEventListener": 214
  } ],
  216: [ (function(require, module, exports) {
    "use strict";
    cc.Touch = function(x, y, id) {
      this._lastModified = 0;
      this.setTouchInfo(id, x, y);
    };
    cc.Touch.prototype = {
      constructor: cc.Touch,
      getLocation: function getLocation() {
        return cc.v2(this._point.x, this._point.y);
      },
      getLocationX: function getLocationX() {
        return this._point.x;
      },
      getLocationY: function getLocationY() {
        return this._point.y;
      },
      getPreviousLocation: function getPreviousLocation() {
        return cc.v2(this._prevPoint.x, this._prevPoint.y);
      },
      getStartLocation: function getStartLocation() {
        return cc.v2(this._startPoint.x, this._startPoint.y);
      },
      getDelta: function getDelta() {
        return this._point.sub(this._prevPoint);
      },
      getLocationInView: function getLocationInView() {
        return cc.v2(this._point.x, cc.view._designResolutionSize.height - this._point.y);
      },
      getPreviousLocationInView: function getPreviousLocationInView() {
        return cc.v2(this._prevPoint.x, cc.view._designResolutionSize.height - this._prevPoint.y);
      },
      getStartLocationInView: function getStartLocationInView() {
        return cc.v2(this._startPoint.x, cc.view._designResolutionSize.height - this._startPoint.y);
      },
      getID: function getID() {
        return this._id;
      },
      setTouchInfo: function setTouchInfo(id, x, y) {
        this._prevPoint = this._point;
        this._point = cc.v2(x || 0, y || 0);
        this._id = id;
        if (!this._startPointCaptured) {
          this._startPoint = cc.v2(this._point);
          cc.view._convertPointWithScale(this._startPoint);
          this._startPointCaptured = true;
        }
      },
      _setPoint: function _setPoint(x, y) {
        if (void 0 === y) {
          this._point.x = x.x;
          this._point.y = x.y;
        } else {
          this._point.x = x;
          this._point.y = y;
        }
      },
      _setPrevPoint: function _setPrevPoint(x, y) {
        this._prevPoint = void 0 === y ? cc.v2(x.x, x.y) : cc.v2(x || 0, y || 0);
      }
    };
  }), {} ],
  217: [ (function(require, module, exports) {
    "use strict";
    require("./CCEvent");
    require("./CCTouch");
    require("./CCEventListener");
    var eventManager = require("./CCEventManager");
    module.exports = eventManager;
    false;
  }), {
    "./CCEvent": 213,
    "./CCEventListener": 214,
    "./CCEventManager": 215,
    "./CCTouch": 216
  } ],
  218: [ (function(require, module, exports) {
    "use strict";
    var js = cc.js;
    var CallbacksInvoker = require("../platform/callbacks-invoker");
    function EventListeners() {
      CallbacksInvoker.call(this);
    }
    js.extend(EventListeners, CallbacksInvoker);
    EventListeners.prototype.emit = function(event, captureListeners) {
      var key = event.type;
      var list = this._callbackTable[key];
      if (list) {
        var rootInvoker = !list.isInvoking;
        list.isInvoking = true;
        var infos = list.callbackInfos;
        for (var i = 0, len = infos.length; i < len; ++i) {
          var info = infos[i];
          if (info && info.callback) {
            info.callback.call(info.target, event, captureListeners);
            if (event._propagationImmediateStopped) break;
          }
        }
        if (rootInvoker) {
          list.isInvoking = false;
          list.containCanceled && list.purgeCanceled();
        }
      }
    };
    module.exports = EventListeners;
    false;
  }), {
    "../platform/callbacks-invoker": 285
  } ],
  219: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    var CallbacksInvoker = require("../platform/callbacks-invoker");
    var fastRemove = js.array.fastRemove;
    function EventTarget() {
      CallbacksInvoker.call(this);
    }
    js.extend(EventTarget, CallbacksInvoker);
    var proto = EventTarget.prototype;
    proto.__on = proto.on;
    proto.on = function(type, callback, target, once) {
      if (!callback) {
        cc.errorID(6800);
        return;
      }
      if (!this.hasEventListener(type, callback, target)) {
        this.__on(type, callback, target, once);
        target && target.__eventTargets && target.__eventTargets.push(this);
      }
      return callback;
    };
    proto.__off = proto.off;
    proto.off = function(type, callback, target) {
      if (callback) {
        this.__off(type, callback, target);
        target && target.__eventTargets && fastRemove(target.__eventTargets, this);
      } else {
        var list = this._callbackTable[type];
        if (!list) return;
        var infos = list.callbackInfos;
        for (var i = 0; i < infos.length; ++i) {
          var _target = infos[i] && infos[i].target;
          _target && _target.__eventTargets && fastRemove(_target.__eventTargets, this);
        }
        this.removeAll(type);
      }
    };
    proto.targetOff = function(target) {
      this.removeAll(target);
      target && target.__eventTargets && fastRemove(target.__eventTargets, this);
    };
    proto.once = function(type, callback, target) {
      this.on(type, callback, target, true);
    };
    proto.dispatchEvent = function(event) {
      this.emit(event.type, event);
    };
    proto.clear = function() {
      for (var key in this._callbackTable) {
        var list = this._callbackTable[key];
        var infos = list.callbackInfos;
        for (var i = infos.length - 1; i >= 0; i--) {
          var info = infos[i];
          info && this.off(key, info.callback, info.target);
        }
      }
    };
    cc.EventTarget = module.exports = EventTarget;
  }), {
    "../platform/callbacks-invoker": 285,
    "../platform/js": 294
  } ],
  220: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    cc.Event = function(type, bubbles) {
      this.type = type;
      this.bubbles = !!bubbles;
      this.target = null;
      this.currentTarget = null;
      this.eventPhase = 0;
      this._propagationStopped = false;
      this._propagationImmediateStopped = false;
    };
    cc.Event.prototype = {
      constructor: cc.Event,
      unuse: function unuse() {
        this.type = cc.Event.NO_TYPE;
        this.target = null;
        this.currentTarget = null;
        this.eventPhase = cc.Event.NONE;
        this._propagationStopped = false;
        this._propagationImmediateStopped = false;
      },
      reuse: function reuse(type, bubbles) {
        this.type = type;
        this.bubbles = bubbles || false;
      },
      stopPropagation: function stopPropagation() {
        this._propagationStopped = true;
      },
      stopPropagationImmediate: function stopPropagationImmediate() {
        this._propagationImmediateStopped = true;
      },
      isStopped: function isStopped() {
        return this._propagationStopped || this._propagationImmediateStopped;
      },
      getCurrentTarget: function getCurrentTarget() {
        return this.currentTarget;
      },
      getType: function getType() {
        return this.type;
      }
    };
    cc.Event.NO_TYPE = "no_type";
    cc.Event.TOUCH = "touch";
    cc.Event.MOUSE = "mouse";
    cc.Event.KEYBOARD = "keyboard";
    cc.Event.ACCELERATION = "acceleration";
    cc.Event.NONE = 0;
    cc.Event.CAPTURING_PHASE = 1;
    cc.Event.AT_TARGET = 2;
    cc.Event.BUBBLING_PHASE = 3;
    var EventCustom = function EventCustom(type, bubbles) {
      cc.Event.call(this, type, bubbles);
      this.detail = null;
    };
    js.extend(EventCustom, cc.Event);
    EventCustom.prototype.reset = EventCustom;
    EventCustom.prototype.setUserData = function(data) {
      this.detail = data;
    };
    EventCustom.prototype.getUserData = function() {
      return this.detail;
    };
    EventCustom.prototype.getEventName = cc.Event.prototype.getType;
    var MAX_POOL_SIZE = 10;
    var _eventPool = new js.Pool(MAX_POOL_SIZE);
    EventCustom.put = function(event) {
      _eventPool.put(event);
    };
    EventCustom.get = function(type, bubbles) {
      var event = _eventPool._get();
      event ? event.reset(type, bubbles) : event = new EventCustom(type, bubbles);
      return event;
    };
    cc.Event.EventCustom = EventCustom;
    module.exports = cc.Event;
  }), {
    "../platform/js": 294
  } ],
  221: [ (function(require, module, exports) {
    "use strict";
    require("./event");
    require("./event-listeners");
    require("./event-target");
    require("./system-event");
  }), {
    "./event": 220,
    "./event-listeners": 218,
    "./event-target": 219,
    "./system-event": 222
  } ],
  222: [ (function(require, module, exports) {
    "use strict";
    var EventTarget = require("../event/event-target");
    var eventManager = require("../event-manager");
    var inputManger = require("../platform/CCInputManager");
    var EventType = cc.Enum({
      KEY_DOWN: "keydown",
      KEY_UP: "keyup",
      DEVICEMOTION: "devicemotion"
    });
    var keyboardListener = null;
    var accelerationListener = null;
    var SystemEvent = cc.Class({
      name: "SystemEvent",
      extends: EventTarget,
      statics: {
        EventType: EventType
      },
      setAccelerometerEnabled: function setAccelerometerEnabled(isEnable) {
        false;
        isEnable && window.DeviceMotionEvent && "function" === typeof DeviceMotionEvent.requestPermission ? DeviceMotionEvent.requestPermission().then((function(response) {
          console.log("Device Motion Event request permission: " + response);
          inputManger.setAccelerometerEnabled("granted" === response);
        })) : inputManger.setAccelerometerEnabled(isEnable);
      },
      setAccelerometerInterval: function setAccelerometerInterval(interval) {
        false;
        inputManger.setAccelerometerInterval(interval);
      },
      on: function on(type, callback, target, once) {
        false;
        this._super(type, callback, target, once);
        if (type === EventType.KEY_DOWN || type === EventType.KEY_UP) {
          keyboardListener || (keyboardListener = cc.EventListener.create({
            event: cc.EventListener.KEYBOARD,
            onKeyPressed: function onKeyPressed(keyCode, event) {
              event.type = EventType.KEY_DOWN;
              cc.systemEvent.dispatchEvent(event);
            },
            onKeyReleased: function onKeyReleased(keyCode, event) {
              event.type = EventType.KEY_UP;
              cc.systemEvent.dispatchEvent(event);
            }
          }));
          eventManager.hasEventListener(cc.EventListener.ListenerID.KEYBOARD) || eventManager.addListener(keyboardListener, 1);
        }
        if (type === EventType.DEVICEMOTION) {
          accelerationListener || (accelerationListener = cc.EventListener.create({
            event: cc.EventListener.ACCELERATION,
            callback: function callback(acc, event) {
              event.type = EventType.DEVICEMOTION;
              cc.systemEvent.dispatchEvent(event);
            }
          }));
          eventManager.hasEventListener(cc.EventListener.ListenerID.ACCELERATION) || eventManager.addListener(accelerationListener, 1);
        }
      },
      off: function off(type, callback, target) {
        false;
        this._super(type, callback, target);
        if (keyboardListener && (type === EventType.KEY_DOWN || type === EventType.KEY_UP)) {
          var hasKeyDownEventListener = this.hasEventListener(EventType.KEY_DOWN);
          var hasKeyUpEventListener = this.hasEventListener(EventType.KEY_UP);
          hasKeyDownEventListener || hasKeyUpEventListener || eventManager.removeListener(keyboardListener);
        }
        accelerationListener && type === EventType.DEVICEMOTION && eventManager.removeListener(accelerationListener);
      }
    });
    cc.SystemEvent = module.exports = SystemEvent;
    cc.systemEvent = new cc.SystemEvent();
  }), {
    "../event-manager": 217,
    "../event/event-target": 219,
    "../platform/CCInputManager": 276
  } ],
  223: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vec = _interopRequireDefault(require("../value-types/vec3"));
    var _mat = _interopRequireDefault(require("../value-types/mat3"));
    var _enums = _interopRequireDefault(require("./enums"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _v3_tmp = new _vec["default"]();
    var _v3_tmp2 = new _vec["default"]();
    var _m3_tmp = new _mat["default"]();
    var transform_extent_m4 = function transform_extent_m4(out, extent, m4) {
      var _m3_tmpm = _m3_tmp.m, m4m = m4.m;
      _m3_tmpm[0] = Math.abs(m4m[0]);
      _m3_tmpm[1] = Math.abs(m4m[1]);
      _m3_tmpm[2] = Math.abs(m4m[2]);
      _m3_tmpm[3] = Math.abs(m4m[4]);
      _m3_tmpm[4] = Math.abs(m4m[5]);
      _m3_tmpm[5] = Math.abs(m4m[6]);
      _m3_tmpm[6] = Math.abs(m4m[8]);
      _m3_tmpm[7] = Math.abs(m4m[9]);
      _m3_tmpm[8] = Math.abs(m4m[10]);
      _vec["default"].transformMat3(out, extent, _m3_tmp);
    };
    var aabb = (function() {
      aabb.create = function create(px, py, pz, w, h, l) {
        return new aabb(px, py, pz, w, h, l);
      };
      aabb.clone = function clone(a) {
        return new aabb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
      };
      aabb.copy = function copy(out, a) {
        _vec["default"].copy(out.center, a.center);
        _vec["default"].copy(out.halfExtents, a.halfExtents);
        return out;
      };
      aabb.fromPoints = function fromPoints(out, minPos, maxPos) {
        _vec["default"].scale(out.center, _vec["default"].add(_v3_tmp, minPos, maxPos), .5);
        _vec["default"].scale(out.halfExtents, _vec["default"].sub(_v3_tmp2, maxPos, minPos), .5);
        return out;
      };
      aabb.set = function set(out, px, py, pz, w, h, l) {
        _vec["default"].set(out.center, px, py, pz);
        _vec["default"].set(out.halfExtents, w, h, l);
        return out;
      };
      function aabb(px, py, pz, w, h, l) {
        this.center = void 0;
        this.halfExtents = void 0;
        this._type = void 0;
        this._type = _enums["default"].SHAPE_AABB;
        this.center = new _vec["default"](px, py, pz);
        this.halfExtents = new _vec["default"](w, h, l);
      }
      var _proto = aabb.prototype;
      _proto.getBoundary = function getBoundary(minPos, maxPos) {
        _vec["default"].sub(minPos, this.center, this.halfExtents);
        _vec["default"].add(maxPos, this.center, this.halfExtents);
      };
      _proto.transform = function transform(m, pos, rot, scale, out) {
        out || (out = this);
        _vec["default"].transformMat4(out.center, this.center, m);
        transform_extent_m4(out.halfExtents, this.halfExtents, m);
      };
      return aabb;
    })();
    exports["default"] = aabb;
    module.exports = exports["default"];
  }), {
    "../value-types/mat3": 402,
    "../value-types/vec3": 411,
    "./enums": 225
  } ],
  224: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.point_plane = point_plane;
    exports.pt_point_aabb = pt_point_aabb;
    exports.pt_point_obb = pt_point_obb;
    exports.pt_point_plane = pt_point_plane;
    var _valueTypes = require("../value-types");
    var X = new _valueTypes.Vec3();
    var Y = new _valueTypes.Vec3();
    var Z = new _valueTypes.Vec3();
    var d = new _valueTypes.Vec3();
    var min = new _valueTypes.Vec3();
    var max = new _valueTypes.Vec3();
    var u = new Array(3);
    var e = new Array(3);
    function point_plane(point, plane_) {
      return _valueTypes.Vec3.dot(plane_.n, point) - plane_.d;
    }
    function pt_point_plane(out, point, plane_) {
      var t = point_plane(point, plane_);
      return _valueTypes.Vec3.subtract(out, point, _valueTypes.Vec3.multiplyScalar(out, plane_.n, t));
    }
    function pt_point_aabb(out, point, aabb_) {
      _valueTypes.Vec3.copy(out, point);
      _valueTypes.Vec3.subtract(min, aabb_.center, aabb_.halfExtents);
      _valueTypes.Vec3.add(max, aabb_.center, aabb_.halfExtents);
      out.x = out.x < min.x ? min.x : out.x;
      out.y = out.y < min.x ? min.y : out.y;
      out.z = out.z < min.x ? min.z : out.z;
      out.x = out.x > max.x ? max.x : out.x;
      out.y = out.y > max.x ? max.y : out.y;
      out.z = out.z > max.x ? max.z : out.z;
      return out;
    }
    function pt_point_obb(out, point, obb_) {
      var obbm = obb_.orientation.m;
      _valueTypes.Vec3.set(X, obbm[0], obbm[1], obbm[2]);
      _valueTypes.Vec3.set(Y, obbm[3], obbm[4], obbm[5]);
      _valueTypes.Vec3.set(Z, obbm[6], obbm[7], obbm[8]);
      u[0] = X;
      u[1] = Y;
      u[2] = Z;
      e[0] = obb_.halfExtents.x;
      e[1] = obb_.halfExtents.y;
      e[2] = obb_.halfExtents.z;
      _valueTypes.Vec3.subtract(d, point, obb_.center);
      _valueTypes.Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z);
      for (var i = 0; i < 3; i++) {
        var dist = _valueTypes.Vec3.dot(d, u[i]);
        dist > e[i] && (dist = e[i]);
        dist < -e[i] && (dist = -e[i]);
        out.x += dist * u[i].x;
        out.y += dist * u[i].y;
        out.z += dist * u[i].z;
      }
      return out;
    }
  }), {
    "../value-types": 401
  } ],
  225: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _default = {
      SHAPE_RAY: 1,
      SHAPE_LINE: 2,
      SHAPE_SPHERE: 4,
      SHAPE_AABB: 8,
      SHAPE_OBB: 16,
      SHAPE_PLANE: 32,
      SHAPE_TRIANGLE: 64,
      SHAPE_FRUSTUM: 128,
      SHAPE_FRUSTUM_ACCURATE: 256
    };
    exports["default"] = _default;
    module.exports = exports["default"];
  }), {} ],
  226: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueTypes = require("../value-types");
    var _enums = _interopRequireDefault(require("./enums"));
    var _plane = _interopRequireDefault(require("./plane"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var _v = new Array(8);
    _v[0] = new _valueTypes.Vec3(1, 1, 1);
    _v[1] = new _valueTypes.Vec3(-1, 1, 1);
    _v[2] = new _valueTypes.Vec3(-1, -1, 1);
    _v[3] = new _valueTypes.Vec3(1, -1, 1);
    _v[4] = new _valueTypes.Vec3(1, 1, -1);
    _v[5] = new _valueTypes.Vec3(-1, 1, -1);
    _v[6] = new _valueTypes.Vec3(-1, -1, -1);
    _v[7] = new _valueTypes.Vec3(1, -1, -1);
    var frustum = (function() {
      frustum.create = function create() {
        return new frustum();
      };
      frustum.clone = function clone(f) {
        return frustum.copy(new frustum(), f);
      };
      frustum.copy = function copy(out, f) {
        out._type = f._type;
        for (var i = 0; i < 6; ++i) _plane["default"].copy(out.planes[i], f.planes[i]);
        for (var _i = 0; _i < 8; ++_i) _valueTypes.Vec3.copy(out.vertices[_i], f.vertices[_i]);
        return out;
      };
      function frustum() {
        this.planes = void 0;
        this.vertices = void 0;
        this._type = void 0;
        this._type = _enums["default"].SHAPE_FRUSTUM;
        this.planes = new Array(6);
        for (var i = 0; i < 6; ++i) this.planes[i] = _plane["default"].create(0, 0, 0, 0);
        this.vertices = new Array(8);
        for (var _i2 = 0; _i2 < 8; ++_i2) this.vertices[_i2] = new _valueTypes.Vec3();
      }
      var _proto = frustum.prototype;
      _proto.update = function update(m, inv) {
        var mm = m.m;
        _valueTypes.Vec3.set(this.planes[0].n, mm[3] + mm[0], mm[7] + mm[4], mm[11] + mm[8]);
        this.planes[0].d = -(mm[15] + mm[12]);
        _valueTypes.Vec3.set(this.planes[1].n, mm[3] - mm[0], mm[7] - mm[4], mm[11] - mm[8]);
        this.planes[1].d = -(mm[15] - mm[12]);
        _valueTypes.Vec3.set(this.planes[2].n, mm[3] + mm[1], mm[7] + mm[5], mm[11] + mm[9]);
        this.planes[2].d = -(mm[15] + mm[13]);
        _valueTypes.Vec3.set(this.planes[3].n, mm[3] - mm[1], mm[7] - mm[5], mm[11] - mm[9]);
        this.planes[3].d = -(mm[15] - mm[13]);
        _valueTypes.Vec3.set(this.planes[4].n, mm[3] + mm[2], mm[7] + mm[6], mm[11] + mm[10]);
        this.planes[4].d = -(mm[15] + mm[14]);
        _valueTypes.Vec3.set(this.planes[5].n, mm[3] - mm[2], mm[7] - mm[6], mm[11] - mm[10]);
        this.planes[5].d = -(mm[15] - mm[14]);
        if (this._type !== _enums["default"].SHAPE_FRUSTUM_ACCURATE) return;
        for (var i = 0; i < 6; i++) {
          var pl = this.planes[i];
          var invDist = 1 / pl.n.length();
          _valueTypes.Vec3.multiplyScalar(pl.n, pl.n, invDist);
          pl.d *= invDist;
        }
        for (var _i3 = 0; _i3 < 8; _i3++) _valueTypes.Vec3.transformMat4(this.vertices[_i3], _v[_i3], inv);
      };
      _proto.transform = function transform(mat) {
        if (this._type !== _enums["default"].SHAPE_FRUSTUM_ACCURATE) return;
        for (var i = 0; i < 8; i++) _valueTypes.Vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
        _plane["default"].fromPoints(this.planes[0], this.vertices[1], this.vertices[5], this.vertices[6]);
        _plane["default"].fromPoints(this.planes[1], this.vertices[3], this.vertices[7], this.vertices[4]);
        _plane["default"].fromPoints(this.planes[2], this.vertices[6], this.vertices[7], this.vertices[3]);
        _plane["default"].fromPoints(this.planes[3], this.vertices[0], this.vertices[4], this.vertices[5]);
        _plane["default"].fromPoints(this.planes[4], this.vertices[2], this.vertices[3], this.vertices[0]);
        _plane["default"].fromPoints(this.planes[0], this.vertices[7], this.vertices[6], this.vertices[5]);
      };
      _createClass(frustum, [ {
        key: "accurate",
        set: function set(b) {
          this._type = b ? _enums["default"].SHAPE_FRUSTUM_ACCURATE : _enums["default"].SHAPE_FRUSTUM;
        }
      } ]);
      return frustum;
    })();
    exports["default"] = frustum;
    frustum.createOrtho = (function() {
      var _temp_v3 = new _valueTypes.Vec3();
      return function(out, width, height, near, far, transform) {
        var halfWidth = width / 2;
        var halfHeight = height / 2;
        _valueTypes.Vec3.set(_temp_v3, halfWidth, halfHeight, near);
        _valueTypes.Vec3.transformMat4(out.vertices[0], _temp_v3, transform);
        _valueTypes.Vec3.set(_temp_v3, -halfWidth, halfHeight, near);
        _valueTypes.Vec3.transformMat4(out.vertices[1], _temp_v3, transform);
        _valueTypes.Vec3.set(_temp_v3, -halfWidth, -halfHeight, near);
        _valueTypes.Vec3.transformMat4(out.vertices[2], _temp_v3, transform);
        _valueTypes.Vec3.set(_temp_v3, halfWidth, -halfHeight, near);
        _valueTypes.Vec3.transformMat4(out.vertices[3], _temp_v3, transform);
        _valueTypes.Vec3.set(_temp_v3, halfWidth, halfHeight, far);
        _valueTypes.Vec3.transformMat4(out.vertices[4], _temp_v3, transform);
        _valueTypes.Vec3.set(_temp_v3, -halfWidth, halfHeight, far);
        _valueTypes.Vec3.transformMat4(out.vertices[5], _temp_v3, transform);
        _valueTypes.Vec3.set(_temp_v3, -halfWidth, -halfHeight, far);
        _valueTypes.Vec3.transformMat4(out.vertices[6], _temp_v3, transform);
        _valueTypes.Vec3.set(_temp_v3, halfWidth, -halfHeight, far);
        _valueTypes.Vec3.transformMat4(out.vertices[7], _temp_v3, transform);
        _plane["default"].fromPoints(out.planes[0], out.vertices[1], out.vertices[6], out.vertices[5]);
        _plane["default"].fromPoints(out.planes[1], out.vertices[3], out.vertices[4], out.vertices[7]);
        _plane["default"].fromPoints(out.planes[2], out.vertices[6], out.vertices[3], out.vertices[7]);
        _plane["default"].fromPoints(out.planes[3], out.vertices[0], out.vertices[5], out.vertices[4]);
        _plane["default"].fromPoints(out.planes[4], out.vertices[2], out.vertices[0], out.vertices[3]);
        _plane["default"].fromPoints(out.planes[0], out.vertices[7], out.vertices[5], out.vertices[6]);
      };
    })();
    module.exports = exports["default"];
  }), {
    "../value-types": 401,
    "./enums": 225,
    "./plane": 231
  } ],
  227: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _exportNames = {
      enums: true,
      Triangle: true,
      Aabb: true,
      Ray: true,
      intersect: true,
      Sphere: true,
      Obb: true,
      Frustum: true,
      Line: true,
      Plane: true
    };
    exports.intersect = exports.enums = exports.Triangle = exports.Sphere = exports.Ray = exports.Plane = exports.Obb = exports.Line = exports.Frustum = exports.Aabb = void 0;
    var _enums = _interopRequireDefault(require("./enums"));
    exports.enums = _enums["default"];
    var _triangle = _interopRequireDefault(require("./triangle"));
    exports.Triangle = _triangle["default"];
    var _aabb = _interopRequireDefault(require("./aabb"));
    exports.Aabb = _aabb["default"];
    var _ray = _interopRequireDefault(require("./ray"));
    exports.Ray = _ray["default"];
    var _intersect = _interopRequireDefault(require("./intersect"));
    exports.intersect = _intersect["default"];
    var _sphere = _interopRequireDefault(require("./sphere"));
    exports.Sphere = _sphere["default"];
    var _obb = _interopRequireDefault(require("./obb"));
    exports.Obb = _obb["default"];
    var _frustum = _interopRequireDefault(require("./frustum"));
    exports.Frustum = _frustum["default"];
    var _line = _interopRequireDefault(require("./line"));
    exports.Line = _line["default"];
    var _plane = _interopRequireDefault(require("./plane"));
    exports.Plane = _plane["default"];
    var _distance = require("./distance");
    Object.keys(_distance).forEach((function(key) {
      if ("default" === key || "__esModule" === key) return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _distance[key]) return;
      exports[key] = _distance[key];
    }));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    cc.geomUtils = module.exports;
  }), {
    "./aabb": 223,
    "./distance": 224,
    "./enums": 225,
    "./frustum": 226,
    "./intersect": 228,
    "./line": 229,
    "./obb": 230,
    "./plane": 231,
    "./ray": 232,
    "./sphere": 233,
    "./triangle": 234
  } ],
  228: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _gfx = _interopRequireDefault(require("../../renderer/gfx"));
    var _recyclePool = _interopRequireDefault(require("../../renderer/memop/recycle-pool"));
    var _valueTypes = require("../value-types");
    var _aabb = _interopRequireDefault(require("./aabb"));
    var distance = _interopRequireWildcard(require("./distance"));
    var _enums = _interopRequireDefault(require("./enums"));
    var _ray = _interopRequireDefault(require("./ray"));
    var _triangle = _interopRequireDefault(require("./triangle"));
    function _getRequireWildcardCache(nodeInterop) {
      if ("function" !== typeof WeakMap) return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) return obj;
      if (null === obj || "object" !== typeof obj && "function" !== typeof obj) return {
        default: obj
      };
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) return cache.get(obj);
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
      }
      newObj["default"] = obj;
      cache && cache.set(obj, newObj);
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ray_mesh = (function() {
      var tri = _triangle["default"].create();
      var minDist = Infinity;
      function getVec3(out, data, idx, stride) {
        _valueTypes.Vec3.set(out, data[idx * stride], data[idx * stride + 1], data[idx * stride + 2]);
      }
      return function(ray, mesh) {
        minDist = Infinity;
        var subMeshes = mesh._subMeshes;
        for (var i = 0; i < subMeshes.length; i++) {
          if (subMeshes[i]._primitiveType !== _gfx["default"].PT_TRIANGLES) continue;
          var subData = mesh._subDatas[i] || mesh._subDatas[0];
          var posData = mesh._getAttrMeshData(i, _gfx["default"].ATTR_POSITION);
          var iData = subData.getIData(Uint16Array);
          var format = subData.vfm;
          var fmt = format.element(_gfx["default"].ATTR_POSITION);
          var num = fmt.num;
          for (var _i = 0; _i < iData.length; _i += 3) {
            getVec3(tri.a, posData, iData[_i], num);
            getVec3(tri.b, posData, iData[_i + 1], num);
            getVec3(tri.c, posData, iData[_i + 2], num);
            var dist = ray_triangle(ray, tri);
            dist > 0 && dist < minDist && (minDist = dist);
          }
        }
        return minDist;
      };
    })();
    var rayMesh = ray_mesh;
    var ray_cast = (function() {
      function traversal(node, cb) {
        var children = node.children;
        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];
          traversal(child, cb);
        }
        cb(node);
      }
      function cmp(a, b) {
        return a.distance - b.distance;
      }
      function transformMat4Normal(out, a, m) {
        var mm = m.m;
        var x = a.x, y = a.y, z = a.z, rhw = mm[3] * x + mm[7] * y + mm[11] * z;
        rhw = rhw ? 1 / rhw : 1;
        out.x = (mm[0] * x + mm[4] * y + mm[8] * z) * rhw;
        out.y = (mm[1] * x + mm[5] * y + mm[9] * z) * rhw;
        out.z = (mm[2] * x + mm[6] * y + mm[10] * z) * rhw;
        return out;
      }
      var resultsPool = new _recyclePool["default"](function() {
        return {
          distance: 0,
          node: null
        };
      }, 1);
      var results = [];
      var nodeAabb = _aabb["default"].create();
      var minPos = new _valueTypes.Vec3();
      var maxPos = new _valueTypes.Vec3();
      var modelRay = new _ray["default"]();
      var m4_1 = cc.mat4();
      var m4_2 = cc.mat4();
      var d = new _valueTypes.Vec3();
      function distanceValid(distance) {
        return distance > 0 && distance < Infinity;
      }
      return function(root, worldRay, handler, filter) {
        resultsPool.reset();
        results.length = 0;
        root = root || cc.director.getScene();
        traversal(root, (function(node) {
          if (filter && !filter(node)) return;
          _valueTypes.Mat4.invert(m4_2, node.getWorldMatrix(m4_1));
          _valueTypes.Vec3.transformMat4(modelRay.o, worldRay.o, m4_2);
          _valueTypes.Vec3.normalize(modelRay.d, transformMat4Normal(modelRay.d, worldRay.d, m4_2));
          var distance = Infinity;
          var component = node._renderComponent;
          if (component instanceof cc.MeshRenderer) distance = ray_aabb(modelRay, component._boundingBox); else if (node.width && node.height) {
            _valueTypes.Vec3.set(minPos, -node.width * node.anchorX, -node.height * node.anchorY, node.z);
            _valueTypes.Vec3.set(maxPos, node.width * (1 - node.anchorX), node.height * (1 - node.anchorY), node.z);
            _aabb["default"].fromPoints(nodeAabb, minPos, maxPos);
            distance = ray_aabb(modelRay, nodeAabb);
          }
          if (!distanceValid(distance)) return;
          handler && (distance = handler(modelRay, node, distance));
          if (distanceValid(distance)) {
            _valueTypes.Vec3.scale(d, modelRay.d, distance);
            transformMat4Normal(d, d, m4_1);
            var res = resultsPool.add();
            res.node = node;
            res.distance = _valueTypes.Vec3.mag(d);
            results.push(res);
          }
        }));
        results.sort(cmp);
        return results;
      };
    })();
    var raycast = ray_cast;
    var ray_plane = (function() {
      var pt = new _valueTypes.Vec3(0, 0, 0);
      return function(ray, plane) {
        var denom = _valueTypes.Vec3.dot(ray.d, plane.n);
        if (Math.abs(denom) < Number.EPSILON) return 0;
        _valueTypes.Vec3.multiplyScalar(pt, plane.n, plane.d);
        var t = _valueTypes.Vec3.dot(_valueTypes.Vec3.subtract(pt, pt, ray.o), plane.n) / denom;
        if (t < 0) return 0;
        return t;
      };
    })();
    var line_plane = (function() {
      var ab = new _valueTypes.Vec3(0, 0, 0);
      return function(line, plane) {
        _valueTypes.Vec3.subtract(ab, line.e, line.s);
        var t = (plane.d - _valueTypes.Vec3.dot(line.s, plane.n)) / _valueTypes.Vec3.dot(ab, plane.n);
        if (t < 0 || t > 1) return 0;
        return t;
      };
    })();
    var ray_triangle = (function() {
      var ab = new _valueTypes.Vec3(0, 0, 0);
      var ac = new _valueTypes.Vec3(0, 0, 0);
      var pvec = new _valueTypes.Vec3(0, 0, 0);
      var tvec = new _valueTypes.Vec3(0, 0, 0);
      var qvec = new _valueTypes.Vec3(0, 0, 0);
      return function(ray, triangle, doubleSided) {
        _valueTypes.Vec3.subtract(ab, triangle.b, triangle.a);
        _valueTypes.Vec3.subtract(ac, triangle.c, triangle.a);
        _valueTypes.Vec3.cross(pvec, ray.d, ac);
        var det = _valueTypes.Vec3.dot(ab, pvec);
        if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) return 0;
        var inv_det = 1 / det;
        _valueTypes.Vec3.subtract(tvec, ray.o, triangle.a);
        var u = _valueTypes.Vec3.dot(tvec, pvec) * inv_det;
        if (u < 0 || u > 1) return 0;
        _valueTypes.Vec3.cross(qvec, tvec, ab);
        var v = _valueTypes.Vec3.dot(ray.d, qvec) * inv_det;
        if (v < 0 || u + v > 1) return 0;
        var t = _valueTypes.Vec3.dot(ac, qvec) * inv_det;
        return t < 0 ? 0 : t;
      };
    })();
    var rayTriangle = ray_triangle;
    var line_triangle = (function() {
      var ab = new _valueTypes.Vec3(0, 0, 0);
      var ac = new _valueTypes.Vec3(0, 0, 0);
      var qp = new _valueTypes.Vec3(0, 0, 0);
      var ap = new _valueTypes.Vec3(0, 0, 0);
      var n = new _valueTypes.Vec3(0, 0, 0);
      var e = new _valueTypes.Vec3(0, 0, 0);
      return function(line, triangle, outPt) {
        _valueTypes.Vec3.subtract(ab, triangle.b, triangle.a);
        _valueTypes.Vec3.subtract(ac, triangle.c, triangle.a);
        _valueTypes.Vec3.subtract(qp, line.s, line.e);
        _valueTypes.Vec3.cross(n, ab, ac);
        var det = _valueTypes.Vec3.dot(qp, n);
        if (det <= 0) return 0;
        _valueTypes.Vec3.subtract(ap, line.s, triangle.a);
        var t = _valueTypes.Vec3.dot(ap, n);
        if (t < 0 || t > det) return 0;
        _valueTypes.Vec3.cross(e, qp, ap);
        var v = _valueTypes.Vec3.dot(ac, e);
        if (v < 0 || v > det) return 0;
        var w = -_valueTypes.Vec3.dot(ab, e);
        if (w < 0 || v + w > det) return 0;
        if (outPt) {
          var invDet = 1 / det;
          v *= invDet;
          w *= invDet;
          var u = 1 - v - w;
          _valueTypes.Vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
        }
        return 1;
      };
    })();
    var line_quad = (function() {
      var pq = new _valueTypes.Vec3(0, 0, 0);
      var pa = new _valueTypes.Vec3(0, 0, 0);
      var pb = new _valueTypes.Vec3(0, 0, 0);
      var pc = new _valueTypes.Vec3(0, 0, 0);
      var pd = new _valueTypes.Vec3(0, 0, 0);
      var m = new _valueTypes.Vec3(0, 0, 0);
      var tmp = new _valueTypes.Vec3(0, 0, 0);
      return function(p, q, a, b, c, d, outPt) {
        _valueTypes.Vec3.subtract(pq, q, p);
        _valueTypes.Vec3.subtract(pa, a, p);
        _valueTypes.Vec3.subtract(pb, b, p);
        _valueTypes.Vec3.subtract(pc, c, p);
        _valueTypes.Vec3.cross(m, pc, pq);
        var v = _valueTypes.Vec3.dot(pa, m);
        if (v >= 0) {
          var u = -_valueTypes.Vec3.dot(pb, m);
          if (u < 0) return 0;
          var w = _valueTypes.Vec3.dot(_valueTypes.Vec3.cross(tmp, pq, pb), pa);
          if (w < 0) return 0;
          if (outPt) {
            var denom = 1 / (u + v + w);
            u *= denom;
            v *= denom;
            w *= denom;
            _valueTypes.Vec3.set(outPt, a.x * u + b.x * v + c.x * w, a.y * u + b.y * v + c.y * w, a.z * u + b.z * v + c.z * w);
          }
        } else {
          _valueTypes.Vec3.subtract(pd, d, p);
          var _u = _valueTypes.Vec3.dot(pd, m);
          if (_u < 0) return 0;
          var _w = _valueTypes.Vec3.dot(_valueTypes.Vec3.cross(tmp, pq, pa), pd);
          if (_w < 0) return 0;
          if (outPt) {
            v = -v;
            var _denom = 1 / (_u + v + _w);
            _u *= _denom;
            v *= _denom;
            _w *= _denom;
            _valueTypes.Vec3.set(outPt, a.x * _u + d.x * v + c.x * _w, a.y * _u + d.y * v + c.y * _w, a.z * _u + d.z * v + c.z * _w);
          }
        }
        return 1;
      };
    })();
    var ray_sphere = (function() {
      var e = new _valueTypes.Vec3(0, 0, 0);
      return function(ray, sphere) {
        var r = sphere.radius;
        var c = sphere.center;
        var o = ray.o;
        var d = ray.d;
        var rSq = r * r;
        _valueTypes.Vec3.subtract(e, c, o);
        var eSq = e.lengthSqr();
        var aLength = _valueTypes.Vec3.dot(e, d);
        var fSq = rSq - (eSq - aLength * aLength);
        if (fSq < 0) return 0;
        var f = Math.sqrt(fSq);
        var t = eSq < rSq ? aLength + f : aLength - f;
        if (t < 0) return 0;
        return t;
      };
    })();
    var ray_aabb = (function() {
      var min = new _valueTypes.Vec3();
      var max = new _valueTypes.Vec3();
      return function(ray, aabb) {
        var o = ray.o, d = ray.d;
        var ix = 1 / d.x, iy = 1 / d.y, iz = 1 / d.z;
        _valueTypes.Vec3.subtract(min, aabb.center, aabb.halfExtents);
        _valueTypes.Vec3.add(max, aabb.center, aabb.halfExtents);
        var t1 = (min.x - o.x) * ix;
        var t2 = (max.x - o.x) * ix;
        var t3 = (min.y - o.y) * iy;
        var t4 = (max.y - o.y) * iy;
        var t5 = (min.z - o.z) * iz;
        var t6 = (max.z - o.z) * iz;
        var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
        if (tmax < 0 || tmin > tmax) return 0;
        return tmin;
      };
    })();
    var rayAabb = ray_aabb;
    var ray_obb = (function() {
      var center = new _valueTypes.Vec3();
      var o = new _valueTypes.Vec3();
      var d = new _valueTypes.Vec3();
      var X = new _valueTypes.Vec3();
      var Y = new _valueTypes.Vec3();
      var Z = new _valueTypes.Vec3();
      var p = new _valueTypes.Vec3();
      var size = new Array(3);
      var f = new Array(3);
      var e = new Array(3);
      var t = new Array(6);
      return function(ray, obb) {
        size[0] = obb.halfExtents.x;
        size[1] = obb.halfExtents.y;
        size[2] = obb.halfExtents.z;
        center = obb.center;
        o = ray.o;
        d = ray.d;
        var obbm = obb.orientation.m;
        _valueTypes.Vec3.set(X, obbm[0], obbm[1], obbm[2]);
        _valueTypes.Vec3.set(Y, obbm[3], obbm[4], obbm[5]);
        _valueTypes.Vec3.set(Z, obbm[6], obbm[7], obbm[8]);
        _valueTypes.Vec3.subtract(p, center, o);
        f[0] = _valueTypes.Vec3.dot(X, d);
        f[1] = _valueTypes.Vec3.dot(Y, d);
        f[2] = _valueTypes.Vec3.dot(Z, d);
        e[0] = _valueTypes.Vec3.dot(X, p);
        e[1] = _valueTypes.Vec3.dot(Y, p);
        e[2] = _valueTypes.Vec3.dot(Z, p);
        for (var i = 0; i < 3; ++i) {
          if (0 === f[i]) {
            if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) return 0;
            f[i] = 1e-7;
          }
          t[2 * i + 0] = (e[i] + size[i]) / f[i];
          t[2 * i + 1] = (e[i] - size[i]) / f[i];
        }
        var tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5]));
        var tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));
        if (tmax < 0 || tmin > tmax || tmin < 0) return 0;
        return tmin;
      };
    })();
    var aabb_aabb = (function() {
      var aMin = new _valueTypes.Vec3();
      var aMax = new _valueTypes.Vec3();
      var bMin = new _valueTypes.Vec3();
      var bMax = new _valueTypes.Vec3();
      return function(aabb1, aabb2) {
        _valueTypes.Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents);
        _valueTypes.Vec3.add(aMax, aabb1.center, aabb1.halfExtents);
        _valueTypes.Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents);
        _valueTypes.Vec3.add(bMax, aabb2.center, aabb2.halfExtents);
        return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
      };
    })();
    function getAABBVertices(min, max, out) {
      _valueTypes.Vec3.set(out[0], min.x, max.y, max.z);
      _valueTypes.Vec3.set(out[1], min.x, max.y, min.z);
      _valueTypes.Vec3.set(out[2], min.x, min.y, max.z);
      _valueTypes.Vec3.set(out[3], min.x, min.y, min.z);
      _valueTypes.Vec3.set(out[4], max.x, max.y, max.z);
      _valueTypes.Vec3.set(out[5], max.x, max.y, min.z);
      _valueTypes.Vec3.set(out[6], max.x, min.y, max.z);
      _valueTypes.Vec3.set(out[7], max.x, min.y, min.z);
    }
    function getOBBVertices(c, e, a1, a2, a3, out) {
      _valueTypes.Vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z);
      _valueTypes.Vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z);
      _valueTypes.Vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z);
      _valueTypes.Vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z);
      _valueTypes.Vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z);
      _valueTypes.Vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z);
      _valueTypes.Vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z);
      _valueTypes.Vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
    }
    function getInterval(vertices, axis) {
      var min = _valueTypes.Vec3.dot(axis, vertices[0]), max = min;
      for (var i = 1; i < 8; ++i) {
        var projection = _valueTypes.Vec3.dot(axis, vertices[i]);
        min = projection < min ? projection : min;
        max = projection > max ? projection : max;
      }
      return [ min, max ];
    }
    var aabb_obb = (function() {
      var test = new Array(15);
      for (var i = 0; i < 15; i++) test[i] = new _valueTypes.Vec3(0, 0, 0);
      var vertices = new Array(8);
      var vertices2 = new Array(8);
      for (var _i2 = 0; _i2 < 8; _i2++) {
        vertices[_i2] = new _valueTypes.Vec3(0, 0, 0);
        vertices2[_i2] = new _valueTypes.Vec3(0, 0, 0);
      }
      var min = new _valueTypes.Vec3();
      var max = new _valueTypes.Vec3();
      return function(aabb, obb) {
        var obbm = obb.orientation.m;
        _valueTypes.Vec3.set(test[0], 1, 0, 0);
        _valueTypes.Vec3.set(test[1], 0, 1, 0);
        _valueTypes.Vec3.set(test[2], 0, 0, 1);
        _valueTypes.Vec3.set(test[3], obbm[0], obbm[1], obbm[2]);
        _valueTypes.Vec3.set(test[4], obbm[3], obbm[4], obbm[5]);
        _valueTypes.Vec3.set(test[5], obbm[6], obbm[7], obbm[8]);
        for (var _i3 = 0; _i3 < 3; ++_i3) {
          _valueTypes.Vec3.cross(test[6 + 3 * _i3 + 0], test[_i3], test[0]);
          _valueTypes.Vec3.cross(test[6 + 3 * _i3 + 1], test[_i3], test[1]);
          _valueTypes.Vec3.cross(test[6 + 3 * _i3 + 1], test[_i3], test[2]);
        }
        _valueTypes.Vec3.subtract(min, aabb.center, aabb.halfExtents);
        _valueTypes.Vec3.add(max, aabb.center, aabb.halfExtents);
        getAABBVertices(min, max, vertices);
        getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);
        for (var j = 0; j < 15; ++j) {
          var a = getInterval(vertices, test[j]);
          var b = getInterval(vertices2, test[j]);
          if (b[0] > a[1] || a[0] > b[1]) return 0;
        }
        return 1;
      };
    })();
    var aabb_plane = function aabb_plane(aabb, plane) {
      var r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z);
      var dot = _valueTypes.Vec3.dot(plane.n, aabb.center);
      if (dot + r < plane.d) return -1;
      if (dot - r > plane.d) return 0;
      return 1;
    };
    var aabb_frustum = function aabb_frustum(aabb, frustum) {
      for (var i = 0; i < frustum.planes.length; i++) if (-1 === aabb_plane(aabb, frustum.planes[i])) return 0;
      return 1;
    };
    var aabb_frustum_accurate = (function() {
      var tmp = new Array(8);
      var out1 = 0, out2 = 0;
      for (var i = 0; i < tmp.length; i++) tmp[i] = new _valueTypes.Vec3(0, 0, 0);
      return function(aabb, frustum) {
        var result = 0, intersects = false;
        for (var _i4 = 0; _i4 < frustum.planes.length; _i4++) {
          result = aabb_plane(aabb, frustum.planes[_i4]);
          if (-1 === result) return 0;
          1 === result && (intersects = true);
        }
        if (!intersects) return 1;
        for (var _i5 = 0; _i5 < frustum.vertices.length; _i5++) _valueTypes.Vec3.subtract(tmp[_i5], frustum.vertices[_i5], aabb.center);
        out1 = 0, out2 = 0;
        for (var _i6 = 0; _i6 < frustum.vertices.length; _i6++) tmp[_i6].x > aabb.halfExtents.x ? out1++ : tmp[_i6].x < -aabb.halfExtents.x && out2++;
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        out1 = 0;
        out2 = 0;
        for (var _i7 = 0; _i7 < frustum.vertices.length; _i7++) tmp[_i7].y > aabb.halfExtents.y ? out1++ : tmp[_i7].y < -aabb.halfExtents.y && out2++;
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        out1 = 0;
        out2 = 0;
        for (var _i8 = 0; _i8 < frustum.vertices.length; _i8++) tmp[_i8].z > aabb.halfExtents.z ? out1++ : tmp[_i8].z < -aabb.halfExtents.z && out2++;
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        return 1;
      };
    })();
    var obb_point = (function() {
      var tmp = new _valueTypes.Vec3(0, 0, 0), m3 = new _valueTypes.Mat3();
      var lessThan = function lessThan(a, b) {
        return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
      };
      return function(obb, point) {
        _valueTypes.Vec3.subtract(tmp, point, obb.center);
        _valueTypes.Vec3.transformMat3(tmp, tmp, _valueTypes.Mat3.transpose(m3, obb.orientation));
        return lessThan(tmp, obb.halfExtents);
      };
    })();
    var obb_plane = (function() {
      var absDot = function absDot(n, x, y, z) {
        return Math.abs(n.x * x + n.y * y + n.z * z);
      };
      return function(obb, plane) {
        var obbm = obb.orientation.m;
        var r = obb.halfExtents.x * absDot(plane.n, obbm[0], obbm[1], obbm[2]) + obb.halfExtents.y * absDot(plane.n, obbm[3], obbm[4], obbm[5]) + obb.halfExtents.z * absDot(plane.n, obbm[6], obbm[7], obbm[8]);
        var dot = _valueTypes.Vec3.dot(plane.n, obb.center);
        if (dot + r < plane.d) return -1;
        if (dot - r > plane.d) return 0;
        return 1;
      };
    })();
    var obb_frustum = function obb_frustum(obb, frustum) {
      for (var i = 0; i < frustum.planes.length; i++) if (-1 === obb_plane(obb, frustum.planes[i])) return 0;
      return 1;
    };
    var obb_frustum_accurate = (function() {
      var tmp = new Array(8);
      var dist = 0, out1 = 0, out2 = 0;
      for (var i = 0; i < tmp.length; i++) tmp[i] = new _valueTypes.Vec3(0, 0, 0);
      var dot = function dot(n, x, y, z) {
        return n.x * x + n.y * y + n.z * z;
      };
      return function(obb, frustum) {
        var result = 0, intersects = false;
        for (var _i9 = 0; _i9 < frustum.planes.length; _i9++) {
          result = obb_plane(obb, frustum.planes[_i9]);
          if (-1 === result) return 0;
          1 === result && (intersects = true);
        }
        if (!intersects) return 1;
        for (var _i10 = 0; _i10 < frustum.vertices.length; _i10++) _valueTypes.Vec3.subtract(tmp[_i10], frustum.vertices[_i10], obb.center);
        out1 = 0, out2 = 0;
        var obbm = obb.orientation.m;
        for (var _i11 = 0; _i11 < frustum.vertices.length; _i11++) {
          dist = dot(tmp[_i11], obbm[0], obbm[1], obbm[2]);
          dist > obb.halfExtents.x ? out1++ : dist < -obb.halfExtents.x && out2++;
        }
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        out1 = 0;
        out2 = 0;
        for (var _i12 = 0; _i12 < frustum.vertices.length; _i12++) {
          dist = dot(tmp[_i12], obbm[3], obbm[4], obbm[5]);
          dist > obb.halfExtents.y ? out1++ : dist < -obb.halfExtents.y && out2++;
        }
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        out1 = 0;
        out2 = 0;
        for (var _i13 = 0; _i13 < frustum.vertices.length; _i13++) {
          dist = dot(tmp[_i13], obbm[6], obbm[7], obbm[8]);
          dist > obb.halfExtents.z ? out1++ : dist < -obb.halfExtents.z && out2++;
        }
        if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) return 0;
        return 1;
      };
    })();
    var obb_obb = (function() {
      var test = new Array(15);
      for (var i = 0; i < 15; i++) test[i] = new _valueTypes.Vec3(0, 0, 0);
      var vertices = new Array(8);
      var vertices2 = new Array(8);
      for (var _i14 = 0; _i14 < 8; _i14++) {
        vertices[_i14] = new _valueTypes.Vec3(0, 0, 0);
        vertices2[_i14] = new _valueTypes.Vec3(0, 0, 0);
      }
      return function(obb1, obb2) {
        var obb1m = obb1.orientation.m;
        var obb2m = obb2.orientation.m;
        _valueTypes.Vec3.set(test[0], obb1m[0], obb1m[1], obb1m[2]);
        _valueTypes.Vec3.set(test[1], obb1m[3], obb1m[4], obb1m[5]);
        _valueTypes.Vec3.set(test[2], obb1m[6], obb1m[7], obb1m[8]);
        _valueTypes.Vec3.set(test[3], obb2m[0], obb2m[1], obb2m[2]);
        _valueTypes.Vec3.set(test[4], obb2m[3], obb2m[4], obb2m[5]);
        _valueTypes.Vec3.set(test[5], obb2m[6], obb2m[7], obb2m[8]);
        for (var _i15 = 0; _i15 < 3; ++_i15) {
          _valueTypes.Vec3.cross(test[6 + 3 * _i15 + 0], test[_i15], test[0]);
          _valueTypes.Vec3.cross(test[6 + 3 * _i15 + 1], test[_i15], test[1]);
          _valueTypes.Vec3.cross(test[6 + 3 * _i15 + 1], test[_i15], test[2]);
        }
        getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices);
        getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);
        for (var _i16 = 0; _i16 < 15; ++_i16) {
          var a = getInterval(vertices, test[_i16]);
          var b = getInterval(vertices2, test[_i16]);
          if (b[0] > a[1] || a[0] > b[1]) return 0;
        }
        return 1;
      };
    })();
    var sphere_plane = function sphere_plane(sphere, plane) {
      var dot = _valueTypes.Vec3.dot(plane.n, sphere.center);
      var r = sphere.radius * plane.n.length();
      if (dot + r < plane.d) return -1;
      if (dot - r > plane.d) return 0;
      return 1;
    };
    var sphere_frustum = function sphere_frustum(sphere, frustum) {
      for (var i = 0; i < frustum.planes.length; i++) if (-1 === sphere_plane(sphere, frustum.planes[i])) return 0;
      return 1;
    };
    var sphere_frustum_accurate = (function() {
      var pt = new _valueTypes.Vec3(0, 0, 0), map = [ 1, -1, 1, -1, 1, -1 ];
      return function(sphere, frustum) {
        for (var i = 0; i < 6; i++) {
          var plane = frustum.planes[i];
          var r = sphere.radius, c = sphere.center;
          var n = plane.n, d = plane.d;
          var dot = _valueTypes.Vec3.dot(n, c);
          if (dot + r < d) return 0;
          if (dot - r > d) continue;
          _valueTypes.Vec3.add(pt, c, _valueTypes.Vec3.multiplyScalar(pt, n, r));
          for (var j = 0; j < 6; j++) {
            if (j === i || j === i + map[i]) continue;
            var test = frustum.planes[j];
            if (_valueTypes.Vec3.dot(test.n, pt) < test.d) return 0;
          }
        }
        return 1;
      };
    })();
    var sphere_sphere = function sphere_sphere(sphere0, sphere1) {
      var r = sphere0.radius + sphere1.radius;
      return _valueTypes.Vec3.squaredDistance(sphere0.center, sphere1.center) < r * r;
    };
    var sphere_aabb = (function() {
      var pt = new _valueTypes.Vec3();
      return function(sphere, aabb) {
        distance.pt_point_aabb(pt, sphere.center, aabb);
        return _valueTypes.Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
      };
    })();
    var sphere_obb = (function() {
      var pt = new _valueTypes.Vec3();
      return function(sphere, obb) {
        distance.pt_point_obb(pt, sphere.center, obb);
        return _valueTypes.Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
      };
    })();
    var intersect = {
      rayAabb: rayAabb,
      rayMesh: rayMesh,
      raycast: raycast,
      rayTriangle: rayTriangle,
      ray_sphere: ray_sphere,
      ray_aabb: ray_aabb,
      ray_obb: ray_obb,
      ray_plane: ray_plane,
      ray_triangle: ray_triangle,
      line_plane: line_plane,
      line_triangle: line_triangle,
      line_quad: line_quad,
      sphere_sphere: sphere_sphere,
      sphere_aabb: sphere_aabb,
      sphere_obb: sphere_obb,
      sphere_plane: sphere_plane,
      sphere_frustum: sphere_frustum,
      sphere_frustum_accurate: sphere_frustum_accurate,
      aabb_aabb: aabb_aabb,
      aabb_obb: aabb_obb,
      aabb_plane: aabb_plane,
      aabb_frustum: aabb_frustum,
      aabb_frustum_accurate: aabb_frustum_accurate,
      obb_obb: obb_obb,
      obb_plane: obb_plane,
      obb_frustum: obb_frustum,
      obb_frustum_accurate: obb_frustum_accurate,
      obb_point: obb_point,
      resolve: function resolve(g1, g2, outPt) {
        void 0 === outPt && (outPt = null);
        var type1 = g1._type, type2 = g2._type;
        var resolver = this[type1 | type2];
        return type1 < type2 ? resolver(g1, g2, outPt) : resolver(g2, g1, outPt);
      }
    };
    intersect[_enums["default"].SHAPE_RAY | _enums["default"].SHAPE_SPHERE] = ray_sphere;
    intersect[_enums["default"].SHAPE_RAY | _enums["default"].SHAPE_AABB] = ray_aabb;
    intersect[_enums["default"].SHAPE_RAY | _enums["default"].SHAPE_OBB] = ray_obb;
    intersect[_enums["default"].SHAPE_RAY | _enums["default"].SHAPE_PLANE] = ray_plane;
    intersect[_enums["default"].SHAPE_RAY | _enums["default"].SHAPE_TRIANGLE] = ray_triangle;
    intersect[_enums["default"].SHAPE_LINE | _enums["default"].SHAPE_PLANE] = line_plane;
    intersect[_enums["default"].SHAPE_LINE | _enums["default"].SHAPE_TRIANGLE] = line_triangle;
    intersect[_enums["default"].SHAPE_SPHERE] = sphere_sphere;
    intersect[_enums["default"].SHAPE_SPHERE | _enums["default"].SHAPE_AABB] = sphere_aabb;
    intersect[_enums["default"].SHAPE_SPHERE | _enums["default"].SHAPE_OBB] = sphere_obb;
    intersect[_enums["default"].SHAPE_SPHERE | _enums["default"].SHAPE_PLANE] = sphere_plane;
    intersect[_enums["default"].SHAPE_SPHERE | _enums["default"].SHAPE_FRUSTUM] = sphere_frustum;
    intersect[_enums["default"].SHAPE_SPHERE | _enums["default"].SHAPE_FRUSTUM_ACCURATE] = sphere_frustum_accurate;
    intersect[_enums["default"].SHAPE_AABB] = aabb_aabb;
    intersect[_enums["default"].SHAPE_AABB | _enums["default"].SHAPE_OBB] = aabb_obb;
    intersect[_enums["default"].SHAPE_AABB | _enums["default"].SHAPE_PLANE] = aabb_plane;
    intersect[_enums["default"].SHAPE_AABB | _enums["default"].SHAPE_FRUSTUM] = aabb_frustum;
    intersect[_enums["default"].SHAPE_AABB | _enums["default"].SHAPE_FRUSTUM_ACCURATE] = aabb_frustum_accurate;
    intersect[_enums["default"].SHAPE_OBB] = obb_obb;
    intersect[_enums["default"].SHAPE_OBB | _enums["default"].SHAPE_PLANE] = obb_plane;
    intersect[_enums["default"].SHAPE_OBB | _enums["default"].SHAPE_FRUSTUM] = obb_frustum;
    intersect[_enums["default"].SHAPE_OBB | _enums["default"].SHAPE_FRUSTUM_ACCURATE] = obb_frustum_accurate;
    var _default = intersect;
    exports["default"] = _default;
    module.exports = exports["default"];
  }), {
    "../../renderer/gfx": 427,
    "../../renderer/memop/recycle-pool": 429,
    "../value-types": 401,
    "./aabb": 223,
    "./distance": 224,
    "./enums": 225,
    "./ray": 232,
    "./triangle": 234
  } ],
  229: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueTypes = require("../value-types");
    var _enums = _interopRequireDefault(require("./enums"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var line = (function() {
      line.create = function create(sx, sy, sz, ex, ey, ez) {
        return new line(sx, sy, sz, ex, ey, ez);
      };
      line.clone = function clone(a) {
        return new line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
      };
      line.copy = function copy(out, a) {
        _valueTypes.Vec3.copy(out.s, a.s);
        _valueTypes.Vec3.copy(out.e, a.e);
        return out;
      };
      line.fromPoints = function fromPoints(out, start, end) {
        _valueTypes.Vec3.copy(out.s, start);
        _valueTypes.Vec3.copy(out.e, end);
        return out;
      };
      line.set = function set(out, sx, sy, sz, ex, ey, ez) {
        out.s.x = sx;
        out.s.y = sy;
        out.s.z = sz;
        out.e.x = ex;
        out.e.y = ey;
        out.e.z = ez;
        return out;
      };
      line.len = function len(a) {
        return _valueTypes.Vec3.distance(a.s, a.e);
      };
      function line(sx, sy, sz, ex, ey, ez) {
        void 0 === sx && (sx = 0);
        void 0 === sy && (sy = 0);
        void 0 === sz && (sz = 0);
        void 0 === ex && (ex = 0);
        void 0 === ey && (ey = 0);
        void 0 === ez && (ez = -1);
        this.s = void 0;
        this.e = void 0;
        this._type = void 0;
        this._type = _enums["default"].SHAPE_LINE;
        this.s = new _valueTypes.Vec3(sx, sy, sz);
        this.e = new _valueTypes.Vec3(ex, ey, ez);
      }
      var _proto = line.prototype;
      _proto.length = function length() {
        return _valueTypes.Vec3.distance(this.s, this.e);
      };
      return line;
    })();
    exports["default"] = line;
    module.exports = exports["default"];
  }), {
    "../value-types": 401,
    "./enums": 225
  } ],
  230: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueTypes = require("../value-types");
    var _enums = _interopRequireDefault(require("./enums"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var _v3_tmp = new _valueTypes.Vec3();
    var _v3_tmp2 = new _valueTypes.Vec3();
    var _m3_tmp = new _valueTypes.Mat3();
    var transform_extent_m3 = function transform_extent_m3(out, extent, m3) {
      var m3_tmpm = _m3_tmp.m, m3m = m3.m;
      m3_tmpm[0] = Math.abs(m3m[0]);
      m3_tmpm[1] = Math.abs(m3m[1]);
      m3_tmpm[2] = Math.abs(m3m[2]);
      m3_tmpm[3] = Math.abs(m3m[3]);
      m3_tmpm[4] = Math.abs(m3m[4]);
      m3_tmpm[5] = Math.abs(m3m[5]);
      m3_tmpm[6] = Math.abs(m3m[6]);
      m3_tmpm[7] = Math.abs(m3m[7]);
      m3_tmpm[8] = Math.abs(m3m[8]);
      _valueTypes.Vec3.transformMat3(out, extent, _m3_tmp);
    };
    var obb = (function() {
      obb.create = function create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
        return new obb(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
      };
      obb.clone = function clone(a) {
        var aom = a.orientation.m;
        return new obb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, aom[0], aom[1], aom[2], aom[3], aom[4], aom[5], aom[6], aom[7], aom[8]);
      };
      obb.copy = function copy(out, a) {
        _valueTypes.Vec3.copy(out.center, a.center);
        _valueTypes.Vec3.copy(out.halfExtents, a.halfExtents);
        _valueTypes.Mat3.copy(out.orientation, a.orientation);
        return out;
      };
      obb.fromPoints = function fromPoints(out, minPos, maxPos) {
        _valueTypes.Vec3.multiplyScalar(out.center, _valueTypes.Vec3.add(_v3_tmp, minPos, maxPos), .5);
        _valueTypes.Vec3.multiplyScalar(out.halfExtents, _valueTypes.Vec3.subtract(_v3_tmp2, maxPos, minPos), .5);
        _valueTypes.Mat3.identity(out.orientation);
        return out;
      };
      obb.set = function set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
        _valueTypes.Vec3.set(out.center, cx, cy, cz);
        _valueTypes.Vec3.set(out.halfExtents, hw, hh, hl);
        _valueTypes.Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
        return out;
      };
      function obb(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
        void 0 === cx && (cx = 0);
        void 0 === cy && (cy = 0);
        void 0 === cz && (cz = 0);
        void 0 === hw && (hw = 1);
        void 0 === hh && (hh = 1);
        void 0 === hl && (hl = 1);
        void 0 === ox_1 && (ox_1 = 1);
        void 0 === ox_2 && (ox_2 = 0);
        void 0 === ox_3 && (ox_3 = 0);
        void 0 === oy_1 && (oy_1 = 0);
        void 0 === oy_2 && (oy_2 = 1);
        void 0 === oy_3 && (oy_3 = 0);
        void 0 === oz_1 && (oz_1 = 0);
        void 0 === oz_2 && (oz_2 = 0);
        void 0 === oz_3 && (oz_3 = 1);
        this.center = void 0;
        this.halfExtents = void 0;
        this.orientation = void 0;
        this._type = void 0;
        this._type = _enums["default"].SHAPE_OBB;
        this.center = new _valueTypes.Vec3(cx, cy, cz);
        this.halfExtents = new _valueTypes.Vec3(hw, hh, hl);
        this.orientation = new _valueTypes.Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
      }
      var _proto = obb.prototype;
      _proto.getBoundary = function getBoundary(minPos, maxPos) {
        transform_extent_m3(_v3_tmp, this.halfExtents, this.orientation);
        _valueTypes.Vec3.subtract(minPos, this.center, _v3_tmp);
        _valueTypes.Vec3.add(maxPos, this.center, _v3_tmp);
      };
      _proto.transform = function transform(m, pos, rot, scale, out) {
        _valueTypes.Vec3.transformMat4(out.center, this.center, m);
        _valueTypes.Mat3.fromQuat(out.orientation, rot);
        _valueTypes.Vec3.multiply(out.halfExtents, this.halfExtents, scale);
      };
      _proto.translateAndRotate = function translateAndRotate(m, rot, out) {
        _valueTypes.Vec3.transformMat4(out.center, this.center, m);
        _valueTypes.Mat3.fromQuat(out.orientation, rot);
      };
      _proto.setScale = function setScale(scale, out) {
        _valueTypes.Vec3.multiply(out.halfExtents, this.halfExtents, scale);
      };
      _createClass(obb, [ {
        key: "type",
        get: function get() {
          return this._type;
        }
      } ]);
      return obb;
    })();
    exports["default"] = obb;
    module.exports = exports["default"];
  }), {
    "../value-types": 401,
    "./enums": 225
  } ],
  231: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueTypes = require("../value-types");
    var _enums = _interopRequireDefault(require("./enums"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var v1 = new _valueTypes.Vec3(0, 0, 0);
    var v2 = new _valueTypes.Vec3(0, 0, 0);
    var temp_mat = cc.mat4();
    var temp_vec4 = cc.v4();
    var plane = (function() {
      plane.create = function create(nx, ny, nz, d) {
        return new plane(nx, ny, nz, d);
      };
      plane.clone = function clone(p) {
        return new plane(p.n.x, p.n.y, p.n.z, p.d);
      };
      plane.copy = function copy(out, p) {
        _valueTypes.Vec3.copy(out.n, p.n);
        out.d = p.d;
        return out;
      };
      plane.fromPoints = function fromPoints(out, a, b, c) {
        _valueTypes.Vec3.subtract(v1, b, a);
        _valueTypes.Vec3.subtract(v2, c, a);
        _valueTypes.Vec3.normalize(out.n, _valueTypes.Vec3.cross(out.n, v1, v2));
        out.d = _valueTypes.Vec3.dot(out.n, a);
        return out;
      };
      plane.set = function set(out, nx, ny, nz, d) {
        out.n.x = nx;
        out.n.y = ny;
        out.n.z = nz;
        out.d = d;
        return out;
      };
      plane.fromNormalAndPoint = function fromNormalAndPoint(out, normal, point) {
        _valueTypes.Vec3.copy(out.n, normal);
        out.d = _valueTypes.Vec3.dot(normal, point);
        return out;
      };
      plane.normalize = function normalize(out, a) {
        var len = a.n.len();
        _valueTypes.Vec3.normalize(out.n, a.n);
        len > 0 && (out.d = a.d / len);
        return out;
      };
      function plane(nx, ny, nz, d) {
        void 0 === nx && (nx = 0);
        void 0 === ny && (ny = 1);
        void 0 === nz && (nz = 0);
        void 0 === d && (d = 0);
        this.n = void 0;
        this.d = void 0;
        this._type = void 0;
        this._type = _enums["default"].SHAPE_PLANE;
        this.n = new _valueTypes.Vec3(nx, ny, nz);
        this.d = d;
      }
      var _proto = plane.prototype;
      _proto.transform = function transform(mat) {
        _valueTypes.Mat4.invert(temp_mat, mat);
        _valueTypes.Mat4.transpose(temp_mat, temp_mat);
        _valueTypes.Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, this.d);
        _valueTypes.Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat);
        _valueTypes.Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z);
        this.d = temp_vec4.w;
      };
      return plane;
    })();
    exports["default"] = plane;
    module.exports = exports["default"];
  }), {
    "../value-types": 401,
    "./enums": 225
  } ],
  232: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueTypes = require("../value-types");
    var _enums = _interopRequireDefault(require("./enums"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ray = (function() {
      ray.create = function create(ox, oy, oz, dx, dy, dz) {
        void 0 === ox && (ox = 0);
        void 0 === oy && (oy = 0);
        void 0 === oz && (oz = 0);
        void 0 === dx && (dx = 0);
        void 0 === dy && (dy = 0);
        void 0 === dz && (dz = 1);
        return new ray(ox, oy, oz, dx, dy, dz);
      };
      ray.clone = function clone(a) {
        return new ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
      };
      ray.copy = function copy(out, a) {
        _valueTypes.Vec3.copy(out.o, a.o);
        _valueTypes.Vec3.copy(out.d, a.d);
        return out;
      };
      ray.fromPoints = function fromPoints(out, origin, target) {
        _valueTypes.Vec3.copy(out.o, origin);
        _valueTypes.Vec3.normalize(out.d, _valueTypes.Vec3.subtract(out.d, target, origin));
        return out;
      };
      ray.set = function set(out, ox, oy, oz, dx, dy, dz) {
        out.o.x = ox;
        out.o.y = oy;
        out.o.z = oz;
        out.d.x = dx;
        out.d.y = dy;
        out.d.z = dz;
        return out;
      };
      function ray(ox, oy, oz, dx, dy, dz) {
        void 0 === ox && (ox = 0);
        void 0 === oy && (oy = 0);
        void 0 === oz && (oz = 0);
        void 0 === dx && (dx = 0);
        void 0 === dy && (dy = 0);
        void 0 === dz && (dz = -1);
        this.o = void 0;
        this.d = void 0;
        this._type = void 0;
        this._type = _enums["default"].SHAPE_RAY;
        this.o = new _valueTypes.Vec3(ox, oy, oz);
        this.d = new _valueTypes.Vec3(dx, dy, dz);
      }
      var _proto = ray.prototype;
      _proto.computeHit = function computeHit(out, distance) {
        _valueTypes.Vec3.normalize(out, this.d);
        _valueTypes.Vec3.scaleAndAdd(out, this.o, out, distance);
      };
      return ray;
    })();
    exports["default"] = ray;
    module.exports = exports["default"];
  }), {
    "../value-types": 401,
    "./enums": 225
  } ],
  233: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueTypes = require("../value-types");
    var _enums = _interopRequireDefault(require("./enums"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _v3_tmp = new _valueTypes.Vec3();
    var sphere = (function() {
      sphere.create = function create(cx, cy, cz, r) {
        return new sphere(cx, cy, cz, r);
      };
      sphere.clone = function clone(p) {
        return new sphere(p.center.x, p.center.y, p.center.z, p.radius);
      };
      sphere.copy = function copy(out, p) {
        _valueTypes.Vec3.copy(out.center, p.center);
        out.radius = p.radius;
        return out;
      };
      sphere.fromPoints = function fromPoints(out, minPos, maxPos) {
        _valueTypes.Vec3.multiplyScalar(out.center, _valueTypes.Vec3.add(_v3_tmp, minPos, maxPos), .5);
        out.radius = .5 * _valueTypes.Vec3.subtract(_v3_tmp, maxPos, minPos).len();
        return out;
      };
      sphere.set = function set(out, cx, cy, cz, r) {
        out.center.x = cx;
        out.center.y = cy;
        out.center.z = cz;
        out.radius = r;
        return out;
      };
      function sphere(cx, cy, cz, r) {
        void 0 === cx && (cx = 0);
        void 0 === cy && (cy = 0);
        void 0 === cz && (cz = 0);
        void 0 === r && (r = 1);
        this.center = void 0;
        this.radius = void 0;
        this._type = void 0;
        this._type = _enums["default"].SHAPE_SPHERE;
        this.center = new _valueTypes.Vec3(cx, cy, cz);
        this.radius = r;
      }
      var _proto = sphere.prototype;
      _proto.clone = function clone() {
        return sphere.clone(this);
      };
      _proto.copy = function copy(a) {
        return sphere.copy(this, a);
      };
      _proto.getBoundary = function getBoundary(minPos, maxPos) {
        _valueTypes.Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius);
        _valueTypes.Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
      };
      _proto.transform = function transform(m, pos, rot, scale, out) {
        _valueTypes.Vec3.transformMat4(out.center, this.center, m);
        out.radius = this.radius * scale.maxAxis();
      };
      _proto.translateAndRotate = function translateAndRotate(m, rot, out) {
        _valueTypes.Vec3.transformMat4(out.center, this.center, m);
      };
      _proto.setScale = function setScale(scale, out) {
        out.radius = this.radius * scale.maxAxis();
      };
      return sphere;
    })();
    exports["default"] = sphere;
    module.exports = exports["default"];
  }), {
    "../value-types": 401,
    "./enums": 225
  } ],
  234: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vec = _interopRequireDefault(require("../value-types/vec3"));
    var _enums = _interopRequireDefault(require("./enums"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var triangle = (function() {
      triangle.create = function create(ax, ay, az, bx, by, bz, cx, cy, cz) {
        return new triangle(ax, ay, az, bx, by, bz, cx, cy, cz);
      };
      triangle.clone = function clone(t) {
        return new triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
      };
      triangle.copy = function copy(out, t) {
        _vec["default"].copy(out.a, t.a);
        _vec["default"].copy(out.b, t.b);
        _vec["default"].copy(out.c, t.c);
        return out;
      };
      triangle.fromPoints = function fromPoints(out, a, b, c) {
        _vec["default"].copy(out.a, a);
        _vec["default"].copy(out.b, b);
        _vec["default"].copy(out.c, c);
        return out;
      };
      triangle.set = function set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
        out.a.x = ax;
        out.a.y = ay;
        out.a.z = az;
        out.b.x = bx;
        out.b.y = by;
        out.b.z = bz;
        out.c.x = cx;
        out.c.y = cy;
        out.c.z = cz;
        return out;
      };
      function triangle(ax, ay, az, bx, by, bz, cx, cy, cz) {
        this.a = void 0;
        this.b = void 0;
        this.c = void 0;
        this._type = void 0;
        this.a = new _vec["default"](ax, ay, az);
        this.b = new _vec["default"](bx, by, bz);
        this.c = new _vec["default"](cx, cy, cz);
        this._type = _enums["default"].SHAPE_TRIANGLE;
      }
      return triangle;
    })();
    exports["default"] = triangle;
    module.exports = exports["default"];
  }), {
    "../value-types/vec3": 411,
    "./enums": 225
  } ],
  235: [ (function(require, module, exports) {
    "use strict";
    var RenderComponent = require("../components/CCRenderComponent");
    var Material = require("../assets/material/CCMaterial");
    var Types = require("./types");
    var LineCap = Types.LineCap;
    var LineJoin = Types.LineJoin;
    var Graphics = cc.Class({
      name: "cc.Graphics",
      extends: RenderComponent,
      editor: false,
      ctor: function ctor() {
        this._impl = new Graphics._Impl(this);
      },
      properties: {
        _lineWidth: 2,
        _strokeColor: cc.Color.BLACK,
        _lineJoin: LineJoin.MITER,
        _lineCap: LineCap.BUTT,
        _fillColor: cc.Color.WHITE,
        _miterLimit: 10,
        lineWidth: {
          get: function get() {
            return this._lineWidth;
          },
          set: function set(value) {
            this._lineWidth = value;
            this._impl.lineWidth = value;
          }
        },
        lineJoin: {
          get: function get() {
            return this._lineJoin;
          },
          set: function set(value) {
            this._lineJoin = value;
            this._impl.lineJoin = value;
          },
          type: LineJoin
        },
        lineCap: {
          get: function get() {
            return this._lineCap;
          },
          set: function set(value) {
            this._lineCap = value;
            this._impl.lineCap = value;
          },
          type: LineCap
        },
        strokeColor: {
          get: function get() {
            return this._strokeColor;
          },
          set: function set(value) {
            this._impl.strokeColor = this._strokeColor = cc.color(value);
          }
        },
        fillColor: {
          get: function get() {
            return this._fillColor;
          },
          set: function set(value) {
            this._impl.fillColor = this._fillColor = cc.color(value);
          }
        },
        miterLimit: {
          get: function get() {
            return this._miterLimit;
          },
          set: function set(value) {
            this._miterLimit = value;
            this._impl.miterLimit = value;
          }
        }
      },
      statics: {
        LineJoin: LineJoin,
        LineCap: LineCap
      },
      onRestore: function onRestore() {
        this._impl || (this._impl = new Graphics._Impl(this));
      },
      onDestroy: function onDestroy() {
        this.clear(true);
        this._super();
        this._impl = null;
      },
      _getDefaultMaterial: function _getDefaultMaterial() {
        return Material.getBuiltinMaterial("2d-graphics");
      },
      _updateMaterial: function _updateMaterial() {
        var material = this._materials[0];
        if (!material) return;
        void 0 !== material.getDefine("CC_USE_MODEL") && material.define("CC_USE_MODEL", true);
        void 0 !== material.getDefine("CC_SUPPORT_standard_derivatives") && cc.sys.glExtension("OES_standard_derivatives") && material.define("CC_SUPPORT_standard_derivatives", true);
      },
      moveTo: function moveTo(x, y) {
        if (true, x instanceof cc.Vec2) {
          cc.warn("[moveTo] : Can not pass Vec2 as [x, y] value, please check it.");
          return;
        }
        this._impl.moveTo(x, y);
      },
      lineTo: function lineTo(x, y) {
        if (true, x instanceof cc.Vec2) {
          cc.warn("[moveTo] : Can not pass Vec2 as [x, y] value, please check it.");
          return;
        }
        this._impl.lineTo(x, y);
      },
      bezierCurveTo: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
        this._impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
      },
      quadraticCurveTo: function quadraticCurveTo(cx, cy, x, y) {
        this._impl.quadraticCurveTo(cx, cy, x, y);
      },
      arc: function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
        this._impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
      },
      ellipse: function ellipse(cx, cy, rx, ry) {
        this._impl.ellipse(cx, cy, rx, ry);
      },
      circle: function circle(cx, cy, r) {
        this._impl.circle(cx, cy, r);
      },
      rect: function rect(x, y, w, h) {
        this._impl.rect(x, y, w, h);
      },
      roundRect: function roundRect(x, y, w, h, r) {
        this._impl.roundRect(x, y, w, h, r);
      },
      fillRect: function fillRect(x, y, w, h) {
        this.rect(x, y, w, h);
        this.fill();
      },
      clear: function clear(clean) {
        this._impl.clear(clean);
        this._assembler && this._assembler.clear(clean);
      },
      close: function close() {
        this._impl.close();
      },
      stroke: function stroke() {
        this._assembler || this._resetAssembler();
        this._assembler.stroke(this);
      },
      fill: function fill() {
        this._assembler || this._resetAssembler();
        this._assembler.fill(this);
      }
    });
    cc.Graphics = module.exports = Graphics;
    cc.Graphics.Types = Types;
    cc.Graphics.Helper = require("./helper");
  }), {
    "../assets/material/CCMaterial": 156,
    "../components/CCRenderComponent": 192,
    "./helper": 236,
    "./types": 238
  } ],
  236: [ (function(require, module, exports) {
    "use strict";
    var PointFlags = require("./types").PointFlags;
    var PI = Math.PI;
    var min = Math.min;
    var max = Math.max;
    var cos = Math.cos;
    var sin = Math.sin;
    var abs = Math.abs;
    var sign = Math.sign;
    var KAPPA90 = .5522847493;
    function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
      counterclockwise = counterclockwise || false;
      var a = 0, da = 0, hda = 0, kappa = 0;
      var dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0;
      var px = 0, py = 0, ptanx = 0, ptany = 0;
      var i, ndivs;
      da = endAngle - startAngle;
      if (counterclockwise) if (abs(da) >= 2 * PI) da = 2 * PI; else while (da < 0) da += 2 * PI; else if (abs(da) >= 2 * PI) da = 2 * -PI; else while (da > 0) da -= 2 * PI;
      ndivs = 0 | max(1, min(abs(da) / (.5 * PI) + .5, 5));
      hda = da / ndivs / 2;
      kappa = abs(4 / 3 * (1 - cos(hda)) / sin(hda));
      counterclockwise || (kappa = -kappa);
      for (i = 0; i <= ndivs; i++) {
        a = startAngle + da * (i / ndivs);
        dx = cos(a);
        dy = sin(a);
        x = cx + dx * r;
        y = cy + dy * r;
        tanx = -dy * r * kappa;
        tany = dx * r * kappa;
        0 === i ? ctx.moveTo(x, y) : ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y);
        px = x;
        py = y;
        ptanx = tanx;
        ptany = tany;
      }
    }
    function ellipse(ctx, cx, cy, rx, ry) {
      ctx.moveTo(cx - rx, cy);
      ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry);
      ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy);
      ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry);
      ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy);
      ctx.close();
    }
    function roundRect(ctx, x, y, w, h, r) {
      if (r < .1) {
        ctx.rect(x, y, w, h);
        return;
      }
      var rx = min(r, .5 * abs(w)) * sign(w), ry = min(r, .5 * abs(h)) * sign(h);
      ctx.moveTo(x, y + ry);
      ctx.lineTo(x, y + h - ry);
      ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h);
      ctx.lineTo(x + w - rx, y + h);
      ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry);
      ctx.lineTo(x + w, y + ry);
      ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y);
      ctx.lineTo(x + rx, y);
      ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry);
      ctx.close();
    }
    function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
      var x12, y12, x23, y23, x34, y34, x123, y123, x234, y234, x1234, y1234;
      var dx, dy, d2, d3;
      if (level > 10) return;
      x12 = .5 * (x1 + x2);
      y12 = .5 * (y1 + y2);
      x23 = .5 * (x2 + x3);
      y23 = .5 * (y2 + y3);
      x34 = .5 * (x3 + x4);
      y34 = .5 * (y3 + y4);
      x123 = .5 * (x12 + x23);
      y123 = .5 * (y12 + y23);
      dx = x4 - x1;
      dy = y4 - y1;
      d2 = abs((x2 - x4) * dy - (y2 - y4) * dx);
      d3 = abs((x3 - x4) * dy - (y3 - y4) * dx);
      if ((d2 + d3) * (d2 + d3) < ctx._tessTol * (dx * dx + dy * dy)) {
        ctx._addPoint(x4, y4, 0 === type ? type | PointFlags.PT_BEVEL : type);
        return;
      }
      x234 = .5 * (x23 + x34);
      y234 = .5 * (y23 + y34);
      x1234 = .5 * (x123 + x234);
      y1234 = .5 * (y123 + y234);
      tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1, 0);
      tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type);
    }
    module.exports = {
      arc: arc,
      ellipse: ellipse,
      roundRect: roundRect,
      tesselateBezier: tesselateBezier
    };
  }), {
    "./types": 238
  } ],
  237: [ (function(require, module, exports) {
    "use strict";
    require("./graphics");
  }), {
    "./graphics": 235
  } ],
  238: [ (function(require, module, exports) {
    "use strict";
    var LineCap = cc.Enum({
      BUTT: 0,
      ROUND: 1,
      SQUARE: 2
    });
    var LineJoin = cc.Enum({
      BEVEL: 0,
      ROUND: 1,
      MITER: 2
    });
    var PointFlags = cc.Enum({
      PT_CORNER: 1,
      PT_LEFT: 2,
      PT_BEVEL: 4,
      PT_INNERBEVEL: 8
    });
    module.exports = {
      LineCap: LineCap,
      LineJoin: LineJoin,
      PointFlags: PointFlags
    };
  }), {} ],
  239: [ (function(require, module, exports) {
    "use strict";
    require("./platform");
    require("./assets");
    true;
    require("./CCNode");
    require("./CCPrivateNode");
    require("./CCScene");
    require("./components");
    require("./graphics");
    require("./collider");
    require("./collider/CCIntersection");
    require("./physics");
    require("./camera/CCCamera");
    require("./geom-utils");
    require("./sp");
    require("./mesh");
    require("./3d");
    require("./base-ui/CCWidgetManager");
  }), {
    "./3d": 30,
    "./CCNode": 104,
    "./CCPrivateNode": 105,
    "./CCScene": 106,
    "./assets": 154,
    "./base-ui/CCWidgetManager": 165,
    "./camera/CCCamera": 166,
    "./collider": 174,
    "./collider/CCIntersection": 172,
    "./components": 211,
    "./geom-utils": 227,
    "./graphics": 237,
    "./mesh": 242,
    "./physics": 257,
    "./platform": 291,
    "./sp": 372
  } ],
  240: [ (function(require, module, exports) {
    "use strict";
    var _inputAssembler = _interopRequireDefault(require("../../renderer/core/input-assembler"));
    var _gfx = _interopRequireDefault(require("../../renderer/gfx"));
    var _meshData = require("./mesh-data");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var renderer = require("../renderer");
    var EventTarget = require("../event/event-target");
    function applyColor(data, offset, value) {
      data[offset] = value._val;
    }
    function applyVec2(data, offset, value) {
      data[offset] = value.x;
      data[offset + 1] = value.y;
    }
    function applyVec3(data, offset, value) {
      data[offset] = value.x;
      data[offset + 1] = value.y;
      data[offset + 2] = value.z;
    }
    var _compType2fn = {
      5120: "getInt8",
      5121: "getUint8",
      5122: "getInt16",
      5123: "getUint16",
      5124: "getInt32",
      5125: "getUint32",
      5126: "getFloat32"
    };
    var _compType2write = {
      5120: "setInt8",
      5121: "setUint8",
      5122: "setInt16",
      5123: "setUint16",
      5124: "setInt32",
      5125: "setUint32",
      5126: "setFloat32"
    };
    var littleEndian = (function() {
      var buffer = new ArrayBuffer(2);
      new DataView(buffer).setInt16(0, 256, true);
      return 256 === new Int16Array(buffer)[0];
    })();
    var Mesh = cc.Class({
      name: "cc.Mesh",
      extends: cc.Asset,
      mixins: [ EventTarget ],
      properties: {
        _nativeAsset: {
          override: true,
          get: function get() {
            return this._buffer;
          },
          set: function set(bin) {
            this._buffer = ArrayBuffer.isView(bin) ? bin.buffer : bin;
            this.initWithBuffer();
          }
        },
        _vertexBundles: {
          default: null,
          type: _meshData.VertexBundle
        },
        _primitives: {
          default: null,
          Primitive: _meshData.Primitive
        },
        _minPos: cc.v3(),
        _maxPos: cc.v3(),
        subMeshes: {
          get: function get() {
            return this._subMeshes;
          },
          set: function set(v) {
            this._subMeshes = v;
          }
        },
        subDatas: {
          get: function get() {
            return this._subDatas;
          }
        }
      },
      ctor: function ctor() {
        this._subMeshes = [];
        this._subDatas = [];
        this.loaded = false;
      },
      initWithBuffer: function initWithBuffer() {
        this._subMeshes.length = 0;
        var primitives = this._primitives;
        for (var i = 0; i < primitives.length; i++) {
          var primitive = primitives[i];
          var ibrange = primitive.data;
          var ibData = new Uint8Array(this._buffer, ibrange.offset, ibrange.length);
          var vertexBundle = this._vertexBundles[primitive.vertexBundleIndices[0]];
          var vbRange = vertexBundle.data;
          var gfxVFmt = new _gfx["default"].VertexFormat(vertexBundle.formats);
          var vbData = new Uint8Array(this._buffer, vbRange.offset, vbRange.length);
          var canBatch = this._canVertexFormatBatch(gfxVFmt);
          var meshData = new _meshData.MeshData();
          meshData.vData = vbData;
          meshData.iData = ibData;
          meshData.vfm = gfxVFmt;
          meshData.offset = vbRange.offset;
          meshData.canBatch = canBatch;
          this._subDatas.push(meshData);
          var vbBuffer;
          var ibBuffer;
          true, true;
          meshData.vDirty = true;
          this._subMeshes.push(new _inputAssembler["default"](null, null));
        }
        this.loaded = true;
        this.emit("load");
      },
      _canVertexFormatBatch: function _canVertexFormatBatch(format) {
        var aPosition = format._attr2el[_gfx["default"].ATTR_POSITION];
        var canBatch = !aPosition || aPosition.type === _gfx["default"].ATTR_TYPE_FLOAT32 && format._bytes % 4 === 0;
        return canBatch;
      },
      init: function init(vertexFormat, vertexCount, dynamic, index) {
        void 0 === dynamic && (dynamic = false);
        void 0 === index && (index = 0);
        var data = new Uint8Array(vertexFormat._bytes * vertexCount);
        var meshData = new _meshData.MeshData();
        meshData.vData = data;
        meshData.vfm = vertexFormat;
        meshData.vDirty = true;
        meshData.canBatch = this._canVertexFormatBatch(vertexFormat);
        if (!(true, true)) {
          var vb = new _gfx["default"].VertexBuffer(renderer.device, vertexFormat, dynamic ? _gfx["default"].USAGE_DYNAMIC : _gfx["default"].USAGE_STATIC, data);
          meshData.vb = vb;
          this._subMeshes[index] = new _inputAssembler["default"](meshData.vb);
        }
        var oldSubData = this._subDatas[index];
        if (oldSubData) {
          oldSubData.vb && oldSubData.vb.destroy();
          oldSubData.ib && oldSubData.ib.destroy();
        }
        this._subDatas[index] = meshData;
        this.loaded = true;
        this.emit("load");
        this.emit("init-format");
      },
      setVertices: function setVertices(name, values, index) {
        index = index || 0;
        var subData = this._subDatas[index];
        var el = subData.vfm.element(name);
        if (!el) return cc.warn("Cannot find " + name + " attribute in vertex defines.");
        var isFlatMode = "number" === typeof values[0];
        var elNum = el.num;
        var verticesCount = isFlatMode ? values.length / elNum | 0 : values.length;
        subData.vData.byteLength < verticesCount * el.stride && subData.setVData(new Uint8Array(verticesCount * subData.vfm._bytes));
        var data;
        var bytes = 4;
        if (name === _gfx["default"].ATTR_COLOR) if (isFlatMode) {
          data = subData.getVData();
          bytes = 1;
        } else data = subData.getVData(Uint32Array); else data = subData.getVData(Float32Array);
        var stride = el.stride / bytes;
        var offset = el.offset / bytes;
        if (isFlatMode) for (var i = 0, l = values.length / elNum; i < l; i++) {
          var sOffset = i * elNum;
          var dOffset = i * stride + offset;
          for (var j = 0; j < elNum; j++) data[dOffset + j] = values[sOffset + j];
        } else {
          var applyFunc;
          applyFunc = name === _gfx["default"].ATTR_COLOR ? applyColor : 2 === elNum ? applyVec2 : applyVec3;
          for (var _i = 0, _l = values.length; _i < _l; _i++) {
            var v = values[_i];
            var vOffset = _i * stride + offset;
            applyFunc(data, vOffset, v);
          }
        }
        subData.vDirty = true;
      },
      setIndices: function setIndices(indices, index, dynamic) {
        index = index || 0;
        var iData = indices;
        if (indices instanceof Uint16Array) iData = new Uint8Array(indices.buffer, indices.byteOffset, indices.byteLength); else if (Array.isArray(indices)) {
          iData = new Uint16Array(indices);
          iData = new Uint8Array(iData.buffer, iData.byteOffset, iData.byteLength);
        }
        var usage = dynamic ? _gfx["default"].USAGE_DYNAMIC : _gfx["default"].USAGE_STATIC;
        var subData = this._subDatas[index];
        if (subData.ib) {
          subData.iData = iData;
          subData.iDirty = true;
        } else {
          subData.iData = iData;
          if (!(true, true)) {
            var buffer = new _gfx["default"].IndexBuffer(renderer.device, _gfx["default"].INDEX_FMT_UINT16, usage, iData, iData.byteLength / _gfx["default"].IndexBuffer.BYTES_PER_INDEX[_gfx["default"].INDEX_FMT_UINT16]);
            subData.ib = buffer;
            this._subMeshes[index]._indexBuffer = subData.ib;
          }
        }
      },
      setPrimitiveType: function setPrimitiveType(type, index) {
        index = index || 0;
        var subMesh = this._subMeshes[index];
        if (!subMesh) {
          cc.warn("Do not have sub mesh at index " + index);
          return;
        }
        this._subMeshes[index]._primitiveType = type;
      },
      clear: function clear() {
        this._subMeshes.length = 0;
        var subDatas = this._subDatas;
        for (var i = 0, len = subDatas.length; i < len; i++) {
          var vb = subDatas[i].vb;
          vb && vb.destroy();
          var ib = subDatas[i].ib;
          ib && ib.destroy();
        }
        subDatas.length = 0;
      },
      setBoundingBox: function setBoundingBox(min, max) {
        this._minPos = min;
        this._maxPos = max;
      },
      destroy: function destroy() {
        this.clear();
      },
      _uploadData: function _uploadData() {
        var subDatas = this._subDatas;
        for (var i = 0, len = subDatas.length; i < len; i++) {
          var subData = subDatas[i];
          if (subData.vDirty) {
            var buffer = subData.vb, data = subData.vData;
            buffer.update(0, data);
            subData.vDirty = false;
          }
          if (subData.iDirty) {
            var _buffer = subData.ib, _data = subData.iData;
            _buffer.update(0, _data);
            subData.iDirty = false;
          }
        }
      },
      _getAttrMeshData: function _getAttrMeshData(subDataIndex, name) {
        var subData = this._subDatas[subDataIndex];
        if (!subData) return [];
        var format = subData.vfm;
        var fmt = format.element(name);
        if (!fmt) return [];
        subData.attrDatas || (subData.attrDatas = {});
        var attrDatas = subData.attrDatas;
        var data = attrDatas[name];
        if (data) return data;
        data = attrDatas[name] = [];
        var vbData = subData.vData;
        var dv = new DataView(vbData.buffer, vbData.byteOffset, vbData.byteLength);
        var stride = fmt.stride;
        var eleOffset = fmt.offset;
        var eleNum = fmt.num;
        var eleByte = fmt.bytes / eleNum;
        var fn = _compType2fn[fmt.type];
        var vertexCount = vbData.byteLength / format._bytes;
        for (var i = 0; i < vertexCount; i++) {
          var offset = i * stride + eleOffset;
          for (var j = 0; j < eleNum; j++) {
            var v = dv[fn](offset + j * eleByte, littleEndian);
            data.push(v);
          }
        }
        return data;
      },
      copyAttribute: function copyAttribute(primitiveIndex, attributeName, buffer, stride, offset) {
        var written = false;
        var subData = this._subDatas[primitiveIndex];
        if (!subData) return written;
        var format = subData.vfm;
        var fmt = format.element(attributeName);
        if (!fmt) return written;
        var writter = _compType2write[fmt.type];
        if (!writter) return written;
        var data = this._getAttrMeshData(primitiveIndex, attributeName);
        var vertexCount = subData.vData.byteLength / format._bytes;
        var eleByte = fmt.bytes / fmt.num;
        if (data.length > 0) {
          var outputView = new DataView(buffer, offset);
          var outputStride = stride;
          var num = fmt.num;
          for (var i = 0; i < vertexCount; ++i) {
            var index = i * num;
            for (var j = 0; j < num; ++j) {
              var inputOffset = index + j;
              var outputOffset = outputStride * i + eleByte * j;
              outputView[writter](outputOffset, data[inputOffset], littleEndian);
            }
          }
          written = true;
        }
        return written;
      },
      copyIndices: function copyIndices(primitiveIndex, outputArray) {
        var subData = this._subDatas[primitiveIndex];
        if (!subData) return false;
        var iData = subData.iData;
        var indexCount = iData.length / 2;
        var dv = new DataView(iData.buffer, iData.byteOffset, iData.byteLength);
        var fn = _compType2fn[_gfx["default"].INDEX_FMT_UINT8];
        for (var i = 0; i < indexCount; ++i) outputArray[i] = dv[fn](2 * i);
        return true;
      }
    });
    cc.Mesh = module.exports = Mesh;
  }), {
    "../../renderer/core/input-assembler": 423,
    "../../renderer/gfx": 427,
    "../event/event-target": 219,
    "../renderer": 322,
    "./mesh-data": 243
  } ],
  241: [ (function(require, module, exports) {
    "use strict";
    var _gfx = _interopRequireDefault(require("../../renderer/gfx"));
    var _inputAssembler = _interopRequireDefault(require("../../renderer/core/input-assembler"));
    var _aabb = _interopRequireDefault(require("../geom-utils/aabb"));
    var _vec = _interopRequireDefault(require("../value-types/vec3"));
    var _mat = _interopRequireDefault(require("../value-types/mat4"));
    var _materialVariant = _interopRequireDefault(require("../assets/material/material-variant"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RenderComponent = require("../components/CCRenderComponent");
    var Mesh = require("./CCMesh");
    var RenderFlow = require("../renderer/render-flow");
    var Renderer = require("../renderer");
    var Material = require("../assets/material/CCMaterial");
    var ShadowCastingMode = cc.Enum({
      OFF: 0,
      ON: 1
    });
    var MeshRenderer = cc.Class({
      name: "cc.MeshRenderer",
      extends: RenderComponent,
      editor: false,
      properties: {
        _mesh: {
          default: null,
          type: Mesh
        },
        _receiveShadows: false,
        _shadowCastingMode: ShadowCastingMode.OFF,
        _enableAutoBatch: false,
        mesh: {
          get: function get() {
            return this._mesh;
          },
          set: function set(v) {
            if (this._mesh === v) return;
            this._setMesh(v);
            if (!v) {
              this.disableRender();
              return;
            }
            this.markForRender(true);
            this.node._renderFlag |= RenderFlow.FLAG_TRANSFORM;
          },
          type: Mesh,
          animatable: false
        },
        textures: {
          default: [],
          type: cc.Texture2D,
          visible: false
        },
        receiveShadows: {
          get: function get() {
            return this._receiveShadows;
          },
          set: function set(val) {
            this._receiveShadows = val;
            this._updateReceiveShadow();
          },
          animatable: false
        },
        shadowCastingMode: {
          get: function get() {
            return this._shadowCastingMode;
          },
          set: function set(val) {
            this._shadowCastingMode = val;
            this._updateCastShadow();
          },
          type: ShadowCastingMode,
          animatable: false
        },
        enableAutoBatch: {
          get: function get() {
            return this._enableAutoBatch;
          },
          set: function set(val) {
            this._enableAutoBatch = val;
          }
        }
      },
      statics: {
        ShadowCastingMode: ShadowCastingMode
      },
      ctor: function ctor() {
        this._boundingBox = cc.geomUtils && new _aabb["default"]();
        true;
        this._debugDatas = {
          wireFrame: [],
          normal: []
        };
      },
      onEnable: function onEnable() {
        var _this = this;
        this._super();
        if (this._mesh && !this._mesh.loaded) {
          this.disableRender();
          this._mesh.once("load", (function() {
            if (!_this.isValid) return;
            _this._setMesh(_this._mesh);
            _this.markForRender(true);
          }));
          cc.assetManager.postLoadNative(this._mesh);
        } else this._setMesh(this._mesh);
        this._updateRenderNode();
        this._updateMaterial();
      },
      onDestroy: function onDestroy() {
        this._setMesh(null);
        cc.pool.assembler.put(this._assembler);
      },
      _updateRenderNode: function _updateRenderNode() {
        this._assembler.setRenderNode(this.node);
      },
      _setMesh: function _setMesh(mesh) {
        cc.geomUtils && mesh && _aabb["default"].fromPoints(this._boundingBox, mesh._minPos, mesh._maxPos);
        this._mesh && this._mesh.off("init-format", this._updateMeshAttribute, this);
        mesh && mesh.on("init-format", this._updateMeshAttribute, this);
        this._mesh = mesh;
        this._assembler && (this._assembler._worldDatas = {});
        this._updateMeshAttribute();
      },
      _getDefaultMaterial: function _getDefaultMaterial() {
        return Material.getBuiltinMaterial("unlit");
      },
      _validateRender: function _validateRender() {
        var mesh = this._mesh;
        if (mesh && mesh._subDatas.length > 0) return;
        this.disableRender();
      },
      _updateMaterial: function _updateMaterial() {
        var textures = this.textures;
        if (textures && textures.length > 0) {
          var defaultMaterial = this._getDefaultMaterial();
          for (var i = 0; i < textures.length; i++) {
            var material = this._materials[i];
            if (material && material._uuid !== defaultMaterial._uuid) continue;
            if (!material) {
              material = _materialVariant["default"].create(defaultMaterial, this);
              this.setMaterial(i, material);
            }
            material.setProperty("diffuseTexture", textures[i]);
          }
        }
        this._updateReceiveShadow();
        this._updateCastShadow();
        this._updateMeshAttribute();
      },
      _updateReceiveShadow: function _updateReceiveShadow() {
        var materials = this.getMaterials();
        for (var i = 0; i < materials.length; i++) materials[i].define("CC_USE_SHADOW_MAP", this._receiveShadows, void 0, true);
      },
      _updateCastShadow: function _updateCastShadow() {
        var materials = this.getMaterials();
        for (var i = 0; i < materials.length; i++) materials[i].define("CC_CASTING_SHADOW", this._shadowCastingMode === ShadowCastingMode.ON, void 0, true);
      },
      _updateMeshAttribute: function _updateMeshAttribute() {
        var subDatas = this._mesh && this._mesh.subDatas;
        if (!subDatas) return;
        var materials = this.getMaterials();
        for (var i = 0; i < materials.length; i++) {
          if (!subDatas[i]) break;
          var vfm = subDatas[i].vfm;
          var material = materials[i];
          material.define("CC_USE_ATTRIBUTE_COLOR", !!vfm.element(_gfx["default"].ATTR_COLOR), void 0, true);
          material.define("CC_USE_ATTRIBUTE_UV0", !!vfm.element(_gfx["default"].ATTR_UV0), void 0, true);
          material.define("CC_USE_ATTRIBUTE_NORMAL", !!vfm.element(_gfx["default"].ATTR_NORMAL), void 0, true);
          material.define("CC_USE_ATTRIBUTE_TANGENT", !!vfm.element(_gfx["default"].ATTR_TANGENT), void 0, true);
        }
        true;
        for (var name in this._debugDatas) this._debugDatas[name].length = 0;
        true, true;
        this._assembler.updateMeshData(this);
      },
      _checkBacth: function _checkBacth() {}
    });
    true;
    var BLACK_COLOR = cc.Color.BLACK;
    var RED_COLOR = cc.Color.RED;
    var v3_tmp = [ cc.v3(), cc.v3() ];
    var mat4_tmp = cc.mat4();
    var createDebugDataFns = {
      normal: function normal(comp, ia, subData, subIndex) {
        var oldVfm = subData.vfm;
        var normalEle = oldVfm.element(_gfx["default"].ATTR_NORMAL);
        var posEle = oldVfm.element(_gfx["default"].ATTR_POSITION);
        var jointEle = oldVfm.element(_gfx["default"].ATTR_JOINTS);
        var weightEle = oldVfm.element(_gfx["default"].ATTR_WEIGHTS);
        if (!normalEle || !posEle) return;
        var indices = [];
        var vbData = [];
        var lineLength = 100;
        _vec["default"].set(v3_tmp[0], 5, 0, 0);
        _mat["default"].invert(mat4_tmp, comp.node._worldMatrix);
        _vec["default"].transformMat4Normal(v3_tmp[0], v3_tmp[0], mat4_tmp);
        lineLength = v3_tmp[0].mag();
        var mesh = comp.mesh;
        var posData = mesh._getAttrMeshData(subIndex, _gfx["default"].ATTR_POSITION);
        var normalData = mesh._getAttrMeshData(subIndex, _gfx["default"].ATTR_NORMAL);
        var jointData = mesh._getAttrMeshData(subIndex, _gfx["default"].ATTR_JOINTS);
        var weightData = mesh._getAttrMeshData(subIndex, _gfx["default"].ATTR_WEIGHTS);
        var vertexCount = posData.length / posEle.num;
        for (var i = 0; i < vertexCount; i++) {
          var normalIndex = i * normalEle.num;
          var posIndex = i * posEle.num;
          _vec["default"].set(v3_tmp[0], normalData[normalIndex], normalData[normalIndex + 1], normalData[normalIndex + 2]);
          _vec["default"].set(v3_tmp[1], posData[posIndex], posData[posIndex + 1], posData[posIndex + 2]);
          _vec["default"].scaleAndAdd(v3_tmp[0], v3_tmp[1], v3_tmp[0], lineLength);
          for (var lineIndex = 0; lineIndex < 2; lineIndex++) {
            vbData.push(v3_tmp[lineIndex].x, v3_tmp[lineIndex].y, v3_tmp[lineIndex].z);
            if (jointEle) {
              var jointIndex = i * jointEle.num;
              for (var j = 0; j < jointEle.num; j++) vbData.push(jointData[jointIndex + j]);
            }
            if (weightEle) {
              var weightIndex = i * weightEle.num;
              for (var _j = 0; _j < weightEle.num; _j++) vbData.push(weightData[weightIndex + _j]);
            }
          }
          indices.push(2 * i, 2 * i + 1);
        }
        var formatOpts = [ {
          name: _gfx["default"].ATTR_POSITION,
          type: _gfx["default"].ATTR_TYPE_FLOAT32,
          num: 3
        } ];
        jointEle && formatOpts.push({
          name: _gfx["default"].ATTR_JOINTS,
          type: _gfx["default"].ATTR_TYPE_FLOAT32,
          num: jointEle.num
        });
        weightEle && formatOpts.push({
          name: _gfx["default"].ATTR_WEIGHTS,
          type: _gfx["default"].ATTR_TYPE_FLOAT32,
          num: weightEle.num
        });
        var gfxVFmt = new _gfx["default"].VertexFormat(formatOpts);
        var vb = new _gfx["default"].VertexBuffer(Renderer.device, gfxVFmt, _gfx["default"].USAGE_STATIC, new Float32Array(vbData));
        var ibData = new Uint16Array(indices);
        var ib = new _gfx["default"].IndexBuffer(Renderer.device, _gfx["default"].INDEX_FMT_UINT16, _gfx["default"].USAGE_STATIC, ibData, ibData.length);
        var m = _materialVariant["default"].createWithBuiltin("unlit");
        m.setProperty("diffuseColor", RED_COLOR);
        return {
          material: m,
          ia: new _inputAssembler["default"](vb, ib, _gfx["default"].PT_LINES)
        };
      },
      wireFrame: function wireFrame(comp, ia, subData) {
        var oldIbData = subData.getIData(Uint16Array);
        var m = _materialVariant["default"].createWithBuiltin("unlit");
        m.setProperty("diffuseColor", BLACK_COLOR);
        var indices = [];
        for (var i = 0; i < oldIbData.length; i += 3) {
          var a = oldIbData[i + 0];
          var b = oldIbData[i + 1];
          var c = oldIbData[i + 2];
          indices.push(a, b, b, c, c, a);
        }
        var ibData = new Uint16Array(indices);
        var ib = new _gfx["default"].IndexBuffer(Renderer.device, _gfx["default"].INDEX_FMT_UINT16, _gfx["default"].USAGE_STATIC, ibData, ibData.length);
        return {
          material: m,
          ia: new _inputAssembler["default"](ia._vertexBuffer, ib, _gfx["default"].PT_LINES)
        };
      }
    };
    var _proto = MeshRenderer.prototype;
    _proto._updateDebugDatas = function() {
      var debugDatas = this._debugDatas;
      var subMeshes = this._mesh.subMeshes;
      var subDatas = this._mesh._subDatas;
      for (var name in debugDatas) {
        var debugData = debugDatas[name];
        if (debugData.length === subMeshes.length) continue;
        if (!cc.macro["SHOW_MESH_" + name.toUpperCase()]) continue;
        debugData.length = subMeshes.length;
        for (var i = 0; i < subMeshes.length; i++) debugData[i] = createDebugDataFns[name](this, subMeshes[i], subDatas[i], i);
      }
    };
    cc.MeshRenderer = module.exports = MeshRenderer;
  }), {
    "../../renderer/core/input-assembler": 423,
    "../../renderer/gfx": 427,
    "../assets/material/CCMaterial": 156,
    "../assets/material/material-variant": 163,
    "../components/CCRenderComponent": 192,
    "../geom-utils/aabb": 223,
    "../renderer": 322,
    "../renderer/render-flow": 323,
    "../value-types/mat4": 403,
    "../value-types/vec3": 411,
    "./CCMesh": 240
  } ],
  242: [ (function(require, module, exports) {
    "use strict";
    require("./CCMesh");
    true;
    require("./CCMeshRenderer");
    require("./mesh-renderer");
  }), {
    "./CCMesh": 240,
    "./CCMeshRenderer": 241,
    "./mesh-renderer": 244
  } ],
  243: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.BufferRange = void 0;
    exports.MeshData = MeshData;
    exports.VertexFormat = exports.VertexBundle = exports.Primitive = void 0;
    var _gfx = _interopRequireDefault(require("../../renderer/gfx"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var BufferRange = cc.Class({
      name: "cc.BufferRange",
      properties: {
        offset: 0,
        length: 0
      }
    });
    exports.BufferRange = BufferRange;
    var VertexFormat = cc.Class({
      name: "cc.mesh.VertexFormat",
      properties: {
        name: "",
        type: -1,
        num: -1,
        normalize: false
      }
    });
    exports.VertexFormat = VertexFormat;
    var VertexBundle = cc.Class({
      name: "cc.mesh.VertexBundle",
      properties: {
        data: {
          default: null,
          type: BufferRange
        },
        formats: {
          default: [],
          type: VertexFormat
        },
        verticesCount: 0
      }
    });
    exports.VertexBundle = VertexBundle;
    var Primitive = cc.Class({
      name: "cc.mesh.Primitive",
      properties: {
        vertexBundleIndices: {
          default: [],
          type: cc.Float
        },
        data: {
          default: null,
          type: BufferRange
        },
        indexUnit: _gfx["default"].INDEX_FMT_UINT16,
        topology: _gfx["default"].PT_TRIANGLES
      }
    });
    exports.Primitive = Primitive;
    function MeshData() {
      this.vData = null;
      this.float32VData = null;
      this.uint32VData = null;
      this.iData = null;
      this.uint16IData = null;
      this.vfm = null;
      this.offset = 0;
      this.vb = null;
      this.ib = null;
      this.vDirty = false;
      this.iDirty = false;
      this.enable = true;
    }
    MeshData.prototype.setVData = function(data) {
      this.vData = data;
      this.float32VData = null;
      this.uint32VData = null;
    };
    MeshData.prototype.getVData = function(format) {
      if (format === Float32Array) {
        this.float32VData || (this.float32VData = new Float32Array(this.vData.buffer, this.vData.byteOffset, this.vData.byteLength / 4));
        return this.float32VData;
      }
      if (format === Uint32Array) {
        this.uint32VData || (this.uint32VData = new Uint32Array(this.vData.buffer, this.vData.byteOffset, this.vData.byteLength / 4));
        return this.uint32VData;
      }
      return this.vData;
    };
    MeshData.prototype.getIData = function(format) {
      if (format === Uint16Array) {
        this.uint16IData || (this.uint16IData = new Uint16Array(this.iData.buffer, this.iData.byteOffset, this.iData.byteLength / 2));
        return this.uint16IData;
      }
      return this.iData;
    };
  }), {
    "../../renderer/gfx": 427
  } ],
  244: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler = _interopRequireDefault(require("../renderer/assembler"));
    var _gfx = _interopRequireDefault(require("../../renderer/gfx"));
    var _vec = _interopRequireDefault(require("../value-types/vec3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var MeshRenderer = require("./CCMeshRenderer");
    var _tmp_vec3 = new _vec["default"]();
    var MeshRendererAssembler = (function(_Assembler) {
      _inheritsLoose(MeshRendererAssembler, _Assembler);
      function MeshRendererAssembler() {
        return _Assembler.apply(this, arguments) || this;
      }
      var _proto = MeshRendererAssembler.prototype;
      _proto.init = function init(renderComp) {
        _Assembler.prototype.init.call(this, renderComp);
        this._worldDatas = {};
        this._renderNode = null;
      };
      _proto.setRenderNode = function setRenderNode(node) {
        this._renderNode = node;
      };
      _proto.fillBuffers = function fillBuffers(comp, renderer) {
        if (!comp.mesh) return;
        comp.mesh._uploadData();
        var isCullingMaskSame = renderer.cullingMask === comp.node._cullingMask;
        var enableAutoBatch = comp.enableAutoBatch;
        var materials = comp._materials;
        var submeshes = comp.mesh._subMeshes;
        var subDatas = comp.mesh.subDatas;
        for (var i = 0; i < submeshes.length; i++) {
          var ia = submeshes[i];
          var meshData = subDatas[i];
          var material = materials[i] || materials[0];
          if (!enableAutoBatch || !meshData.canBatch || ia._primitiveType !== _gfx["default"].PT_TRIANGLES) {
            renderer._flush();
            renderer.material = material;
            renderer.cullingMask = comp.node._cullingMask;
            renderer.node = this._renderNode;
            renderer._flushIA(ia);
            continue;
          }
          isCullingMaskSame && material.getHash() === renderer.material.getHash() || renderer._flush();
          renderer.material = material;
          renderer.cullingMask = comp.node._cullingMask;
          renderer.node = renderer._dummyNode;
          this._fillBuffer(comp, meshData, renderer, i);
        }
        if ((true, cc.macro.SHOW_MESH_WIREFRAME || cc.macro.SHOW_MESH_NORMAL) && !(comp.node._cullingMask & 1 << cc.Node.BuiltinGroupIndex.DEBUG)) {
          renderer._flush();
          renderer.node = this._renderNode;
          comp._updateDebugDatas();
          cc.macro.SHOW_MESH_WIREFRAME && this._drawDebugDatas(comp, renderer, "wireFrame");
          cc.macro.SHOW_MESH_NORMAL && this._drawDebugDatas(comp, renderer, "normal");
        }
      };
      _proto._fillBuffer = function _fillBuffer(comp, meshData, renderer, dataIndex) {
        var vData = meshData.getVData(Float32Array);
        var vtxFormat = meshData.vfm;
        var vertexCount = vData.byteLength / vtxFormat._bytes | 0;
        var indices = meshData.getIData(Uint16Array);
        var indicesCount = indices.length;
        var buffer = renderer.getBuffer("mesh", vtxFormat);
        var offsetInfo = buffer.request(vertexCount, indicesCount);
        var indiceOffset = offsetInfo.indiceOffset, vertexOffset = offsetInfo.byteOffset >> 2, vertexId = offsetInfo.vertexOffset, vbuf = buffer._vData, ibuf = buffer._iData;
        !renderer.worldMatDirty && this._worldDatas[dataIndex] || this._updateWorldVertices(dataIndex, vertexCount, vData, vtxFormat, comp.node._worldMatrix);
        vbuf.set(this._worldDatas[dataIndex], vertexOffset);
        for (var i = 0; i < indicesCount; i++) ibuf[indiceOffset + i] = vertexId + indices[i];
      };
      _proto._updateWorldVertices = function _updateWorldVertices(dataIndex, vertexCount, local, vtxFormat, wolrdMatrix) {
        var world = this._worldDatas[dataIndex];
        if (!world) {
          world = this._worldDatas[dataIndex] = new Float32Array(local.length);
          world.set(local);
        }
        var floatCount = vtxFormat._bytes / 4;
        var elements = vtxFormat._elements;
        for (var i = 0, n = elements.length; i < n; i++) {
          var element = elements[i];
          var attrOffset = element.offset / 4;
          if (element.name === _gfx["default"].ATTR_POSITION || element.name === _gfx["default"].ATTR_NORMAL) {
            var transformMat4 = element.name === _gfx["default"].ATTR_NORMAL ? _vec["default"].transformMat4Normal : _vec["default"].transformMat4;
            for (var j = 0; j < vertexCount; j++) {
              var offset = j * floatCount + attrOffset;
              _tmp_vec3.x = local[offset];
              _tmp_vec3.y = local[offset + 1];
              _tmp_vec3.z = local[offset + 2];
              transformMat4(_tmp_vec3, _tmp_vec3, wolrdMatrix);
              world[offset] = _tmp_vec3.x;
              world[offset + 1] = _tmp_vec3.y;
              world[offset + 2] = _tmp_vec3.z;
            }
          }
        }
      };
      _proto._drawDebugDatas = function _drawDebugDatas(comp, renderer, name) {
        var debugDatas = comp._debugDatas[name];
        if (!debugDatas) return;
        for (var i = 0; i < debugDatas.length; i++) {
          var debugData = debugDatas[i];
          if (!debugData) continue;
          var material = debugData.material;
          renderer.material = material;
          renderer._flushIA(debugData.ia);
        }
      };
      return MeshRendererAssembler;
    })(_assembler["default"]);
    exports["default"] = MeshRendererAssembler;
    _assembler["default"].register(MeshRenderer, MeshRendererAssembler);
    module.exports = exports["default"];
  }), {
    "../../renderer/gfx": 427,
    "../renderer/assembler": 302,
    "../value-types/vec3": 411,
    "./CCMeshRenderer": 241
  } ],
  245: [ (function(require, module, exports) {
    "use strict";
    var CompScheduler = require("./component-scheduler");
    var Flags = require("./platform/CCObject").Flags;
    var js = require("./platform/js");
    var callerFunctor = false;
    var MAX_POOL_SIZE = 4;
    var IsPreloadStarted = Flags.IsPreloadStarted;
    var IsOnLoadStarted = Flags.IsOnLoadStarted;
    var IsOnLoadCalled = Flags.IsOnLoadCalled;
    var Deactivating = Flags.Deactivating;
    var callPreloadInTryCatch = false;
    var callOnLoadInTryCatch = false;
    var callOnDestroyInTryCatch = false;
    var callOnFocusInTryCatch = false;
    var callOnLostFocusInTryCatch = false;
    var UnsortedInvoker = cc.Class({
      extends: CompScheduler.LifeCycleInvoker,
      add: function add(comp) {
        this._zero.array.push(comp);
      },
      remove: function remove(comp) {
        this._zero.fastRemove(comp);
      },
      cancelInactive: function cancelInactive(flagToClear) {
        CompScheduler.LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
      },
      invoke: function invoke() {
        this._invoke(this._zero);
        this._zero.array.length = 0;
      }
    });
    var invokePreload = CompScheduler.createInvokeImpl("c.__preload();");
    var invokeOnLoad = CompScheduler.createInvokeImpl("c.onLoad();c._objFlags|=" + IsOnLoadCalled, false, IsOnLoadCalled);
    var activateTasksPool = new js.Pool(MAX_POOL_SIZE);
    activateTasksPool.get = function getActivateTask() {
      var task = this._get() || {
        preload: new UnsortedInvoker(invokePreload),
        onLoad: new CompScheduler.OneOffInvoker(invokeOnLoad),
        onEnable: new CompScheduler.OneOffInvoker(CompScheduler.invokeOnEnable)
      };
      task.preload._zero.i = -1;
      var invoker = task.onLoad;
      invoker._zero.i = -1;
      invoker._neg.i = -1;
      invoker._pos.i = -1;
      invoker = task.onEnable;
      invoker._zero.i = -1;
      invoker._neg.i = -1;
      invoker._pos.i = -1;
      return task;
    };
    function _componentCorrupted(node, comp, index) {
      true;
      cc.errorID(3817, node.name, index);
      console.log("Corrupted component value:", comp);
      comp ? node._removeComponent(comp) : js.array.removeAt(node._components, index);
    }
    function _onLoadInEditor(comp) {
      if (comp.onLoad && !cc.engine._isPlaying) {
        var focused = Editor.Selection.curActivate("node") === comp.node.uuid;
        focused ? comp.onFocusInEditor && callOnFocusInTryCatch(comp) : comp.onLostFocusInEditor && callOnLostFocusInTryCatch(comp);
      }
      true;
      _Scene.AssetsWatcher.start(comp);
    }
    function ctor() {
      this._activatingStack = [];
    }
    var NodeActivator = cc.Class({
      ctor: ctor,
      reset: ctor,
      _activateNodeRecursively: function _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
        if (node._objFlags & Deactivating) {
          cc.errorID(3816, node.name);
          return;
        }
        node._activeInHierarchy = true;
        var originCount = node._components.length;
        for (var i = 0; i < originCount; ++i) {
          var component = node._components[i];
          if (component instanceof cc.Component) this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker); else {
            _componentCorrupted(node, component, i);
            --i;
            --originCount;
          }
        }
        node._childArrivalOrder = node._children.length;
        for (var _i = 0, len = node._children.length; _i < len; ++_i) {
          var child = node._children[_i];
          child._localZOrder = 4294901760 & child._localZOrder | _i + 1;
          child._active && this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
        }
        node._onPostActivated(true);
      },
      _deactivateNodeRecursively: function _deactivateNodeRecursively(node) {
        true;
        cc.assert(!(node._objFlags & Deactivating), "node should not deactivating");
        cc.assert(node._activeInHierarchy, "node should not deactivated");
        node._objFlags |= Deactivating;
        node._activeInHierarchy = false;
        var originCount = node._components.length;
        for (var c = 0; c < originCount; ++c) {
          var component = node._components[c];
          if (component._enabled) {
            cc.director._compScheduler.disableComp(component);
            if (node._activeInHierarchy) {
              node._objFlags &= ~Deactivating;
              return;
            }
          }
        }
        for (var i = 0, len = node._children.length; i < len; ++i) {
          var child = node._children[i];
          if (child._activeInHierarchy) {
            this._deactivateNodeRecursively(child);
            if (node._activeInHierarchy) {
              node._objFlags &= ~Deactivating;
              return;
            }
          }
        }
        node._onPostActivated(false);
        node._objFlags &= ~Deactivating;
      },
      activateNode: function activateNode(node, active) {
        if (active) {
          var task = activateTasksPool.get();
          this._activatingStack.push(task);
          this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);
          task.preload.invoke();
          task.onLoad.invoke();
          task.onEnable.invoke();
          this._activatingStack.pop();
          activateTasksPool.put(task);
        } else {
          this._deactivateNodeRecursively(node);
          var stack = this._activatingStack;
          for (var i = 0; i < stack.length; i++) {
            var lastTask = stack[i];
            lastTask.preload.cancelInactive(IsPreloadStarted);
            lastTask.onLoad.cancelInactive(IsOnLoadStarted);
            lastTask.onEnable.cancelInactive();
          }
        }
        node.emit("active-in-hierarchy-changed", node);
      },
      activateComp: function(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
        if (!cc.isValid(comp, true)) return;
        if (!(comp._objFlags & IsPreloadStarted)) {
          comp._objFlags |= IsPreloadStarted;
          comp.__preload && (preloadInvoker ? preloadInvoker.add(comp) : comp.__preload());
        }
        if (!(comp._objFlags & IsOnLoadStarted)) {
          comp._objFlags |= IsOnLoadStarted;
          if (comp.onLoad) if (onLoadInvoker) onLoadInvoker.add(comp); else {
            comp.onLoad();
            comp._objFlags |= IsOnLoadCalled;
          } else comp._objFlags |= IsOnLoadCalled;
        }
        if (comp._enabled) {
          var deactivatedOnLoading = !comp.node._activeInHierarchy;
          if (deactivatedOnLoading) return;
          cc.director._compScheduler.enableComp(comp, onEnableInvoker);
        }
      },
      destroyComp: function(comp) {
        cc.director._compScheduler.disableComp(comp);
        comp.onDestroy && comp._objFlags & IsOnLoadCalled && comp.onDestroy();
      },
      resetComp: false
    });
    module.exports = NodeActivator;
  }), {
    "./component-scheduler": 175,
    "./platform/CCObject": 278,
    "./platform/js": 294,
    "./utils/misc": 386
  } ],
  246: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("./CCPhysicsTypes").PTM_RATIO;
    var ContactType = require("./CCPhysicsTypes").ContactType;
    var pools = [];
    var pointCache = [ cc.v2(), cc.v2() ];
    var b2worldmanifold = new b2.WorldManifold();
    var worldmanifold = {
      points: [],
      separations: [],
      normal: cc.v2()
    };
    function ManifoldPoint() {
      this.localPoint = cc.v2();
      this.normalImpulse = 0;
      this.tangentImpulse = 0;
    }
    var manifoldPointCache = [ new ManifoldPoint(), new ManifoldPoint() ];
    var b2manifold = new b2.Manifold();
    var manifold = {
      type: 0,
      localPoint: cc.v2(),
      localNormal: cc.v2(),
      points: []
    };
    var impulse = {
      normalImpulses: [],
      tangentImpulses: []
    };
    function PhysicsContact() {}
    PhysicsContact.prototype.init = function(b2contact) {
      this.colliderA = b2contact.GetFixtureA().collider;
      this.colliderB = b2contact.GetFixtureB().collider;
      this.disabled = false;
      this.disabledOnce = false;
      this._impulse = null;
      this._inverted = false;
      this._b2contact = b2contact;
      b2contact._contact = this;
    };
    PhysicsContact.prototype.reset = function() {
      this.setTangentSpeed(0);
      this.resetFriction();
      this.resetRestitution();
      this.colliderA = null;
      this.colliderB = null;
      this.disabled = false;
      this._impulse = null;
      this._b2contact._contact = null;
      this._b2contact = null;
    };
    PhysicsContact.prototype.getWorldManifold = function() {
      var points = worldmanifold.points;
      var separations = worldmanifold.separations;
      var normal = worldmanifold.normal;
      this._b2contact.GetWorldManifold(b2worldmanifold);
      var b2points = b2worldmanifold.points;
      var b2separations = b2worldmanifold.separations;
      var count = this._b2contact.GetManifold().pointCount;
      points.length = separations.length = count;
      for (var i = 0; i < count; i++) {
        var p = pointCache[i];
        p.x = b2points[i].x * PTM_RATIO;
        p.y = b2points[i].y * PTM_RATIO;
        points[i] = p;
        separations[i] = b2separations[i] * PTM_RATIO;
      }
      normal.x = b2worldmanifold.normal.x;
      normal.y = b2worldmanifold.normal.y;
      if (this._inverted) {
        normal.x *= -1;
        normal.y *= -1;
      }
      return worldmanifold;
    };
    PhysicsContact.prototype.getManifold = function() {
      var points = manifold.points;
      var localNormal = manifold.localNormal;
      var localPoint = manifold.localPoint;
      var b2manifold = this._b2contact.GetManifold();
      var b2points = b2manifold.points;
      var count = points.length = b2manifold.pointCount;
      for (var i = 0; i < count; i++) {
        var p = manifoldPointCache[i];
        var b2p = b2points[i];
        p.localPoint.x = b2p.localPoint.x * PTM_RATIO;
        p.localPoint.Y = b2p.localPoint.Y * PTM_RATIO;
        p.normalImpulse = b2p.normalImpulse * PTM_RATIO;
        p.tangentImpulse = b2p.tangentImpulse;
        points[i] = p;
      }
      localPoint.x = b2manifold.localPoint.x * PTM_RATIO;
      localPoint.y = b2manifold.localPoint.y * PTM_RATIO;
      localNormal.x = b2manifold.localNormal.x;
      localNormal.y = b2manifold.localNormal.y;
      manifold.type = b2manifold.type;
      if (this._inverted) {
        localNormal.x *= -1;
        localNormal.y *= -1;
      }
      return manifold;
    };
    PhysicsContact.prototype.getImpulse = function() {
      var b2impulse = this._impulse;
      if (!b2impulse) return null;
      var normalImpulses = impulse.normalImpulses;
      var tangentImpulses = impulse.tangentImpulses;
      var count = b2impulse.count;
      for (var i = 0; i < count; i++) {
        normalImpulses[i] = b2impulse.normalImpulses[i] * PTM_RATIO;
        tangentImpulses[i] = b2impulse.tangentImpulses[i];
      }
      tangentImpulses.length = normalImpulses.length = count;
      return impulse;
    };
    PhysicsContact.prototype.emit = function(contactType) {
      var func;
      switch (contactType) {
       case ContactType.BEGIN_CONTACT:
        func = "onBeginContact";
        break;

       case ContactType.END_CONTACT:
        func = "onEndContact";
        break;

       case ContactType.PRE_SOLVE:
        func = "onPreSolve";
        break;

       case ContactType.POST_SOLVE:
        func = "onPostSolve";
      }
      var colliderA = this.colliderA;
      var colliderB = this.colliderB;
      var bodyA = colliderA.body;
      var bodyB = colliderB.body;
      var comps;
      var i, l, comp;
      if (bodyA.enabledContactListener) {
        comps = bodyA.node._components;
        this._inverted = false;
        for (i = 0, l = comps.length; i < l; i++) {
          comp = comps[i];
          comp[func] && comp[func](this, colliderA, colliderB);
        }
      }
      if (bodyB.enabledContactListener) {
        comps = bodyB.node._components;
        this._inverted = true;
        for (i = 0, l = comps.length; i < l; i++) {
          comp = comps[i];
          comp[func] && comp[func](this, colliderB, colliderA);
        }
      }
      if (this.disabled || this.disabledOnce) {
        this.setEnabled(false);
        this.disabledOnce = false;
      }
    };
    PhysicsContact.get = function(b2contact) {
      var c;
      c = 0 === pools.length ? new cc.PhysicsContact() : pools.pop();
      c.init(b2contact);
      return c;
    };
    PhysicsContact.put = function(b2contact) {
      var c = b2contact._contact;
      if (!c) return;
      pools.push(c);
      c.reset();
    };
    var _p = PhysicsContact.prototype;
    _p.setEnabled = function(value) {
      this._b2contact.SetEnabled(value);
    };
    _p.isTouching = function() {
      return this._b2contact.IsTouching();
    };
    _p.setTangentSpeed = function(value) {
      this._b2contact.SetTangentSpeed(value / PTM_RATIO);
    };
    _p.getTangentSpeed = function() {
      return this._b2contact.GetTangentSpeed() * PTM_RATIO;
    };
    _p.setFriction = function(value) {
      this._b2contact.SetFriction(value);
    };
    _p.getFriction = function() {
      return this._b2contact.GetFriction();
    };
    _p.resetFriction = function() {
      return this._b2contact.ResetFriction();
    };
    _p.setRestitution = function(value) {
      this._b2contact.SetRestitution(value);
    };
    _p.getRestitution = function() {
      return this._b2contact.GetRestitution();
    };
    _p.resetRestitution = function() {
      return this._b2contact.ResetRestitution();
    };
    PhysicsContact.ContactType = ContactType;
    cc.PhysicsContact = module.exports = PhysicsContact;
  }), {
    "./CCPhysicsTypes": 248
  } ],
  247: [ (function(require, module, exports) {
    "use strict";
    var PhysicsTypes = require("./CCPhysicsTypes");
    var ContactType = PhysicsTypes.ContactType;
    var BodyType = PhysicsTypes.BodyType;
    var RayCastType = PhysicsTypes.RayCastType;
    var DrawBits = PhysicsTypes.DrawBits;
    var PTM_RATIO = PhysicsTypes.PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = PhysicsTypes.ANGLE_TO_PHYSICS_ANGLE;
    var PHYSICS_ANGLE_TO_ANGLE = PhysicsTypes.PHYSICS_ANGLE_TO_ANGLE;
    var convertToNodeRotation = require("./utils").convertToNodeRotation;
    var DebugDraw = require("./platform/CCPhysicsDebugDraw");
    var b2_aabb_tmp = new b2.AABB();
    var b2_vec2_tmp1 = new b2.Vec2();
    var b2_vec2_tmp2 = new b2.Vec2();
    var vec2_tmp = cc.v2();
    var PhysicsManager = cc.Class({
      mixins: [ cc.EventTarget ],
      statics: {
        DrawBits: DrawBits,
        PTM_RATIO: PTM_RATIO,
        VELOCITY_ITERATIONS: 10,
        POSITION_ITERATIONS: 10,
        FIXED_TIME_STEP: 1 / 60,
        MAX_ACCUMULATOR: .2
      },
      ctor: function ctor() {
        this._debugDrawFlags = 0;
        this._debugDrawer = null;
        this._world = null;
        this._bodies = [];
        this._joints = [];
        this._contactMap = {};
        this._contactID = 0;
        this._delayEvents = [];
        this._accumulator = 0;
        cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
        this.enabledAccumulator = false;
      },
      pushDelayEvent: function pushDelayEvent(target, func, args) {
        this._steping ? this._delayEvents.push({
          target: target,
          func: func,
          args: args
        }) : target[func].apply(target, args);
      },
      update: function update(dt) {
        var world = this._world;
        if (!world || !this.enabled) return;
        this.emit("before-step");
        this._steping = true;
        var velocityIterations = PhysicsManager.VELOCITY_ITERATIONS;
        var positionIterations = PhysicsManager.POSITION_ITERATIONS;
        if (this.enabledAccumulator) {
          this._accumulator += dt;
          var FIXED_TIME_STEP = PhysicsManager.FIXED_TIME_STEP;
          var MAX_ACCUMULATOR = PhysicsManager.MAX_ACCUMULATOR;
          this._accumulator > MAX_ACCUMULATOR && (this._accumulator = MAX_ACCUMULATOR);
          while (this._accumulator > FIXED_TIME_STEP) {
            world.Step(FIXED_TIME_STEP, velocityIterations, positionIterations);
            this._accumulator -= FIXED_TIME_STEP;
          }
        } else {
          var timeStep = 1 / cc.game.config["frameRate"];
          world.Step(timeStep, velocityIterations, positionIterations);
        }
        if (this.debugDrawFlags) {
          this._checkDebugDrawValid();
          this._debugDrawer.clear();
          world.DrawDebugData();
        }
        this._steping = false;
        var events = this._delayEvents;
        for (var i = 0, l = events.length; i < l; i++) {
          var event = events[i];
          event.target[event.func].apply(event.target, event.args);
        }
        events.length = 0;
        this._syncNode();
      },
      testPoint: function testPoint(point) {
        var x = b2_vec2_tmp1.x = point.x / PTM_RATIO;
        var y = b2_vec2_tmp1.y = point.y / PTM_RATIO;
        var d = .2 / PTM_RATIO;
        b2_aabb_tmp.lowerBound.x = x - d;
        b2_aabb_tmp.lowerBound.y = y - d;
        b2_aabb_tmp.upperBound.x = x + d;
        b2_aabb_tmp.upperBound.y = y + d;
        var callback = this._aabbQueryCallback;
        callback.init(b2_vec2_tmp1);
        this._world.QueryAABB(callback, b2_aabb_tmp);
        var fixture = callback.getFixture();
        if (fixture) return fixture.collider;
        return null;
      },
      testAABB: function testAABB(rect) {
        b2_aabb_tmp.lowerBound.x = rect.xMin / PTM_RATIO;
        b2_aabb_tmp.lowerBound.y = rect.yMin / PTM_RATIO;
        b2_aabb_tmp.upperBound.x = rect.xMax / PTM_RATIO;
        b2_aabb_tmp.upperBound.y = rect.yMax / PTM_RATIO;
        var callback = this._aabbQueryCallback;
        callback.init();
        this._world.QueryAABB(callback, b2_aabb_tmp);
        var fixtures = callback.getFixtures();
        var colliders = fixtures.map((function(fixture) {
          return fixture.collider;
        }));
        return colliders;
      },
      rayCast: function rayCast(p1, p2, type) {
        if (p1.equals(p2)) return [];
        type = type || RayCastType.Closest;
        b2_vec2_tmp1.x = p1.x / PTM_RATIO;
        b2_vec2_tmp1.y = p1.y / PTM_RATIO;
        b2_vec2_tmp2.x = p2.x / PTM_RATIO;
        b2_vec2_tmp2.y = p2.y / PTM_RATIO;
        var callback = this._raycastQueryCallback;
        callback.init(type);
        this._world.RayCast(callback, b2_vec2_tmp1, b2_vec2_tmp2);
        var fixtures = callback.getFixtures();
        if (fixtures.length > 0) {
          var points = callback.getPoints();
          var normals = callback.getNormals();
          var fractions = callback.getFractions();
          var results = [];
          for (var i = 0, l = fixtures.length; i < l; i++) {
            var fixture = fixtures[i];
            var collider = fixture.collider;
            if (type === RayCastType.AllClosest) {
              var result = results.find((function(result) {
                return result.collider === collider;
              }));
              if (result) {
                if (fractions[i] < result.fraction) {
                  result.fixtureIndex = collider._getFixtureIndex(fixture);
                  result.point.x = points[i].x * PTM_RATIO;
                  result.point.y = points[i].y * PTM_RATIO;
                  result.normal.x = normals[i].x;
                  result.normal.y = normals[i].y;
                  result.fraction = fractions[i];
                }
                continue;
              }
            }
            results.push({
              collider: collider,
              fixtureIndex: collider._getFixtureIndex(fixture),
              point: cc.v2(points[i].x * PTM_RATIO, points[i].y * PTM_RATIO),
              normal: cc.v2(normals[i]),
              fraction: fractions[i]
            });
          }
          return results;
        }
        return [];
      },
      syncPosition: function syncPosition() {
        var bodies = this._bodies;
        for (var i = 0; i < bodies.length; i++) bodies[i].syncPosition();
      },
      syncRotation: function syncRotation() {
        var bodies = this._bodies;
        for (var i = 0; i < bodies.length; i++) bodies[i].syncRotation();
      },
      _registerContactFixture: function _registerContactFixture(fixture) {
        this._contactListener.registerContactFixture(fixture);
      },
      _unregisterContactFixture: function _unregisterContactFixture(fixture) {
        this._contactListener.unregisterContactFixture(fixture);
      },
      _addBody: function _addBody(body, bodyDef) {
        var world = this._world;
        var node = body.node;
        if (!world || !node) return;
        body._b2Body = world.CreateBody(bodyDef);
        body._b2Body.body = body;
        this._bodies.push(body);
      },
      _removeBody: function _removeBody(body) {
        var world = this._world;
        if (!world) return;
        body._b2Body.body = null;
        world.DestroyBody(body._b2Body);
        body._b2Body = null;
        cc.js.array.remove(this._bodies, body);
      },
      _addJoint: function _addJoint(joint, jointDef) {
        var b2joint = this._world.CreateJoint(jointDef);
        if (!b2joint) return;
        b2joint._joint = joint;
        joint._joint = b2joint;
        this._joints.push(joint);
      },
      _removeJoint: function _removeJoint(joint) {
        joint._isValid() && this._world.DestroyJoint(joint._joint);
        joint._joint && (joint._joint._joint = null);
        cc.js.array.remove(this._joints, joint);
      },
      _initCallback: function _initCallback() {
        if (!this._world) {
          cc.warn("Please init PhysicsManager first");
          return;
        }
        if (this._contactListener) return;
        var listener = new cc.PhysicsContactListener();
        listener.setBeginContact(this._onBeginContact);
        listener.setEndContact(this._onEndContact);
        listener.setPreSolve(this._onPreSolve);
        listener.setPostSolve(this._onPostSolve);
        this._world.SetContactListener(listener);
        this._contactListener = listener;
        this._aabbQueryCallback = new cc.PhysicsAABBQueryCallback();
        this._raycastQueryCallback = new cc.PhysicsRayCastCallback();
      },
      _init: function _init() {
        this.enabled = true;
        this.debugDrawFlags = DrawBits.e_shapeBit;
      },
      _getWorld: function _getWorld() {
        return this._world;
      },
      _syncNode: function _syncNode() {
        var bodies = this._bodies;
        for (var i = 0, l = bodies.length; i < l; i++) {
          var body = bodies[i];
          var node = body.node;
          var b2body = body._b2Body;
          var pos = b2body.GetPosition();
          vec2_tmp.x = pos.x * PTM_RATIO;
          vec2_tmp.y = pos.y * PTM_RATIO;
          var angle = b2body.GetAngle() * PHYSICS_ANGLE_TO_ANGLE;
          if (null !== node.parent.parent) {
            vec2_tmp = node.parent.convertToNodeSpaceAR(vec2_tmp);
            angle = convertToNodeRotation(node.parent, angle);
          }
          var tempMask = node._eventMask;
          node._eventMask = 0;
          node.position = vec2_tmp;
          node.angle = -angle;
          node._eventMask = tempMask;
          body.type === BodyType.Animated && body.resetVelocity();
        }
      },
      _onBeginContact: function _onBeginContact(b2contact) {
        var c = cc.PhysicsContact.get(b2contact);
        c.emit(ContactType.BEGIN_CONTACT);
      },
      _onEndContact: function _onEndContact(b2contact) {
        var c = b2contact._contact;
        if (!c) return;
        c.emit(ContactType.END_CONTACT);
        cc.PhysicsContact.put(b2contact);
      },
      _onPreSolve: function _onPreSolve(b2contact) {
        var c = b2contact._contact;
        if (!c) return;
        c.emit(ContactType.PRE_SOLVE);
      },
      _onPostSolve: function _onPostSolve(b2contact, impulse) {
        var c = b2contact._contact;
        if (!c) return;
        c._impulse = impulse;
        c.emit(ContactType.POST_SOLVE);
        c._impulse = null;
      },
      _checkDebugDrawValid: function _checkDebugDrawValid() {
        if (!this._debugDrawer || !this._debugDrawer.isValid) {
          var node = new cc.Node("PHYSICS_MANAGER_DEBUG_DRAW");
          node.zIndex = cc.macro.MAX_ZINDEX;
          cc.game.addPersistRootNode(node);
          this._debugDrawer = node.addComponent(cc.Graphics);
          var debugDraw = new DebugDraw(this._debugDrawer);
          debugDraw.SetFlags(this.debugDrawFlags);
          this._world.SetDebugDraw(debugDraw);
        }
      }
    });
    cc.js.getset(PhysicsManager.prototype, "enabled", (function() {
      return this._enabled;
    }), (function(value) {
      false;
      if (value && !this._world) {
        var world = new b2.World(new b2.Vec2(0, -10));
        world.SetAllowSleeping(true);
        this._world = world;
        this._initCallback();
      }
      this._enabled = value;
    }));
    cc.js.getset(PhysicsManager.prototype, "debugDrawFlags", (function() {
      return this._debugDrawFlags;
    }), (function(value) {
      false;
      value && !this._debugDrawFlags ? this._debugDrawer && this._debugDrawer.node && (this._debugDrawer.node.active = true) : !value && this._debugDrawFlags && this._debugDrawer && this._debugDrawer.node && (this._debugDrawer.node.active = false);
      if (value) {
        this._checkDebugDrawValid();
        this._world.m_debugDraw.SetFlags(value);
      }
      this._debugDrawFlags = value;
      if (value) {
        this._checkDebugDrawValid();
        this._world.m_debugDraw.SetFlags(value);
      }
    }));
    cc.js.getset(PhysicsManager.prototype, "gravity", (function() {
      if (this._world) {
        var g = this._world.GetGravity();
        return cc.v2(g.x * PTM_RATIO, g.y * PTM_RATIO);
      }
      return cc.v2();
    }), (function(value) {
      this._world && this._world.SetGravity(new b2.Vec2(value.x / PTM_RATIO, value.y / PTM_RATIO));
    }));
    cc.PhysicsManager = module.exports = PhysicsManager;
  }), {
    "./CCPhysicsTypes": 248,
    "./platform/CCPhysicsDebugDraw": 269,
    "./utils": 271
  } ],
  248: [ (function(require, module, exports) {
    "use strict";
    var ContactType = {
      BEGIN_CONTACT: "begin-contact",
      END_CONTACT: "end-contact",
      PRE_SOLVE: "pre-solve",
      POST_SOLVE: "post-solve"
    };
    var BodyType = cc.Enum({
      Static: 0,
      Kinematic: 1,
      Dynamic: 2,
      Animated: 3
    });
    cc.RigidBodyType = BodyType;
    var RayCastType = cc.Enum({
      Closest: 0,
      Any: 1,
      AllClosest: 2,
      All: 3
    });
    cc.RayCastType = RayCastType;
    module.exports = {
      BodyType: BodyType,
      ContactType: ContactType,
      RayCastType: RayCastType,
      DrawBits: b2.DrawFlags,
      PTM_RATIO: 32,
      ANGLE_TO_PHYSICS_ANGLE: -Math.PI / 180,
      PHYSICS_ANGLE_TO_ANGLE: -180 / Math.PI
    };
  }), {} ],
  249: [ (function(require, module, exports) {
    "use strict";
    function At(i, vertices) {
      var s = vertices.length;
      return vertices[i < 0 ? s - -i % s : i % s];
    }
    function Copy(i, j, vertices) {
      var p = [];
      while (j < i) j += vertices.length;
      for (;i <= j; ++i) p.push(At(i, vertices));
      return p;
    }
    function ConvexPartition(vertices) {
      ForceCounterClockWise(vertices);
      var list = [];
      var d, lowerDist, upperDist;
      var p;
      var lowerInt = cc.v2();
      var upperInt = cc.v2();
      var lowerIndex = 0, upperIndex = 0;
      var lowerPoly, upperPoly;
      for (var i = 0; i < vertices.length; ++i) if (Reflex(i, vertices)) {
        lowerDist = upperDist = 1e8;
        for (var j = 0; j < vertices.length; ++j) {
          if (Left(At(i - 1, vertices), At(i, vertices), At(j, vertices)) && RightOn(At(i - 1, vertices), At(i, vertices), At(j - 1, vertices))) {
            p = LineIntersect(At(i - 1, vertices), At(i, vertices), At(j, vertices), At(j - 1, vertices));
            if (Right(At(i + 1, vertices), At(i, vertices), p)) {
              d = SquareDist(At(i, vertices), p);
              if (d < lowerDist) {
                lowerDist = d;
                lowerInt = p;
                lowerIndex = j;
              }
            }
          }
          if (Left(At(i + 1, vertices), At(i, vertices), At(j + 1, vertices)) && RightOn(At(i + 1, vertices), At(i, vertices), At(j, vertices))) {
            p = LineIntersect(At(i + 1, vertices), At(i, vertices), At(j, vertices), At(j + 1, vertices));
            if (Left(At(i - 1, vertices), At(i, vertices), p)) {
              d = SquareDist(At(i, vertices), p);
              if (d < upperDist) {
                upperDist = d;
                upperIndex = j;
                upperInt = p;
              }
            }
          }
        }
        if (lowerIndex == (upperIndex + 1) % vertices.length) {
          var sp = lowerInt.add(upperInt).div(2);
          lowerPoly = Copy(i, upperIndex, vertices);
          lowerPoly.push(sp);
          upperPoly = Copy(lowerIndex, i, vertices);
          upperPoly.push(sp);
        } else {
          var highestScore = 0, bestIndex = lowerIndex;
          while (upperIndex < lowerIndex) upperIndex += vertices.length;
          for (var j = lowerIndex; j <= upperIndex; ++j) if (CanSee(i, j, vertices)) {
            var score = 1 / (SquareDist(At(i, vertices), At(j, vertices)) + 1);
            Reflex(j, vertices) ? RightOn(At(j - 1, vertices), At(j, vertices), At(i, vertices)) && LeftOn(At(j + 1, vertices), At(j, vertices), At(i, vertices)) ? score += 3 : score += 2 : score += 1;
            if (score > highestScore) {
              bestIndex = j;
              highestScore = score;
            }
          }
          lowerPoly = Copy(i, bestIndex, vertices);
          upperPoly = Copy(bestIndex, i, vertices);
        }
        list = list.concat(ConvexPartition(lowerPoly));
        list = list.concat(ConvexPartition(upperPoly));
        return list;
      }
      list.push(vertices);
      for (var i = list.length - 1; i >= 0; i--) 0 == list[i].length && list.splice(i, 0);
      return list;
    }
    function CanSee(i, j, vertices) {
      if (Reflex(i, vertices)) {
        if (LeftOn(At(i, vertices), At(i - 1, vertices), At(j, vertices)) && RightOn(At(i, vertices), At(i + 1, vertices), At(j, vertices))) return false;
      } else if (RightOn(At(i, vertices), At(i + 1, vertices), At(j, vertices)) || LeftOn(At(i, vertices), At(i - 1, vertices), At(j, vertices))) return false;
      if (Reflex(j, vertices)) {
        if (LeftOn(At(j, vertices), At(j - 1, vertices), At(i, vertices)) && RightOn(At(j, vertices), At(j + 1, vertices), At(i, vertices))) return false;
      } else if (RightOn(At(j, vertices), At(j + 1, vertices), At(i, vertices)) || LeftOn(At(j, vertices), At(j - 1, vertices), At(i, vertices))) return false;
      for (var k = 0; k < vertices.length; ++k) {
        if ((k + 1) % vertices.length == i || k == i || (k + 1) % vertices.length == j || k == j) continue;
        var intersectionPoint = cc.v2();
        if (LineIntersect2(At(i, vertices), At(j, vertices), At(k, vertices), At(k + 1, vertices), intersectionPoint)) return false;
      }
      return true;
    }
    function Reflex(i, vertices) {
      return Right(i, vertices);
    }
    function Right(a, b, c) {
      if ("undefined" === typeof c) {
        var i = a, vertices = b;
        a = At(i - 1, vertices);
        b = At(i, vertices);
        c = At(i + 1, vertices);
      }
      return Area(a, b, c) < 0;
    }
    function Left(a, b, c) {
      return Area(a, b, c) > 0;
    }
    function LeftOn(a, b, c) {
      return Area(a, b, c) >= 0;
    }
    function RightOn(a, b, c) {
      return Area(a, b, c) <= 0;
    }
    function SquareDist(a, b) {
      var dx = b.x - a.x;
      var dy = b.y - a.y;
      return dx * dx + dy * dy;
    }
    function ForceCounterClockWise(vertices) {
      IsCounterClockWise(vertices) || vertices.reverse();
    }
    function IsCounterClockWise(vertices) {
      if (vertices.length < 3) return true;
      return GetSignedArea(vertices) > 0;
    }
    function GetSignedArea(vertices) {
      var i;
      var area = 0;
      for (i = 0; i < vertices.length; i++) {
        var j = (i + 1) % vertices.length;
        area += vertices[i].x * vertices[j].y;
        area -= vertices[i].y * vertices[j].x;
      }
      area /= 2;
      return area;
    }
    function LineIntersect(p1, p2, q1, q2) {
      var i = cc.v2();
      var a1 = p2.y - p1.y;
      var b1 = p1.x - p2.x;
      var c1 = a1 * p1.x + b1 * p1.y;
      var a2 = q2.y - q1.y;
      var b2 = q1.x - q2.x;
      var c2 = a2 * q1.x + b2 * q1.y;
      var det = a1 * b2 - a2 * b1;
      if (!FloatEquals(det, 0)) {
        i.x = (b2 * c1 - b1 * c2) / det;
        i.y = (a1 * c2 - a2 * c1) / det;
      }
      return i;
    }
    function LineIntersect2(a0, a1, b0, b1, intersectionPoint) {
      if (a0 == b0 || a0 == b1 || a1 == b0 || a1 == b1) return false;
      var x1 = a0.x;
      var y1 = a0.y;
      var x2 = a1.x;
      var y2 = a1.y;
      var x3 = b0.x;
      var y3 = b0.y;
      var x4 = b1.x;
      var y4 = b1.y;
      if (Math.max(x1, x2) < Math.min(x3, x4) || Math.max(x3, x4) < Math.min(x1, x2)) return false;
      if (Math.max(y1, y2) < Math.min(y3, y4) || Math.max(y3, y4) < Math.min(y1, y2)) return false;
      var ua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
      var ub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
      var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      if (Math.abs(denom) < 1e-6) return false;
      ua /= denom;
      ub /= denom;
      if (0 < ua && ua < 1 && 0 < ub && ub < 1) {
        intersectionPoint.x = x1 + ua * (x2 - x1);
        intersectionPoint.y = y1 + ua * (y2 - y1);
        return true;
      }
      return false;
    }
    function FloatEquals(value1, value2) {
      return Math.abs(value1 - value2) <= 1e-6;
    }
    function Area(a, b, c) {
      return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y);
    }
    module.exports = {
      ConvexPartition: ConvexPartition,
      ForceCounterClockWise: ForceCounterClockWise,
      IsCounterClockWise: IsCounterClockWise
    };
  }), {} ],
  250: [ (function(require, module, exports) {
    "use strict";
    var NodeEvent = require("../CCNode").EventType;
    var PTM_RATIO = require("./CCPhysicsTypes").PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = require("./CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
    var PHYSICS_ANGLE_TO_ANGLE = require("./CCPhysicsTypes").PHYSICS_ANGLE_TO_ANGLE;
    var getWorldRotation = require("./utils").getWorldRotation;
    var BodyType = require("./CCPhysicsTypes").BodyType;
    var tempb2Vec21 = new b2.Vec2();
    var tempb2Vec22 = new b2.Vec2();
    var VEC2_ZERO = cc.Vec2.ZERO;
    var RigidBody = cc.Class({
      name: "cc.RigidBody",
      extends: cc.Component,
      editor: false,
      properties: {
        _type: BodyType.Dynamic,
        _allowSleep: true,
        _gravityScale: 1,
        _linearDamping: 0,
        _angularDamping: 0,
        _linearVelocity: cc.v2(0, 0),
        _angularVelocity: 0,
        _fixedRotation: false,
        enabled: {
          get: function get() {
            return this._enabled;
          },
          set: function set() {
            cc.warnID(8200);
          },
          visible: false,
          override: true
        },
        enabledContactListener: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.physics.rigidbody.enabledContactListener")
        },
        bullet: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.physics.rigidbody.bullet")
        },
        type: {
          type: BodyType,
          tooltip: (true, "i18n:COMPONENT.physics.rigidbody.type"),
          get: function get() {
            return this._type;
          },
          set: function set(value) {
            this._type = value;
            this._b2Body && (value === BodyType.Animated ? this._b2Body.SetType(BodyType.Kinematic) : this._b2Body.SetType(value));
          }
        },
        allowSleep: {
          tooltip: (true, "i18n:COMPONENT.physics.rigidbody.allowSleep"),
          get: function get() {
            if (this._b2Body) return this._b2Body.IsSleepingAllowed();
            return this._allowSleep;
          },
          set: function set(value) {
            this._allowSleep = value;
            this._b2Body && this._b2Body.SetSleepingAllowed(value);
          }
        },
        gravityScale: {
          tooltip: (true, "i18n:COMPONENT.physics.rigidbody.gravityScale"),
          get: function get() {
            return this._gravityScale;
          },
          set: function set(value) {
            this._gravityScale = value;
            this._b2Body && this._b2Body.SetGravityScale(value);
          }
        },
        linearDamping: {
          tooltip: (true, "i18n:COMPONENT.physics.rigidbody.linearDamping"),
          get: function get() {
            return this._linearDamping;
          },
          set: function set(value) {
            this._linearDamping = value;
            this._b2Body && this._b2Body.SetLinearDamping(this._linearDamping);
          }
        },
        angularDamping: {
          tooltip: (true, "i18n:COMPONENT.physics.rigidbody.angularDamping"),
          get: function get() {
            return this._angularDamping;
          },
          set: function set(value) {
            this._angularDamping = value;
            this._b2Body && this._b2Body.SetAngularDamping(value);
          }
        },
        linearVelocity: {
          tooltip: (true, "i18n:COMPONENT.physics.rigidbody.linearVelocity"),
          type: cc.Vec2,
          get: function get() {
            var lv = this._linearVelocity;
            if (this._b2Body) {
              var velocity = this._b2Body.GetLinearVelocity();
              lv.x = velocity.x * PTM_RATIO;
              lv.y = velocity.y * PTM_RATIO;
            }
            return lv;
          },
          set: function set(value) {
            this._linearVelocity = value;
            var b2body = this._b2Body;
            if (b2body) {
              var temp = b2body.m_linearVelocity;
              temp.Set(value.x / PTM_RATIO, value.y / PTM_RATIO);
              b2body.SetLinearVelocity(temp);
            }
          }
        },
        angularVelocity: {
          tooltip: (true, "i18n:COMPONENT.physics.rigidbody.angularVelocity"),
          get: function get() {
            if (this._b2Body) return this._b2Body.GetAngularVelocity() * PHYSICS_ANGLE_TO_ANGLE;
            return this._angularVelocity;
          },
          set: function set(value) {
            this._angularVelocity = value;
            this._b2Body && this._b2Body.SetAngularVelocity(value * ANGLE_TO_PHYSICS_ANGLE);
          }
        },
        fixedRotation: {
          tooltip: (true, "i18n:COMPONENT.physics.rigidbody.fixedRotation"),
          get: function get() {
            return this._fixedRotation;
          },
          set: function set(value) {
            this._fixedRotation = value;
            this._b2Body && this._b2Body.SetFixedRotation(value);
          }
        },
        awake: {
          visible: false,
          tooltip: (true, "i18n:COMPONENT.physics.rigidbody.awake"),
          get: function get() {
            return !!this._b2Body && this._b2Body.IsAwake();
          },
          set: function set(value) {
            this._b2Body && this._b2Body.SetAwake(value);
          }
        },
        awakeOnLoad: {
          default: true,
          tooltip: (true, "i18n:COMPONENT.physics.rigidbody.awakeOnLoad"),
          animatable: false
        },
        active: {
          visible: false,
          get: function get() {
            return !!this._b2Body && this._b2Body.IsActive();
          },
          set: function set(value) {
            this._b2Body && this._b2Body.SetActive(value);
          }
        }
      },
      getLocalPoint: function getLocalPoint(worldPoint, out) {
        out = out || cc.v2();
        if (this._b2Body) {
          tempb2Vec21.Set(worldPoint.x / PTM_RATIO, worldPoint.y / PTM_RATIO);
          var pos = this._b2Body.GetLocalPoint(tempb2Vec21, out);
          out.x = pos.x * PTM_RATIO;
          out.y = pos.y * PTM_RATIO;
        }
        return out;
      },
      getWorldPoint: function getWorldPoint(localPoint, out) {
        out = out || cc.v2();
        if (this._b2Body) {
          tempb2Vec21.Set(localPoint.x / PTM_RATIO, localPoint.y / PTM_RATIO);
          var pos = this._b2Body.GetWorldPoint(tempb2Vec21, out);
          out.x = pos.x * PTM_RATIO;
          out.y = pos.y * PTM_RATIO;
        }
        return out;
      },
      getWorldVector: function getWorldVector(localVector, out) {
        out = out || cc.v2();
        if (this._b2Body) {
          tempb2Vec21.Set(localVector.x / PTM_RATIO, localVector.y / PTM_RATIO);
          var vector = this._b2Body.GetWorldVector(tempb2Vec21, out);
          out.x = vector.x * PTM_RATIO;
          out.y = vector.y * PTM_RATIO;
        }
        return out;
      },
      getLocalVector: function getLocalVector(worldVector, out) {
        out = out || cc.v2();
        if (this._b2Body) {
          tempb2Vec21.Set(worldVector.x / PTM_RATIO, worldVector.y / PTM_RATIO);
          var vector = this._b2Body.GetLocalVector(tempb2Vec21, out);
          out.x = vector.x * PTM_RATIO;
          out.y = vector.y * PTM_RATIO;
        }
        return out;
      },
      getWorldPosition: function getWorldPosition(out) {
        out = out || cc.v2();
        if (this._b2Body) {
          var pos = this._b2Body.GetPosition();
          out.x = pos.x * PTM_RATIO;
          out.y = pos.y * PTM_RATIO;
        }
        return out;
      },
      getWorldRotation: function getWorldRotation() {
        if (this._b2Body) return this._b2Body.GetAngle() * PHYSICS_ANGLE_TO_ANGLE;
        return 0;
      },
      getLocalCenter: function getLocalCenter(out) {
        out = out || cc.v2();
        if (this._b2Body) {
          var pos = this._b2Body.GetLocalCenter();
          out.x = pos.x * PTM_RATIO;
          out.y = pos.y * PTM_RATIO;
        }
        return out;
      },
      getWorldCenter: function getWorldCenter(out) {
        out = out || cc.v2();
        if (this._b2Body) {
          var pos = this._b2Body.GetWorldCenter();
          out.x = pos.x * PTM_RATIO;
          out.y = pos.y * PTM_RATIO;
        }
        return out;
      },
      getLinearVelocityFromWorldPoint: function getLinearVelocityFromWorldPoint(worldPoint, out) {
        out = out || cc.v2();
        if (this._b2Body) {
          tempb2Vec21.Set(worldPoint.x / PTM_RATIO, worldPoint.y / PTM_RATIO);
          var velocity = this._b2Body.GetLinearVelocityFromWorldPoint(tempb2Vec21, out);
          out.x = velocity.x * PTM_RATIO;
          out.y = velocity.y * PTM_RATIO;
        }
        return out;
      },
      getMass: function getMass() {
        return this._b2Body ? this._b2Body.GetMass() : 0;
      },
      getInertia: function getInertia() {
        return this._b2Body ? this._b2Body.GetInertia() * PTM_RATIO * PTM_RATIO : 0;
      },
      getJointList: function getJointList() {
        if (!this._b2Body) return [];
        var joints = [];
        var list = this._b2Body.GetJointList();
        if (!list) return [];
        joints.push(list.joint._joint);
        var prev = list.prev;
        while (prev) {
          joints.push(prev.joint._joint);
          prev = prev.prev;
        }
        var next = list.next;
        while (next) {
          joints.push(next.joint._joint);
          next = next.next;
        }
        return joints;
      },
      applyForce: function applyForce(force, point, wake) {
        if (this._b2Body) {
          tempb2Vec21.Set(force.x / PTM_RATIO, force.y / PTM_RATIO);
          tempb2Vec22.Set(point.x / PTM_RATIO, point.y / PTM_RATIO);
          this._b2Body.ApplyForce(tempb2Vec21, tempb2Vec22, wake);
        }
      },
      applyForceToCenter: function applyForceToCenter(force, wake) {
        if (this._b2Body) {
          tempb2Vec21.Set(force.x / PTM_RATIO, force.y / PTM_RATIO);
          this._b2Body.ApplyForceToCenter(tempb2Vec21, wake);
        }
      },
      applyTorque: function applyTorque(torque, wake) {
        this._b2Body && this._b2Body.ApplyTorque(torque / PTM_RATIO, wake);
      },
      applyLinearImpulse: function applyLinearImpulse(impulse, point, wake) {
        if (this._b2Body) {
          tempb2Vec21.Set(impulse.x / PTM_RATIO, impulse.y / PTM_RATIO);
          tempb2Vec22.Set(point.x / PTM_RATIO, point.y / PTM_RATIO);
          this._b2Body.ApplyLinearImpulse(tempb2Vec21, tempb2Vec22, wake);
        }
      },
      applyAngularImpulse: function applyAngularImpulse(impulse, wake) {
        this._b2Body && this._b2Body.ApplyAngularImpulse(impulse / PTM_RATIO / PTM_RATIO, wake);
      },
      syncPosition: function syncPosition(enableAnimated) {
        var b2body = this._b2Body;
        if (!b2body) return;
        var pos = this.node.convertToWorldSpaceAR(VEC2_ZERO);
        var temp;
        temp = this.type === BodyType.Animated ? b2body.GetLinearVelocity() : b2body.GetPosition();
        temp.x = pos.x / PTM_RATIO;
        temp.y = pos.y / PTM_RATIO;
        if (this.type === BodyType.Animated && enableAnimated) {
          var b2Pos = b2body.GetPosition();
          var timeStep = cc.game.config["frameRate"];
          temp.x = (temp.x - b2Pos.x) * timeStep;
          temp.y = (temp.y - b2Pos.y) * timeStep;
          b2body.SetAwake(true);
          b2body.SetLinearVelocity(temp);
        } else b2body.SetTransformVec(temp, b2body.GetAngle());
      },
      syncRotation: function syncRotation(enableAnimated) {
        var b2body = this._b2Body;
        if (!b2body) return;
        var rotation = ANGLE_TO_PHYSICS_ANGLE * getWorldRotation(this.node);
        if (this.type === BodyType.Animated && enableAnimated) {
          var b2Rotation = b2body.GetAngle();
          var timeStep = cc.game.config["frameRate"];
          b2body.SetAwake(true);
          b2body.SetAngularVelocity((rotation - b2Rotation) * timeStep);
        } else b2body.SetTransformVec(b2body.GetPosition(), rotation);
      },
      resetVelocity: function resetVelocity() {
        var b2body = this._b2Body;
        if (!b2body) return;
        var temp = b2body.m_linearVelocity;
        temp.Set(0, 0);
        b2body.SetLinearVelocity(temp);
        b2body.SetAngularVelocity(0);
      },
      onEnable: function onEnable() {
        this._init();
      },
      onDisable: function onDisable() {
        this._destroy();
      },
      _registerNodeEvents: function _registerNodeEvents() {
        var node = this.node;
        node.on(NodeEvent.POSITION_CHANGED, this._onNodePositionChanged, this);
        node.on(NodeEvent.ROTATION_CHANGED, this._onNodeRotationChanged, this);
        node.on(NodeEvent.SCALE_CHANGED, this._onNodeScaleChanged, this);
      },
      _unregisterNodeEvents: function _unregisterNodeEvents() {
        var node = this.node;
        node.off(NodeEvent.POSITION_CHANGED, this._onNodePositionChanged, this);
        node.off(NodeEvent.ROTATION_CHANGED, this._onNodeRotationChanged, this);
        node.off(NodeEvent.SCALE_CHANGED, this._onNodeScaleChanged, this);
      },
      _onNodePositionChanged: function _onNodePositionChanged() {
        this.syncPosition(true);
      },
      _onNodeRotationChanged: function _onNodeRotationChanged(event) {
        this.syncRotation(true);
      },
      _onNodeScaleChanged: function _onNodeScaleChanged(event) {
        if (this._b2Body) {
          var colliders = this.getComponents(cc.PhysicsCollider);
          for (var i = 0; i < colliders.length; i++) colliders[i].apply();
        }
      },
      _init: function _init() {
        cc.director.getPhysicsManager().pushDelayEvent(this, "__init", []);
      },
      _destroy: function _destroy() {
        cc.director.getPhysicsManager().pushDelayEvent(this, "__destroy", []);
      },
      __init: function __init() {
        if (this._inited) return;
        this._registerNodeEvents();
        var bodyDef = new b2.BodyDef();
        this.type === BodyType.Animated ? bodyDef.type = BodyType.Kinematic : bodyDef.type = this.type;
        bodyDef.allowSleep = this.allowSleep;
        bodyDef.gravityScale = this.gravityScale;
        bodyDef.linearDamping = this.linearDamping;
        bodyDef.angularDamping = this.angularDamping;
        var linearVelocity = this.linearVelocity;
        bodyDef.linearVelocity = new b2.Vec2(linearVelocity.x / PTM_RATIO, linearVelocity.y / PTM_RATIO);
        bodyDef.angularVelocity = this.angularVelocity * ANGLE_TO_PHYSICS_ANGLE;
        bodyDef.fixedRotation = this.fixedRotation;
        bodyDef.bullet = this.bullet;
        var node = this.node;
        var pos = node.convertToWorldSpaceAR(VEC2_ZERO);
        bodyDef.position = new b2.Vec2(pos.x / PTM_RATIO, pos.y / PTM_RATIO);
        bodyDef.angle = -Math.PI / 180 * getWorldRotation(node);
        bodyDef.awake = this.awakeOnLoad;
        cc.director.getPhysicsManager()._addBody(this, bodyDef);
        this._inited = true;
      },
      __destroy: function __destroy() {
        if (!this._inited) return;
        cc.director.getPhysicsManager()._removeBody(this);
        this._unregisterNodeEvents();
        this._inited = false;
      },
      _getBody: function _getBody() {
        return this._b2Body;
      }
    });
    cc.RigidBody = module.exports = RigidBody;
  }), {
    "../CCNode": 104,
    "./CCPhysicsTypes": 248,
    "./utils": 271
  } ],
  251: [ (function(require, module, exports) {
    "use strict";
    var box2d = require("../../../external/box2d/box2d");
    window.b2 = {};
    for (var key in box2d) {
      if (-1 !== key.indexOf("b2_")) continue;
      var newKey = key.replace("b2", "");
      b2[newKey] = box2d[key];
    }
    b2.maxPolygonVertices = 8;
  }), {
    "../../../external/box2d/box2d": 462
  } ],
  252: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var PhysicsBoxCollider = cc.Class({
      name: "cc.PhysicsBoxCollider",
      extends: cc.PhysicsCollider,
      mixins: [ cc.Collider.Box ],
      editor: {
        menu: false,
        requireComponent: cc.RigidBody
      },
      _createShape: function _createShape(scale) {
        var scaleX = Math.abs(scale.x);
        var scaleY = Math.abs(scale.y);
        var width = this.size.width / 2 / PTM_RATIO * scaleX;
        var height = this.size.height / 2 / PTM_RATIO * scaleY;
        var offsetX = this.offset.x / PTM_RATIO * scaleX;
        var offsetY = this.offset.y / PTM_RATIO * scaleY;
        var shape = new b2.PolygonShape();
        shape.SetAsBox(width, height, new b2.Vec2(offsetX, offsetY), 0);
        return shape;
      }
    });
    cc.PhysicsBoxCollider = module.exports = PhysicsBoxCollider;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  253: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var PhysicsChainCollider = cc.Class({
      name: "cc.PhysicsChainCollider",
      extends: cc.PhysicsCollider,
      editor: {
        menu: false,
        inspector: false,
        requireComponent: cc.RigidBody
      },
      properties: {
        loop: false,
        points: {
          default: function _default() {
            return [ cc.v2(-50, 0), cc.v2(50, 0) ];
          },
          type: [ cc.Vec2 ]
        },
        threshold: {
          default: 1,
          serializable: false,
          visible: false
        }
      },
      _createShape: function _createShape(scale) {
        var shape = new b2.ChainShape();
        var points = this.points;
        var vertices = [];
        for (var i = 0; i < points.length; i++) {
          var p = points[i];
          vertices.push(new b2.Vec2(p.x / PTM_RATIO * scale.x, p.y / PTM_RATIO * scale.y));
        }
        this.loop ? shape.CreateLoop(vertices, vertices.length) : shape.CreateChain(vertices, vertices.length);
        return shape;
      },
      resetInEditor: false,
      resetPointsByContour: false
    });
    cc.PhysicsChainCollider = module.exports = PhysicsChainCollider;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  254: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var PhysicsCircleCollider = cc.Class({
      name: "cc.PhysicsCircleCollider",
      extends: cc.PhysicsCollider,
      mixins: [ cc.Collider.Circle ],
      editor: {
        menu: false,
        requireComponent: cc.RigidBody
      },
      _createShape: function _createShape(scale) {
        var scaleX = Math.abs(scale.x);
        var scaleY = Math.abs(scale.y);
        var offsetX = this.offset.x / PTM_RATIO * scaleX;
        var offsetY = this.offset.y / PTM_RATIO * scaleY;
        var shape = new b2.CircleShape();
        shape.m_radius = this.radius / PTM_RATIO * scaleX;
        shape.m_p = new b2.Vec2(offsetX, offsetY);
        return shape;
      }
    });
    cc.PhysicsCircleCollider = module.exports = PhysicsCircleCollider;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  255: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var getWorldScale = require("../utils").getWorldScale;
    var b2_aabb_tmp = new b2.AABB();
    var PhysicsCollider = cc.Class({
      name: "cc.PhysicsCollider",
      extends: cc.Collider,
      ctor: function ctor() {
        this._fixtures = [];
        this._shapes = [];
        this._inited = false;
        this._rect = cc.rect();
      },
      properties: {
        _density: 1,
        _sensor: false,
        _friction: .2,
        _restitution: 0,
        density: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.density"),
          get: function get() {
            return this._density;
          },
          set: function set(value) {
            this._density = value;
          }
        },
        sensor: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.sensor"),
          get: function get() {
            return this._sensor;
          },
          set: function set(value) {
            this._sensor = value;
          }
        },
        friction: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.friction"),
          get: function get() {
            return this._friction;
          },
          set: function set(value) {
            this._friction = value;
          }
        },
        restitution: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.restitution"),
          get: function get() {
            return this._restitution;
          },
          set: function set(value) {
            this._restitution = value;
          }
        },
        body: {
          default: null,
          type: cc.RigidBody,
          visible: false
        }
      },
      onDisable: function onDisable() {
        this._destroy();
      },
      onEnable: function onEnable() {
        this._init();
      },
      start: function start() {
        this._init();
      },
      _getFixtureIndex: function _getFixtureIndex(fixture) {
        return this._fixtures.indexOf(fixture);
      },
      _init: function _init() {
        cc.director.getPhysicsManager().pushDelayEvent(this, "__init", []);
      },
      _destroy: function _destroy() {
        cc.director.getPhysicsManager().pushDelayEvent(this, "__destroy", []);
      },
      __init: function __init() {
        if (this._inited) return;
        var body = this.body || this.getComponent(cc.RigidBody);
        if (!body) return;
        var innerBody = body._getBody();
        if (!innerBody) return;
        var node = body.node;
        var scale = getWorldScale(node);
        this._scale = scale;
        var shapes = 0 === scale.x && 0 === scale.y ? [] : this._createShape(scale);
        shapes instanceof Array || (shapes = [ shapes ]);
        var categoryBits = 1 << node.groupIndex;
        var maskBits = 0;
        var bits = cc.game.collisionMatrix[node.groupIndex];
        for (var i = 0; i < bits.length; i++) {
          if (!bits[i]) continue;
          maskBits |= 1 << i;
        }
        var filter = {
          categoryBits: categoryBits,
          maskBits: maskBits,
          groupIndex: 0
        };
        var manager = cc.director.getPhysicsManager();
        for (var _i = 0; _i < shapes.length; _i++) {
          var shape = shapes[_i];
          var fixDef = new b2.FixtureDef();
          fixDef.density = this.density;
          fixDef.isSensor = this.sensor;
          fixDef.friction = this.friction;
          fixDef.restitution = this.restitution;
          fixDef.shape = shape;
          fixDef.filter = filter;
          var fixture = innerBody.CreateFixture(fixDef);
          fixture.collider = this;
          body.enabledContactListener && manager._registerContactFixture(fixture);
          this._shapes.push(shape);
          this._fixtures.push(fixture);
        }
        this.body = body;
        this._inited = true;
      },
      __destroy: function __destroy() {
        if (!this._inited) return;
        var fixtures = this._fixtures;
        var body = this.body._getBody();
        var manager = cc.director.getPhysicsManager();
        for (var i = fixtures.length - 1; i >= 0; i--) {
          var fixture = fixtures[i];
          fixture.collider = null;
          manager._unregisterContactFixture(fixture);
          body && body.DestroyFixture(fixture);
        }
        this.body = null;
        this._fixtures.length = 0;
        this._shapes.length = 0;
        this._inited = false;
      },
      _createShape: function _createShape() {},
      apply: function apply() {
        this._destroy();
        this._init();
      },
      getAABB: function getAABB() {
        var MAX = 1e7;
        var minX = MAX, minY = MAX;
        var maxX = -MAX, maxY = -MAX;
        var xf = this.body._getBody().GetTransform();
        var fixtures = this._fixtures;
        for (var i = 0; i < fixtures.length; i++) {
          var shape = fixtures[i].GetShape();
          var count = shape.GetChildCount();
          for (var j = 0; j < count; j++) {
            shape.ComputeAABB(b2_aabb_tmp, xf, j);
            b2_aabb_tmp.lowerBound.x < minX && (minX = b2_aabb_tmp.lowerBound.x);
            b2_aabb_tmp.lowerBound.y < minY && (minY = b2_aabb_tmp.lowerBound.y);
            b2_aabb_tmp.upperBound.x > maxX && (maxX = b2_aabb_tmp.upperBound.x);
            b2_aabb_tmp.upperBound.y > maxY && (maxY = b2_aabb_tmp.upperBound.y);
          }
        }
        minX *= PTM_RATIO;
        minY *= PTM_RATIO;
        maxX *= PTM_RATIO;
        maxY *= PTM_RATIO;
        var r = this._rect;
        r.x = minX;
        r.y = minY;
        r.width = maxX - minX;
        r.height = maxY - minY;
        return r;
      }
    });
    cc.PhysicsCollider = module.exports = PhysicsCollider;
  }), {
    "../CCPhysicsTypes": 248,
    "../utils": 271
  } ],
  256: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var PolygonSeparator = require("../CCPolygonSeparator");
    var PhysicsPolygonCollider = cc.Class({
      name: "cc.PhysicsPolygonCollider",
      extends: cc.PhysicsCollider,
      mixins: [ cc.Collider.Polygon ],
      editor: {
        menu: false,
        inspector: false,
        requireComponent: cc.RigidBody
      },
      _createShape: function _createShape(scale) {
        var shapes = [];
        var points = this.points;
        points.length > 0 && points[0].equals(points[points.length - 1]) && (points.length -= 1);
        var polys = PolygonSeparator.ConvexPartition(points);
        var offset = this.offset;
        for (var i = 0; i < polys.length; i++) {
          var poly = polys[i];
          var shape = null, vertices = [];
          var firstVertice = null;
          for (var j = 0, l = poly.length; j < l; j++) {
            shape || (shape = new b2.PolygonShape());
            var p = poly[j];
            var x = (p.x + offset.x) / PTM_RATIO * scale.x;
            var y = (p.y + offset.y) / PTM_RATIO * scale.y;
            var v = new b2.Vec2(x, y);
            vertices.push(v);
            firstVertice || (firstVertice = v);
            if (vertices.length === b2.maxPolygonVertices) {
              shape.Set(vertices, vertices.length);
              shapes.push(shape);
              shape = null;
              j < l - 1 && (vertices = [ firstVertice, vertices[vertices.length - 1] ]);
            }
          }
          if (shape) {
            shape.Set(vertices, vertices.length);
            shapes.push(shape);
          }
        }
        return shapes;
      }
    });
    cc.PhysicsPolygonCollider = module.exports = PhysicsPolygonCollider;
  }), {
    "../CCPhysicsTypes": 248,
    "../CCPolygonSeparator": 249
  } ],
  257: [ (function(require, module, exports) {
    "use strict";
    require("./box2d-adapter");
    require("./CCPhysicsManager");
    require("./CCRigidBody");
    require("./CCPhysicsContact");
    require("./collider/CCPhysicsCollider");
    require("./collider/CCPhysicsChainCollider");
    require("./collider/CCPhysicsCircleCollider");
    require("./collider/CCPhysicsBoxCollider");
    require("./collider/CCPhysicsPolygonCollider");
    require("./joint/CCJoint");
    require("./joint/CCDistanceJoint");
    require("./joint/CCRevoluteJoint");
    require("./joint/CCMouseJoint");
    require("./joint/CCMotorJoint");
    require("./joint/CCPrismaticJoint");
    require("./joint/CCWeldJoint");
    require("./joint/CCWheelJoint");
    require("./joint/CCRopeJoint");
    require("./platform/CCPhysicsContactListner");
    require("./platform/CCPhysicsAABBQueryCallback");
    require("./platform/CCPhysicsRayCastCallback");
  }), {
    "./CCPhysicsContact": 246,
    "./CCPhysicsManager": 247,
    "./CCRigidBody": 250,
    "./box2d-adapter": 251,
    "./collider/CCPhysicsBoxCollider": 252,
    "./collider/CCPhysicsChainCollider": 253,
    "./collider/CCPhysicsCircleCollider": 254,
    "./collider/CCPhysicsCollider": 255,
    "./collider/CCPhysicsPolygonCollider": 256,
    "./joint/CCDistanceJoint": 258,
    "./joint/CCJoint": 259,
    "./joint/CCMotorJoint": 260,
    "./joint/CCMouseJoint": 261,
    "./joint/CCPrismaticJoint": 262,
    "./joint/CCRevoluteJoint": 263,
    "./joint/CCRopeJoint": 264,
    "./joint/CCWeldJoint": 265,
    "./joint/CCWheelJoint": 266,
    "./platform/CCPhysicsAABBQueryCallback": 267,
    "./platform/CCPhysicsContactListner": 268,
    "./platform/CCPhysicsRayCastCallback": 270
  } ],
  258: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var DistanceJoint = cc.Class({
      name: "cc.DistanceJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        _distance: 1,
        _frequency: 0,
        _dampingRatio: 0,
        distance: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.distance"),
          get: function get() {
            return this._distance;
          },
          set: function set(value) {
            this._distance = value;
            this._joint && this._joint.SetLength(value);
          }
        },
        frequency: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.frequency"),
          get: function get() {
            return this._frequency;
          },
          set: function set(value) {
            this._frequency = value;
            this._joint && this._joint.SetFrequency(value);
          }
        },
        dampingRatio: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.dampingRatio"),
          get: function get() {
            return this._dampingRatio;
          },
          set: function set(value) {
            this._dampingRatio = value;
            this._joint && this._joint.SetDampingRatio(value);
          }
        }
      },
      _createJointDef: function _createJointDef() {
        var def = new b2.DistanceJointDef();
        def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
        def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
        def.length = this.distance / PTM_RATIO;
        def.dampingRatio = this.dampingRatio;
        def.frequencyHz = this.frequency;
        return def;
      }
    });
    cc.DistanceJoint = module.exports = DistanceJoint;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  259: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var Joint = cc.Class({
      name: "cc.Joint",
      extends: cc.Component,
      editor: {
        requireComponent: cc.RigidBody
      },
      properties: {
        anchor: {
          default: cc.v2(0, 0),
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.anchor")
        },
        connectedAnchor: {
          default: cc.v2(0, 0),
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.connectedAnchor")
        },
        connectedBody: {
          default: null,
          type: cc.RigidBody,
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.connectedBody")
        },
        collideConnected: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.collideConnected")
        }
      },
      onDisable: function onDisable() {
        this._destroy();
      },
      onEnable: function onEnable() {
        this._init();
      },
      start: function start() {
        this._init();
      },
      apply: function apply() {
        this._destroy();
        this._init();
      },
      getWorldAnchor: function getWorldAnchor() {
        if (this._joint) {
          var anchor = this._joint.GetAnchorA();
          return cc.v2(anchor.x * PTM_RATIO, anchor.y * PTM_RATIO);
        }
        return cc.Vec2.ZERO;
      },
      getWorldConnectedAnchor: function getWorldConnectedAnchor() {
        if (this._joint) {
          var anchor = this._joint.GetAnchorB();
          return cc.v2(anchor.x * PTM_RATIO, anchor.y * PTM_RATIO);
        }
        return cc.Vec2.ZERO;
      },
      getReactionForce: function getReactionForce(timeStep) {
        var out = cc.v2();
        if (this._joint) return this._joint.GetReactionForce(timeStep, out);
        return out;
      },
      getReactionTorque: function getReactionTorque(timeStep) {
        if (this._joint) return this._joint.GetReactionTorque(timeStep);
        return 0;
      },
      _init: function _init() {
        cc.director.getPhysicsManager().pushDelayEvent(this, "__init", []);
      },
      _destroy: function _destroy() {
        cc.director.getPhysicsManager().pushDelayEvent(this, "__destroy", []);
      },
      __init: function __init() {
        if (this._inited) return;
        this.body = this.getComponent(cc.RigidBody);
        if (this._isValid()) {
          var def = this._createJointDef();
          if (!def) return;
          def.bodyA = this.body._getBody();
          def.bodyB = this.connectedBody._getBody();
          def.collideConnected = this.collideConnected;
          cc.director.getPhysicsManager()._addJoint(this, def);
          this._inited = true;
        }
      },
      __destroy: function __destroy() {
        if (!this._inited) return;
        cc.director.getPhysicsManager()._removeJoint(this);
        this._joint = null;
        this._inited = false;
      },
      _createJointDef: function _createJointDef() {
        return null;
      },
      _isValid: function _isValid() {
        return this.body && this.body._getBody() && this.connectedBody && this.connectedBody._getBody();
      }
    });
    cc.Joint = module.exports = Joint;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  260: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
    var MotorJoint = cc.Class({
      name: "cc.MotorJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        _linearOffset: cc.v2(0, 0),
        _angularOffset: 0,
        _maxForce: 1,
        _maxTorque: 1,
        _correctionFactor: .3,
        anchor: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.anchor"),
          default: cc.v2(0, 0),
          override: true,
          visible: false
        },
        connectedAnchor: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.connectedAnchor"),
          default: cc.v2(0, 0),
          override: true,
          visible: false
        },
        linearOffset: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.linearOffset"),
          get: function get() {
            return this._linearOffset;
          },
          set: function set(value) {
            this._linearOffset = value;
            this._joint && this._joint.SetLinearOffset(new b2.Vec2(value.x / PTM_RATIO, value.y / PTM_RATIO));
          }
        },
        angularOffset: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.angularOffset"),
          get: function get() {
            return this._angularOffset;
          },
          set: function set(value) {
            this._angularOffset = value;
            this._joint && this._joint.SetAngularOffset(value);
          }
        },
        maxForce: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.maxForce"),
          get: function get() {
            return this._maxForce;
          },
          set: function set(value) {
            this._maxForce = value;
            this._joint && this._joint.SetMaxForce(value);
          }
        },
        maxTorque: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.maxTorque"),
          get: function get() {
            return this._maxTorque;
          },
          set: function set(value) {
            this._maxTorque = value;
            this._joint && this._joint.SetMaxTorque(value);
          }
        },
        correctionFactor: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.correctionFactor"),
          get: function get() {
            return this._correctionFactor;
          },
          set: function set(value) {
            this._correctionFactor = value;
            this._joint && this._joint.SetCorrectionFactor(value);
          }
        }
      },
      _createJointDef: function _createJointDef() {
        var def = new b2.MotorJointDef();
        def.linearOffset = new b2.Vec2(this.linearOffset.x / PTM_RATIO, this.linearOffset.y / PTM_RATIO);
        def.angularOffset = this.angularOffset * ANGLE_TO_PHYSICS_ANGLE;
        def.maxForce = this.maxForce;
        def.maxTorque = this.maxTorque;
        def.correctionFactor = this.correctionFactor;
        return def;
      }
    });
    cc.MotorJoint = module.exports = MotorJoint;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  261: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var tempB2Vec2 = new b2.Vec2();
    var MouseJoint = cc.Class({
      name: "cc.MouseJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        _target: 1,
        _frequency: 5,
        _dampingRatio: .7,
        _maxForce: 0,
        connectedBody: {
          default: null,
          type: cc.RigidBody,
          visible: false,
          override: true
        },
        collideConnected: {
          default: true,
          visible: false,
          override: true
        },
        anchor: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.anchor"),
          default: cc.v2(0, 0),
          override: true,
          visible: false
        },
        connectedAnchor: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.connectedAnchor"),
          default: cc.v2(0, 0),
          override: true,
          visible: false
        },
        mouseRegion: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.mouseRegion"),
          default: null,
          type: cc.Node
        },
        target: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.target"),
          visible: false,
          get: function get() {
            return this._target;
          },
          set: function set(value) {
            this._target = value;
            if (this._joint) {
              tempB2Vec2.x = value.x / PTM_RATIO;
              tempB2Vec2.y = value.y / PTM_RATIO;
              this._joint.SetTarget(tempB2Vec2);
            }
          }
        },
        frequency: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.frequency"),
          get: function get() {
            return this._frequency;
          },
          set: function set(value) {
            this._frequency = value;
            this._joint && this._joint.SetFrequency(value);
          }
        },
        dampingRatio: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.dampingRatio"),
          get: function get() {
            return this._dampingRatio;
          },
          set: function set(value) {
            this._dampingRatio = value;
            this._joint && this._joint.SetDampingRatio(value);
          }
        },
        maxForce: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.maxForce"),
          visible: false,
          get: function get() {
            return this._maxForce;
          },
          set: function set(value) {
            this._maxForce = value;
            this._joint && this._joint.SetMaxForce(value);
          }
        }
      },
      onLoad: function onLoad() {
        var mouseRegion = this.mouseRegion || this.node;
        mouseRegion.on(cc.Node.EventType.TOUCH_START, this.onTouchBegan, this);
        mouseRegion.on(cc.Node.EventType.TOUCH_MOVE, this.onTouchMove, this);
        mouseRegion.on(cc.Node.EventType.TOUCH_END, this.onTouchEnd, this);
        mouseRegion.on(cc.Node.EventType.TOUCH_CANCEL, this.onTouchEnd, this);
      },
      onEnable: function onEnable() {},
      start: function start() {},
      onTouchBegan: function onTouchBegan(event) {
        var manager = cc.director.getPhysicsManager();
        var target = this._pressPoint = event.touch.getLocation();
        cc.Camera && cc.Camera.main && (target = cc.Camera.main.getScreenToWorldPoint(target));
        var collider = manager.testPoint(target);
        if (!collider) return;
        var body = this.connectedBody = collider.body;
        body.awake = true;
        this.maxForce = 1e3 * this.connectedBody.getMass();
        this.target = target;
        this._init();
      },
      onTouchMove: function onTouchMove(event) {
        this._pressPoint = event.touch.getLocation();
      },
      onTouchEnd: function onTouchEnd(event) {
        this._destroy();
        this._pressPoint = null;
      },
      _createJointDef: function _createJointDef() {
        var def = new b2.MouseJointDef();
        tempB2Vec2.x = this.target.x / PTM_RATIO;
        tempB2Vec2.y = this.target.y / PTM_RATIO;
        def.target = tempB2Vec2;
        def.maxForce = this.maxForce;
        def.dampingRatio = this.dampingRatio;
        def.frequencyHz = this.frequency;
        return def;
      },
      update: function update() {
        if (!this._pressPoint || !this._isValid()) return;
        var camera = cc.Camera.findCamera(this.node);
        this.target = camera ? camera.getScreenToWorldPoint(this._pressPoint) : this._pressPoint;
      }
    });
    cc.MouseJoint = module.exports = MouseJoint;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  262: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
    var PrismaticJoint = cc.Class({
      name: "cc.PrismaticJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        localAxisA: {
          default: cc.v2(1, 0),
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.localAxisA")
        },
        referenceAngle: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.referenceAngle")
        },
        enableLimit: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.enableLimit")
        },
        enableMotor: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.enableMotor")
        },
        lowerLimit: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.lowerLimit")
        },
        upperLimit: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.upperLimit")
        },
        _maxMotorForce: 0,
        _motorSpeed: 0,
        maxMotorForce: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.maxMotorForce"),
          get: function get() {
            return this._maxMotorForce;
          },
          set: function set(value) {
            this._maxMotorForce = value;
            this._joint && this._joint.SetMaxMotorForce(value);
          }
        },
        motorSpeed: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.motorSpeed"),
          get: function get() {
            return this._motorSpeed;
          },
          set: function set(value) {
            this._motorSpeed = value;
            this._joint && this._joint.SetMotorSpeed(value);
          }
        }
      },
      _createJointDef: function _createJointDef() {
        var def = new b2.PrismaticJointDef();
        def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
        def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
        def.localAxisA = new b2.Vec2(this.localAxisA.x, this.localAxisA.y);
        def.referenceAngle = this.referenceAngle * ANGLE_TO_PHYSICS_ANGLE;
        def.enableLimit = this.enableLimit;
        def.lowerTranslation = this.lowerLimit / PTM_RATIO;
        def.upperTranslation = this.upperLimit / PTM_RATIO;
        def.enableMotor = this.enableMotor;
        def.maxMotorForce = this.maxMotorForce;
        def.motorSpeed = this.motorSpeed;
        return def;
      }
    });
    cc.PrismaticJoint = module.exports = PrismaticJoint;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  263: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
    var PHYSICS_ANGLE_TO_ANGLE = require("../CCPhysicsTypes").PHYSICS_ANGLE_TO_ANGLE;
    var RevoluteJoint = cc.Class({
      name: "cc.RevoluteJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        _maxMotorTorque: 0,
        _motorSpeed: 0,
        _enableLimit: false,
        _enableMotor: false,
        referenceAngle: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.referenceAngle")
        },
        lowerAngle: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.lowerAngle")
        },
        upperAngle: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.upperAngle")
        },
        maxMotorTorque: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.maxMotorTorque"),
          get: function get() {
            return this._maxMotorTorque;
          },
          set: function set(value) {
            this._maxMotorTorque = value;
            this._joint && this._joint.SetMaxMotorTorque(value);
          }
        },
        motorSpeed: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.motorSpeed"),
          get: function get() {
            return this._motorSpeed;
          },
          set: function set(value) {
            this._motorSpeed = value;
            this._joint && this._joint.SetMotorSpeed(value * ANGLE_TO_PHYSICS_ANGLE);
          }
        },
        enableLimit: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.enableLimit"),
          get: function get() {
            return this._enableLimit;
          },
          set: function set(value) {
            this._enableLimit = value;
            this._joint && this._joint.EnableLimit(value);
          }
        },
        enableMotor: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.enableMotor"),
          get: function get() {
            return this._enableMotor;
          },
          set: function set(value) {
            this._enableMotor = value;
            this._joint && this._joint.EnableMotor(value);
          }
        }
      },
      getJointAngle: function getJointAngle() {
        if (this._joint) return this._joint.GetJointAngle() * PHYSICS_ANGLE_TO_ANGLE;
        return 0;
      },
      setLimits: function setLimits(lower, upper) {
        if (this._joint) return this._joint.SetLimits(lower * ANGLE_TO_PHYSICS_ANGLE, upper * ANGLE_TO_PHYSICS_ANGLE);
      },
      _createJointDef: function _createJointDef() {
        var def = new b2.RevoluteJointDef();
        def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
        def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
        def.lowerAngle = this.upperAngle * ANGLE_TO_PHYSICS_ANGLE;
        def.upperAngle = this.lowerAngle * ANGLE_TO_PHYSICS_ANGLE;
        def.maxMotorTorque = this.maxMotorTorque;
        def.motorSpeed = this.motorSpeed * ANGLE_TO_PHYSICS_ANGLE;
        def.enableLimit = this.enableLimit;
        def.enableMotor = this.enableMotor;
        def.referenceAngle = this.referenceAngle * ANGLE_TO_PHYSICS_ANGLE;
        return def;
      }
    });
    cc.RevoluteJoint = module.exports = RevoluteJoint;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  264: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var RopeJoint = cc.Class({
      name: "cc.RopeJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        _maxLength: 1,
        maxLength: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.maxLength"),
          get: function get() {
            return this._maxLength;
          },
          set: function set(value) {
            this._maxLength = value;
            this._joint && this._joint.SetMaxLength(value);
          }
        }
      },
      _createJointDef: function _createJointDef() {
        var def = new b2.RopeJointDef();
        def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
        def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
        def.maxLength = this.maxLength / PTM_RATIO;
        return def;
      }
    });
    cc.RopeJoint = module.exports = RopeJoint;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  265: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
    var WeldJoint = cc.Class({
      name: "cc.WeldJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        referenceAngle: {
          default: 0,
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.referenceAngle")
        },
        _frequency: 0,
        _dampingRatio: 0,
        frequency: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.frequency"),
          get: function get() {
            return this._frequency;
          },
          set: function set(value) {
            this._frequency = value;
            this._joint && this._joint.SetFrequency(value);
          }
        },
        dampingRatio: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.dampingRatio"),
          get: function get() {
            return this._dampingRatio;
          },
          set: function set(value) {
            this._dampingRatio = value;
            this._joint && this._joint.SetDampingRatio(value);
          }
        }
      },
      _createJointDef: function _createJointDef() {
        var def = new b2.WeldJointDef();
        def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
        def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
        def.referenceAngle = this.referenceAngle * ANGLE_TO_PHYSICS_ANGLE;
        def.frequencyHz = this.frequency;
        def.dampingRatio = this.dampingRatio;
        return def;
      }
    });
    cc.WeldJoint = module.exports = WeldJoint;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  266: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var ANGLE_TO_PHYSICS_ANGLE = require("../CCPhysicsTypes").ANGLE_TO_PHYSICS_ANGLE;
    var WheelJoint = cc.Class({
      name: "cc.WheelJoint",
      extends: cc.Joint,
      editor: false,
      properties: {
        _maxMotorTorque: 0,
        _motorSpeed: 0,
        _enableMotor: false,
        _frequency: 2,
        _dampingRatio: .7,
        localAxisA: {
          default: cc.v2(1, 0),
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.localAxisA")
        },
        maxMotorTorque: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.maxMotorTorque"),
          get: function get() {
            return this._maxMotorTorque;
          },
          set: function set(value) {
            this._maxMotorTorque = value;
            this._joint && this._joint.SetMaxMotorTorque(value);
          }
        },
        motorSpeed: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.motorSpeed"),
          get: function get() {
            return this._motorSpeed;
          },
          set: function set(value) {
            this._motorSpeed = value;
            this._joint && this._joint.SetMotorSpeed(value * ANGLE_TO_PHYSICS_ANGLE);
          }
        },
        enableMotor: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.enableMotor"),
          get: function get() {
            return this._enableMotor;
          },
          set: function set(value) {
            this._enableMotor = value;
            this._joint && this._joint.EnableMotor(value);
          }
        },
        frequency: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.frequency"),
          get: function get() {
            return this._frequency;
          },
          set: function set(value) {
            this._frequency = value;
            this._joint && this._joint.SetSpringFrequencyHz(value);
          }
        },
        dampingRatio: {
          tooltip: (true, "i18n:COMPONENT.physics.physics_collider.dampingRatio"),
          get: function get() {
            return this._dampingRatio;
          },
          set: function set(value) {
            this._dampingRatio = value;
            this._joint && this._joint.SetDampingRatio(value);
          }
        }
      },
      _createJointDef: function _createJointDef() {
        var def = new b2.WheelJointDef();
        def.localAnchorA = new b2.Vec2(this.anchor.x / PTM_RATIO, this.anchor.y / PTM_RATIO);
        def.localAnchorB = new b2.Vec2(this.connectedAnchor.x / PTM_RATIO, this.connectedAnchor.y / PTM_RATIO);
        def.localAxisA = new b2.Vec2(this.localAxisA.x, this.localAxisA.y);
        def.maxMotorTorque = this.maxMotorTorque;
        def.motorSpeed = this.motorSpeed * ANGLE_TO_PHYSICS_ANGLE;
        def.enableMotor = this.enableMotor;
        def.dampingRatio = this.dampingRatio;
        def.frequencyHz = this.frequency;
        return def;
      }
    });
    cc.WheelJoint = module.exports = WheelJoint;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  267: [ (function(require, module, exports) {
    "use strict";
    var BodyType = require("../CCPhysicsTypes").BodyType;
    function PhysicsAABBQueryCallback() {
      this._point = new b2.Vec2();
      this._isPoint = false;
      this._fixtures = [];
    }
    PhysicsAABBQueryCallback.prototype.init = function(point) {
      if (point) {
        this._isPoint = true;
        this._point.x = point.x;
        this._point.y = point.y;
      } else this._isPoint = false;
      this._fixtures.length = 0;
    };
    PhysicsAABBQueryCallback.prototype.ReportFixture = function(fixture) {
      var body = fixture.GetBody();
      if (body.GetType() === BodyType.Dynamic) if (this._isPoint) {
        if (fixture.TestPoint(this._point)) {
          this._fixtures.push(fixture);
          return false;
        }
      } else this._fixtures.push(fixture);
      return true;
    };
    PhysicsAABBQueryCallback.prototype.getFixture = function() {
      return this._fixtures[0];
    };
    PhysicsAABBQueryCallback.prototype.getFixtures = function() {
      return this._fixtures;
    };
    cc.PhysicsAABBQueryCallback = module.exports = PhysicsAABBQueryCallback;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  268: [ (function(require, module, exports) {
    "use strict";
    function PhysicsContactListener() {
      this._contactFixtures = [];
    }
    PhysicsContactListener.prototype.setBeginContact = function(cb) {
      this._BeginContact = cb;
    };
    PhysicsContactListener.prototype.setEndContact = function(cb) {
      this._EndContact = cb;
    };
    PhysicsContactListener.prototype.setPreSolve = function(cb) {
      this._PreSolve = cb;
    };
    PhysicsContactListener.prototype.setPostSolve = function(cb) {
      this._PostSolve = cb;
    };
    PhysicsContactListener.prototype.BeginContact = function(contact) {
      if (!this._BeginContact) return;
      var fixtureA = contact.GetFixtureA();
      var fixtureB = contact.GetFixtureB();
      var fixtures = this._contactFixtures;
      contact._shouldReport = false;
      if (-1 !== fixtures.indexOf(fixtureA) || -1 !== fixtures.indexOf(fixtureB)) {
        contact._shouldReport = true;
        this._BeginContact(contact);
      }
    };
    PhysicsContactListener.prototype.EndContact = function(contact) {
      if (this._EndContact && contact._shouldReport) {
        contact._shouldReport = false;
        this._EndContact(contact);
      }
    };
    PhysicsContactListener.prototype.PreSolve = function(contact, oldManifold) {
      this._PreSolve && contact._shouldReport && this._PreSolve(contact, oldManifold);
    };
    PhysicsContactListener.prototype.PostSolve = function(contact, impulse) {
      this._PostSolve && contact._shouldReport && this._PostSolve(contact, impulse);
    };
    PhysicsContactListener.prototype.registerContactFixture = function(fixture) {
      this._contactFixtures.push(fixture);
    };
    PhysicsContactListener.prototype.unregisterContactFixture = function(fixture) {
      cc.js.array.remove(this._contactFixtures, fixture);
    };
    cc.PhysicsContactListener = module.exports = PhysicsContactListener;
  }), {} ],
  269: [ (function(require, module, exports) {
    "use strict";
    var PTM_RATIO = require("../CCPhysicsTypes").PTM_RATIO;
    var _tmp_vec2 = cc.v2();
    var GREEN_COLOR = cc.Color.GREEN;
    var RED_COLOR = cc.Color.RED;
    function PhysicsDebugDraw(drawer) {
      b2.Draw.call(this);
      this._drawer = drawer;
      this._xf = this._dxf = new b2.Transform();
    }
    cc.js.extend(PhysicsDebugDraw, b2.Draw);
    cc.js.mixin(PhysicsDebugDraw.prototype, {
      _DrawPolygon: function _DrawPolygon(vertices, vertexCount) {
        var drawer = this._drawer;
        for (var i = 0; i < vertexCount; i++) {
          b2.Transform.MulXV(this._xf, vertices[i], _tmp_vec2);
          var x = _tmp_vec2.x * PTM_RATIO, y = _tmp_vec2.y * PTM_RATIO;
          0 === i ? drawer.moveTo(x, y) : drawer.lineTo(x, y);
        }
        drawer.close();
      },
      DrawPolygon: function DrawPolygon(vertices, vertexCount, color) {
        this._applyStrokeColor(color);
        this._DrawPolygon(vertices, vertexCount);
        this._drawer.stroke();
      },
      DrawSolidPolygon: function DrawSolidPolygon(vertices, vertexCount, color) {
        this._applyFillColor(color);
        this._DrawPolygon(vertices, vertexCount);
        this._drawer.fill();
        this._drawer.stroke();
      },
      _DrawCircle: function _DrawCircle(center, radius) {
        var p = this._xf.p;
        this._drawer.circle((center.x + p.x) * PTM_RATIO, (center.y + p.y) * PTM_RATIO, radius * PTM_RATIO);
      },
      DrawCircle: function DrawCircle(center, radius, color) {
        this._applyStrokeColor(color);
        this._DrawCircle(center, radius);
        this._drawer.stroke();
      },
      DrawSolidCircle: function DrawSolidCircle(center, radius, axis, color) {
        this._applyFillColor(color);
        this._DrawCircle(center, radius);
        this._drawer.fill();
      },
      DrawSegment: function DrawSegment(p1, p2, color) {
        var drawer = this._drawer;
        if (p1.x === p2.x && p1.y === p2.y) {
          this._applyFillColor(color);
          this._DrawCircle(p1, 2 / PTM_RATIO);
          drawer.fill();
          return;
        }
        this._applyStrokeColor(color);
        b2.Transform.MulXV(this._xf, p1, _tmp_vec2);
        drawer.moveTo(_tmp_vec2.x * PTM_RATIO, _tmp_vec2.y * PTM_RATIO);
        b2.Transform.MulXV(this._xf, p2, _tmp_vec2);
        drawer.lineTo(_tmp_vec2.x * PTM_RATIO, _tmp_vec2.y * PTM_RATIO);
        drawer.stroke();
      },
      DrawTransform: function DrawTransform(xf) {
        var drawer = this._drawer;
        drawer.strokeColor = RED_COLOR;
        _tmp_vec2.x = _tmp_vec2.y = 0;
        b2.Transform.MulXV(xf, _tmp_vec2, _tmp_vec2);
        drawer.moveTo(_tmp_vec2.x * PTM_RATIO, _tmp_vec2.y * PTM_RATIO);
        _tmp_vec2.x = 1;
        _tmp_vec2.y = 0;
        b2.Transform.MulXV(xf, _tmp_vec2, _tmp_vec2);
        drawer.lineTo(_tmp_vec2.x * PTM_RATIO, _tmp_vec2.y * PTM_RATIO);
        drawer.stroke();
        drawer.strokeColor = GREEN_COLOR;
        _tmp_vec2.x = _tmp_vec2.y = 0;
        b2.Transform.MulXV(xf, _tmp_vec2, _tmp_vec2);
        drawer.moveTo(_tmp_vec2.x * PTM_RATIO, _tmp_vec2.y * PTM_RATIO);
        _tmp_vec2.x = 0;
        _tmp_vec2.y = 1;
        b2.Transform.MulXV(xf, _tmp_vec2, _tmp_vec2);
        drawer.lineTo(_tmp_vec2.x * PTM_RATIO, _tmp_vec2.y * PTM_RATIO);
        drawer.stroke();
      },
      DrawPoint: function DrawPoint(center, radius, color) {},
      _applyStrokeColor: function _applyStrokeColor(color) {
        var strokeColor = this._drawer.strokeColor;
        strokeColor.r = 255 * color.r;
        strokeColor.g = 255 * color.g;
        strokeColor.b = 255 * color.b;
        strokeColor.a = 150;
        this._drawer.strokeColor = strokeColor;
      },
      _applyFillColor: function _applyFillColor(color) {
        var fillColor = this._drawer.fillColor;
        fillColor.r = 255 * color.r;
        fillColor.g = 255 * color.g;
        fillColor.b = 255 * color.b;
        fillColor.a = 150;
        this._drawer.fillColor = fillColor;
      },
      PushTransform: function PushTransform(xf) {
        this._xf = xf;
      },
      PopTransform: function PopTransform() {
        this._xf = this._dxf;
      }
    });
    module.exports = PhysicsDebugDraw;
  }), {
    "../CCPhysicsTypes": 248
  } ],
  270: [ (function(require, module, exports) {
    "use strict";
    function PhysicsRayCastCallback() {
      this._type = 0;
      this._fixtures = [];
      this._points = [];
      this._normals = [];
      this._fractions = [];
    }
    PhysicsRayCastCallback.prototype.init = function(type) {
      this._type = type;
      this._fixtures.length = 0;
      this._points.length = 0;
      this._normals.length = 0;
      this._fractions.length = 0;
    };
    PhysicsRayCastCallback.prototype.ReportFixture = function(fixture, point, normal, fraction) {
      if (0 === this._type) {
        this._fixtures[0] = fixture;
        this._points[0] = point;
        this._normals[0] = normal;
        this._fractions[0] = fraction;
        return fraction;
      }
      this._fixtures.push(fixture);
      this._points.push(cc.v2(point));
      this._normals.push(cc.v2(normal));
      this._fractions.push(fraction);
      if (1 === this._type) return 0;
      if (this._type >= 2) return 1;
      return fraction;
    };
    PhysicsRayCastCallback.prototype.getFixtures = function() {
      return this._fixtures;
    };
    PhysicsRayCastCallback.prototype.getPoints = function() {
      return this._points;
    };
    PhysicsRayCastCallback.prototype.getNormals = function() {
      return this._normals;
    };
    PhysicsRayCastCallback.prototype.getFractions = function() {
      return this._fractions;
    };
    cc.PhysicsRayCastCallback = module.exports = PhysicsRayCastCallback;
  }), {} ],
  271: [ (function(require, module, exports) {
    "use strict";
    function getWorldRotation(node) {
      var rot = node.angle;
      var parent = node.parent;
      while (parent.parent) {
        rot += parent.angle;
        parent = parent.parent;
      }
      return -rot;
    }
    function getWorldScale(node) {
      var scaleX = node.scaleX;
      var scaleY = node.scaleY;
      var parent = node.parent;
      while (parent.parent) {
        scaleX *= parent.scaleX;
        scaleY *= parent.scaleY;
        parent = parent.parent;
      }
      return cc.v2(scaleX, scaleY);
    }
    function convertToNodeRotation(node, rotation) {
      rotation -= -node.angle;
      var parent = node.parent;
      while (parent.parent) {
        rotation -= -parent.angle;
        parent = parent.parent;
      }
      return rotation;
    }
    module.exports = {
      getWorldRotation: getWorldRotation,
      getWorldScale: getWorldScale,
      convertToNodeRotation: convertToNodeRotation
    };
  }), {} ],
  272: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    var Enum = require("./CCEnum");
    var utils = require("./utils");
    var _isPlainEmptyObj_DEV = utils.isPlainEmptyObj_DEV;
    var _cloneable_DEV = utils.cloneable_DEV;
    var Attr = require("./attribute");
    var DELIMETER = Attr.DELIMETER;
    var preprocess = require("./preprocess-class");
    require("./requiring-frame");
    var BUILTIN_ENTRIES = [ "name", "extends", "mixins", "ctor", "__ctor__", "properties", "statics", "editor", "__ES6__" ];
    var INVALID_STATICS_DEV = (true, [ "name", "__ctors__", "__props__", "__values__", "arguments", "call", "apply", "caller", "length", "prototype" ]);
    function pushUnique(array, item) {
      array.indexOf(item) < 0 && array.push(item);
    }
    var deferredInitializer = {
      datas: null,
      push: function push(data) {
        if (this.datas) this.datas.push(data); else {
          this.datas = [ data ];
          var self = this;
          setTimeout((function() {
            self.init();
          }), 0);
        }
      },
      init: function init() {
        var datas = this.datas;
        if (datas) {
          for (var i = 0; i < datas.length; ++i) {
            var data = datas[i];
            var cls = data.cls;
            var properties = data.props;
            "function" === typeof properties && (properties = properties());
            var name = js.getClassName(cls);
            properties ? declareProperties(cls, name, properties, cls.$super, data.mixins) : cc.errorID(3633, name);
          }
          this.datas = null;
        }
      }
    };
    function appendProp(cls, name) {
      true;
      if (-1 !== name.indexOf(".")) {
        cc.errorID(3634);
        return;
      }
      pushUnique(cls.__props__, name);
    }
    function defineProp(cls, className, propName, val, es6) {
      var defaultValue = val["default"];
      true;
      if (!es6 && "object" === typeof defaultValue && defaultValue) if (Array.isArray(defaultValue)) {
        if (defaultValue.length > 0) {
          cc.errorID(3635, className, propName, propName);
          return;
        }
      } else if (!_isPlainEmptyObj_DEV(defaultValue) && !_cloneable_DEV(defaultValue)) {
        cc.errorID(3636, className, propName, propName);
        return;
      }
      if (CCClass.getInheritanceChain(cls).some((function(x) {
        return x.prototype.hasOwnProperty(propName);
      }))) {
        cc.errorID(3637, className, propName, className);
        return;
      }
      Attr.setClassAttr(cls, propName, "default", defaultValue);
      appendProp(cls, propName);
      parseAttributes(cls, val, className, propName, false);
      var i;
      false, false;
    }
    function defineGetSet(cls, name, propName, val, es6) {
      var getter = val.get;
      var setter = val.set;
      var proto = cls.prototype;
      var d = Object.getOwnPropertyDescriptor(proto, propName);
      var setterUndefined = !d;
      if (getter) {
        if ((true, !es6) && d && d.get) {
          cc.errorID(3638, name, propName);
          return;
        }
        parseAttributes(cls, val, name, propName, true);
        false, false;
        Attr.setClassAttr(cls, propName, "serializable", false);
        true;
        appendProp(cls, propName);
        es6 || js.get(proto, propName, getter, setterUndefined, setterUndefined);
        false, true;
        Attr.setClassAttr(cls, propName, "hasGetter", true);
      }
      if (setter) {
        if (!es6) {
          if ((true, d) && d.set) return cc.errorID(3640, name, propName);
          js.set(proto, propName, setter, setterUndefined, setterUndefined);
        }
        false, true;
        Attr.setClassAttr(cls, propName, "hasSetter", true);
      }
    }
    function getDefault(defaultVal) {
      if ("function" === typeof defaultVal) {
        false;
        return defaultVal();
      }
      return defaultVal;
    }
    function mixinWithInherited(dest, src, filter) {
      for (var prop in src) dest.hasOwnProperty(prop) || filter && !filter(prop) || Object.defineProperty(dest, prop, js.getPropertyDescriptor(src, prop));
    }
    function doDefine(className, baseClass, mixins, options) {
      var shouldAddProtoCtor;
      var __ctor__ = options.__ctor__;
      var ctor = options.ctor;
      var __es6__ = options.__ES6__;
      true;
      var ctorToUse = __ctor__ || ctor;
      if (ctorToUse) {
        if (CCClass._isCCClass(ctorToUse)) cc.errorID(3618, className); else if ("function" !== typeof ctorToUse) cc.errorID(3619, className); else if (baseClass && /\bprototype.ctor\b/.test(ctorToUse)) if (__es6__) cc.errorID(3651, className || ""); else {
          cc.warnID(3600, className || "");
          shouldAddProtoCtor = true;
        }
        ctor && (__ctor__ ? cc.errorID(3649, className) : ctor = options.ctor = _validateCtor_DEV(ctor, baseClass, className, options));
      }
      var ctors;
      var fireClass;
      if (__es6__) {
        ctors = [ ctor ];
        fireClass = ctor;
      } else {
        ctors = __ctor__ ? [ __ctor__ ] : _getAllCtors(baseClass, mixins, options);
        fireClass = _createCtor(ctors, baseClass, className, options);
        js.value(fireClass, "extend", (function(options) {
          options["extends"] = this;
          return CCClass(options);
        }), true);
      }
      js.value(fireClass, "__ctors__", ctors.length > 0 ? ctors : null, true);
      var prototype = fireClass.prototype;
      if (baseClass) {
        if (!__es6__) {
          js.extend(fireClass, baseClass);
          prototype = fireClass.prototype;
        }
        fireClass.$super = baseClass;
        (true, shouldAddProtoCtor) && (prototype.ctor = function() {});
      }
      if (mixins) {
        for (var m = mixins.length - 1; m >= 0; m--) {
          var mixin = mixins[m];
          mixinWithInherited(prototype, mixin.prototype);
          mixinWithInherited(fireClass, mixin, (function(prop) {
            return mixin.hasOwnProperty(prop) && (false, INVALID_STATICS_DEV.indexOf(prop) < 0);
          }));
          CCClass._isCCClass(mixin) && mixinWithInherited(Attr.getClassAttrs(fireClass), Attr.getClassAttrs(mixin));
        }
        prototype.constructor = fireClass;
      }
      __es6__ || (prototype.__initProps__ = compileProps);
      js.setClassName(className, fireClass);
      return fireClass;
    }
    function define(className, baseClass, mixins, options) {
      var Component = cc.Component;
      var frame = cc._RF.peek();
      if (frame && js.isChildClassOf(baseClass, Component)) {
        if (js.isChildClassOf(frame.cls, Component)) {
          cc.errorID(3615);
          return null;
        }
        (true, frame.uuid) && className && cc.warnID(3616, className);
        className = className || frame.script;
      }
      var cls = doDefine(className, baseClass, mixins, options);
      if (frame) if (js.isChildClassOf(baseClass, Component)) {
        var uuid = frame.uuid;
        if (uuid) {
          js._setClassId(uuid, cls);
          false;
        }
        frame.cls = cls;
      } else js.isChildClassOf(frame.cls, Component) || (frame.cls = cls);
      return cls;
    }
    function normalizeClassName_DEV(className) {
      var DefaultName = "CCClass";
      if (className) {
        className = className.replace(/^[^$A-Za-z_]/, "_").replace(/[^0-9A-Za-z_$]/g, "_");
        try {
          Function("function " + className + "(){}")();
          return className;
        } catch (e) {}
      }
      return DefaultName;
    }
    function getNewValueTypeCodeJit(value) {
      var clsName = js.getClassName(value);
      var type = value.constructor;
      var res = "new " + clsName + "(";
      for (var i = 0; i < type.__props__.length; i++) {
        var prop = type.__props__[i];
        var propVal = value[prop];
        if (true, "object" === typeof propVal) {
          cc.errorID(3641, clsName);
          return "new " + clsName + "()";
        }
        res += propVal;
        i < type.__props__.length - 1 && (res += ",");
      }
      return res + ")";
    }
    function escapeForJS(s) {
      return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    function getInitPropsJit(attrs, propList) {
      var F = [];
      var func = "";
      for (var i = 0; i < propList.length; i++) {
        var prop = propList[i];
        var attrKey = prop + DELIMETER + "default";
        if (attrKey in attrs) {
          var statement;
          statement = IDENTIFIER_RE.test(prop) ? "this." + prop + "=" : "this[" + escapeForJS(prop) + "]=";
          var expression;
          var def = attrs[attrKey];
          if ("object" === typeof def && def) expression = def instanceof cc.ValueType ? getNewValueTypeCodeJit(def) : Array.isArray(def) ? "[]" : "{}"; else if ("function" === typeof def) {
            var index = F.length;
            F.push(def);
            expression = "F[" + index + "]()";
            false;
          } else expression = "string" === typeof def ? escapeForJS(def) : def;
          statement = statement + expression + ";\n";
          func += statement;
        }
      }
      var initProps;
      initProps = 0 === F.length ? Function(func) : Function("F", "return (function(){\n" + func + "})")(F);
      return initProps;
    }
    function getInitProps(attrs, propList) {
      var props = null;
      var simpleEnd = 0;
      var valueTypeEnd = 0;
      (function() {
        var simples = null;
        var valueTypes = null;
        var advanceds = null;
        for (var i = 0; i < propList.length; ++i) {
          var prop = propList[i];
          var attrKey = prop + DELIMETER + "default";
          if (attrKey in attrs) {
            var def = attrs[attrKey];
            if ("object" === typeof def && def || "function" === typeof def) if (def instanceof cc.ValueType) {
              valueTypes || (valueTypes = []);
              valueTypes.push(prop, def);
            } else {
              advanceds || (advanceds = []);
              advanceds.push(prop, def);
            } else {
              simples || (simples = []);
              simples.push(prop, def);
            }
          }
        }
        simpleEnd = simples ? simples.length : 0;
        valueTypeEnd = simpleEnd + (valueTypes ? valueTypes.length : 0);
        var totalLength = valueTypeEnd + (advanceds ? advanceds.length : 0);
        props = new Array(totalLength);
        for (var _i = 0; _i < simpleEnd; ++_i) props[_i] = simples[_i];
        for (var _i2 = simpleEnd; _i2 < valueTypeEnd; ++_i2) props[_i2] = valueTypes[_i2 - simpleEnd];
        for (var _i3 = valueTypeEnd; _i3 < totalLength; ++_i3) props[_i3] = advanceds[_i3 - valueTypeEnd];
      })();
      return function() {
        var i = 0;
        for (;i < simpleEnd; i += 2) this[props[i]] = props[i + 1];
        for (;i < valueTypeEnd; i += 2) this[props[i]] = props[i + 1].clone();
        for (;i < props.length; i += 2) {
          var def = props[i + 1];
          if (Array.isArray(def)) this[props[i]] = []; else {
            var value;
            if ("object" === typeof def) value = {}; else {
              false;
              value = def();
            }
            this[props[i]] = value;
          }
        }
      };
    }
    var IDENTIFIER_RE = /^[A-Za-z_$][0-9A-Za-z_$]*$/;
    function compileProps(actualClass) {
      var attrs = Attr.getClassAttrs(actualClass);
      var propList = actualClass.__props__;
      if (null === propList) {
        deferredInitializer.init();
        propList = actualClass.__props__;
      }
      var initProps = getInitPropsJit(attrs, propList);
      actualClass.prototype.__initProps__ = initProps;
      initProps.call(this);
    }
    var _createCtor = function(ctors, baseClass, className, options) {
      var superCallBounded = baseClass && boundSuperCalls(baseClass, options, className);
      var ctorName = normalizeClassName_DEV(className);
      var body = "return function " + ctorName + "(){\n";
      superCallBounded && (body += "this._super=null;\n");
      body += "this.__initProps__(" + ctorName + ");\n";
      var ctorLen = ctors.length;
      if (ctorLen > 0) {
        var useTryCatch = (true, !(className && className.startsWith("cc.")));
        useTryCatch && (body += "try{\n");
        var SNIPPET = "].apply(this,arguments);\n";
        if (1 === ctorLen) body += ctorName + ".__ctors__[0" + SNIPPET; else {
          body += "var cs=" + ctorName + ".__ctors__;\n";
          for (var i = 0; i < ctorLen; i++) body += "cs[" + i + SNIPPET;
        }
        useTryCatch && (body += "}catch(e){\ncc._throw(e);\n}\n");
      }
      body += "}";
      return Function(body)();
    };
    function _validateCtor_DEV(ctor, baseClass, className, options) {
      var originCtor;
      false;
      !(ctor.length > 0) || className && className.startsWith("cc.") || cc.warnID(3617, className);
      return ctor;
    }
    function _getAllCtors(baseClass, mixins, options) {
      function getCtors(cls) {
        return CCClass._isCCClass(cls) ? cls.__ctors__ || [] : [ cls ];
      }
      var ctors = [];
      var baseOrMixins = [ baseClass ].concat(mixins);
      for (var b = 0; b < baseOrMixins.length; b++) {
        var baseOrMixin = baseOrMixins[b];
        if (baseOrMixin) {
          var baseCtors = getCtors(baseOrMixin);
          for (var c = 0; c < baseCtors.length; c++) pushUnique(ctors, baseCtors[c]);
        }
      }
      var ctor = options.ctor;
      ctor && ctors.push(ctor);
      return ctors;
    }
    var SuperCallReg = /xyz/.test((function() {
      xyz;
    })) ? /\b\._super\b/ : /.*/;
    var SuperCallRegStrict = /xyz/.test((function() {
      xyz;
    })) ? /this\._super\s*\(/ : /(NONE){99}/;
    function boundSuperCalls(baseClass, options, className) {
      var hasSuperCall = false;
      for (var funcName in options) {
        if (BUILTIN_ENTRIES.indexOf(funcName) >= 0) continue;
        var func = options[funcName];
        if ("function" !== typeof func) continue;
        var pd = js.getPropertyDescriptor(baseClass.prototype, funcName);
        if (pd) {
          var superFunc = pd.value;
          if ("function" === typeof superFunc) {
            if (SuperCallReg.test(func)) {
              hasSuperCall = true;
              options[funcName] = (function(superFunc, func) {
                return function() {
                  var tmp = this._super;
                  this._super = superFunc;
                  var ret = func.apply(this, arguments);
                  this._super = tmp;
                  return ret;
                };
              })(superFunc, func);
            }
            continue;
          }
        }
        (true, SuperCallRegStrict.test(func)) && cc.warnID(3620, className, funcName);
      }
      return hasSuperCall;
    }
    function declareProperties(cls, className, properties, baseClass, mixins, es6) {
      cls.__props__ = [];
      baseClass && baseClass.__props__ && (cls.__props__ = baseClass.__props__.slice());
      if (mixins) for (var m = 0; m < mixins.length; ++m) {
        var mixin = mixins[m];
        mixin.__props__ && (cls.__props__ = cls.__props__.concat(mixin.__props__.filter((function(x) {
          return cls.__props__.indexOf(x) < 0;
        }))));
      }
      if (properties) {
        preprocess.preprocessAttrs(properties, className, cls, es6);
        for (var propName in properties) {
          var val = properties[propName];
          "default" in val ? defineProp(cls, className, propName, val, es6) : defineGetSet(cls, className, propName, val, es6);
        }
      }
      var attrs = Attr.getClassAttrs(cls);
      cls.__values__ = cls.__props__.filter((function(prop) {
        return false !== attrs[prop + DELIMETER + "serializable"];
      }));
    }
    function CCClass(options) {
      options = options || {};
      var name = options.name;
      var base = options["extends"];
      var mixins = options.mixins;
      var cls = define(name, base, mixins, options);
      name || (name = cc.js.getClassName(cls));
      cls._sealed = true;
      base && (base._sealed = false);
      var properties = options.properties;
      if ("function" === typeof properties || base && null === base.__props__ || mixins && mixins.some((function(x) {
        return null === x.__props__;
      }))) if (true, options.__ES6__) cc.error("not yet implement deferred properties for ES6 Classes"); else {
        deferredInitializer.push({
          cls: cls,
          props: properties,
          mixins: mixins
        });
        cls.__props__ = cls.__values__ = null;
      } else declareProperties(cls, name, properties, base, options.mixins, options.__ES6__);
      var statics = options.statics;
      if (statics) {
        var staticPropName;
        true;
        for (staticPropName in statics) -1 !== INVALID_STATICS_DEV.indexOf(staticPropName) && cc.errorID(3642, name, staticPropName, staticPropName);
        for (staticPropName in statics) cls[staticPropName] = statics[staticPropName];
      }
      for (var funcName in options) {
        if (BUILTIN_ENTRIES.indexOf(funcName) >= 0) continue;
        var func = options[funcName];
        if (!preprocess.validateMethodWithProps(func, funcName, name, cls, base)) continue;
        js.value(cls.prototype, funcName, func, true, true);
      }
      var editor = options.editor;
      editor && cc.Component._registerEditorProps(cls, editor);
      return cls;
    }
    CCClass._isCCClass = function(constructor) {
      return constructor && constructor.hasOwnProperty("__ctors__");
    };
    CCClass._fastDefine = function(className, constructor, serializableFields) {
      js.setClassName(className, constructor);
      var props = constructor.__props__ = constructor.__values__ = Object.keys(serializableFields);
      var attrs = Attr.getClassAttrs(constructor);
      for (var i = 0; i < props.length; i++) {
        var key = props[i];
        attrs[key + DELIMETER + "visible"] = false;
        attrs[key + DELIMETER + "default"] = serializableFields[key];
      }
    };
    CCClass.Attr = Attr;
    CCClass.attr = Attr.attr;
    CCClass.getInheritanceChain = function(klass) {
      var chain = [];
      for (;;) {
        klass = js.getSuper(klass);
        if (!klass) break;
        klass !== Object && chain.push(klass);
      }
      return chain;
    };
    var PrimitiveTypes = {
      Integer: "Number",
      Float: "Number",
      Boolean: "Boolean",
      String: "String"
    };
    var onAfterProps_ET = [];
    function parseAttributes(cls, attributes, className, propName, usedInGetter) {
      var ERR_Type = "The %s of %s must be type %s";
      var attrs = null;
      var propNamePrefix = "";
      function initAttrs() {
        propNamePrefix = propName + DELIMETER;
        return attrs = Attr.getClassAttrs(cls);
      }
      false, false;
      var type = attributes.type;
      if (type) {
        var primitiveType = PrimitiveTypes[type];
        if (primitiveType) {
          (attrs || initAttrs())[propNamePrefix + "type"] = type;
          (false, false) && !attributes._short && onAfterProps_ET.push(Attr.getTypeChecker_ET(primitiveType, "cc." + type));
        } else if ("Object" === type) {
          true;
          cc.errorID(3644, className, propName);
        } else if (type === Attr.ScriptUuid) {
          (attrs || initAttrs())[propNamePrefix + "type"] = "Script";
          attrs[propNamePrefix + "ctor"] = cc.ScriptAsset;
        } else if ("object" === typeof type) if (Enum.isEnum(type)) {
          (attrs || initAttrs())[propNamePrefix + "type"] = "Enum";
          attrs[propNamePrefix + "enumList"] = Enum.getList(type);
        } else {
          true;
          cc.errorID(3645, className, propName, type);
        } else if ("function" === typeof type) {
          (attrs || initAttrs())[propNamePrefix + "type"] = "Object";
          attrs[propNamePrefix + "ctor"] = type;
          (false, false) && !attributes._short && onAfterProps_ET.push(Attr.getObjTypeChecker_ET(type));
        } else {
          true;
          cc.errorID(3646, className, propName, type);
        }
      }
      function parseSimpleAttr(attrName, expectType) {
        if (attrName in attributes) {
          var val = attributes[attrName];
          if (typeof val === expectType) (attrs || initAttrs())[propNamePrefix + attrName] = val; else {
            true;
            cc.error(ERR_Type, attrName, className, propName, expectType);
          }
        }
      }
      attributes.editorOnly && (true, usedInGetter ? cc.errorID(3613, "editorOnly", name, propName) : (attrs || initAttrs())[propNamePrefix + "editorOnly"] = true);
      true;
      parseSimpleAttr("displayName", "string");
      parseSimpleAttr("multiline", "boolean");
      attributes.readonly && ((attrs || initAttrs())[propNamePrefix + "readonly"] = true);
      parseSimpleAttr("tooltip", "string");
      parseSimpleAttr("slide", "boolean");
      false === attributes.serializable && (true, usedInGetter ? cc.errorID(3613, "serializable", name, propName) : (attrs || initAttrs())[propNamePrefix + "serializable"] = false);
      parseSimpleAttr("formerlySerializedAs", "string");
      false;
      true;
      var visible = attributes.visible;
      if ("undefined" !== typeof visible) visible ? "function" === typeof visible && ((attrs || initAttrs())[propNamePrefix + "visible"] = visible) : (attrs || initAttrs())[propNamePrefix + "visible"] = false; else {
        var startsWithUS = 95 === propName.charCodeAt(0);
        startsWithUS && ((attrs || initAttrs())[propNamePrefix + "visible"] = false);
      }
      var range = attributes.range;
      if (range) if (Array.isArray(range)) if (range.length >= 2) {
        (attrs || initAttrs())[propNamePrefix + "min"] = range[0];
        attrs[propNamePrefix + "max"] = range[1];
        range.length > 2 && (attrs[propNamePrefix + "step"] = range[2]);
      } else {
        true;
        cc.errorID(3647);
      } else {
        true;
        cc.error(ERR_Type, "range", className, propName, "array");
      }
      parseSimpleAttr("min", "number");
      parseSimpleAttr("max", "number");
      parseSimpleAttr("step", "number");
      parseSimpleAttr("userData", "object");
    }
    cc.Class = CCClass;
    module.exports = {
      isArray: function isArray(defaultVal) {
        defaultVal = getDefault(defaultVal);
        return Array.isArray(defaultVal);
      },
      fastDefine: CCClass._fastDefine,
      getNewValueTypeCode: (true, getNewValueTypeCodeJit),
      IDENTIFIER_RE: IDENTIFIER_RE,
      escapeForJS: escapeForJS,
      getDefault: getDefault
    };
    false;
  }), {
    "./CCEnum": 274,
    "./attribute": 284,
    "./js": 294,
    "./preprocess-class": 295,
    "./requiring-frame": 296,
    "./utils": 297
  } ],
  273: [ (function(require, module, exports) {
    "use strict";
    require("./CCClass");
    var Preprocess = require("./preprocess-class");
    var js = require("./js");
    var isPlainEmptyObj_DEV = (true, require("./utils").isPlainEmptyObj_DEV);
    var CACHE_KEY = "__ccclassCache__";
    function fNOP(ctor) {
      return ctor;
    }
    function getSubDict(obj, key) {
      return obj[key] || (obj[key] = {});
    }
    function checkCtorArgument(decorate) {
      return function(target) {
        if ("function" === typeof target) return decorate(target);
        return function(ctor) {
          return decorate(ctor, target);
        };
      };
    }
    function _checkNormalArgument(validator_DEV, decorate, decoratorName) {
      return function(target) {
        if (true, false === validator_DEV(target, decoratorName)) return function() {
          return fNOP;
        };
        return function(ctor) {
          return decorate(ctor, target);
        };
      };
    }
    var checkCompArgument = _checkNormalArgument.bind(null, (true, function(arg, decoratorName) {
      if (!cc.Class._isCCClass(arg)) {
        cc.error("The parameter for %s is missing.", decoratorName);
        return false;
      }
    }));
    function _argumentChecker(type) {
      return _checkNormalArgument.bind(null, (true, function(arg, decoratorName) {
        if (arg instanceof cc.Component || void 0 === arg) {
          cc.error("The parameter for %s is missing.", decoratorName);
          return false;
        }
        if (typeof arg !== type) {
          cc.error("The parameter for %s must be type %s.", decoratorName, type);
          return false;
        }
      }));
    }
    var checkStringArgument = _argumentChecker("string");
    var checkNumberArgument = _argumentChecker("number");
    function getClassCache(ctor, decoratorName) {
      if (true, cc.Class._isCCClass(ctor)) {
        cc.error('`@%s` should be used after @ccclass for class "%s"', decoratorName, js.getClassName(ctor));
        return null;
      }
      return getSubDict(ctor, CACHE_KEY);
    }
    function getDefaultFromInitializer(initializer) {
      var value;
      try {
        value = initializer();
      } catch (e) {
        return initializer;
      }
      return "object" !== typeof value || null === value ? value : initializer;
    }
    function extractActualDefaultValues(ctor) {
      var dummyObj;
      try {
        dummyObj = new ctor();
      } catch (e) {
        true;
        cc.errorID(3652, js.getClassName(ctor), e);
        return {};
      }
      return dummyObj;
    }
    function genProperty(ctor, properties, propName, options, desc, cache) {
      var fullOptions;
      var isGetset = desc && (desc.get || desc.set);
      options && (fullOptions = Preprocess.getFullFormOfProperty(options, isGetset));
      var existsProperty = properties[propName];
      var prop = js.mixin(existsProperty || {}, fullOptions || options || {});
      if (isGetset) {
        if ((true, options) && ((fullOptions || options).get || (fullOptions || options).set)) {
          var errorProps = getSubDict(cache, "errorProps");
          if (!errorProps[propName]) {
            errorProps[propName] = true;
            cc.warnID(3655, propName, js.getClassName(ctor), propName, propName);
          }
        }
        desc.get && (prop.get = desc.get);
        desc.set && (prop.set = desc.set);
      } else {
        if (true, prop.get || prop.set) {
          cc.errorID(3655, propName, js.getClassName(ctor), propName, propName);
          return;
        }
        var defaultValue = void 0;
        var isDefaultValueSpecified = false;
        if (desc) {
          if (desc.initializer) {
            defaultValue = getDefaultFromInitializer(desc.initializer);
            isDefaultValueSpecified = true;
          }
        } else {
          var actualDefaultValues = cache["default"] || (cache["default"] = extractActualDefaultValues(ctor));
          if (actualDefaultValues.hasOwnProperty(propName)) {
            defaultValue = actualDefaultValues[propName];
            isDefaultValueSpecified = true;
          }
        }
        false, false;
        prop["default"] = defaultValue;
      }
      properties[propName] = prop;
    }
    var ccclass = checkCtorArgument((function(ctor, name) {
      var base = js.getSuper(ctor);
      base === Object && (base = null);
      var proto = {
        name: name,
        extends: base,
        ctor: ctor,
        __ES6__: true
      };
      var cache = ctor[CACHE_KEY];
      if (cache) {
        var decoratedProto = cache.proto;
        decoratedProto && js.mixin(proto, decoratedProto);
        ctor[CACHE_KEY] = void 0;
      }
      var res = cc.Class(proto);
      true;
      var propNames = Object.getOwnPropertyNames(ctor.prototype);
      for (var i = 0; i < propNames.length; ++i) {
        var prop = propNames[i];
        if ("constructor" !== prop) {
          var desc = Object.getOwnPropertyDescriptor(ctor.prototype, prop);
          var func = desc && desc.value;
          "function" === typeof func && Preprocess.doValidateMethodWithProps_DEV(func, prop, js.getClassName(ctor), ctor, base);
        }
      }
      return res;
    }));
    function property(ctorProtoOrOptions, propName, desc) {
      var options = null;
      function normalized(ctorProto, propName, desc) {
        var cache = getClassCache(ctorProto.constructor);
        if (cache) {
          var ccclassProto = getSubDict(cache, "proto");
          var properties = getSubDict(ccclassProto, "properties");
          genProperty(ctorProto.constructor, properties, propName, options, desc, cache);
        }
      }
      if ("undefined" === typeof propName) {
        options = ctorProtoOrOptions;
        return normalized;
      }
      normalized(ctorProtoOrOptions, propName, desc);
    }
    function createEditorDecorator(argCheckFunc, editorPropName, staticValue) {
      return argCheckFunc((function(ctor, decoratedValue) {
        var cache = getClassCache(ctor, editorPropName);
        if (cache) {
          var value = void 0 !== staticValue ? staticValue : decoratedValue;
          var proto = getSubDict(cache, "proto");
          getSubDict(proto, "editor")[editorPropName] = value;
        }
      }), editorPropName);
    }
    function createDummyDecorator(argCheckFunc) {
      return argCheckFunc(fNOP);
    }
    var executeInEditMode = createEditorDecorator(checkCtorArgument, "executeInEditMode", true);
    var requireComponent = createEditorDecorator(checkCompArgument, "requireComponent");
    var menu = createEditorDecorator(checkStringArgument, "menu");
    var executionOrder = createEditorDecorator(checkNumberArgument, "executionOrder");
    var disallowMultiple = createEditorDecorator(checkCtorArgument, "disallowMultiple");
    var playOnFocus = createEditorDecorator(checkCtorArgument, "playOnFocus", true);
    var inspector = createEditorDecorator(checkStringArgument, "inspector");
    var icon = createEditorDecorator(checkStringArgument, "icon");
    var help = createEditorDecorator(checkStringArgument, "help");
    function mixins() {
      var mixins = [];
      for (var i = 0; i < arguments.length; i++) mixins[i] = arguments[i];
      return function(ctor) {
        var cache = getClassCache(ctor, "mixins");
        cache && (getSubDict(cache, "proto").mixins = mixins);
      };
    }
    cc._decorator = module.exports = {
      ccclass: ccclass,
      property: property,
      executeInEditMode: executeInEditMode,
      requireComponent: requireComponent,
      menu: menu,
      executionOrder: executionOrder,
      disallowMultiple: disallowMultiple,
      playOnFocus: playOnFocus,
      inspector: inspector,
      icon: icon,
      help: help,
      mixins: mixins
    };
  }), {
    "./CCClass": 272,
    "./js": 294,
    "./preprocess-class": 295,
    "./utils": 297
  } ],
  274: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    function Enum(obj) {
      if ("__enums__" in obj) return obj;
      js.value(obj, "__enums__", null, true);
      var lastIndex = -1;
      var keys = Object.keys(obj);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = obj[key];
        if (-1 === val) {
          val = ++lastIndex;
          obj[key] = val;
        } else if ("number" === typeof val) lastIndex = val; else if ("string" === typeof val && Number.isInteger(parseFloat(key))) continue;
        var reverseKey = "" + val;
        if (key !== reverseKey) {
          if ((false, false) && reverseKey in obj && obj[reverseKey] !== key) {
            cc.errorID(7100, reverseKey);
            continue;
          }
          js.value(obj, reverseKey, key);
        }
      }
      return obj;
    }
    Enum.isEnum = function(enumType) {
      return enumType && enumType.hasOwnProperty("__enums__");
    };
    Enum.getList = function(enumDef) {
      if (enumDef.__enums__) return enumDef.__enums__;
      var enums = enumDef.__enums__ = [];
      for (var name in enumDef) {
        var value = enumDef[name];
        Number.isInteger(value) && enums.push({
          name: name,
          value: value
        });
      }
      enums.sort((function(a, b) {
        return a.value - b.value;
      }));
      return enums;
    };
    true;
    var _TestEnum = Enum({
      ZERO: -1,
      ONE: -1,
      TWO: -1,
      THREE: -1
    });
    0 === _TestEnum.ZERO && 1 === _TestEnum.ONE && 3 === _TestEnum.THREE || cc.errorID(7101);
    module.exports = cc.Enum = Enum;
  }), {
    "./js": 294
  } ],
  275: [ (function(require, module, exports) {
    "use strict";
    var eventManager = require("../event-manager");
    var inputManager = require("./CCInputManager");
    var PORTRAIT = 0;
    var LANDSCAPE_LEFT = -90;
    var PORTRAIT_UPSIDE_DOWN = 180;
    var LANDSCAPE_RIGHT = 90;
    var _didAccelerateFun;
    cc.Acceleration = function(x, y, z, timestamp) {
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.timestamp = timestamp || 0;
    };
    inputManager.setAccelerometerEnabled = function(isEnable) {
      var _t = this;
      if (_t._accelEnabled === isEnable) return;
      _t._accelEnabled = isEnable;
      var scheduler = cc.director.getScheduler();
      scheduler.enableForTarget(_t);
      if (_t._accelEnabled) {
        _t._registerAccelerometerEvent();
        _t._accelCurTime = 0;
        scheduler.scheduleUpdate(_t);
      } else {
        _t._unregisterAccelerometerEvent();
        _t._accelCurTime = 0;
        scheduler.unscheduleUpdate(_t);
      }
      true;
      jsb.device.setMotionEnabled(isEnable);
    };
    inputManager.setAccelerometerInterval = function(interval) {
      if (this._accelInterval !== interval) {
        this._accelInterval = interval;
        true;
        jsb.device.setMotionInterval(interval);
      }
    };
    inputManager._registerKeyboardEvent = function() {
      cc.game.canvas.addEventListener("keydown", (function(e) {
        eventManager.dispatchEvent(new cc.Event.EventKeyboard(e.keyCode, true));
        e.stopPropagation();
        e.preventDefault();
      }), false);
      cc.game.canvas.addEventListener("keyup", (function(e) {
        eventManager.dispatchEvent(new cc.Event.EventKeyboard(e.keyCode, false));
        e.stopPropagation();
        e.preventDefault();
      }), false);
    };
    inputManager._registerAccelerometerEvent = function() {
      var w = window, _t = this;
      _t._acceleration = new cc.Acceleration();
      _t._accelDeviceEvent = w.DeviceMotionEvent || w.DeviceOrientationEvent;
      cc.sys.browserType === cc.sys.BROWSER_TYPE_MOBILE_QQ && (_t._accelDeviceEvent = window.DeviceOrientationEvent);
      var _deviceEventType = _t._accelDeviceEvent === w.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
      var ua = navigator.userAgent;
      (/Android/.test(ua) || /Adr/.test(ua) && cc.sys.browserType === cc.BROWSER_TYPE_UC) && (_t._minus = -1);
      _didAccelerateFun = _t.didAccelerate.bind(_t);
      w.addEventListener(_deviceEventType, _didAccelerateFun, false);
    };
    inputManager._unregisterAccelerometerEvent = function() {
      var w = window, _t = this;
      var _deviceEventType = _t._accelDeviceEvent === w.DeviceMotionEvent ? "devicemotion" : "deviceorientation";
      _didAccelerateFun && w.removeEventListener(_deviceEventType, _didAccelerateFun, false);
    };
    inputManager.didAccelerate = function(eventData) {
      var _t = this, w = window;
      if (!_t._accelEnabled) return;
      var mAcceleration = _t._acceleration;
      var x, y, z;
      if (_t._accelDeviceEvent === window.DeviceMotionEvent) {
        var eventAcceleration = eventData["accelerationIncludingGravity"];
        x = _t._accelMinus * eventAcceleration.x * .1;
        y = _t._accelMinus * eventAcceleration.y * .1;
        z = .1 * eventAcceleration.z;
      } else {
        x = eventData["gamma"] / 90 * .981;
        y = -eventData["beta"] / 90 * .981;
        z = eventData["alpha"] / 90 * .981;
      }
      if (cc.view._isRotated) {
        var tmp = x;
        x = -y;
        y = tmp;
      }
      mAcceleration.x = x;
      mAcceleration.y = y;
      mAcceleration.z = z;
      mAcceleration.timestamp = eventData.timeStamp || Date.now();
      var tmpX = mAcceleration.x;
      if (w.orientation === LANDSCAPE_RIGHT) {
        mAcceleration.x = -mAcceleration.y;
        mAcceleration.y = tmpX;
      } else if (w.orientation === LANDSCAPE_LEFT) {
        mAcceleration.x = mAcceleration.y;
        mAcceleration.y = -tmpX;
      } else if (w.orientation === PORTRAIT_UPSIDE_DOWN) {
        mAcceleration.x = -mAcceleration.x;
        mAcceleration.y = -mAcceleration.y;
      }
      if (cc.sys.os === cc.sys.OS_ANDROID && cc.sys.browserType !== cc.sys.BROWSER_TYPE_MOBILE_QQ) {
        mAcceleration.x = -mAcceleration.x;
        mAcceleration.y = -mAcceleration.y;
      }
    };
  }), {
    "../event-manager": 217,
    "./CCInputManager": 276
  } ],
  276: [ (function(require, module, exports) {
    "use strict";
    var macro = require("./CCMacro");
    var sys = require("./CCSys");
    var eventManager = require("../event-manager");
    var _vec2 = cc.v2();
    var inputManager = {
      _mousePressed: false,
      _isRegisterEvent: false,
      _preTouchPoint: cc.v2(0, 0),
      _prevMousePoint: cc.v2(0, 0),
      _preTouchPool: [],
      _preTouchPoolPointer: 0,
      _touches: [],
      _maxTouches: 10,
      _touchesIntegerDict: {},
      _indexBitsUsed: 0,
      _touchesCache: {},
      _touchCount: 0,
      _accelEnabled: false,
      _accelInterval: .2,
      _accelMinus: 1,
      _accelCurTime: 0,
      _acceleration: null,
      _accelDeviceEvent: null,
      _canvasBoundingRect: {
        left: 0,
        top: 0,
        adjustedLeft: 0,
        adjustedTop: 0,
        width: 0,
        height: 0
      },
      _getUnUsedIndex: function _getUnUsedIndex() {
        var now = cc.sys.now();
        var timeout = macro.TOUCH_TIMEOUT;
        var temp = this._indexBitsUsed;
        var unused = -1;
        var locTouches = this._touches;
        var locTouchesIntDict = this._touchesIntegerDict;
        var locTouchesCache = this._touchesCache;
        for (var i = 0; i < this._maxTouches; i++) {
          if (1 & temp) {
            var ccTouch = locTouches[i];
            if (ccTouch && now - ccTouch._lastModified > timeout) {
              var touchID = ccTouch.getID();
              delete locTouchesIntDict[touchID];
              delete locTouchesCache[touchID];
              this._touchCount--;
              if (-1 === unused) {
                unused = i;
                this._indexBitsUsed |= 1 << i;
              } else this._indexBitsUsed &= ~(1 << i);
            }
          } else if (-1 === unused) {
            unused = i;
            this._indexBitsUsed |= 1 << i;
          }
          temp >>= 1;
        }
        return unused;
      },
      _glView: null,
      _updateCanvasBoundingRect: function _updateCanvasBoundingRect() {
        var element = cc.game.canvas;
        var canvasBoundingRect = this._canvasBoundingRect;
        var docElem = document.documentElement;
        var leftOffset = window.pageXOffset - docElem.clientLeft;
        var topOffset = window.pageYOffset - docElem.clientTop;
        if (element.getBoundingClientRect) {
          var box = element.getBoundingClientRect();
          canvasBoundingRect.left = box.left + leftOffset;
          canvasBoundingRect.top = box.top + topOffset;
          canvasBoundingRect.width = box.width;
          canvasBoundingRect.height = box.height;
        } else if (element instanceof HTMLCanvasElement) {
          canvasBoundingRect.left = leftOffset;
          canvasBoundingRect.top = topOffset;
          canvasBoundingRect.width = element.width;
          canvasBoundingRect.height = element.height;
        } else {
          canvasBoundingRect.left = leftOffset;
          canvasBoundingRect.top = topOffset;
          canvasBoundingRect.width = parseInt(element.style.width);
          canvasBoundingRect.height = parseInt(element.style.height);
        }
      },
      handleTouchesBegin: function handleTouchesBegin(touches) {
        var now = sys.now();
        var selTouch, index, touchID, handleTouches = [];
        var locTouches = this._touches;
        var locTouchesIntDict = this._touchesIntegerDict;
        var locTouchesCache = this._touchesCache;
        for (var i = 0, len = touches.length; i < len; i++) {
          selTouch = touches[i];
          touchID = selTouch.getID();
          index = locTouchesIntDict[touchID];
          if (void 0 === index) {
            var unusedIndex = this._getUnUsedIndex();
            if (-1 === unusedIndex) {
              cc.logID(2300, unusedIndex);
              continue;
            }
            var ccTouch = new cc.Touch(selTouch._point.x, selTouch._point.y, touchID);
            ccTouch._setPrevPoint(selTouch._prevPoint);
            ccTouch._lastModified = now;
            locTouches[unusedIndex] = ccTouch;
            locTouchesIntDict[touchID] = unusedIndex;
            locTouchesCache[touchID] = ccTouch;
            this._touchCount++;
            handleTouches.push(ccTouch);
          }
        }
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.BEGAN;
          eventManager.dispatchEvent(touchEvent);
        }
      },
      handleTouchesMove: function handleTouchesMove(touches) {
        var now = sys.now();
        var selTouch, index, touchID, handleTouches = [];
        var locTouches = this._touches;
        var locTouchesIntDict = this._touchesIntegerDict;
        for (var i = 0, len = touches.length; i < len; i++) {
          selTouch = touches[i];
          touchID = selTouch.getID();
          index = locTouchesIntDict[touchID];
          if (void 0 === index) continue;
          var ccTouch = locTouches[index];
          if (ccTouch) {
            ccTouch._setPoint(selTouch._point);
            ccTouch._setPrevPoint(selTouch._prevPoint);
            ccTouch._lastModified = now;
            handleTouches.push(ccTouch);
          }
        }
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.MOVED;
          eventManager.dispatchEvent(touchEvent);
        }
      },
      handleTouchesEnd: function handleTouchesEnd(touches) {
        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.ENDED;
          eventManager.dispatchEvent(touchEvent);
        }
        this._preTouchPool.length = 0;
      },
      handleTouchesCancel: function handleTouchesCancel(touches) {
        var handleTouches = this.getSetOfTouchesEndOrCancel(touches);
        if (handleTouches.length > 0) {
          this._glView._convertTouchesWithScale(handleTouches);
          var touchEvent = new cc.Event.EventTouch(handleTouches);
          touchEvent._eventCode = cc.Event.EventTouch.CANCELED;
          eventManager.dispatchEvent(touchEvent);
        }
        this._preTouchPool.length = 0;
      },
      getSetOfTouchesEndOrCancel: function getSetOfTouchesEndOrCancel(touches) {
        var selTouch, index, touchID, handleTouches = [];
        var locTouches = this._touches;
        var locTouchesIntDict = this._touchesIntegerDict;
        var locTouchesCache = this._touchesCache;
        for (var i = 0, len = touches.length; i < len; i++) {
          selTouch = touches[i];
          touchID = selTouch.getID();
          index = locTouchesIntDict[touchID];
          if (void 0 === index) continue;
          var ccTouch = locTouches[index];
          if (ccTouch) {
            ccTouch._setPoint(selTouch._point);
            ccTouch._setPrevPoint(selTouch._prevPoint);
            handleTouches.push(ccTouch);
            delete locTouchesIntDict[touchID];
            delete locTouchesCache[touchID];
            this._touchCount--;
            this._indexBitsUsed &= ~(1 << index);
          }
        }
        return handleTouches;
      },
      getGlobalTouchCount: function getGlobalTouchCount() {
        return this._touchCount;
      },
      getGlobalTouches: function getGlobalTouches() {
        return this._touchesCache;
      },
      getPreTouch: function getPreTouch(touch) {
        var preTouch = null;
        var locPreTouchPool = this._preTouchPool;
        var id = touch.getID();
        for (var i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
          preTouch = locPreTouchPool[i];
          break;
        }
        preTouch || (preTouch = touch);
        return preTouch;
      },
      setPreTouch: function setPreTouch(touch) {
        var find = false;
        var locPreTouchPool = this._preTouchPool;
        var id = touch.getID();
        for (var i = locPreTouchPool.length - 1; i >= 0; i--) if (locPreTouchPool[i].getID() === id) {
          locPreTouchPool[i] = touch;
          find = true;
          break;
        }
        if (!find) if (locPreTouchPool.length <= 50) locPreTouchPool.push(touch); else {
          locPreTouchPool[this._preTouchPoolPointer] = touch;
          this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50;
        }
      },
      getTouchByXY: function getTouchByXY(tx, ty, pos) {
        var locPreTouch = this._preTouchPoint;
        var location = this._glView.convertToLocationInView(tx, ty, pos);
        var touch = new cc.Touch(location.x, location.y, 0);
        touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
        locPreTouch.x = location.x;
        locPreTouch.y = location.y;
        return touch;
      },
      getMouseEvent: function getMouseEvent(location, pos, eventType) {
        var locPreMouse = this._prevMousePoint;
        var mouseEvent = new cc.Event.EventMouse(eventType);
        mouseEvent._setPrevCursor(locPreMouse.x, locPreMouse.y);
        locPreMouse.x = location.x;
        locPreMouse.y = location.y;
        this._glView._convertMouseToLocationInView(locPreMouse, pos);
        mouseEvent.setLocation(locPreMouse.x, locPreMouse.y);
        return mouseEvent;
      },
      getPointByEvent: function getPointByEvent(event, pos) {
        cc.sys.browserType !== cc.sys.BROWSER_TYPE_QQ && cc.sys.browserType !== cc.sys.BROWSER_TYPE_UC && cc.sys.browserType !== cc.sys.BROWSER_TYPE_SAFARI || this._updateCanvasBoundingRect();
        if (null != event.pageX) return {
          x: event.pageX,
          y: event.pageY
        };
        pos.left -= document.body.scrollLeft;
        pos.top -= document.body.scrollTop;
        return {
          x: event.clientX,
          y: event.clientY
        };
      },
      getTouchesByEvent: function getTouchesByEvent(event, pos) {
        var touchArr = [], locView = this._glView;
        var touch_event, touch, preLocation;
        var locPreTouch = this._preTouchPoint;
        var length = event.changedTouches.length;
        for (var i = 0; i < length; i++) {
          touch_event = event.changedTouches[i];
          if (touch_event) {
            var location = void 0;
            location = sys.BROWSER_TYPE_FIREFOX === sys.browserType ? locView.convertToLocationInView(touch_event.pageX, touch_event.pageY, pos, _vec2) : locView.convertToLocationInView(touch_event.clientX, touch_event.clientY, pos, _vec2);
            if (null != touch_event.identifier) {
              touch = new cc.Touch(location.x, location.y, touch_event.identifier);
              preLocation = this.getPreTouch(touch).getLocation();
              touch._setPrevPoint(preLocation.x, preLocation.y);
              this.setPreTouch(touch);
            } else {
              touch = new cc.Touch(location.x, location.y);
              touch._setPrevPoint(locPreTouch.x, locPreTouch.y);
            }
            locPreTouch.x = location.x;
            locPreTouch.y = location.y;
            touchArr.push(touch);
          }
        }
        return touchArr;
      },
      registerSystemEvent: function registerSystemEvent(element) {
        if (this._isRegisterEvent) return;
        this._glView = cc.view;
        var selfPointer = this;
        var canvasBoundingRect = this._canvasBoundingRect;
        window.addEventListener("resize", this._updateCanvasBoundingRect.bind(this));
        var prohibition = sys.isMobile;
        var supportMouse = "mouse" in sys.capabilities;
        var supportTouches = "touches" in sys.capabilities;
        if (supportMouse) {
          if (!prohibition) {
            window.addEventListener("mousedown", (function() {
              selfPointer._mousePressed = true;
            }), false);
            window.addEventListener("mouseup", (function(event) {
              if (!selfPointer._mousePressed) return;
              selfPointer._mousePressed = false;
              var location = selfPointer.getPointByEvent(event, canvasBoundingRect);
              if (!cc.rect(canvasBoundingRect.left, canvasBoundingRect.top, canvasBoundingRect.width, canvasBoundingRect.height).contains(location)) {
                selfPointer.handleTouchesEnd([ selfPointer.getTouchByXY(location.x, location.y, canvasBoundingRect) ]);
                var mouseEvent = selfPointer.getMouseEvent(location, canvasBoundingRect, cc.Event.EventMouse.UP);
                mouseEvent.setButton(event.button);
                eventManager.dispatchEvent(mouseEvent);
              }
            }), false);
          }
          var EventMouse = cc.Event.EventMouse;
          var _mouseEventsOnElement = [ !prohibition && [ "mousedown", EventMouse.DOWN, function(event, mouseEvent, location, canvasBoundingRect) {
            selfPointer._mousePressed = true;
            selfPointer.handleTouchesBegin([ selfPointer.getTouchByXY(location.x, location.y, canvasBoundingRect) ]);
            element.focus();
          } ], !prohibition && [ "mouseup", EventMouse.UP, function(event, mouseEvent, location, canvasBoundingRect) {
            selfPointer._mousePressed = false;
            selfPointer.handleTouchesEnd([ selfPointer.getTouchByXY(location.x, location.y, canvasBoundingRect) ]);
          } ], !prohibition && [ "mousemove", EventMouse.MOVE, function(event, mouseEvent, location, canvasBoundingRect) {
            selfPointer.handleTouchesMove([ selfPointer.getTouchByXY(location.x, location.y, canvasBoundingRect) ]);
            selfPointer._mousePressed || mouseEvent.setButton(null);
          } ], [ "mousewheel", EventMouse.SCROLL, function(event, mouseEvent) {
            mouseEvent.setScrollData(0, event.wheelDelta);
          } ], [ "DOMMouseScroll", EventMouse.SCROLL, function(event, mouseEvent) {
            mouseEvent.setScrollData(0, -120 * event.detail);
          } ] ];
          for (var i = 0; i < _mouseEventsOnElement.length; ++i) {
            var entry = _mouseEventsOnElement[i];
            entry && (function() {
              var name = entry[0];
              var type = entry[1];
              var handler = entry[2];
              element.addEventListener(name, (function(event) {
                var location = selfPointer.getPointByEvent(event, canvasBoundingRect);
                var mouseEvent = selfPointer.getMouseEvent(location, canvasBoundingRect, type);
                mouseEvent.setButton(event.button);
                handler(event, mouseEvent, location, canvasBoundingRect);
                eventManager.dispatchEvent(mouseEvent);
                event.stopPropagation();
                event.preventDefault();
              }), false);
            })();
          }
        }
        if (window.navigator.msPointerEnabled) {
          var _pointerEventsMap = {
            MSPointerDown: selfPointer.handleTouchesBegin,
            MSPointerMove: selfPointer.handleTouchesMove,
            MSPointerUp: selfPointer.handleTouchesEnd,
            MSPointerCancel: selfPointer.handleTouchesCancel
          };
          var _loop = function _loop(eventName) {
            var touchEvent = _pointerEventsMap[eventName];
            element.addEventListener(eventName, (function(event) {
              var documentElement = document.documentElement;
              canvasBoundingRect.adjustedLeft = canvasBoundingRect.left - documentElement.scrollLeft;
              canvasBoundingRect.adjustedTop = canvasBoundingRect.top - documentElement.scrollTop;
              touchEvent.call(selfPointer, [ selfPointer.getTouchByXY(event.clientX, event.clientY, canvasBoundingRect) ]);
              event.stopPropagation();
            }), false);
          };
          for (var eventName in _pointerEventsMap) _loop(eventName);
        }
        if (supportTouches) {
          var _touchEventsMap = {
            touchstart: function touchstart(touchesToHandle) {
              selfPointer.handleTouchesBegin(touchesToHandle);
              element.focus();
            },
            touchmove: function touchmove(touchesToHandle) {
              selfPointer.handleTouchesMove(touchesToHandle);
            },
            touchend: function touchend(touchesToHandle) {
              selfPointer.handleTouchesEnd(touchesToHandle);
            },
            touchcancel: function touchcancel(touchesToHandle) {
              selfPointer.handleTouchesCancel(touchesToHandle);
            }
          };
          var registerTouchEvent = function registerTouchEvent(eventName) {
            var handler = _touchEventsMap[eventName];
            element.addEventListener(eventName, (function(event) {
              if (!event.changedTouches) return;
              var body = document.body;
              canvasBoundingRect.adjustedLeft = canvasBoundingRect.left - (body.scrollLeft || window.scrollX || 0);
              canvasBoundingRect.adjustedTop = canvasBoundingRect.top - (body.scrollTop || window.scrollY || 0);
              handler(selfPointer.getTouchesByEvent(event, canvasBoundingRect));
              event.stopPropagation();
              event.preventDefault();
            }), false);
          };
          for (var _eventName in _touchEventsMap) registerTouchEvent(_eventName);
        }
        this._registerKeyboardEvent();
        this._isRegisterEvent = true;
      },
      _registerKeyboardEvent: function _registerKeyboardEvent() {},
      _registerAccelerometerEvent: function _registerAccelerometerEvent() {},
      update: function update(dt) {
        if (this._accelCurTime > this._accelInterval) {
          this._accelCurTime -= this._accelInterval;
          eventManager.dispatchEvent(new cc.Event.EventAcceleration(this._acceleration));
        }
        this._accelCurTime += dt;
      }
    };
    module.exports = cc.internal.inputManager = inputManager;
  }), {
    "../event-manager": 217,
    "./CCMacro": 277,
    "./CCSys": 281
  } ],
  277: [ (function(require, module, exports) {
    "use strict";
    cc.macro = {
      RAD: Math.PI / 180,
      DEG: 180 / Math.PI,
      REPEAT_FOREVER: Number.MAX_VALUE - 1,
      FLT_EPSILON: 1.192092896e-7,
      MIN_ZINDEX: -Math.pow(2, 15),
      MAX_ZINDEX: Math.pow(2, 15) - 1,
      ONE: 1,
      ZERO: 0,
      SRC_ALPHA: 770,
      SRC_ALPHA_SATURATE: 776,
      SRC_COLOR: 768,
      DST_ALPHA: 772,
      DST_COLOR: 774,
      ONE_MINUS_SRC_ALPHA: 771,
      ONE_MINUS_SRC_COLOR: 769,
      ONE_MINUS_DST_ALPHA: 773,
      ONE_MINUS_DST_COLOR: 775,
      ONE_MINUS_CONSTANT_ALPHA: 32772,
      ONE_MINUS_CONSTANT_COLOR: 32770,
      ORIENTATION_PORTRAIT: 1,
      ORIENTATION_LANDSCAPE: 2,
      ORIENTATION_AUTO: 3,
      DENSITYDPI_DEVICE: "device-dpi",
      DENSITYDPI_HIGH: "high-dpi",
      DENSITYDPI_MEDIUM: "medium-dpi",
      DENSITYDPI_LOW: "low-dpi",
      FIX_ARTIFACTS_BY_STRECHING_TEXEL_TMX: true,
      DIRECTOR_STATS_POSITION: cc.v2(0, 0),
      ENABLE_STACKABLE_ACTIONS: true,
      TOUCH_TIMEOUT: 5e3,
      BATCH_VERTEX_COUNT: 2e4,
      ENABLE_TILEDMAP_CULLING: true,
      ENABLE_TRANSPARENT_CANVAS: false,
      ENABLE_WEBGL_ANTIALIAS: false,
      ENABLE_CULLING: false,
      CLEANUP_IMAGE_CACHE: false,
      SHOW_MESH_WIREFRAME: false,
      SHOW_MESH_NORMAL: false,
      ENABLE_MULTI_TOUCH: true,
      ALLOW_IMAGE_BITMAP: !cc.sys.isMobile,
      ENABLE_NATIVE_TTF_RENDERER: false
    };
    Object.defineProperty(cc.macro, "ROTATE_ACTION_CCW", {
      set: function set(value) {
        cc.RotateTo && cc.RotateBy && (cc.RotateTo._reverse = cc.RotateBy._reverse = value);
      }
    });
    var SUPPORT_TEXTURE_FORMATS = [ ".pkm", ".pvr", ".webp", ".jpg", ".jpeg", ".bmp", ".png" ];
    cc.macro.SUPPORT_TEXTURE_FORMATS = SUPPORT_TEXTURE_FORMATS;
    cc.macro.KEY = {
      none: 0,
      back: 6,
      menu: 18,
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      ctrl: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      space: 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      select: 41,
      insert: 45,
      Delete: 46,
      0: 48,
      1: 49,
      2: 50,
      3: 51,
      4: 52,
      5: 53,
      6: 54,
      7: 55,
      8: 56,
      9: 57,
      a: 65,
      b: 66,
      c: 67,
      d: 68,
      e: 69,
      f: 70,
      g: 71,
      h: 72,
      i: 73,
      j: 74,
      k: 75,
      l: 76,
      m: 77,
      n: 78,
      o: 79,
      p: 80,
      q: 81,
      r: 82,
      s: 83,
      t: 84,
      u: 85,
      v: 86,
      w: 87,
      x: 88,
      y: 89,
      z: 90,
      num0: 96,
      num1: 97,
      num2: 98,
      num3: 99,
      num4: 100,
      num5: 101,
      num6: 102,
      num7: 103,
      num8: 104,
      num9: 105,
      "*": 106,
      "+": 107,
      "-": 109,
      numdel: 110,
      "/": 111,
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      semicolon: 186,
      equal: 187,
      "=": 187,
      ",": 188,
      comma: 188,
      dash: 189,
      ".": 190,
      period: 190,
      forwardslash: 191,
      grave: 192,
      "[": 219,
      openbracket: 219,
      backslash: 220,
      "]": 221,
      closebracket: 221,
      quote: 222,
      dpadLeft: 1e3,
      dpadRight: 1001,
      dpadUp: 1003,
      dpadDown: 1004,
      dpadCenter: 1005
    };
    cc.macro.ImageFormat = cc.Enum({
      JPG: 0,
      PNG: 1,
      TIFF: 2,
      WEBP: 3,
      PVR: 4,
      ETC: 5,
      S3TC: 6,
      ATITC: 7,
      TGA: 8,
      RAWDATA: 9,
      UNKNOWN: 10
    });
    cc.macro.BlendFactor = cc.Enum({
      ONE: 1,
      ZERO: 0,
      SRC_ALPHA: 770,
      SRC_COLOR: 768,
      DST_ALPHA: 772,
      DST_COLOR: 774,
      ONE_MINUS_SRC_ALPHA: 771,
      ONE_MINUS_SRC_COLOR: 769,
      ONE_MINUS_DST_ALPHA: 773,
      ONE_MINUS_DST_COLOR: 775
    });
    cc.macro.TextAlignment = cc.Enum({
      LEFT: 0,
      CENTER: 1,
      RIGHT: 2
    });
    cc.macro.VerticalTextAlignment = cc.Enum({
      TOP: 0,
      CENTER: 1,
      BOTTOM: 2
    });
    module.exports = cc.macro;
  }), {} ],
  278: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    var CCClass = require("./CCClass");
    var Destroyed = 1;
    var RealDestroyed = 2;
    var ToDestroy = 4;
    var DontSave = 8;
    var EditorOnly = 16;
    var Dirty = 32;
    var DontDestroy = 64;
    var Destroying = 128;
    var Deactivating = 256;
    var LockedInEditor = 512;
    var HideInHierarchy = 1024;
    var IsOnEnableCalled = 2048;
    var IsEditorOnEnableCalled = 4096;
    var IsPreloadStarted = 8192;
    var IsOnLoadCalled = 16384;
    var IsOnLoadStarted = 32768;
    var IsStartCalled = 65536;
    var IsRotationLocked = 1 << 17;
    var IsScaleLocked = 1 << 18;
    var IsAnchorLocked = 1 << 19;
    var IsSizeLocked = 1 << 20;
    var IsPositionLocked = 1 << 21;
    var PersistentMask = ~(ToDestroy | Dirty | Destroying | DontDestroy | Deactivating | IsPreloadStarted | IsOnLoadStarted | IsOnLoadCalled | IsStartCalled | IsOnEnableCalled | IsEditorOnEnableCalled | IsRotationLocked | IsScaleLocked | IsAnchorLocked | IsSizeLocked | IsPositionLocked);
    function CCObject() {
      this._name = "";
      this._objFlags = 0;
    }
    CCClass.fastDefine("cc.Object", CCObject, {
      _name: "",
      _objFlags: 0
    });
    js.value(CCObject, "Flags", {
      Destroyed: Destroyed,
      DontSave: DontSave,
      EditorOnly: EditorOnly,
      Dirty: Dirty,
      DontDestroy: DontDestroy,
      PersistentMask: PersistentMask,
      Destroying: Destroying,
      Deactivating: Deactivating,
      LockedInEditor: LockedInEditor,
      HideInHierarchy: HideInHierarchy,
      IsPreloadStarted: IsPreloadStarted,
      IsOnLoadStarted: IsOnLoadStarted,
      IsOnLoadCalled: IsOnLoadCalled,
      IsOnEnableCalled: IsOnEnableCalled,
      IsStartCalled: IsStartCalled,
      IsEditorOnEnableCalled: IsEditorOnEnableCalled,
      IsPositionLocked: IsPositionLocked,
      IsRotationLocked: IsRotationLocked,
      IsScaleLocked: IsScaleLocked,
      IsAnchorLocked: IsAnchorLocked,
      IsSizeLocked: IsSizeLocked
    });
    var objectsToDestroy = [];
    function deferredDestroy() {
      var deleteCount = objectsToDestroy.length;
      for (var i = 0; i < deleteCount; ++i) {
        var obj = objectsToDestroy[i];
        obj._objFlags & Destroyed || obj._destroyImmediate();
      }
      deleteCount === objectsToDestroy.length ? objectsToDestroy.length = 0 : objectsToDestroy.splice(0, deleteCount);
      false;
    }
    js.value(CCObject, "_deferredDestroy", deferredDestroy);
    false;
    var prototype = CCObject.prototype;
    js.getset(prototype, "name", (function() {
      return this._name;
    }), (function(value) {
      this._name = value;
    }), true);
    js.get(prototype, "isValid", (function() {
      return !(this._objFlags & Destroyed);
    }), true);
    false, false;
    var deferredDestroyTimer = null;
    prototype.destroy = function() {
      if (this._objFlags & Destroyed) {
        cc.warnID(5e3);
        return false;
      }
      if (this._objFlags & ToDestroy) return false;
      this._objFlags |= ToDestroy;
      objectsToDestroy.push(this);
      false;
      return true;
    };
    false, false;
    function compileDestruct(obj, ctor) {
      var shouldSkipId = obj instanceof cc._BaseNode || obj instanceof cc.Component;
      var idToSkip = shouldSkipId ? "_id" : null;
      var key, propsToReset = {};
      for (key in obj) if (obj.hasOwnProperty(key)) {
        if (key === idToSkip) continue;
        switch (typeof obj[key]) {
         case "string":
          propsToReset[key] = "";
          break;

         case "object":
         case "function":
          propsToReset[key] = null;
        }
      }
      if (cc.Class._isCCClass(ctor)) {
        var attrs = cc.Class.Attr.getClassAttrs(ctor);
        var propList = ctor.__props__;
        for (var i = 0; i < propList.length; i++) {
          key = propList[i];
          var attrKey = key + cc.Class.Attr.DELIMETER + "default";
          if (attrKey in attrs) {
            if (shouldSkipId && "_id" === key) continue;
            switch (typeof attrs[attrKey]) {
             case "string":
              propsToReset[key] = "";
              break;

             case "object":
             case "function":
              propsToReset[key] = null;
              break;

             case "undefined":
              propsToReset[key] = void 0;
            }
          }
        }
      }
      true;
      var func = "";
      for (key in propsToReset) {
        var statement;
        statement = CCClass.IDENTIFIER_RE.test(key) ? "o." + key + "=" : "o[" + CCClass.escapeForJS(key) + "]=";
        var val = propsToReset[key];
        "" === val && (val = '""');
        func += statement + val + ";\n";
      }
      return Function("o", func);
    }
    prototype._destruct = function() {
      var ctor = this.constructor;
      var destruct = ctor.__destruct__;
      if (!destruct) {
        destruct = compileDestruct(this, ctor);
        js.value(ctor, "__destruct__", destruct, true);
      }
      destruct(this);
    };
    prototype._onPreDestroy = null;
    prototype._destroyImmediate = function() {
      if (this._objFlags & Destroyed) {
        cc.errorID(5e3);
        return;
      }
      this._onPreDestroy && this._onPreDestroy();
      true;
      this._destruct();
      this._objFlags |= Destroyed;
    };
    false;
    prototype._deserialize = null;
    cc.isValid = function(value, strictMode) {
      return "object" === typeof value ? !!value && !(value._objFlags & (strictMode ? Destroyed | ToDestroy : Destroyed)) : "undefined" !== typeof value;
    };
    false, false;
    cc.Object = module.exports = CCObject;
  }), {
    "./CCClass": 272,
    "./js": 294
  } ],
  279: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    cc.SAXParser = function() {
      if (true, window.DOMParser) {
        this._isSupportDOMParser = true;
        this._parser = new DOMParser();
      } else {
        this._isSupportDOMParser = false;
        this._parser = null;
      }
    };
    cc.SAXParser.prototype = {
      constructor: cc.SAXParser,
      parse: function parse(xmlTxt) {
        return this._parseXML(xmlTxt);
      },
      _parseXML: function _parseXML(textxml) {
        var xmlDoc;
        if (this._isSupportDOMParser) xmlDoc = this._parser.parseFromString(textxml, "text/xml"); else {
          xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
          xmlDoc.async = "false";
          xmlDoc.loadXML(textxml);
        }
        return xmlDoc;
      }
    };
    cc.PlistParser = function() {
      cc.SAXParser.call(this);
    };
    js.extend(cc.PlistParser, cc.SAXParser);
    js.mixin(cc.PlistParser.prototype, {
      parse: function parse(xmlTxt) {
        var xmlDoc = this._parseXML(xmlTxt);
        var plist = xmlDoc.documentElement;
        if ("plist" !== plist.tagName) {
          cc.warnID(5100);
          return {};
        }
        var node = null;
        for (var i = 0, len = plist.childNodes.length; i < len; i++) {
          node = plist.childNodes[i];
          if (1 === node.nodeType) break;
        }
        xmlDoc = null;
        return this._parseNode(node);
      },
      _parseNode: function _parseNode(node) {
        var data = null, tagName = node.tagName;
        if ("dict" === tagName) data = this._parseDict(node); else if ("array" === tagName) data = this._parseArray(node); else if ("string" === tagName) if (1 === node.childNodes.length) data = node.firstChild.nodeValue; else {
          data = "";
          for (var i = 0; i < node.childNodes.length; i++) data += node.childNodes[i].nodeValue;
        } else "false" === tagName ? data = false : "true" === tagName ? data = true : "real" === tagName ? data = parseFloat(node.firstChild.nodeValue) : "integer" === tagName && (data = parseInt(node.firstChild.nodeValue, 10));
        return data;
      },
      _parseArray: function _parseArray(node) {
        var data = [];
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
          var child = node.childNodes[i];
          if (1 !== child.nodeType) continue;
          data.push(this._parseNode(child));
        }
        return data;
      },
      _parseDict: function _parseDict(node) {
        var data = {};
        var key = null;
        for (var i = 0, len = node.childNodes.length; i < len; i++) {
          var child = node.childNodes[i];
          if (1 !== child.nodeType) continue;
          "key" === child.tagName ? key = child.firstChild.nodeValue : data[key] = this._parseNode(child);
        }
        return data;
      }
    });
    cc.saxParser = new cc.SAXParser();
    cc.plistParser = new cc.PlistParser();
    module.exports = {
      saxParser: cc.saxParser,
      plistParser: cc.plistParser
    };
  }), {
    "../platform/js": 294
  } ],
  280: [ (function(require, module, exports) {
    "use strict";
    cc.screen = {
      _supportsFullScreen: false,
      _onfullscreenchange: null,
      _onfullscreenerror: null,
      _preOnFullScreenChange: null,
      _preOnFullScreenError: null,
      _preOnTouch: null,
      _touchEvent: "",
      _fn: null,
      _fnMap: [ [ "requestFullscreen", "exitFullscreen", "fullscreenchange", "fullscreenEnabled", "fullscreenElement", "fullscreenerror" ], [ "requestFullScreen", "exitFullScreen", "fullScreenchange", "fullScreenEnabled", "fullScreenElement", "fullscreenerror" ], [ "webkitRequestFullScreen", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitIsFullScreen", "webkitCurrentFullScreenElement", "webkitfullscreenerror" ], [ "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozFullScreen", "mozFullScreenElement", "mozfullscreenerror" ], [ "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "msFullscreenEnabled", "msFullscreenElement", "msfullscreenerror" ] ],
      init: function init() {
        this._fn = {};
        var i, l, val, map = this._fnMap, valL;
        for (i = 0, l = map.length; i < l; i++) {
          val = map[i];
          if (val && "undefined" !== typeof document[val[1]]) {
            for (i = 0, valL = val.length; i < valL; i++) this._fn[map[0][i]] = val[i];
            break;
          }
        }
        this._supportsFullScreen = void 0 !== this._fn.requestFullscreen;
        this._touchEvent = "ontouchend" in window ? "touchend" : "mousedown";
      },
      fullScreen: function fullScreen() {
        return !!this._supportsFullScreen && !!(document[this._fn.fullscreenElement] || document[this._fn.webkitFullscreenElement] || document[this._fn.mozFullScreenElement]);
      },
      requestFullScreen: function requestFullScreen(element, onFullScreenChange, onFullScreenError) {
        if (element && "video" === element.tagName.toLowerCase()) {
          if (cc.sys.os === cc.sys.OS_IOS && cc.sys.isBrowser && element.readyState > 0) {
            element.webkitEnterFullscreen && element.webkitEnterFullscreen();
            return;
          }
          element.setAttribute("x5-video-player-fullscreen", "true");
        }
        if (!this._supportsFullScreen) return;
        element = element || document.documentElement;
        if (onFullScreenChange) {
          var eventName = this._fn.fullscreenchange;
          this._onfullscreenchange && document.removeEventListener(eventName, this._onfullscreenchange);
          this._onfullscreenchange = onFullScreenChange;
          document.addEventListener(eventName, onFullScreenChange, false);
        }
        if (onFullScreenError) {
          var _eventName = this._fn.fullscreenerror;
          this._onfullscreenerror && document.removeEventListener(_eventName, this._onfullscreenerror);
          this._onfullscreenerror = onFullScreenError;
          document.addEventListener(_eventName, onFullScreenError, {
            once: true
          });
        }
        var requestPromise = element[this._fn.requestFullscreen]();
        "undefined" === typeof document[this._fn.fullscreenerror] && window.Promise && requestPromise instanceof Promise && requestPromise["catch"]((function(err) {}));
      },
      exitFullScreen: function exitFullScreen(element) {
        if (element && "video" === element.tagName.toLowerCase()) {
          if (cc.sys.os === cc.sys.OS_IOS && cc.sys.isBrowser) {
            element.webkitExitFullscreen && element.webkitExitFullscreen();
            return;
          }
          element.setAttribute("x5-video-player-fullscreen", "false");
        }
        return !this._supportsFullScreen || document[this._fn.exitFullscreen]();
      },
      autoFullScreen: function autoFullScreen(element, onFullScreenChange) {
        element = element || document.body;
        this._ensureFullScreen(element, onFullScreenChange);
        this.requestFullScreen(element, onFullScreenChange);
      },
      disableAutoFullScreen: function disableAutoFullScreen(element) {
        var touchTarget = cc.game.canvas || element;
        var touchEventName = this._touchEvent;
        if (this._preOnTouch) {
          touchTarget.removeEventListener(touchEventName, this._preOnTouch);
          this._preOnTouch = null;
        }
      },
      _ensureFullScreen: function _ensureFullScreen(element, onFullScreenChange) {
        var self = this;
        var touchTarget = cc.game.canvas || element;
        var fullScreenErrorEventName = this._fn.fullscreenerror;
        var touchEventName = this._touchEvent;
        function onFullScreenError() {
          self._preOnFullScreenError = null;
          function onTouch() {
            self._preOnTouch = null;
            self.requestFullScreen(element, onFullScreenChange);
          }
          self._preOnTouch && touchTarget.removeEventListener(touchEventName, self._preOnTouch);
          self._preOnTouch = onTouch;
          touchTarget.addEventListener(touchEventName, self._preOnTouch, {
            once: true
          });
        }
        this._preOnFullScreenError && element.removeEventListener(fullScreenErrorEventName, this._preOnFullScreenError);
        this._preOnFullScreenError = onFullScreenError;
        element.addEventListener(fullScreenErrorEventName, onFullScreenError, {
          once: true
        });
      }
    };
    cc.screen.init();
  }), {} ],
  281: [ (function(require, module, exports) {
    "use strict";
    var settingPlatform;
    true;
    settingPlatform = window._CCSettings ? _CCSettings.platform : void 0;
    var isVivoGame = "qgame" === settingPlatform;
    var isOppoGame = "quickgame" === settingPlatform;
    var isHuaweiGame = "huawei" === settingPlatform;
    var isJKWGame = "jkw-game" === settingPlatform;
    var isQttGame = "qtt-game" === settingPlatform;
    var isLinkSure = "link-sure" === settingPlatform;
    var _global = "undefined" === typeof window ? global : window;
    function initSys() {
      cc.sys = {};
      var sys = cc.sys;
      sys.LANGUAGE_ENGLISH = "en";
      sys.LANGUAGE_CHINESE = "zh";
      sys.LANGUAGE_FRENCH = "fr";
      sys.LANGUAGE_ITALIAN = "it";
      sys.LANGUAGE_GERMAN = "de";
      sys.LANGUAGE_SPANISH = "es";
      sys.LANGUAGE_DUTCH = "du";
      sys.LANGUAGE_RUSSIAN = "ru";
      sys.LANGUAGE_KOREAN = "ko";
      sys.LANGUAGE_JAPANESE = "ja";
      sys.LANGUAGE_HUNGARIAN = "hu";
      sys.LANGUAGE_PORTUGUESE = "pt";
      sys.LANGUAGE_ARABIC = "ar";
      sys.LANGUAGE_NORWEGIAN = "no";
      sys.LANGUAGE_POLISH = "pl";
      sys.LANGUAGE_TURKISH = "tr";
      sys.LANGUAGE_UKRAINIAN = "uk";
      sys.LANGUAGE_ROMANIAN = "ro";
      sys.LANGUAGE_BULGARIAN = "bg";
      sys.LANGUAGE_UNKNOWN = "unknown";
      sys.OS_IOS = "iOS";
      sys.OS_ANDROID = "Android";
      sys.OS_WINDOWS = "Windows";
      sys.OS_MARMALADE = "Marmalade";
      sys.OS_LINUX = "Linux";
      sys.OS_BADA = "Bada";
      sys.OS_BLACKBERRY = "Blackberry";
      sys.OS_OSX = "OS X";
      sys.OS_WP8 = "WP8";
      sys.OS_WINRT = "WINRT";
      sys.OS_UNKNOWN = "Unknown";
      sys.UNKNOWN = -1;
      sys.WIN32 = 0;
      sys.LINUX = 1;
      sys.MACOS = 2;
      sys.ANDROID = 3;
      sys.IPHONE = 4;
      sys.IPAD = 5;
      sys.BLACKBERRY = 6;
      sys.NACL = 7;
      sys.EMSCRIPTEN = 8;
      sys.TIZEN = 9;
      sys.WINRT = 10;
      sys.WP8 = 11;
      sys.MOBILE_BROWSER = 100;
      sys.DESKTOP_BROWSER = 101;
      sys.EDITOR_PAGE = 102;
      sys.EDITOR_CORE = 103;
      sys.WECHAT_GAME = 104;
      sys.QQ_PLAY = 105;
      sys.FB_PLAYABLE_ADS = 106;
      sys.BAIDU_GAME = 107;
      sys.VIVO_GAME = 108;
      sys.OPPO_GAME = 109;
      sys.HUAWEI_GAME = 110;
      sys.XIAOMI_GAME = 111;
      sys.JKW_GAME = 112;
      sys.ALIPAY_GAME = 113;
      sys.WECHAT_GAME_SUB = 114;
      sys.BAIDU_GAME_SUB = 115;
      sys.QTT_GAME = 116;
      sys.BYTEDANCE_GAME = 117;
      sys.BYTEDANCE_GAME_SUB = 118;
      sys.LINKSURE = 119;
      sys.TAOBAO = 120;
      sys.BROWSER_TYPE_WECHAT = "wechat";
      sys.BROWSER_TYPE_ANDROID = "androidbrowser";
      sys.BROWSER_TYPE_IE = "ie";
      sys.BROWSER_TYPE_EDGE = "edge";
      sys.BROWSER_TYPE_QQ = "qqbrowser";
      sys.BROWSER_TYPE_MOBILE_QQ = "mqqbrowser";
      sys.BROWSER_TYPE_UC = "ucbrowser";
      sys.BROWSER_TYPE_UCBS = "ucbs";
      sys.BROWSER_TYPE_360 = "360browser";
      sys.BROWSER_TYPE_BAIDU_APP = "baiduboxapp";
      sys.BROWSER_TYPE_BAIDU = "baidubrowser";
      sys.BROWSER_TYPE_MAXTHON = "maxthon";
      sys.BROWSER_TYPE_OPERA = "opera";
      sys.BROWSER_TYPE_OUPENG = "oupeng";
      sys.BROWSER_TYPE_MIUI = "miuibrowser";
      sys.BROWSER_TYPE_FIREFOX = "firefox";
      sys.BROWSER_TYPE_SAFARI = "safari";
      sys.BROWSER_TYPE_CHROME = "chrome";
      sys.BROWSER_TYPE_LIEBAO = "liebao";
      sys.BROWSER_TYPE_QZONE = "qzone";
      sys.BROWSER_TYPE_SOUGOU = "sogou";
      sys.BROWSER_TYPE_HUAWEI = "huawei";
      sys.BROWSER_TYPE_UNKNOWN = "unknown";
      sys.isNative = true;
      sys.isBrowser = "object" === typeof window && "object" === typeof document && false;
      sys.glExtension = function(name) {
        return !!cc.renderer.device.ext(name);
      };
      sys.getMaxJointMatrixSize = function() {
        if (!sys._maxJointMatrixSize) {
          var JOINT_MATRICES_SIZE = 50;
          var LEFT_UNIFORM_SIZE = 10;
          var gl = cc.game._renderContext;
          var maxUniforms = Math.floor(gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS) / 4) - LEFT_UNIFORM_SIZE;
          sys._maxJointMatrixSize = maxUniforms < JOINT_MATRICES_SIZE ? 0 : JOINT_MATRICES_SIZE;
        }
        return sys._maxJointMatrixSize;
      };
      sys.getSafeAreaRect = function() {
        var visibleSize = cc.view.getVisibleSize();
        return cc.rect(0, 0, visibleSize.width, visibleSize.height);
      };
      if (_global.__globalAdapter && _global.__globalAdapter.adaptSys) _global.__globalAdapter.adaptSys(sys); else {
        false;
        var win, nav, doc, docEle;
        var ua;
        var currLanguage;
        var isAndroid, iOS, osVersion, osMainVersion;
        var uaResult;
        var osName;
        var w;
        var h;
        var ratio;
        var _tmpCanvas1;
        var create3DContext;
        var localStorage;
        var warn;
        var _supportWebp;
        var _supportCanvas;
        var _supportWebGL;
        var capabilities;
        var __audioSupport;
        var formatSupport;
        true;
        var platform;
        platform = isVivoGame ? sys.VIVO_GAME : isOppoGame ? sys.OPPO_GAME : isHuaweiGame ? sys.HUAWEI_GAME : isJKWGame ? sys.JKW_GAME : isQttGame ? sys.QTT_GAME : isLinkSure ? sys.LINKSURE : __getPlatform();
        sys.platform = platform;
        sys.isMobile = platform === sys.ANDROID || platform === sys.IPAD || platform === sys.IPHONE || platform === sys.WP8 || platform === sys.TIZEN || platform === sys.BLACKBERRY || platform === sys.XIAOMI_GAME || isVivoGame || isOppoGame || isHuaweiGame || isJKWGame || isQttGame;
        sys.os = __getOS();
        sys.language = __getCurrentLanguage();
        var languageCode;
        true;
        languageCode = __getCurrentLanguageCode();
        sys.languageCode = languageCode ? languageCode.toLowerCase() : void 0;
        sys.osVersion = __getOSVersion();
        sys.osMainVersion = parseInt(sys.osVersion);
        sys.browserType = null;
        sys.browserVersion = null;
        var w = window.innerWidth;
        var h = window.innerHeight;
        var ratio = window.devicePixelRatio || 1;
        sys.windowPixelResolution = {
          width: ratio * w,
          height: ratio * h
        };
        sys.localStorage = window.localStorage;
        var capabilities;
        capabilities = sys.capabilities = {
          canvas: false,
          opengl: true,
          webp: true
        };
        if (sys.isMobile) capabilities["accelerometer"] = true; else {
          capabilities["keyboard"] = true;
          capabilities["mouse"] = true;
        }
        capabilities["touches"] = sys.isBrowser || sys.isMobile;
        capabilities["imageBitmap"] = false;
        sys.__audioSupport = {
          ONLY_ONE: false,
          WEB_AUDIO: false,
          DELAY_CREATE_CTX: false,
          format: [ ".mp3" ]
        };
      }
      sys.NetworkType = {
        NONE: 0,
        LAN: 1,
        WWAN: 2
      };
      sys.getNetworkType = function() {
        return sys.NetworkType.LAN;
      };
      sys.getBatteryLevel = function() {
        return 1;
      };
      sys.garbageCollect = function() {};
      sys.restartVM = function() {};
      sys.isObjectValid = function(obj) {
        if (obj) return true;
        return false;
      };
      sys.dump = function() {
        var self = this;
        var str = "";
        str += "isMobile : " + self.isMobile + "\r\n";
        str += "language : " + self.language + "\r\n";
        str += "browserType : " + self.browserType + "\r\n";
        str += "browserVersion : " + self.browserVersion + "\r\n";
        str += "capabilities : " + JSON.stringify(self.capabilities) + "\r\n";
        str += "os : " + self.os + "\r\n";
        str += "osVersion : " + self.osVersion + "\r\n";
        str += "platform : " + self.platform + "\r\n";
        str += "Using " + (cc.game.renderType === cc.game.RENDER_TYPE_WEBGL ? "WEBGL" : "CANVAS") + " renderer.\r\n";
        cc.log(str);
      };
      sys.openURL = function(url) {
        true;
        jsb.openURL(url);
      };
      sys.now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      return sys;
    }
    var sys = cc && cc.sys ? cc.sys : initSys();
    module.exports = sys;
  }), {} ],
  282: [ (function(require, module, exports) {
    "use strict";
    var EventTarget = require("../event/event-target");
    var js = require("../platform/js");
    var renderer = require("../renderer");
    require("../platform/CCClass");
    var __BrowserGetter = {
      init: function init() {
        this.html = document.getElementsByTagName("html")[0];
      },
      availWidth: function availWidth(frame) {
        return frame && frame !== this.html ? frame.clientWidth : window.innerWidth;
      },
      availHeight: function availHeight(frame) {
        return frame && frame !== this.html ? frame.clientHeight : window.innerHeight;
      },
      meta: {
        width: "device-width"
      },
      adaptationType: cc.sys.browserType
    };
    cc.sys.os === cc.sys.OS_IOS && (__BrowserGetter.adaptationType = cc.sys.BROWSER_TYPE_SAFARI);
    switch (__BrowserGetter.adaptationType) {
     case cc.sys.BROWSER_TYPE_SAFARI:
     case cc.sys.BROWSER_TYPE_SOUGOU:
     case cc.sys.BROWSER_TYPE_UC:
      __BrowserGetter.meta["minimal-ui"] = "true";
      __BrowserGetter.availWidth = function(frame) {
        return frame.clientWidth;
      };
      __BrowserGetter.availHeight = function(frame) {
        return frame.clientHeight;
      };
    }
    var _scissorRect = null;
    var View = function View() {
      EventTarget.call(this);
      var _t = this, _strategyer = cc.ContainerStrategy, _strategy = cc.ContentStrategy;
      __BrowserGetter.init(this);
      _t._frameSize = cc.size(0, 0);
      _t._designResolutionSize = cc.size(0, 0);
      _t._originalDesignResolutionSize = cc.size(0, 0);
      _t._scaleX = 1;
      _t._scaleY = 1;
      _t._viewportRect = cc.rect(0, 0, 0, 0);
      _t._visibleRect = cc.rect(0, 0, 0, 0);
      _t._autoFullScreen = false;
      _t._devicePixelRatio = 1;
      true;
      _t._maxPixelRatio = 4;
      _t._retinaEnabled = false;
      _t._resizeCallback = null;
      _t._resizing = false;
      _t._resizeWithBrowserSize = false;
      _t._orientationChanging = true;
      _t._isRotated = false;
      _t._orientation = cc.macro.ORIENTATION_AUTO;
      _t._isAdjustViewport = true;
      _t._antiAliasEnabled = false;
      _t._resolutionPolicy = null;
      _t._rpExactFit = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.EXACT_FIT);
      _t._rpShowAll = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.SHOW_ALL);
      _t._rpNoBorder = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.NO_BORDER);
      _t._rpFixedHeight = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_HEIGHT);
      _t._rpFixedWidth = new cc.ResolutionPolicy(_strategyer.EQUAL_TO_FRAME, _strategy.FIXED_WIDTH);
      cc.game.once(cc.game.EVENT_ENGINE_INITED, this.init, this);
    };
    cc.js.extend(View, EventTarget);
    cc.js.mixin(View.prototype, {
      init: function init() {
        this._initFrameSize();
        var w = cc.game.canvas.width, h = cc.game.canvas.height;
        this._designResolutionSize.width = w;
        this._designResolutionSize.height = h;
        this._originalDesignResolutionSize.width = w;
        this._originalDesignResolutionSize.height = h;
        this._viewportRect.width = w;
        this._viewportRect.height = h;
        this._visibleRect.width = w;
        this._visibleRect.height = h;
        cc.winSize.width = this._visibleRect.width;
        cc.winSize.height = this._visibleRect.height;
        cc.visibleRect && cc.visibleRect.init(this._visibleRect);
      },
      _resizeEvent: function _resizeEvent(forceOrEvent) {
        var view;
        view = this.setDesignResolutionSize ? this : cc.view;
        var sys = cc.sys;
        if (sys.browserType === sys.BROWSER_TYPE_UC && sys.os === sys.OS_IOS) {
          setTimeout((function() {
            view._resizeEvent(forceOrEvent);
          }), 0);
          return;
        }
        var prevFrameW = view._frameSize.width, prevFrameH = view._frameSize.height, prevRotated = view._isRotated;
        if (cc.sys.isMobile) {
          var containerStyle = cc.game.container.style, margin = containerStyle.margin;
          containerStyle.margin = "0";
          containerStyle.display = "none";
          view._initFrameSize();
          containerStyle.margin = margin;
          containerStyle.display = "block";
        } else view._initFrameSize();
        if (true !== forceOrEvent && view._isRotated === prevRotated && view._frameSize.width === prevFrameW && view._frameSize.height === prevFrameH) return;
        var width = view._originalDesignResolutionSize.width;
        var height = view._originalDesignResolutionSize.height;
        view._resizing = true;
        width > 0 && view.setDesignResolutionSize(width, height, view._resolutionPolicy);
        view._resizing = false;
        view.emit("canvas-resize");
        view._resizeCallback && view._resizeCallback.call();
      },
      _orientationChange: function _orientationChange() {
        cc.view._orientationChanging = true;
        cc.view._resizeEvent();
        cc.sys.browserType === cc.sys.BROWSER_TYPE_SAFARI && cc.sys.isMobile && setTimeout((function() {
          window.innerHeight > window.innerWidth && window.scrollTo(0, 1);
        }), 500);
      },
      _resize: function _resize() {
        cc.view._resizeEvent(true);
      },
      resizeWithBrowserSize: function resizeWithBrowserSize(enabled) {
        if (enabled) {
          if (!this._resizeWithBrowserSize) {
            this._resizeWithBrowserSize = true;
            window.addEventListener("resize", this._resize);
            window.addEventListener("orientationchange", this._orientationChange);
          }
        } else if (this._resizeWithBrowserSize) {
          this._resizeWithBrowserSize = false;
          window.removeEventListener("resize", this._resize);
          window.removeEventListener("orientationchange", this._orientationChange);
        }
      },
      setResizeCallback: function setResizeCallback(callback) {
        false;
        "function" !== typeof callback && null != callback || (this._resizeCallback = callback);
      },
      setOrientation: function setOrientation(orientation) {
        orientation &= cc.macro.ORIENTATION_AUTO;
        if (orientation && this._orientation !== orientation) {
          this._orientation = orientation;
          var designWidth = this._originalDesignResolutionSize.width;
          var designHeight = this._originalDesignResolutionSize.height;
          this.setDesignResolutionSize(designWidth, designHeight, this._resolutionPolicy);
        }
      },
      _initFrameSize: function _initFrameSize() {
        var locFrameSize = this._frameSize;
        var w = __BrowserGetter.availWidth(cc.game.frame);
        var h = __BrowserGetter.availHeight(cc.game.frame);
        var isLandscape = w >= h;
        if ((false, !cc.sys.isMobile) || isLandscape && this._orientation & cc.macro.ORIENTATION_LANDSCAPE || !isLandscape && this._orientation & cc.macro.ORIENTATION_PORTRAIT) {
          locFrameSize.width = w;
          locFrameSize.height = h;
          cc.game.container.style["-webkit-transform"] = "rotate(0deg)";
          cc.game.container.style.transform = "rotate(0deg)";
          this._isRotated = false;
        } else {
          locFrameSize.width = h;
          locFrameSize.height = w;
          cc.game.container.style["-webkit-transform"] = "rotate(90deg)";
          cc.game.container.style.transform = "rotate(90deg)";
          cc.game.container.style["-webkit-transform-origin"] = "0px 0px 0px";
          cc.game.container.style.transformOrigin = "0px 0px 0px";
          this._isRotated = true;
        }
        this._orientationChanging && setTimeout((function() {
          cc.view._orientationChanging = false;
        }), 1e3);
      },
      _setViewportMeta: function _setViewportMeta(metas, overwrite) {
        var vp = document.getElementById("cocosMetaElement");
        vp && overwrite && document.head.removeChild(vp);
        var elems = document.getElementsByName("viewport"), currentVP = elems ? elems[0] : null, content, key, pattern;
        content = currentVP ? currentVP.content : "";
        vp = vp || document.createElement("meta");
        vp.id = "cocosMetaElement";
        vp.name = "viewport";
        vp.content = "";
        for (key in metas) if (-1 == content.indexOf(key)) content += "," + key + "=" + metas[key]; else if (overwrite) {
          pattern = new RegExp(key + "s*=s*[^,]+");
          content = content.replace(pattern, key + "=" + metas[key]);
        }
        /^,/.test(content) && (content = content.substr(1));
        vp.content = content;
        currentVP && (currentVP.content = content);
        document.head.appendChild(vp);
      },
      _adjustViewportMeta: function _adjustViewportMeta() {
        if (this._isAdjustViewport && false) {
          this._setViewportMeta(__BrowserGetter.meta, false);
          this._isAdjustViewport = false;
        }
      },
      adjustViewportMeta: function adjustViewportMeta(enabled) {
        this._isAdjustViewport = enabled;
      },
      enableRetina: function enableRetina(enabled) {
        this._retinaEnabled = !!enabled;
      },
      isRetinaEnabled: function isRetinaEnabled() {
        return this._retinaEnabled;
      },
      enableAntiAlias: function enableAntiAlias(enabled) {
        cc.warnID(9200);
        if (this._antiAliasEnabled === enabled) return;
        this._antiAliasEnabled = enabled;
        if (cc.game.renderType === cc.game.RENDER_TYPE_WEBGL) {
          var cache = cc.assetManager.assets;
          cache.forEach((function(asset) {
            if (asset instanceof cc.Texture2D) {
              var Filter = cc.Texture2D.Filter;
              enabled ? asset.setFilters(Filter.LINEAR, Filter.LINEAR) : asset.setFilters(Filter.NEAREST, Filter.NEAREST);
            }
          }));
        } else if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
          var ctx = cc.game.canvas.getContext("2d");
          ctx.imageSmoothingEnabled = enabled;
          ctx.mozImageSmoothingEnabled = enabled;
        }
      },
      isAntiAliasEnabled: function isAntiAliasEnabled() {
        return this._antiAliasEnabled;
      },
      enableAutoFullScreen: function enableAutoFullScreen(enabled) {
        if (enabled && enabled !== this._autoFullScreen && cc.sys.isMobile) {
          this._autoFullScreen = true;
          cc.screen.autoFullScreen(cc.game.frame);
        } else {
          this._autoFullScreen = false;
          cc.screen.disableAutoFullScreen(cc.game.frame);
        }
      },
      isAutoFullScreenEnabled: function isAutoFullScreenEnabled() {
        return this._autoFullScreen;
      },
      setCanvasSize: function setCanvasSize(width, height) {
        var canvas = cc.game.canvas;
        var container = cc.game.container;
        canvas.width = width * this._devicePixelRatio;
        canvas.height = height * this._devicePixelRatio;
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
        container.style.width = width + "px";
        container.style.height = height + "px";
        this._resizeEvent();
      },
      getCanvasSize: function getCanvasSize() {
        return cc.size(cc.game.canvas.width, cc.game.canvas.height);
      },
      getFrameSize: function getFrameSize() {
        return cc.size(this._frameSize.width, this._frameSize.height);
      },
      setFrameSize: function setFrameSize(width, height) {
        this._frameSize.width = width;
        this._frameSize.height = height;
        cc.game.frame.style.width = width + "px";
        cc.game.frame.style.height = height + "px";
        this._resizeEvent(true);
      },
      getVisibleSize: function getVisibleSize() {
        return cc.size(this._visibleRect.width, this._visibleRect.height);
      },
      getVisibleSizeInPixel: function getVisibleSizeInPixel() {
        return cc.size(this._visibleRect.width * this._scaleX, this._visibleRect.height * this._scaleY);
      },
      getVisibleOrigin: function getVisibleOrigin() {
        return cc.v2(this._visibleRect.x, this._visibleRect.y);
      },
      getVisibleOriginInPixel: function getVisibleOriginInPixel() {
        return cc.v2(this._visibleRect.x * this._scaleX, this._visibleRect.y * this._scaleY);
      },
      getResolutionPolicy: function getResolutionPolicy() {
        return this._resolutionPolicy;
      },
      setResolutionPolicy: function setResolutionPolicy(resolutionPolicy) {
        var _t = this;
        if (resolutionPolicy instanceof cc.ResolutionPolicy) _t._resolutionPolicy = resolutionPolicy; else {
          var _locPolicy = cc.ResolutionPolicy;
          resolutionPolicy === _locPolicy.EXACT_FIT && (_t._resolutionPolicy = _t._rpExactFit);
          resolutionPolicy === _locPolicy.SHOW_ALL && (_t._resolutionPolicy = _t._rpShowAll);
          resolutionPolicy === _locPolicy.NO_BORDER && (_t._resolutionPolicy = _t._rpNoBorder);
          resolutionPolicy === _locPolicy.FIXED_HEIGHT && (_t._resolutionPolicy = _t._rpFixedHeight);
          resolutionPolicy === _locPolicy.FIXED_WIDTH && (_t._resolutionPolicy = _t._rpFixedWidth);
        }
      },
      setDesignResolutionSize: function setDesignResolutionSize(width, height, resolutionPolicy) {
        if (!(width > 0 && height > 0)) {
          cc.errorID(2200);
          return;
        }
        this.setResolutionPolicy(resolutionPolicy);
        var policy = this._resolutionPolicy;
        policy && policy.preApply(this);
        cc.sys.isMobile && this._adjustViewportMeta();
        this._orientationChanging = true;
        this._resizing || this._initFrameSize();
        if (!policy) {
          cc.logID(2201);
          return;
        }
        this._originalDesignResolutionSize.width = this._designResolutionSize.width = width;
        this._originalDesignResolutionSize.height = this._designResolutionSize.height = height;
        var result = policy.apply(this, this._designResolutionSize);
        if (result.scale && 2 === result.scale.length) {
          this._scaleX = result.scale[0];
          this._scaleY = result.scale[1];
        }
        if (result.viewport) {
          var vp = this._viewportRect, vb = this._visibleRect, rv = result.viewport;
          vp.x = rv.x;
          vp.y = rv.y;
          vp.width = rv.width;
          vp.height = rv.height;
          vb.x = 0;
          vb.y = 0;
          vb.width = rv.width / this._scaleX;
          vb.height = rv.height / this._scaleY;
        }
        policy.postApply(this);
        cc.winSize.width = this._visibleRect.width;
        cc.winSize.height = this._visibleRect.height;
        cc.visibleRect && cc.visibleRect.init(this._visibleRect);
        renderer.updateCameraViewport();
        cc.internal.inputManager._updateCanvasBoundingRect();
        this.emit("design-resolution-changed");
      },
      getDesignResolutionSize: function getDesignResolutionSize() {
        return cc.size(this._designResolutionSize.width, this._designResolutionSize.height);
      },
      setRealPixelResolution: function setRealPixelResolution(width, height, resolutionPolicy) {
        false;
        this.setDesignResolutionSize(width, height, resolutionPolicy);
      },
      setViewportInPoints: function setViewportInPoints(x, y, w, h) {
        var locScaleX = this._scaleX, locScaleY = this._scaleY;
        cc.game._renderContext.viewport(x * locScaleX + this._viewportRect.x, y * locScaleY + this._viewportRect.y, w * locScaleX, h * locScaleY);
      },
      setScissorInPoints: function setScissorInPoints(x, y, w, h) {
        var scaleX = this._scaleX, scaleY = this._scaleY;
        var sx = Math.ceil(x * scaleX + this._viewportRect.x);
        var sy = Math.ceil(y * scaleY + this._viewportRect.y);
        var sw = Math.ceil(w * scaleX);
        var sh = Math.ceil(h * scaleY);
        var gl = cc.game._renderContext;
        if (!_scissorRect) {
          var boxArr = gl.getParameter(gl.SCISSOR_BOX);
          _scissorRect = cc.rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
        }
        if (_scissorRect.x !== sx || _scissorRect.y !== sy || _scissorRect.width !== sw || _scissorRect.height !== sh) {
          _scissorRect.x = sx;
          _scissorRect.y = sy;
          _scissorRect.width = sw;
          _scissorRect.height = sh;
          gl.scissor(sx, sy, sw, sh);
        }
      },
      isScissorEnabled: function isScissorEnabled() {
        return cc.game._renderContext.isEnabled(gl.SCISSOR_TEST);
      },
      getScissorRect: function getScissorRect() {
        if (!_scissorRect) {
          var boxArr = gl.getParameter(gl.SCISSOR_BOX);
          _scissorRect = cc.rect(boxArr[0], boxArr[1], boxArr[2], boxArr[3]);
        }
        var scaleXFactor = 1 / this._scaleX;
        var scaleYFactor = 1 / this._scaleY;
        return cc.rect((_scissorRect.x - this._viewportRect.x) * scaleXFactor, (_scissorRect.y - this._viewportRect.y) * scaleYFactor, _scissorRect.width * scaleXFactor, _scissorRect.height * scaleYFactor);
      },
      getViewportRect: function getViewportRect() {
        return this._viewportRect;
      },
      getScaleX: function getScaleX() {
        return this._scaleX;
      },
      getScaleY: function getScaleY() {
        return this._scaleY;
      },
      getDevicePixelRatio: function getDevicePixelRatio() {
        return this._devicePixelRatio;
      },
      convertToLocationInView: function convertToLocationInView(tx, ty, relatedPos, out) {
        var result = out || cc.v2();
        var posLeft = relatedPos.adjustedLeft ? relatedPos.adjustedLeft : relatedPos.left;
        var posTop = relatedPos.adjustedTop ? relatedPos.adjustedTop : relatedPos.top;
        var x = this._devicePixelRatio * (tx - posLeft);
        var y = this._devicePixelRatio * (posTop + relatedPos.height - ty);
        if (this._isRotated) {
          result.x = cc.game.canvas.width - y;
          result.y = x;
        } else {
          result.x = x;
          result.y = y;
        }
        return result;
      },
      _convertMouseToLocationInView: function _convertMouseToLocationInView(in_out_point, relatedPos) {
        var viewport = this._viewportRect, _t = this;
        in_out_point.x = (_t._devicePixelRatio * (in_out_point.x - relatedPos.left) - viewport.x) / _t._scaleX;
        in_out_point.y = (_t._devicePixelRatio * (relatedPos.top + relatedPos.height - in_out_point.y) - viewport.y) / _t._scaleY;
      },
      _convertPointWithScale: function _convertPointWithScale(point) {
        var viewport = this._viewportRect;
        point.x = (point.x - viewport.x) / this._scaleX;
        point.y = (point.y - viewport.y) / this._scaleY;
      },
      _convertTouchesWithScale: function _convertTouchesWithScale(touches) {
        var viewport = this._viewportRect, scaleX = this._scaleX, scaleY = this._scaleY, selTouch, selPoint, selPrePoint;
        for (var i = 0; i < touches.length; i++) {
          selTouch = touches[i];
          selPoint = selTouch._point;
          selPrePoint = selTouch._prevPoint;
          selPoint.x = (selPoint.x - viewport.x) / scaleX;
          selPoint.y = (selPoint.y - viewport.y) / scaleY;
          selPrePoint.x = (selPrePoint.x - viewport.x) / scaleX;
          selPrePoint.y = (selPrePoint.y - viewport.y) / scaleY;
        }
      }
    });
    cc.ContainerStrategy = cc.Class({
      name: "ContainerStrategy",
      preApply: function preApply(view) {},
      apply: function apply(view, designedResolution) {},
      postApply: function postApply(view) {},
      _setupContainer: function _setupContainer(view, w, h) {
        var locCanvas = cc.game.canvas;
        this._setupStyle(view, w, h);
        var devicePixelRatio = view._devicePixelRatio = 1;
        true;
        devicePixelRatio = view._devicePixelRatio = window.devicePixelRatio;
        locCanvas.width = w * devicePixelRatio;
        locCanvas.height = h * devicePixelRatio;
      },
      _setupStyle: function _setupStyle(view, w, h) {
        var locCanvas = cc.game.canvas;
        var locContainer = cc.game.container;
        if (cc.sys.os === cc.sys.OS_ANDROID) {
          document.body.style.width = (view._isRotated ? h : w) + "px";
          document.body.style.height = (view._isRotated ? w : h) + "px";
        }
        locContainer.style.width = locCanvas.style.width = w + "px";
        locContainer.style.height = locCanvas.style.height = h + "px";
      },
      _fixContainer: function _fixContainer() {
        document.body.insertBefore(cc.game.container, document.body.firstChild);
        var bs = document.body.style;
        bs.width = window.innerWidth + "px";
        bs.height = window.innerHeight + "px";
        bs.overflow = "hidden";
        var contStyle = cc.game.container.style;
        contStyle.position = "fixed";
        contStyle.left = contStyle.top = "0px";
        document.body.scrollTop = 0;
      }
    });
    cc.ContentStrategy = cc.Class({
      name: "ContentStrategy",
      ctor: function ctor() {
        this._result = {
          scale: [ 1, 1 ],
          viewport: null
        };
      },
      _buildResult: function _buildResult(containerW, containerH, contentW, contentH, scaleX, scaleY) {
        Math.abs(containerW - contentW) < 2 && (contentW = containerW);
        Math.abs(containerH - contentH) < 2 && (contentH = containerH);
        var viewport = cc.rect((containerW - contentW) / 2, (containerH - contentH) / 2, contentW, contentH);
        cc.game.renderType === cc.game.RENDER_TYPE_CANVAS;
        this._result.scale = [ scaleX, scaleY ];
        this._result.viewport = viewport;
        return this._result;
      },
      preApply: function preApply(view) {},
      apply: function apply(view, designedResolution) {
        return {
          scale: [ 1, 1 ]
        };
      },
      postApply: function postApply(view) {}
    });
    (function() {
      var EqualToFrame = cc.Class({
        name: "EqualToFrame",
        extends: cc.ContainerStrategy,
        apply: function apply(view) {
          var frameH = view._frameSize.height, containerStyle = cc.game.container.style;
          this._setupContainer(view, view._frameSize.width, view._frameSize.height);
          view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px";
          containerStyle.padding = "0px";
        }
      });
      var ProportionalToFrame = cc.Class({
        name: "ProportionalToFrame",
        extends: cc.ContainerStrategy,
        apply: function apply(view, designedResolution) {
          var frameW = view._frameSize.width, frameH = view._frameSize.height, containerStyle = cc.game.container.style, designW = designedResolution.width, designH = designedResolution.height, scaleX = frameW / designW, scaleY = frameH / designH, containerW, containerH;
          scaleX < scaleY ? (containerW = frameW, containerH = designH * scaleX) : (containerW = designW * scaleY, 
          containerH = frameH);
          var offx = Math.round((frameW - containerW) / 2);
          var offy = Math.round((frameH - containerH) / 2);
          containerW = frameW - 2 * offx;
          containerH = frameH - 2 * offy;
          this._setupContainer(view, containerW, containerH);
          true;
          view._isRotated ? containerStyle.margin = "0 0 0 " + frameH + "px" : containerStyle.margin = "0px";
          containerStyle.paddingLeft = offx + "px";
          containerStyle.paddingRight = offx + "px";
          containerStyle.paddingTop = offy + "px";
          containerStyle.paddingBottom = offy + "px";
        }
      });
      var EqualToWindow = cc.Class({
        name: "EqualToWindow",
        extends: EqualToFrame,
        preApply: function preApply(view) {
          this._super(view);
          cc.game.frame = document.documentElement;
        },
        apply: function apply(view) {
          this._super(view);
          this._fixContainer();
        }
      });
      var ProportionalToWindow = cc.Class({
        name: "ProportionalToWindow",
        extends: ProportionalToFrame,
        preApply: function preApply(view) {
          this._super(view);
          cc.game.frame = document.documentElement;
        },
        apply: function apply(view, designedResolution) {
          this._super(view, designedResolution);
          this._fixContainer();
        }
      });
      var OriginalContainer = cc.Class({
        name: "OriginalContainer",
        extends: cc.ContainerStrategy,
        apply: function apply(view) {
          this._setupContainer(view, cc.game.canvas.width, cc.game.canvas.height);
        }
      });
      var _global = "undefined" === typeof window ? global : window;
      var globalAdapter = _global.__globalAdapter;
      if (globalAdapter) {
        globalAdapter.adaptContainerStrategy && globalAdapter.adaptContainerStrategy(cc.ContainerStrategy.prototype);
        globalAdapter.adaptView && globalAdapter.adaptView(View.prototype);
      }
      cc.ContainerStrategy.EQUAL_TO_FRAME = new EqualToFrame();
      cc.ContainerStrategy.PROPORTION_TO_FRAME = new ProportionalToFrame();
      cc.ContainerStrategy.ORIGINAL_CONTAINER = new OriginalContainer();
      var ExactFit = cc.Class({
        name: "ExactFit",
        extends: cc.ContentStrategy,
        apply: function apply(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, scaleX = containerW / designedResolution.width, scaleY = containerH / designedResolution.height;
          return this._buildResult(containerW, containerH, containerW, containerH, scaleX, scaleY);
        }
      });
      var ShowAll = cc.Class({
        name: "ShowAll",
        extends: cc.ContentStrategy,
        apply: function apply(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale = 0, contentW, contentH;
          scaleX < scaleY ? (scale = scaleX, contentW = containerW, contentH = designH * scale) : (scale = scaleY, 
          contentW = designW * scale, contentH = containerH);
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
      });
      var NoBorder = cc.Class({
        name: "NoBorder",
        extends: cc.ContentStrategy,
        apply: function apply(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, designH = designedResolution.height, scaleX = containerW / designW, scaleY = containerH / designH, scale, contentW, contentH;
          scaleX < scaleY ? (scale = scaleY, contentW = designW * scale, contentH = containerH) : (scale = scaleX, 
          contentW = containerW, contentH = designH * scale);
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
      });
      var FixedHeight = cc.Class({
        name: "FixedHeight",
        extends: cc.ContentStrategy,
        apply: function apply(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designH = designedResolution.height, scale = containerH / designH, contentW = containerW, contentH = containerH;
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
      });
      var FixedWidth = cc.Class({
        name: "FixedWidth",
        extends: cc.ContentStrategy,
        apply: function apply(view, designedResolution) {
          var containerW = cc.game.canvas.width, containerH = cc.game.canvas.height, designW = designedResolution.width, scale = containerW / designW, contentW = containerW, contentH = containerH;
          return this._buildResult(containerW, containerH, contentW, contentH, scale, scale);
        }
      });
      cc.ContentStrategy.EXACT_FIT = new ExactFit();
      cc.ContentStrategy.SHOW_ALL = new ShowAll();
      cc.ContentStrategy.NO_BORDER = new NoBorder();
      cc.ContentStrategy.FIXED_HEIGHT = new FixedHeight();
      cc.ContentStrategy.FIXED_WIDTH = new FixedWidth();
    })();
    cc.ResolutionPolicy = cc.Class({
      name: "cc.ResolutionPolicy",
      ctor: function ctor(containerStg, contentStg) {
        this._containerStrategy = null;
        this._contentStrategy = null;
        this.setContainerStrategy(containerStg);
        this.setContentStrategy(contentStg);
      },
      preApply: function preApply(view) {
        this._containerStrategy.preApply(view);
        this._contentStrategy.preApply(view);
      },
      apply: function apply(view, designedResolution) {
        this._containerStrategy.apply(view, designedResolution);
        return this._contentStrategy.apply(view, designedResolution);
      },
      postApply: function postApply(view) {
        this._containerStrategy.postApply(view);
        this._contentStrategy.postApply(view);
      },
      setContainerStrategy: function setContainerStrategy(containerStg) {
        containerStg instanceof cc.ContainerStrategy && (this._containerStrategy = containerStg);
      },
      setContentStrategy: function setContentStrategy(contentStg) {
        contentStg instanceof cc.ContentStrategy && (this._contentStrategy = contentStg);
      }
    });
    js.get(cc.ResolutionPolicy.prototype, "canvasSize", (function() {
      return cc.v2(cc.game.canvas.width, cc.game.canvas.height);
    }));
    cc.ResolutionPolicy.EXACT_FIT = 0;
    cc.ResolutionPolicy.NO_BORDER = 1;
    cc.ResolutionPolicy.SHOW_ALL = 2;
    cc.ResolutionPolicy.FIXED_HEIGHT = 3;
    cc.ResolutionPolicy.FIXED_WIDTH = 4;
    cc.ResolutionPolicy.UNKNOWN = 5;
    cc.view = new View();
    cc.winSize = cc.size();
    module.exports = cc.view;
  }), {
    "../event/event-target": 219,
    "../platform/CCClass": 272,
    "../platform/js": 294,
    "../renderer": 322
  } ],
  283: [ (function(require, module, exports) {
    "use strict";
    cc.visibleRect = {
      topLeft: cc.v2(0, 0),
      topRight: cc.v2(0, 0),
      top: cc.v2(0, 0),
      bottomLeft: cc.v2(0, 0),
      bottomRight: cc.v2(0, 0),
      bottom: cc.v2(0, 0),
      center: cc.v2(0, 0),
      left: cc.v2(0, 0),
      right: cc.v2(0, 0),
      width: 0,
      height: 0,
      init: function init(visibleRect) {
        var w = this.width = visibleRect.width;
        var h = this.height = visibleRect.height;
        var l = visibleRect.x, b = visibleRect.y, t = b + h, r = l + w;
        this.topLeft.x = l;
        this.topLeft.y = t;
        this.topRight.x = r;
        this.topRight.y = t;
        this.top.x = l + w / 2;
        this.top.y = t;
        this.bottomLeft.x = l;
        this.bottomLeft.y = b;
        this.bottomRight.x = r;
        this.bottomRight.y = b;
        this.bottom.x = l + w / 2;
        this.bottom.y = b;
        this.center.x = l + w / 2;
        this.center.y = b + h / 2;
        this.left.x = l;
        this.left.y = b + h / 2;
        this.right.x = r;
        this.right.y = b + h / 2;
      }
    };
  }), {} ],
  284: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    var isPlainEmptyObj = require("./utils").isPlainEmptyObj_DEV;
    var DELIMETER = "$_$";
    function createAttrsSingle(owner, superAttrs) {
      var attrs = superAttrs ? Object.create(superAttrs) : {};
      js.value(owner, "__attrs__", attrs);
      return attrs;
    }
    function createAttrs(subclass) {
      if ("function" !== typeof subclass) {
        var instance = subclass;
        return createAttrsSingle(instance, getClassAttrs(instance.constructor));
      }
      var superClass;
      var chains = cc.Class.getInheritanceChain(subclass);
      for (var i = chains.length - 1; i >= 0; i--) {
        var cls = chains[i];
        var attrs = cls.hasOwnProperty("__attrs__") && cls.__attrs__;
        if (!attrs) {
          superClass = chains[i + 1];
          createAttrsSingle(cls, superClass && superClass.__attrs__);
        }
      }
      superClass = chains[0];
      createAttrsSingle(subclass, superClass && superClass.__attrs__);
      return subclass.__attrs__;
    }
    function attr(ctor, propName, newAttrs) {
      var attrs = getClassAttrs(ctor);
      if (false, "undefined" === typeof newAttrs) {
        var prefix = propName + DELIMETER;
        var ret = {};
        for (var key in attrs) key.startsWith(prefix) && (ret[key.slice(prefix.length)] = attrs[key]);
        return ret;
      }
      if (true, "object" === typeof newAttrs) {
        cc.warn("`cc.Class.attr(obj, prop, { key: value });` is deprecated, use `cc.Class.Attr.setClassAttr(obj, prop, 'key', value);` instead please.");
        for (var _key in newAttrs) attrs[propName + DELIMETER + _key] = newAttrs[_key];
      }
    }
    function getClassAttrs(ctor) {
      return ctor.hasOwnProperty("__attrs__") && ctor.__attrs__ || createAttrs(ctor);
    }
    function setClassAttr(ctor, propName, key, value) {
      getClassAttrs(ctor)[propName + DELIMETER + key] = value;
    }
    function PrimitiveType(name, def) {
      this.name = name;
      this["default"] = def;
    }
    PrimitiveType.prototype.toString = function() {
      return this.name;
    };
    cc.Integer = new PrimitiveType("Integer", 0);
    cc.Float = new PrimitiveType("Float", 0);
    false;
    cc.Boolean = new PrimitiveType("Boolean", false);
    cc.String = new PrimitiveType("String", "");
    function getTypeChecker(type, attrName) {
      return function(constructor, mainPropName) {
        var propInfo = '"' + js.getClassName(constructor) + "." + mainPropName + '"';
        var mainPropAttrs = attr(constructor, mainPropName);
        var mainPropAttrsType = mainPropAttrs.type;
        mainPropAttrsType === cc.Integer || mainPropAttrsType === cc.Float ? mainPropAttrsType = "Number" : mainPropAttrsType !== cc.String && mainPropAttrsType !== cc.Boolean || (mainPropAttrsType = "" + mainPropAttrsType);
        if (mainPropAttrsType !== type) {
          cc.warnID(3604, propInfo);
          return;
        }
        if (!mainPropAttrs.hasOwnProperty("default")) return;
        var defaultVal = mainPropAttrs["default"];
        if ("undefined" === typeof defaultVal) return;
        var isContainer = Array.isArray(defaultVal) || isPlainEmptyObj(defaultVal);
        if (isContainer) return;
        var defaultType = typeof defaultVal;
        var type_lowerCase = type.toLowerCase();
        if (defaultType === type_lowerCase) if ("object" === type_lowerCase) {
          if (!defaultVal || defaultVal instanceof mainPropAttrs.ctor) return;
          cc.warnID(3605, propInfo, js.getClassName(mainPropAttrs.ctor));
        } else "Number" !== type && cc.warnID(3606, attrName, propInfo, type); else {
          if ("function" === defaultType) return;
          type === cc.String && null == defaultVal ? cc.warnID(3607, propInfo) : cc.warnID(3611, attrName, propInfo, defaultType);
        }
        delete mainPropAttrs.type;
      };
    }
    function getObjTypeChecker(typeCtor) {
      return function(classCtor, mainPropName) {
        getTypeChecker("Object", "type")(classCtor, mainPropName);
        var defaultDef = getClassAttrs(classCtor)[mainPropName + DELIMETER + "default"];
        var defaultVal = require("./CCClass").getDefault(defaultDef);
        if (!Array.isArray(defaultVal) && js.isChildClassOf(typeCtor, cc.ValueType)) {
          var typename = js.getClassName(typeCtor);
          var info = cc.js.formatStr('No need to specify the "type" of "%s.%s" because %s is a child class of ValueType.', js.getClassName(classCtor), mainPropName, typename);
          defaultDef ? cc.log(info) : cc.warnID(3612, info, typename, js.getClassName(classCtor), mainPropName, typename);
        }
      };
    }
    module.exports = {
      PrimitiveType: PrimitiveType,
      attr: attr,
      getClassAttrs: getClassAttrs,
      setClassAttr: setClassAttr,
      DELIMETER: DELIMETER,
      getTypeChecker_ET: (false, false) && getTypeChecker,
      getObjTypeChecker_ET: (false, false) && getObjTypeChecker,
      ScriptUuid: {}
    };
  }), {
    "./CCClass": 272,
    "./js": 294,
    "./utils": 297
  } ],
  285: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    var fastRemoveAt = js.array.fastRemoveAt;
    function empty() {}
    function CallbackInfo() {
      this.callback = empty;
      this.target = void 0;
      this.once = false;
    }
    CallbackInfo.prototype.set = function(callback, target, once) {
      this.callback = callback;
      this.target = target;
      this.once = !!once;
    };
    var callbackInfoPool = new js.Pool(function(info) {
      info.callback = empty;
      info.target = void 0;
      info.once = false;
      return true;
    }, 32);
    callbackInfoPool.get = function() {
      return this._get() || new CallbackInfo();
    };
    function CallbackList() {
      this.callbackInfos = [];
      this.isInvoking = false;
      this.containCanceled = false;
    }
    var proto = CallbackList.prototype;
    proto.removeByCallback = function(cb) {
      for (var i = 0; i < this.callbackInfos.length; ++i) {
        var info = this.callbackInfos[i];
        if (info && info.callback === cb) {
          callbackInfoPool.put(info);
          fastRemoveAt(this.callbackInfos, i);
          --i;
        }
      }
    };
    proto.removeByTarget = function(target) {
      for (var i = 0; i < this.callbackInfos.length; ++i) {
        var info = this.callbackInfos[i];
        if (info && info.target === target) {
          callbackInfoPool.put(info);
          fastRemoveAt(this.callbackInfos, i);
          --i;
        }
      }
    };
    proto.cancel = function(index) {
      var info = this.callbackInfos[index];
      if (info) {
        callbackInfoPool.put(info);
        this.callbackInfos[index] = null;
      }
      this.containCanceled = true;
    };
    proto.cancelAll = function() {
      for (var i = 0; i < this.callbackInfos.length; i++) {
        var info = this.callbackInfos[i];
        if (info) {
          callbackInfoPool.put(info);
          this.callbackInfos[i] = null;
        }
      }
      this.containCanceled = true;
    };
    proto.purgeCanceled = function() {
      for (var i = this.callbackInfos.length - 1; i >= 0; --i) {
        var info = this.callbackInfos[i];
        info || fastRemoveAt(this.callbackInfos, i);
      }
      this.containCanceled = false;
    };
    proto.clear = function() {
      this.cancelAll();
      this.callbackInfos.length = 0;
      this.isInvoking = false;
      this.containCanceled = false;
    };
    var MAX_SIZE = 16;
    var callbackListPool = new js.Pool(function(info) {
      info.callbackInfos = [];
      info.isInvoking = false;
      info.containCanceled = false;
      return true;
    }, MAX_SIZE);
    callbackListPool.get = function() {
      return this._get() || new CallbackList();
    };
    function CallbacksInvoker() {
      this._callbackTable = js.createMap(true);
    }
    proto = CallbacksInvoker.prototype;
    proto.on = function(key, callback, target, once) {
      var list = this._callbackTable[key];
      list || (list = this._callbackTable[key] = callbackListPool.get());
      var info = callbackInfoPool.get();
      info.set(callback, target, once);
      list.callbackInfos.push(info);
    };
    proto.hasEventListener = function(key, callback, target) {
      var list = this._callbackTable[key];
      if (!list) return false;
      var infos = list.callbackInfos;
      if (!callback) {
        if (list.isInvoking) {
          for (var i = 0; i < infos.length; ++i) if (infos[i]) return true;
          return false;
        }
        return infos.length > 0;
      }
      for (var _i = 0; _i < infos.length; ++_i) {
        var info = infos[_i];
        if (info && info.callback === callback && info.target === target) return true;
      }
      return false;
    };
    proto.removeAll = function(keyOrTarget) {
      if ("string" === typeof keyOrTarget) {
        var list = this._callbackTable[keyOrTarget];
        if (list) if (list.isInvoking) list.cancelAll(); else {
          list.clear();
          callbackListPool.put(list);
          delete this._callbackTable[keyOrTarget];
        }
      } else if (keyOrTarget) for (var key in this._callbackTable) {
        var _list = this._callbackTable[key];
        if (_list.isInvoking) {
          var infos = _list.callbackInfos;
          for (var i = 0; i < infos.length; ++i) {
            var info = infos[i];
            info && info.target === keyOrTarget && _list.cancel(i);
          }
        } else _list.removeByTarget(keyOrTarget);
      }
    };
    proto.off = function(key, callback, target) {
      var list = this._callbackTable[key];
      if (list) {
        var infos = list.callbackInfos;
        for (var i = 0; i < infos.length; ++i) {
          var info = infos[i];
          if (info && info.callback === callback && info.target === target) {
            if (list.isInvoking) list.cancel(i); else {
              fastRemoveAt(infos, i);
              callbackInfoPool.put(info);
            }
            break;
          }
        }
      }
    };
    proto.emit = function(key, arg1, arg2, arg3, arg4, arg5) {
      var list = this._callbackTable[key];
      if (list) {
        var rootInvoker = !list.isInvoking;
        list.isInvoking = true;
        var infos = list.callbackInfos;
        for (var i = 0, len = infos.length; i < len; ++i) {
          var info = infos[i];
          if (info) {
            var target = info.target;
            var callback = info.callback;
            info.once && this.off(key, callback, target);
            target ? callback.call(target, arg1, arg2, arg3, arg4, arg5) : callback(arg1, arg2, arg3, arg4, arg5);
          }
        }
        if (rootInvoker) {
          list.isInvoking = false;
          list.containCanceled && list.purgeCanceled();
        }
      }
    };
    false;
    module.exports = CallbacksInvoker;
  }), {
    "./js": 294
  } ],
  286: [ (function(require, module, exports) {
    "use strict";
    function deepFlatten(strList, array) {
      for (var i = 0; i < array.length; i++) {
        var item = array[i];
        Array.isArray(item) ? deepFlatten(strList, item) : strList.push(item);
      }
    }
    function flattenCodeArray(array) {
      var separator = "\n";
      var strList = [];
      deepFlatten(strList, array);
      return strList.join(separator);
    }
    module.exports = {
      flattenCodeArray: flattenCodeArray
    };
  }), {} ],
  287: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = deserialize;
    exports.getDependUuidList = getDependUuidList;
    exports.hasNativeDep = hasNativeDep;
    exports.packCustomObjData = packCustomObjData;
    exports.unpackJSONs = unpackJSONs;
    var _js = _interopRequireDefault(require("./js"));
    var _vec = _interopRequireDefault(require("../value-types/vec2"));
    var _vec2 = _interopRequireDefault(require("../value-types/vec3"));
    var _vec3 = _interopRequireDefault(require("../value-types/vec4"));
    var _color = _interopRequireDefault(require("../value-types/color"));
    var _size = _interopRequireDefault(require("../value-types/size"));
    var _rect = _interopRequireDefault(require("../value-types/rect"));
    var _quat = _interopRequireDefault(require("../value-types/quat"));
    var _mat = _interopRequireDefault(require("../value-types/mat4"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var SUPPORT_MIN_FORMAT_VERSION = 1;
    var EMPTY_PLACEHOLDER = 0;
    var BuiltinValueTypes = [ _vec["default"], _vec2["default"], _vec3["default"], _quat["default"], _color["default"], _size["default"], _rect["default"], _mat["default"] ];
    function BuiltinValueTypeParsers_xyzw(obj, data) {
      obj.x = data[1];
      obj.y = data[2];
      obj.z = data[3];
      obj.w = data[4];
    }
    var BuiltinValueTypeSetters = [ function(obj, data) {
      obj.x = data[1];
      obj.y = data[2];
    }, function(obj, data) {
      obj.x = data[1];
      obj.y = data[2];
      obj.z = data[3];
    }, BuiltinValueTypeParsers_xyzw, BuiltinValueTypeParsers_xyzw, function(obj, data) {
      obj._val = data[1];
    }, function(obj, data) {
      obj.width = data[1];
      obj.height = data[2];
    }, function(obj, data) {
      obj.x = data[1];
      obj.y = data[2];
      obj.width = data[3];
      obj.height = data[4];
    }, function(obj, data) {
      _mat["default"].fromArray(obj, data, 1);
    } ];
    function serializeBuiltinValueTypes(obj) {
      var ctor = obj.constructor;
      var typeId = BuiltinValueTypes.indexOf(ctor);
      switch (ctor) {
       case _vec["default"]:
        return [ typeId, obj.x, obj.y ];

       case _vec2["default"]:
        return [ typeId, obj.x, obj.y, obj.z ];

       case _vec3["default"]:
       case _quat["default"]:
        return [ typeId, obj.x, obj.y, obj.z, obj.w ];

       case _color["default"]:
        return [ typeId, obj._val ];

       case _size["default"]:
        return [ typeId, obj.width, obj.height ];

       case _rect["default"]:
        return [ typeId, obj.x, obj.y, obj.width, obj.height ];

       case _mat["default"]:
        var res = new Array(17);
        res[0] = typeId;
        _mat["default"].toArray(res, obj, 1);
        return res;

       default:
        return null;
      }
    }
    var DataTypeID = {
      SimpleType: 0,
      InstanceRef: 1,
      Array_InstanceRef: 2,
      Array_AssetRefByInnerObj: 3,
      Class: 4,
      ValueTypeCreated: 5,
      AssetRefByInnerObj: 6,
      TRS: 7,
      ValueType: 8,
      Array_Class: 9,
      CustomizedClass: 10,
      Dict: 11,
      Array: 12,
      ARRAY_LENGTH: 13
    };
    var CLASS_TYPE = 0;
    var CLASS_KEYS = 1;
    var CLASS_PROP_TYPE_OFFSET = 2;
    var MASK_CLASS = 0;
    var OBJ_DATA_MASK = 0;
    var CUSTOM_OBJ_DATA_CLASS = 0;
    var CUSTOM_OBJ_DATA_CONTENT = 1;
    var VALUETYPE_SETTER = 0;
    var DICT_JSON_LAYOUT = 0;
    var ARRAY_ITEM_VALUES = 0;
    var Refs = {
      EACH_RECORD_LENGTH: 3,
      OWNER_OFFSET: 0,
      KEY_OFFSET: 1,
      TARGET_OFFSET: 2
    };
    var File = {
      Version: 0,
      Context: 0,
      SharedUuids: 1,
      SharedStrings: 2,
      SharedClasses: 3,
      SharedMasks: 4,
      Instances: 5,
      InstanceTypes: 6,
      Refs: 7,
      DependObjs: 8,
      DependKeys: 9,
      DependUuidIndices: 10,
      ARRAY_LENGTH: 11
    };
    var PACKED_SECTIONS = 5;
    var Details = (function() {
      function Details() {
        this.uuidObjList = null;
        this.uuidPropList = null;
        this.uuidList = null;
      }
      var _proto = Details.prototype;
      _proto.init = function init(data) {
        this.uuidObjList = data[8];
        this.uuidPropList = data[9];
        this.uuidList = data[10];
      };
      _proto.reset = function reset() {
        this.uuidList = null;
        this.uuidObjList = null;
        this.uuidPropList = null;
      };
      _proto.push = function push(obj, propName, uuid) {
        this.uuidObjList.push(obj);
        this.uuidPropList.push(propName);
        this.uuidList.push(uuid);
      };
      return Details;
    })();
    Details.pool = new _js["default"].Pool(function(obj) {
      obj.reset();
    }, 5);
    Details.pool.get = function() {
      return this._get() || new Details();
    };
    false, false;
    function dereference(refs, instances, strings) {
      var dataLength = refs.length - 1;
      var i = 0;
      var instanceOffset = 3 * refs[dataLength];
      for (;i < instanceOffset; i += 3) {
        var _owner = refs[i];
        var target = instances[refs[i + 2]];
        var keyIndex = refs[i + 1];
        keyIndex >= 0 ? _owner[strings[keyIndex]] = target : _owner[~keyIndex] = target;
      }
      for (;i < dataLength; i += 3) {
        var _owner2 = instances[refs[i]];
        var _target = instances[refs[i + 2]];
        var _keyIndex = refs[i + 1];
        _keyIndex >= 0 ? _owner2[strings[_keyIndex]] = _target : _owner2[~_keyIndex] = _target;
      }
    }
    function deserializeCCObject(data, objectData) {
      var mask = data[4][objectData[0]];
      var clazz = mask[0];
      var ctor = clazz[0];
      var obj = new ctor();
      var keys = clazz[1];
      var classTypeOffset = clazz[2];
      var maskTypeOffset = mask[mask.length - 1];
      var i = 1;
      for (;i < maskTypeOffset; ++i) {
        var _key = keys[mask[i]];
        obj[_key] = objectData[i];
      }
      for (;i < objectData.length; ++i) {
        var _key2 = keys[mask[i]];
        var _type = clazz[mask[i] + classTypeOffset];
        var op = ASSIGNMENTS[_type];
        op(data, obj, _key2, objectData[i]);
      }
      return obj;
    }
    function deserializeCustomCCObject(data, ctor, value) {
      var obj = new ctor();
      obj._deserialize ? obj._deserialize(value, data[0]) : cc.errorID(5303, _js["default"].getClassName(ctor));
      return obj;
    }
    function assignSimple(data, owner, key, value) {
      owner[key] = value;
    }
    function assignInstanceRef(data, owner, key, value) {
      value >= 0 ? owner[key] = data[5][value] : data[7][3 * ~value] = owner;
    }
    function genArrayParser(parser) {
      return function(data, owner, key, value) {
        owner[key] = value;
        for (var i = 0; i < value.length; ++i) parser(data, value, i, value[i]);
      };
    }
    function parseAssetRefByInnerObj(data, owner, key, value) {
      owner[key] = null;
      data[8][value] = owner;
    }
    function parseClass(data, owner, key, value) {
      owner[key] = deserializeCCObject(data, value);
    }
    function parseCustomClass(data, owner, key, value) {
      var ctor = data[3][value[0]];
      owner[key] = deserializeCustomCCObject(data, ctor, value[1]);
    }
    function parseValueTypeCreated(data, owner, key, value) {
      BuiltinValueTypeSetters[value[0]](owner[key], value);
    }
    function parseValueType(data, owner, key, value) {
      var val = new BuiltinValueTypes[value[0]]();
      BuiltinValueTypeSetters[value[0]](val, value);
      owner[key] = val;
    }
    function parseTRS(data, owner, key, value) {
      var typedArray = owner[key];
      typedArray.set(value);
    }
    function parseDict(data, owner, key, value) {
      var dict = value[0];
      owner[key] = dict;
      for (var i = 1; i < value.length; i += 3) {
        var _key3 = value[i];
        var _type2 = value[i + 1];
        var subValue = value[i + 2];
        var op = ASSIGNMENTS[_type2];
        op(data, dict, _key3, subValue);
      }
    }
    function parseArray(data, owner, key, value) {
      var array = value[0];
      owner[key] = array;
      for (var i = 0; i < array.length; ++i) {
        var subValue = array[i];
        var _type3 = value[i + 1];
        if (0 !== _type3) {
          var op = ASSIGNMENTS[_type3];
          op(data, array, i, subValue);
        }
      }
    }
    var ASSIGNMENTS = new Array(13);
    ASSIGNMENTS[0] = assignSimple;
    ASSIGNMENTS[1] = assignInstanceRef;
    ASSIGNMENTS[2] = genArrayParser(assignInstanceRef);
    ASSIGNMENTS[3] = genArrayParser(parseAssetRefByInnerObj);
    ASSIGNMENTS[4] = parseClass;
    ASSIGNMENTS[5] = parseValueTypeCreated;
    ASSIGNMENTS[6] = parseAssetRefByInnerObj;
    ASSIGNMENTS[7] = parseTRS;
    ASSIGNMENTS[8] = parseValueType;
    ASSIGNMENTS[9] = genArrayParser(parseClass);
    ASSIGNMENTS[10] = parseCustomClass;
    ASSIGNMENTS[11] = parseDict;
    ASSIGNMENTS[12] = parseArray;
    function parseInstances(data) {
      var instances = data[5];
      var instanceTypes = data[6];
      var instanceTypesLen = 0 === instanceTypes ? 0 : instanceTypes.length;
      var rootIndex = instances[instances.length - 1];
      var normalObjectCount = instances.length - instanceTypesLen;
      if ("number" !== typeof rootIndex) rootIndex = 0; else {
        rootIndex < 0 && (rootIndex = ~rootIndex);
        --normalObjectCount;
      }
      var insIndex = 0;
      for (;insIndex < normalObjectCount; ++insIndex) instances[insIndex] = deserializeCCObject(data, instances[insIndex]);
      var classes = data[3];
      for (var typeIndex = 0; typeIndex < instanceTypesLen; ++typeIndex, ++insIndex) {
        var _type4 = instanceTypes[typeIndex];
        var eachData = instances[insIndex];
        if (_type4 >= 0) {
          var ctor = classes[_type4];
          instances[insIndex] = deserializeCustomCCObject(data, ctor, eachData);
        } else {
          _type4 = ~_type4;
          var op = ASSIGNMENTS[_type4];
          op(data, instances, insIndex, eachData);
        }
      }
      return rootIndex;
    }
    function getMissingClass(hasCustomFinder, type) {
      hasCustomFinder || deserialize.reportMissingClass(type);
      return Object;
    }
    function doLookupClass(classFinder, type, container, index, silent, hasCustomFinder) {
      var klass = classFinder(type);
      if (!klass) {
        if (silent) {
          container[index] = (function(container, index, type) {
            return function proxy() {
              var klass = classFinder(type) || getMissingClass(hasCustomFinder, type);
              container[index] = klass;
              return new klass();
            };
          })(container, index, type);
          return;
        }
        klass = getMissingClass(hasCustomFinder, type);
      }
      container[index] = klass;
    }
    function lookupClasses(data, silent, customFinder) {
      var classFinder = customFinder || _js["default"]._getClassById;
      var classes = data[3];
      for (var i = 0; i < classes.length; ++i) {
        var klassLayout = classes[i];
        if ("string" !== typeof klassLayout) {
          true;
          if ("function" === typeof klassLayout[0]) throw new Error("Can not deserialize the same JSON data again.");
          var _type5 = klassLayout[0];
          doLookupClass(classFinder, _type5, klassLayout, CLASS_TYPE, silent, customFinder);
        } else doLookupClass(classFinder, klassLayout, classes, i, silent, customFinder);
      }
    }
    function cacheMasks(data) {
      var masks = data[4];
      if (masks) {
        var classes = data[3];
        for (var i = 0; i < masks.length; ++i) {
          var mask = masks[i];
          mask[0] = classes[mask[0]];
        }
      }
    }
    function parseResult(data) {
      var instances = data[5];
      var sharedStrings = data[2];
      var dependSharedUuids = data[1];
      var dependObjs = data[8];
      var dependKeys = data[9];
      var dependUuids = data[10];
      for (var i = 0; i < dependObjs.length; ++i) {
        var _obj = dependObjs[i];
        "number" === typeof _obj && (dependObjs[i] = instances[_obj]);
        var _key4 = dependKeys[i];
        if ("number" === typeof _key4) {
          _key4 = _key4 >= 0 ? sharedStrings[_key4] : ~_key4;
          dependKeys[i] = _key4;
        }
        var uuid = dependUuids[i];
        "number" === typeof uuid && (dependUuids[i] = dependSharedUuids[uuid]);
      }
    }
    function deserialize(data, details, options) {
      false;
      "string" === typeof data && (data = JSON.parse(data));
      var borrowDetails = !details;
      details = details || Details.pool.get();
      details.init(data);
      options = options || {};
      var version = data[0];
      var preprocessed = false;
      if ("object" === typeof version) {
        preprocessed = version.preprocessed;
        version = version.version;
      }
      if (version < 1) throw new Error(cc.debug.getError(5304, version));
      options._version = version;
      options.result = details;
      data[0] = options;
      if (!preprocessed) {
        lookupClasses(data, false, options.classFinder);
        cacheMasks(data);
      }
      cc.game._isCloning = true;
      var instances = data[5];
      var rootIndex = parseInstances(data);
      cc.game._isCloning = false;
      data[7] && dereference(data[7], instances, data[2]);
      parseResult(data);
      borrowDetails && Details.pool.put(details);
      return instances[rootIndex];
    }
    deserialize.Details = Details;
    var FileInfo = function FileInfo(version) {
      this.preprocessed = true;
      this.version = version;
    };
    function unpackJSONs(data, classFinder) {
      if (data[0] < 1) throw new Error(cc.debug.getError(5304, data[0]));
      lookupClasses(data, true, classFinder);
      cacheMasks(data);
      var version = new FileInfo(data[0]);
      var sharedUuids = data[1];
      var sharedStrings = data[2];
      var sharedClasses = data[3];
      var sharedMasks = data[4];
      var sections = data[PACKED_SECTIONS];
      for (var i = 0; i < sections.length; ++i) sections[i].unshift(version, sharedUuids, sharedStrings, sharedClasses, sharedMasks);
      return sections;
    }
    function packCustomObjData(type, data, hasNativeDep) {
      return [ 1, EMPTY_PLACEHOLDER, EMPTY_PLACEHOLDER, [ type ], EMPTY_PLACEHOLDER, hasNativeDep ? [ data, -1 ] : [ data ], [ 0 ], EMPTY_PLACEHOLDER, [], [], [] ];
    }
    function hasNativeDep(data) {
      var instances = data[5];
      var rootInfo = instances[instances.length - 1];
      return "number" === typeof rootInfo && rootInfo < 0;
    }
    true;
    deserialize.isCompiledJson = function(json) {
      if (Array.isArray(json)) {
        var version = json[0];
        return "number" === typeof version || version instanceof FileInfo;
      }
      return false;
    };
    function getDependUuidList(json) {
      var sharedUuids = json[1];
      return json[10].map((function(index) {
        return sharedUuids[index];
      }));
    }
    false, false;
    false;
  }), {
    "../value-types/color": 400,
    "../value-types/mat4": 403,
    "../value-types/quat": 404,
    "../value-types/rect": 405,
    "../value-types/size": 406,
    "../value-types/vec2": 410,
    "../value-types/vec3": 411,
    "../value-types/vec4": 412,
    "./js": 294
  } ],
  288: [ (function(require, module, exports) {
    "use strict";
    var _deserializeCompiled = _interopRequireDefault(require("./deserialize-compiled"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var js = require("./js");
    var Attr = require("./attribute");
    var CCClass = require("./CCClass");
    var misc = require("../utils/misc");
    var Details = function Details() {
      this.uuidList = [];
      this.uuidObjList = [];
      this.uuidPropList = [];
    };
    Details.prototype.reset = function() {
      this.uuidList.length = 0;
      this.uuidObjList.length = 0;
      this.uuidPropList.length = 0;
    };
    false, false;
    Details.prototype.push = function(obj, propName, uuid) {
      this.uuidList.push(uuid);
      this.uuidObjList.push(obj);
      this.uuidPropList.push(propName);
    };
    Details.pool = new js.Pool(function(obj) {
      obj.reset();
    }, 10);
    Details.pool.get = function() {
      return this._get() || new Details();
    };
    var _Deserializer = (function() {
      function _Deserializer(result, classFinder, customEnv, ignoreEditorOnly) {
        this.result = result;
        this.customEnv = customEnv;
        this.deserializedList = [];
        this.deserializedData = null;
        this._classFinder = classFinder;
        true;
        this._ignoreEditorOnly = ignoreEditorOnly;
        this._idList = [];
        this._idObjList = [];
        this._idPropList = [];
      }
      function _dereference(self) {
        var deserializedList = self.deserializedList;
        var idPropList = self._idPropList;
        var idList = self._idList;
        var idObjList = self._idObjList;
        var onDereferenced = self._classFinder && self._classFinder.onDereferenced;
        var i, propName, id;
        false;
        for (i = 0; i < idList.length; i++) {
          propName = idPropList[i];
          id = idList[i];
          idObjList[i][propName] = deserializedList[id];
        }
      }
      var prototype = _Deserializer.prototype;
      prototype.deserialize = function(jsonObj) {
        if (Array.isArray(jsonObj)) {
          var jsonArray = jsonObj;
          var refCount = jsonArray.length;
          this.deserializedList.length = refCount;
          for (var i = 0; i < refCount; i++) if (jsonArray[i]) {
            false, false;
            this.deserializedList[i] = this._deserializeObject(jsonArray[i]);
          }
          this.deserializedData = refCount > 0 ? this.deserializedList[0] : [];
        } else {
          this.deserializedList.length = 1;
          false, false;
          this.deserializedData = jsonObj ? this._deserializeObject(jsonObj) : null;
          this.deserializedList[0] = this.deserializedData;
        }
        _dereference(this);
        return this.deserializedData;
      };
      prototype._deserializeObject = function(serialized, owner, propName) {
        var prop;
        var obj = null;
        var klass = null;
        var type = serialized.__type__;
        if ("TypedArray" === type) {
          var array = serialized.array;
          obj = new window[serialized.ctor](array.length);
          for (var i = 0; i < array.length; ++i) obj[i] = array[i];
          return obj;
        }
        if (type) {
          klass = this._classFinder(type, serialized, owner, propName);
          if (!klass) {
            var notReported = this._classFinder === js._getClassById;
            notReported && deserialize.reportMissingClass(type);
            return null;
          }
          obj = new klass();
          if (obj._deserialize) {
            obj._deserialize(serialized.content, this);
            return obj;
          }
          cc.Class._isCCClass(klass) ? _deserializeFireClass(this, obj, serialized, klass) : this._deserializeTypedObject(obj, serialized, klass);
        } else if (Array.isArray(serialized)) {
          obj = new Array(serialized.length);
          for (var _i = 0; _i < serialized.length; _i++) {
            prop = serialized[_i];
            if ("object" === typeof prop && prop) {
              var isAssetType = this._deserializeObjField(obj, prop, "" + _i);
              isAssetType && (obj[_i] = null);
            } else obj[_i] = prop;
          }
        } else {
          obj = {};
          this._deserializePrimitiveObject(obj, serialized);
        }
        return obj;
      };
      prototype._deserializeObjField = function(obj, jsonObj, propName) {
        var id = jsonObj.__id__;
        if (void 0 === id) {
          var uuid = jsonObj.__uuid__;
          if (uuid) {
            this.result.push(obj, propName, uuid);
            return true;
          }
          false, false;
          obj[propName] = this._deserializeObject(jsonObj);
        } else {
          var dObj = this.deserializedList[id];
          if (dObj) obj[propName] = dObj; else {
            this._idList.push(id);
            this._idObjList.push(obj);
            this._idPropList.push(propName);
          }
        }
      };
      prototype._deserializePrimitiveObject = function(instance, serialized) {
        for (var propName in serialized) if (serialized.hasOwnProperty(propName)) {
          var prop = serialized[propName];
          if ("object" !== typeof prop) "__type__" !== propName && (instance[propName] = prop); else if (prop) {
            var isAssetType = this._deserializeObjField(instance, prop, propName);
            isAssetType && (instance[propName] = null);
          } else instance[propName] = null;
        }
      };
      prototype._deserializeTypedObject = function(instance, serialized, klass) {
        if (klass === cc.Vec2) {
          instance.x = serialized.x || 0;
          instance.y = serialized.y || 0;
          return;
        }
        if (klass === cc.Vec3) {
          instance.x = serialized.x || 0;
          instance.y = serialized.y || 0;
          instance.z = serialized.z || 0;
          return;
        }
        if (klass === cc.Color) {
          instance.r = serialized.r || 0;
          instance.g = serialized.g || 0;
          instance.b = serialized.b || 0;
          var a = serialized.a;
          instance.a = void 0 === a ? 255 : a;
          return;
        }
        if (klass === cc.Size) {
          instance.width = serialized.width || 0;
          instance.height = serialized.height || 0;
          return;
        }
        var DEFAULT = Attr.DELIMETER + "default";
        var attrs = Attr.getClassAttrs(klass);
        var fastDefinedProps = klass.__props__ || Object.keys(instance);
        for (var i = 0; i < fastDefinedProps.length; i++) {
          var propName = fastDefinedProps[i];
          var value = serialized[propName];
          void 0 !== value && serialized.hasOwnProperty(propName) || (value = CCClass.getDefault(attrs[propName + DEFAULT]));
          "object" !== typeof value ? instance[propName] = value : value ? this._deserializeObjField(instance, value, propName) : instance[propName] = null;
        }
      };
      function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue) {
        if (defaultValue instanceof cc.ValueType) {
          assumeHavePropIfIsValue || sources.push("if(prop){");
          var ctorCode = js.getClassName(defaultValue);
          sources.push("s._deserializeTypedObject(o" + accessorToSet + ",prop," + ctorCode + ");");
          assumeHavePropIfIsValue || sources.push("}else o" + accessorToSet + "=null;");
        } else {
          sources.push("if(prop){");
          sources.push("s._deserializeObjField(o,prop," + propNameLiteralToSet + ");");
          sources.push("}else o" + accessorToSet + "=null;");
        }
      }
      var compileDeserialize = function(self, klass) {
        var TYPE = Attr.DELIMETER + "type";
        var EDITOR_ONLY = Attr.DELIMETER + "editorOnly";
        var DEFAULT = Attr.DELIMETER + "default";
        var FORMERLY_SERIALIZED_AS = Attr.DELIMETER + "formerlySerializedAs";
        var attrs = Attr.getClassAttrs(klass);
        var props = klass.__values__;
        var sources = [ "var prop;" ];
        var fastMode = misc.BUILTIN_CLASSID_RE.test(js._getClassId(klass));
        for (var p = 0; p < props.length; p++) {
          var propName = props[p];
          if (true, attrs[propName + EDITOR_ONLY]) continue;
          var accessorToSet, propNameLiteralToSet;
          if (CCClass.IDENTIFIER_RE.test(propName)) {
            propNameLiteralToSet = '"' + propName + '"';
            accessorToSet = "." + propName;
          } else {
            propNameLiteralToSet = CCClass.escapeForJS(propName);
            accessorToSet = "[" + propNameLiteralToSet + "]";
          }
          var accessorToGet = accessorToSet;
          if (attrs[propName + FORMERLY_SERIALIZED_AS]) {
            var propNameToRead = attrs[propName + FORMERLY_SERIALIZED_AS];
            accessorToGet = CCClass.IDENTIFIER_RE.test(propNameToRead) ? "." + propNameToRead : "[" + CCClass.escapeForJS(propNameToRead) + "]";
          }
          sources.push("prop=d" + accessorToGet + ";");
          sources.push('if(typeof (prop)!=="undefined"){');
          var defaultValue = CCClass.getDefault(attrs[propName + DEFAULT]);
          if (fastMode) {
            var isPrimitiveType;
            var userType = attrs[propName + TYPE];
            if (void 0 === defaultValue && userType) isPrimitiveType = userType instanceof Attr.PrimitiveType; else {
              var defaultType = typeof defaultValue;
              isPrimitiveType = "string" === defaultType || "number" === defaultType || "boolean" === defaultType;
            }
            isPrimitiveType ? sources.push("o" + accessorToSet + "=prop;") : compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, true);
          } else {
            sources.push('if(typeof (prop)!=="object"){o' + accessorToSet + "=prop;}else{");
            compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, false);
            sources.push("}");
          }
          sources.push("}");
        }
        if (cc.js.isChildClassOf(klass, cc._BaseNode) || cc.js.isChildClassOf(klass, cc.Component)) {
          true;
          var mayUsedInPersistRoot = js.isChildClassOf(klass, cc.Node);
          mayUsedInPersistRoot && sources.push("d._id&&(o._id=d._id);");
        }
        if ("_$erialized" === props[props.length - 1]) {
          sources.push("o._$erialized=JSON.parse(JSON.stringify(d));");
          sources.push("s._deserializePrimitiveObject(o._$erialized,d);");
        }
        return Function("s", "o", "d", "k", sources.join(""));
      };
      function unlinkUnusedPrefab(self, serialized, obj) {
        var uuid = serialized["asset"] && serialized["asset"].__uuid__;
        if (uuid) {
          var last = self.result.uuidList.length - 1;
          if (self.result.uuidList[last] === uuid && self.result.uuidObjList[last] === obj && "asset" === self.result.uuidPropList[last]) {
            self.result.uuidList.pop();
            self.result.uuidObjList.pop();
            self.result.uuidPropList.pop();
          } else {
            var debugEnvOnlyInfo = "Failed to skip prefab asset while deserializing PrefabInfo";
            cc.warn(debugEnvOnlyInfo);
          }
        }
      }
      function _deserializeFireClass(self, obj, serialized, klass) {
        var deserialize;
        if (klass.hasOwnProperty("__deserialize__")) deserialize = klass.__deserialize__; else {
          deserialize = compileDeserialize(self, klass);
          js.value(klass, "__deserialize__", deserialize, true);
        }
        deserialize(self, obj, serialized, klass);
        true;
        klass !== cc._PrefabInfo || obj.sync || unlinkUnusedPrefab(self, serialized, obj);
      }
      _Deserializer.pool = new js.Pool(function(obj) {
        obj.result = null;
        obj.customEnv = null;
        obj.deserializedList.length = 0;
        obj.deserializedData = null;
        obj._classFinder = null;
        obj._idList.length = 0;
        obj._idObjList.length = 0;
        obj._idPropList.length = 0;
      }, 1);
      _Deserializer.pool.get = function(result, classFinder, customEnv, ignoreEditorOnly) {
        var cache = this._get();
        if (cache) {
          cache.result = result;
          cache.customEnv = customEnv;
          cache._classFinder = classFinder;
          true;
          cache._ignoreEditorOnly = ignoreEditorOnly;
          return cache;
        }
        return new _Deserializer(result, classFinder, customEnv, ignoreEditorOnly);
      };
      return _Deserializer;
    })();
    var deserialize = module.exports = function(data, details, options) {
      options = options || {};
      var classFinder = options.classFinder || js._getClassById;
      var createAssetRefs = options.createAssetRefs || cc.sys.platform === cc.sys.EDITOR_CORE;
      var customEnv = options.customEnv;
      var ignoreEditorOnly = options.ignoreEditorOnly;
      var tempDetails = !details;
      details = details || Details.pool.get();
      var deserializer = _Deserializer.pool.get(details, classFinder, customEnv, ignoreEditorOnly);
      cc.game._isCloning = true;
      var res = deserializer.deserialize(data);
      cc.game._isCloning = false;
      _Deserializer.pool.put(deserializer);
      createAssetRefs && details.assignAssetsBy(Editor.serialize.asAsset);
      tempDetails && Details.pool.put(details);
      return res;
    };
    deserialize.Details = Details;
  }), {
    "../utils/misc": 386,
    "./CCClass": 272,
    "./attribute": 284,
    "./deserialize-compiled": 287,
    "./js": 294
  } ],
  289: [ (function(require, module, exports) {
    "use strict";
    var _deserializeCompiled = _interopRequireDefault(require("./deserialize-compiled"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    _deserializeCompiled["default"].reportMissingClass = function(id) {
      false;
      cc.warnID(5302, id);
    };
    false;
    var deserializeForEditor = require("./deserialize-editor");
    cc.deserialize = function(data, details, options) {
      false;
      "string" === typeof data && (data = JSON.parse(data));
      true;
      if (_deserializeCompiled["default"].isCompiledJson(data)) return (0, _deserializeCompiled["default"])(data, details, options);
      return deserializeForEditor(data, details, options);
    };
    cc.deserialize.reportMissingClass = _deserializeCompiled["default"].reportMissingClass;
    cc.deserialize.Details = deserializeForEditor.Details;
  }), {
    "./deserialize-compiled": 287,
    "./deserialize-editor": 288
  } ],
  290: [ (function(require, module, exports) {
    "use strict";
    var NonUuidMark = ".";
    function IdGenerater(category) {
      this.id = 0 | 998 * Math.random();
      this.prefix = category ? category + NonUuidMark : "";
    }
    IdGenerater.prototype.getNewId = function() {
      return this.prefix + ++this.id;
    };
    IdGenerater.global = new IdGenerater("global");
    module.exports = IdGenerater;
  }), {} ],
  291: [ (function(require, module, exports) {
    "use strict";
    require("./js");
    require("./CCClass");
    require("./CCClassDecorator");
    require("./CCEnum");
    require("./CCObject");
    require("./callbacks-invoker");
    require("./deserialize");
    require("./instantiate");
    require("./instantiate-jit");
    require("./requiring-frame");
    require("./CCSys");
    require("./CCMacro");
    true;
    require("./CCVisibleRect");
  }), {
    "./CCClass": 272,
    "./CCClassDecorator": 273,
    "./CCEnum": 274,
    "./CCMacro": 277,
    "./CCObject": 278,
    "./CCSys": 281,
    "./CCVisibleRect": 283,
    "./callbacks-invoker": 285,
    "./deserialize": 289,
    "./instantiate": 293,
    "./instantiate-jit": 292,
    "./js": 294,
    "./requiring-frame": 296
  } ],
  292: [ (function(require, module, exports) {
    "use strict";
    var CCObject = require("./CCObject");
    var Destroyed = CCObject.Flags.Destroyed;
    var PersistentMask = CCObject.Flags.PersistentMask;
    var Attr = require("./attribute");
    var js = require("./js");
    var CCClass = require("./CCClass");
    var Compiler = require("./compiler");
    var DEFAULT = Attr.DELIMETER + "default";
    var IDENTIFIER_RE = CCClass.IDENTIFIER_RE;
    var escapeForJS = CCClass.escapeForJS;
    var VAR = "var ";
    var LOCAL_OBJ = "o";
    var LOCAL_TEMP_OBJ = "t";
    var LOCAL_ARRAY = "a";
    var LINE_INDEX_OF_NEW_OBJ = 0;
    var DEFAULT_MODULE_CACHE = {
      "cc.Node": "cc.Node",
      "cc.Sprite": "cc.Sprite",
      "cc.Label": "cc.Label",
      "cc.Button": "cc.Button",
      "cc.Widget": "cc.Widget",
      "cc.Animation": "cc.Animation",
      "cc.ClickEvent": false,
      "cc.PrefabInfo": false
    };
    try {
      !Float32Array.name && (Float32Array.name = "Float32Array");
      !Float64Array.name && (Float64Array.name = "Float64Array");
      !Int8Array.name && (Int8Array.name = "Int8Array");
      !Int16Array.name && (Int16Array.name = "Int16Array");
      !Int32Array.name && (Int32Array.name = "Int32Array");
      !Uint8Array.name && (Uint8Array.name = "Uint8Array");
      !Uint16Array.name && (Uint16Array.name = "Uint16Array");
      !Uint32Array.name && (Uint32Array.name = "Uint32Array");
      !Uint8ClampedArray.name && (Uint8ClampedArray.name = "Uint8ClampedArray");
    } catch (e) {}
    function getTypedArrayName(constructor) {
      if (constructor === Float32Array) return "Float32Array";
      if (constructor === Float64Array) return "Float64Array";
      if (constructor === Int8Array) return "Int8Array";
      if (constructor === Int16Array) return "Int16Array";
      if (constructor === Int32Array) return "Int32Array";
      if (constructor === Uint8Array) return "Uint8Array";
      if (constructor === Uint16Array) return "Uint16Array";
      if (constructor === Uint32Array) return "Uint32Array";
      if (constructor === Uint8ClampedArray) return "Uint8ClampedArray";
      throw new Error("Unknown TypedArray to instantiate: " + constructor);
    }
    function Declaration(varName, expression) {
      this.varName = varName;
      this.expression = expression;
    }
    Declaration.prototype.toString = function() {
      return VAR + this.varName + "=" + this.expression + ";";
    };
    function mergeDeclaration(statement, expression) {
      return expression instanceof Declaration ? new Declaration(expression.varName, statement + expression.expression) : statement + expression;
    }
    function writeAssignment(codeArray, statement, expression) {
      if (Array.isArray(expression)) {
        expression[0] = mergeDeclaration(statement, expression[0]);
        codeArray.push(expression);
      } else codeArray.push(mergeDeclaration(statement, expression) + ";");
    }
    function Assignments(targetExpression) {
      this._exps = [];
      this._targetExp = targetExpression;
    }
    Assignments.prototype.append = function(key, expression) {
      this._exps.push([ key, expression ]);
    };
    Assignments.prototype.writeCode = function(codeArray) {
      var targetVar;
      if (this._exps.length > 1) {
        codeArray.push(LOCAL_TEMP_OBJ + "=" + this._targetExp + ";");
        targetVar = LOCAL_TEMP_OBJ;
      } else {
        if (1 !== this._exps.length) return;
        targetVar = this._targetExp;
      }
      for (var i = 0; i < this._exps.length; i++) {
        var pair = this._exps[i];
        writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + "=", pair[1]);
      }
    };
    Assignments.pool = new js.Pool(function(obj) {
      obj._exps.length = 0;
      obj._targetExp = null;
    }, 1);
    Assignments.pool.get = function(targetExpression) {
      var cache = this._get() || new Assignments();
      cache._targetExp = targetExpression;
      return cache;
    };
    function equalsToDefault(def, value) {
      if ("function" === typeof def) try {
        def = def();
      } catch (e) {
        return false;
      }
      if (def === value) return true;
      if (def && value && "object" === typeof def && "object" === typeof value && def.constructor === value.constructor) if (def instanceof cc.ValueType) {
        if (def.equals(value)) return true;
      } else {
        if (Array.isArray(def)) return 0 === def.length && 0 === value.length;
        if (def.constructor === Object) return js.isEmptyObject(def) && js.isEmptyObject(value);
      }
      return false;
    }
    function getPropAccessor(key) {
      return IDENTIFIER_RE.test(key) ? "." + key : "[" + escapeForJS(key) + "]";
    }
    function Parser(obj, parent) {
      this.parent = parent;
      this.objsToClear_iN$t = [];
      this.codeArray = [];
      this.objs = [];
      this.funcs = [];
      this.funcModuleCache = js.createMap();
      js.mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE);
      this.globalVariables = [];
      this.globalVariableId = 0;
      this.localVariableId = 0;
      this.codeArray.push(VAR + LOCAL_OBJ + "," + LOCAL_TEMP_OBJ + ";", "if(R){", LOCAL_OBJ + "=R;", "}else{", LOCAL_OBJ + "=R=new " + this.getFuncModule(obj.constructor, true) + "();", "}");
      js.value(obj, "_iN$t", {
        globalVar: "R"
      }, true);
      this.objsToClear_iN$t.push(obj);
      this.enumerateObject(this.codeArray, obj);
      var globalVariablesDeclaration;
      this.globalVariables.length > 0 && (globalVariablesDeclaration = VAR + this.globalVariables.join(",") + ";");
      var code = Compiler.flattenCodeArray([ "return (function(R){", globalVariablesDeclaration || [], this.codeArray, "return o;", "})" ]);
      this.result = Function("O", "F", code)(this.objs, this.funcs);
      for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) this.objsToClear_iN$t[i]._iN$t = null;
      this.objsToClear_iN$t.length = 0;
    }
    var proto = Parser.prototype;
    proto.getFuncModule = function(func, usedInNew) {
      var clsName = js.getClassName(func);
      if (clsName) {
        var cache = this.funcModuleCache[clsName];
        if (cache) return cache;
        if (void 0 === cache) {
          var clsNameIsModule = -1 !== clsName.indexOf(".");
          if (clsNameIsModule) try {
            clsNameIsModule = func === Function("return " + clsName)();
            if (clsNameIsModule) {
              this.funcModuleCache[clsName] = clsName;
              return clsName;
            }
          } catch (e) {}
        }
      }
      var index = this.funcs.indexOf(func);
      if (index < 0) {
        index = this.funcs.length;
        this.funcs.push(func);
      }
      var res = "F[" + index + "]";
      usedInNew && (res = "(" + res + ")");
      this.funcModuleCache[clsName] = res;
      return res;
    };
    proto.getObjRef = function(obj) {
      var index = this.objs.indexOf(obj);
      if (index < 0) {
        index = this.objs.length;
        this.objs.push(obj);
      }
      return "O[" + index + "]";
    };
    proto.setValueType = function(codeArray, defaultValue, srcValue, targetExpression) {
      var assignments = Assignments.pool.get(targetExpression);
      var fastDefinedProps = defaultValue.constructor.__props__;
      fastDefinedProps || (fastDefinedProps = Object.keys(defaultValue));
      for (var i = 0; i < fastDefinedProps.length; i++) {
        var propName = fastDefinedProps[i];
        var prop = srcValue[propName];
        if (defaultValue[propName] === prop) continue;
        var expression = this.enumerateField(srcValue, propName, prop);
        assignments.append(propName, expression);
      }
      assignments.writeCode(codeArray);
      Assignments.pool.put(assignments);
    };
    proto.enumerateCCClass = function(codeArray, obj, klass) {
      var props = klass.__values__;
      var attrs = Attr.getClassAttrs(klass);
      for (var p = 0; p < props.length; p++) {
        var key = props[p];
        var val = obj[key];
        var defaultValue = attrs[key + DEFAULT];
        if (equalsToDefault(defaultValue, val)) continue;
        if ("object" === typeof val && val instanceof cc.ValueType) {
          defaultValue = CCClass.getDefault(defaultValue);
          if (defaultValue && defaultValue.constructor === val.constructor) {
            var targetExpression = LOCAL_OBJ + getPropAccessor(key);
            this.setValueType(codeArray, defaultValue, val, targetExpression);
            continue;
          }
        }
        this.setObjProp(codeArray, obj, key, val);
      }
    };
    proto.instantiateArray = function(value) {
      if (0 === value.length) return "[]";
      var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
      var declaration = new Declaration(arrayVar, "new Array(" + value.length + ")");
      var codeArray = [ declaration ];
      js.value(value, "_iN$t", {
        globalVar: "",
        source: codeArray
      }, true);
      this.objsToClear_iN$t.push(value);
      for (var i = 0; i < value.length; ++i) {
        var statement = arrayVar + "[" + i + "]=";
        var expression = this.enumerateField(value, i, value[i]);
        writeAssignment(codeArray, statement, expression);
      }
      return codeArray;
    };
    proto.instantiateTypedArray = function(value) {
      var type = value.constructor.name || getTypedArrayName(value.constructor);
      if (0 === value.length) return "new " + type;
      var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
      var declaration = new Declaration(arrayVar, "new " + type + "(" + value.length + ")");
      var codeArray = [ declaration ];
      value._iN$t = {
        globalVar: "",
        source: codeArray
      };
      this.objsToClear_iN$t.push(value);
      for (var i = 0; i < value.length; ++i) if (0 !== value[i]) {
        var statement = arrayVar + "[" + i + "]=";
        writeAssignment(codeArray, statement, value[i]);
      }
      return codeArray;
    };
    proto.enumerateField = function(obj, key, value) {
      if ("object" === typeof value && value) {
        var _iN$t = value._iN$t;
        if (_iN$t) {
          var globalVar = _iN$t.globalVar;
          if (!globalVar) {
            globalVar = _iN$t.globalVar = "v" + ++this.globalVariableId;
            this.globalVariables.push(globalVar);
            var line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
            _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(globalVar + "=", line);
          }
          return globalVar;
        }
        return ArrayBuffer.isView(value) ? this.instantiateTypedArray(value) : Array.isArray(value) ? this.instantiateArray(value) : this.instantiateObj(value);
      }
      if ("function" === typeof value) return this.getFuncModule(value);
      if ("string" === typeof value) return escapeForJS(value);
      "_objFlags" === key && obj instanceof CCObject && (value &= PersistentMask);
      return value;
    };
    proto.setObjProp = function(codeArray, obj, key, value) {
      var statement = LOCAL_OBJ + getPropAccessor(key) + "=";
      var expression = this.enumerateField(obj, key, value);
      writeAssignment(codeArray, statement, expression);
    };
    proto.enumerateObject = function(codeArray, obj) {
      var klass = obj.constructor;
      if (cc.Class._isCCClass(klass)) this.enumerateCCClass(codeArray, obj, klass); else for (var key in obj) {
        if (!obj.hasOwnProperty(key) || 95 === key.charCodeAt(0) && 95 === key.charCodeAt(1) && "__type__" !== key) continue;
        var value = obj[key];
        if ("object" === typeof value && value && value === obj._iN$t) continue;
        this.setObjProp(codeArray, obj, key, value);
      }
    };
    proto.instantiateObj = function(obj) {
      if (obj instanceof cc.ValueType) return CCClass.getNewValueTypeCode(obj);
      if (obj instanceof cc.Asset) return this.getObjRef(obj);
      if (obj._objFlags & Destroyed) return null;
      var createCode;
      var ctor = obj.constructor;
      if (cc.Class._isCCClass(ctor)) {
        if (this.parent) if (this.parent instanceof cc.Component) {
          if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return this.getObjRef(obj);
        } else if (this.parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
          if (!obj.isChildOf(this.parent)) return this.getObjRef(obj);
        } else if (obj instanceof cc.Component) {
          var _obj$node;
          if (!(null != (_obj$node = obj.node) && _obj$node.isChildOf(this.parent))) return this.getObjRef(obj);
        }
        createCode = new Declaration(LOCAL_OBJ, "new " + this.getFuncModule(ctor, true) + "()");
      } else if (ctor === Object) createCode = new Declaration(LOCAL_OBJ, "{}"); else {
        if (ctor) return this.getObjRef(obj);
        createCode = new Declaration(LOCAL_OBJ, "Object.create(null)");
      }
      var codeArray = [ createCode ];
      js.value(obj, "_iN$t", {
        globalVar: "",
        source: codeArray
      }, true);
      this.objsToClear_iN$t.push(obj);
      this.enumerateObject(codeArray, obj);
      return [ "(function(){", codeArray, "return o;})();" ];
    };
    function compile(node) {
      var root = node instanceof cc._BaseNode && node;
      var parser = new Parser(node, root);
      return parser.result;
    }
    module.exports = {
      compile: compile,
      equalsToDefault: equalsToDefault
    };
    false;
  }), {
    "./CCClass": 272,
    "./CCObject": 278,
    "./attribute": 284,
    "./compiler": 286,
    "./js": 294
  } ],
  293: [ (function(require, module, exports) {
    "use strict";
    var CCObject = require("./CCObject");
    var CCValueType = require("../value-types/value-type");
    var Destroyed = CCObject.Flags.Destroyed;
    var PersistentMask = CCObject.Flags.PersistentMask;
    var _isDomNode = require("./utils").isDomNode;
    var js = require("./js");
    function instantiate(original, internal_force) {
      if (!internal_force) {
        if ("object" !== typeof original || Array.isArray(original)) {
          true;
          cc.errorID(6900);
          return null;
        }
        if (!original) {
          true;
          cc.errorID(6901);
          return null;
        }
        if (!cc.isValid(original)) {
          true;
          cc.errorID(6902);
          return null;
        }
        (true, original instanceof cc.Component) && cc.warn("Should not instantiate a single cc.Component directly, you must instantiate the entire node.");
      }
      var clone;
      if (original instanceof CCObject) {
        if (original._instantiate) {
          cc.game._isCloning = true;
          clone = original._instantiate(null, true);
          cc.game._isCloning = false;
          return clone;
        }
        if (original instanceof cc.Asset) {
          true;
          cc.errorID(6903);
          return null;
        }
      }
      cc.game._isCloning = true;
      clone = doInstantiate(original);
      cc.game._isCloning = false;
      return clone;
    }
    var objsToClearTmpVar = [];
    function doInstantiate(obj, parent) {
      if (Array.isArray(obj)) {
        true;
        cc.errorID(6904);
        return null;
      }
      if (_isDomNode && _isDomNode(obj)) {
        true;
        cc.errorID(6905);
        return null;
      }
      var clone;
      if (obj._iN$t) clone = obj._iN$t; else if (obj.constructor) {
        var klass = obj.constructor;
        clone = new klass();
      } else clone = Object.create(null);
      enumerateObject(obj, clone, parent);
      for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) objsToClearTmpVar[i]._iN$t = null;
      objsToClearTmpVar.length = 0;
      return clone;
    }
    function enumerateCCClass(klass, obj, clone, parent) {
      var props = klass.__values__;
      for (var p = 0; p < props.length; p++) {
        var key = props[p];
        var value = obj[key];
        if ("object" === typeof value && value) {
          var initValue = clone[key];
          initValue instanceof CCValueType && initValue.constructor === value.constructor ? initValue.set(value) : clone[key] = value._iN$t || instantiateObj(value, parent);
        } else clone[key] = value;
      }
    }
    function enumerateObject(obj, clone, parent) {
      js.value(obj, "_iN$t", clone, true);
      objsToClearTmpVar.push(obj);
      var klass = obj.constructor;
      if (cc.Class._isCCClass(klass)) enumerateCCClass(klass, obj, clone, parent); else for (var key in obj) {
        if (!obj.hasOwnProperty(key) || 95 === key.charCodeAt(0) && 95 === key.charCodeAt(1) && "__type__" !== key) continue;
        var value = obj[key];
        if ("object" === typeof value && value) {
          if (value === clone) continue;
          clone[key] = value._iN$t || instantiateObj(value, parent);
        } else clone[key] = value;
      }
      obj instanceof CCObject && (clone._objFlags &= PersistentMask);
    }
    function instantiateObj(obj, parent) {
      if (obj instanceof CCValueType) return obj.clone();
      if (obj instanceof cc.Asset) return obj;
      var clone;
      if (ArrayBuffer.isView(obj)) {
        var len = obj.length;
        clone = new obj.constructor(len);
        obj._iN$t = clone;
        objsToClearTmpVar.push(obj);
        for (var i = 0; i < len; ++i) clone[i] = obj[i];
        return clone;
      }
      if (Array.isArray(obj)) {
        var _len = obj.length;
        clone = new Array(_len);
        js.value(obj, "_iN$t", clone, true);
        objsToClearTmpVar.push(obj);
        for (var _i = 0; _i < _len; ++_i) {
          var value = obj[_i];
          clone[_i] = "object" === typeof value && value ? value._iN$t || instantiateObj(value, parent) : value;
        }
        return clone;
      }
      if (obj._objFlags & Destroyed) return null;
      var ctor = obj.constructor;
      if (cc.Class._isCCClass(ctor)) {
        if (parent) if (parent instanceof cc.Component) {
          if (obj instanceof cc._BaseNode || obj instanceof cc.Component) return obj;
        } else if (parent instanceof cc._BaseNode) if (obj instanceof cc._BaseNode) {
          if (!obj.isChildOf(parent)) return obj;
        } else if (obj instanceof cc.Component) {
          var _obj$node;
          if (!(null != (_obj$node = obj.node) && _obj$node.isChildOf(parent))) return obj;
        }
        clone = new ctor();
      } else if (ctor === Object) clone = {}; else {
        if (ctor) return obj;
        clone = Object.create(null);
      }
      enumerateObject(obj, clone, parent);
      return clone;
    }
    instantiate._clone = doInstantiate;
    cc.instantiate = instantiate;
    module.exports = instantiate;
  }), {
    "../value-types/value-type": 409,
    "./CCObject": 278,
    "./js": 294,
    "./utils": 297
  } ],
  294: [ (function(require, module, exports) {
    "use strict";
    var tempCIDGenerater = new (require("./id-generater"))("TmpCId.");
    function _getPropertyDescriptor(obj, name) {
      while (obj) {
        var pd = Object.getOwnPropertyDescriptor(obj, name);
        if (pd) return pd;
        obj = Object.getPrototypeOf(obj);
      }
      return null;
    }
    function _copyprop(name, source, target) {
      var pd = _getPropertyDescriptor(source, name);
      Object.defineProperty(target, name, pd);
    }
    var js = {
      isNumber: function isNumber(obj) {
        return "number" === typeof obj || obj instanceof Number;
      },
      isString: function isString(obj) {
        return "string" === typeof obj || obj instanceof String;
      },
      addon: function addon(obj) {
        obj = obj || {};
        for (var i = 1, length = arguments.length; i < length; i++) {
          var source = arguments[i];
          if (source) {
            if ("object" !== typeof source) {
              cc.errorID(5402, source);
              continue;
            }
            for (var name in source) name in obj || _copyprop(name, source, obj);
          }
        }
        return obj;
      },
      mixin: function mixin(obj) {
        obj = obj || {};
        for (var i = 1, length = arguments.length; i < length; i++) {
          var source = arguments[i];
          if (source) {
            if ("object" !== typeof source) {
              cc.errorID(5403, source);
              continue;
            }
            for (var name in source) _copyprop(name, source, obj);
          }
        }
        return obj;
      },
      extend: function extend(cls, base) {
        true;
        if (!base) {
          cc.errorID(5404);
          return;
        }
        if (!cls) {
          cc.errorID(5405);
          return;
        }
        Object.keys(cls.prototype).length > 0 && cc.errorID(5406);
        for (var p in base) base.hasOwnProperty(p) && (cls[p] = base[p]);
        cls.prototype = Object.create(base.prototype, {
          constructor: {
            value: cls,
            writable: true,
            configurable: true
          }
        });
        return cls;
      },
      getSuper: function getSuper(ctor) {
        var proto = ctor.prototype;
        var dunderProto = proto && Object.getPrototypeOf(proto);
        return dunderProto && dunderProto.constructor;
      },
      isChildClassOf: function isChildClassOf(subclass, superclass) {
        if (subclass && superclass) {
          if ("function" !== typeof subclass) return false;
          if ("function" !== typeof superclass) {
            true;
            cc.warnID(3625, superclass);
            return false;
          }
          if (subclass === superclass) return true;
          for (;;) {
            subclass = js.getSuper(subclass);
            if (!subclass) return false;
            if (subclass === superclass) return true;
          }
        }
        return false;
      },
      clear: function clear(obj) {
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) delete obj[keys[i]];
      },
      isEmptyObject: function isEmptyObject(obj) {
        for (var key in obj) return false;
        return true;
      },
      getPropertyDescriptor: _getPropertyDescriptor
    };
    var tmpValueDesc = {
      value: void 0,
      enumerable: false,
      writable: false,
      configurable: true
    };
    js.value = function(obj, prop, value, writable, enumerable) {
      tmpValueDesc.value = value;
      tmpValueDesc.writable = writable;
      tmpValueDesc.enumerable = enumerable;
      Object.defineProperty(obj, prop, tmpValueDesc);
      tmpValueDesc.value = void 0;
    };
    var tmpGetSetDesc = {
      get: null,
      set: null,
      enumerable: false
    };
    js.getset = function(obj, prop, getter, setter, enumerable, configurable) {
      if ("function" !== typeof setter) {
        enumerable = setter;
        setter = void 0;
      }
      tmpGetSetDesc.get = getter;
      tmpGetSetDesc.set = setter;
      tmpGetSetDesc.enumerable = enumerable;
      tmpGetSetDesc.configurable = configurable;
      Object.defineProperty(obj, prop, tmpGetSetDesc);
      tmpGetSetDesc.get = null;
      tmpGetSetDesc.set = null;
    };
    var tmpGetDesc = {
      get: null,
      enumerable: false,
      configurable: false
    };
    js.get = function(obj, prop, getter, enumerable, configurable) {
      tmpGetDesc.get = getter;
      tmpGetDesc.enumerable = enumerable;
      tmpGetDesc.configurable = configurable;
      Object.defineProperty(obj, prop, tmpGetDesc);
      tmpGetDesc.get = null;
    };
    var tmpSetDesc = {
      set: null,
      enumerable: false,
      configurable: false
    };
    js.set = function(obj, prop, setter, enumerable, configurable) {
      tmpSetDesc.set = setter;
      tmpSetDesc.enumerable = enumerable;
      tmpSetDesc.configurable = configurable;
      Object.defineProperty(obj, prop, tmpSetDesc);
      tmpSetDesc.set = null;
    };
    js.getClassName = function(objOrCtor) {
      if ("function" === typeof objOrCtor) {
        var prototype = objOrCtor.prototype;
        if (prototype && prototype.hasOwnProperty("__classname__") && prototype.__classname__) return prototype.__classname__;
        var retval = "";
        objOrCtor.name && (retval = objOrCtor.name);
        if (objOrCtor.toString) {
          var arr, str = objOrCtor.toString();
          arr = "[" === str.charAt(0) ? str.match(/\[\w+\s*(\w+)\]/) : str.match(/function\s*(\w+)/);
          arr && 2 === arr.length && (retval = arr[1]);
        }
        return "Object" !== retval ? retval : "";
      }
      if (objOrCtor && objOrCtor.constructor) return js.getClassName(objOrCtor.constructor);
      return "";
    };
    function isTempClassId(id) {
      return "string" !== typeof id || id.startsWith(tempCIDGenerater.prefix);
    }
    (function() {
      var _idToClass = {};
      var _nameToClass = {};
      function setup(key, publicName, table) {
        js.getset(js, publicName, (function() {
          return Object.assign({}, table);
        }), (function(value) {
          js.clear(table);
          Object.assign(table, value);
        }));
        return function(id, constructor) {
          constructor.prototype.hasOwnProperty(key) && delete table[constructor.prototype[key]];
          js.value(constructor.prototype, key, id);
          if (id) {
            var registered = table[id];
            if (registered && registered !== constructor) {
              var error = "A Class already exists with the same " + key + ' : "' + id + '".';
              false;
              cc.error(error);
            } else table[id] = constructor;
          }
        };
      }
      js._setClassId = setup("__cid__", "_registeredClassIds", _idToClass);
      var doSetClassName = setup("__classname__", "_registeredClassNames", _nameToClass);
      js.setClassName = function(className, constructor) {
        doSetClassName(className, constructor);
        if (!constructor.prototype.hasOwnProperty("__cid__")) {
          var id = className || tempCIDGenerater.getNewId();
          id && js._setClassId(id, constructor);
        }
      };
      js.unregisterClass = function() {
        for (var i = 0; i < arguments.length; i++) {
          var p = arguments[i].prototype;
          var classId = p.__cid__;
          classId && delete _idToClass[classId];
          var classname = p.__classname__;
          classname && delete _nameToClass[classname];
        }
      };
      js._getClassById = function(classId) {
        return _idToClass[classId];
      };
      js.getClassByName = function(classname) {
        return _nameToClass[classname];
      };
      js._getClassId = function(obj, allowTempId) {
        allowTempId = "undefined" === typeof allowTempId || allowTempId;
        var res;
        if ("function" === typeof obj && obj.prototype.hasOwnProperty("__cid__")) {
          res = obj.prototype.__cid__;
          if (!allowTempId && isTempClassId(res)) return "";
          return res;
        }
        if (obj && obj.constructor) {
          var prototype = obj.constructor.prototype;
          if (prototype && prototype.hasOwnProperty("__cid__")) {
            res = obj.__cid__;
            if (!allowTempId && isTempClassId(res)) return "";
            return res;
          }
        }
        return "";
      };
    })();
    js.obsolete = function(obj, obsoleted, newExpr, writable) {
      var extractPropName = /([^.]+)$/;
      var oldProp = extractPropName.exec(obsoleted)[0];
      var newProp = extractPropName.exec(newExpr)[0];
      function get() {
        true;
        cc.warnID(1400, obsoleted, newExpr);
        return this[newProp];
      }
      writable ? js.getset(obj, oldProp, get, (function(value) {
        true;
        cc.warnID(1400, obsoleted, newExpr);
        this[newProp] = value;
      })) : js.get(obj, oldProp, get);
    };
    js.obsoletes = function(obj, objName, props, writable) {
      for (var obsoleted in props) {
        var newName = props[obsoleted];
        js.obsolete(obj, objName + "." + obsoleted, newName, writable);
      }
    };
    var REGEXP_NUM_OR_STR = /(%d)|(%s)/;
    var REGEXP_STR = /%s/;
    js.formatStr = function() {
      var argLen = arguments.length;
      if (0 === argLen) return "";
      var msg = arguments[0];
      if (1 === argLen) return "" + msg;
      var hasSubstitution = "string" === typeof msg && REGEXP_NUM_OR_STR.test(msg);
      if (hasSubstitution) for (var i = 1; i < argLen; ++i) {
        var arg = arguments[i];
        var regExpToTest = "number" === typeof arg ? REGEXP_NUM_OR_STR : REGEXP_STR;
        if (regExpToTest.test(msg)) {
          var notReplaceFunction = "" + arg;
          msg = msg.replace(regExpToTest, notReplaceFunction);
        } else msg += " " + arg;
      } else for (var _i = 1; _i < argLen; ++_i) msg += " " + arguments[_i];
      return msg;
    };
    js.shiftArguments = function() {
      var len = arguments.length - 1;
      var args = new Array(len);
      for (var i = 0; i < len; ++i) args[i] = arguments[i + 1];
      return args;
    };
    js.createMap = function(forceDictMode) {
      var map = Object.create(null);
      if (forceDictMode) {
        var INVALID_IDENTIFIER_1 = ".";
        var INVALID_IDENTIFIER_2 = "/";
        map[INVALID_IDENTIFIER_1] = true;
        map[INVALID_IDENTIFIER_2] = true;
        delete map[INVALID_IDENTIFIER_1];
        delete map[INVALID_IDENTIFIER_2];
      }
      return map;
    };
    function removeAt(array, index) {
      array.splice(index, 1);
    }
    function fastRemoveAt(array, index) {
      var length = array.length;
      if (index < 0 || index >= length) return;
      array[index] = array[length - 1];
      array.length = length - 1;
    }
    function remove(array, value) {
      var index = array.indexOf(value);
      if (index >= 0) {
        removeAt(array, index);
        return true;
      }
      return false;
    }
    function fastRemove(array, value) {
      var index = array.indexOf(value);
      if (index >= 0) {
        array[index] = array[array.length - 1];
        --array.length;
      }
    }
    function verifyType(array, type) {
      if (array && array.length > 0) for (var i = 0; i < array.length; i++) if (!(array[i] instanceof type)) {
        cc.logID(1300);
        return false;
      }
      return true;
    }
    function removeArray(array, minusArr) {
      for (var i = 0, l = minusArr.length; i < l; i++) remove(array, minusArr[i]);
    }
    function appendObjectsAt(array, addObjs, index) {
      array.splice.apply(array, [ index, 0 ].concat(addObjs));
      return array;
    }
    function contains(array, value) {
      return array.indexOf(value) >= 0;
    }
    function copy(array) {
      var i, len = array.length, arr_clone = new Array(len);
      for (i = 0; i < len; i += 1) arr_clone[i] = array[i];
      return arr_clone;
    }
    js.array = {
      remove: remove,
      fastRemove: fastRemove,
      removeAt: removeAt,
      fastRemoveAt: fastRemoveAt,
      contains: contains,
      verifyType: verifyType,
      removeArray: removeArray,
      appendObjectsAt: appendObjectsAt,
      copy: copy,
      MutableForwardIterator: require("../utils/mutable-forward-iterator")
    };
    function Pool(cleanupFunc, size) {
      if (void 0 === size) {
        size = cleanupFunc;
        cleanupFunc = null;
      }
      this.get = null;
      this.count = 0;
      this._pool = new Array(size);
      this._cleanup = cleanupFunc;
    }
    Pool.prototype._get = function() {
      if (this.count > 0) {
        --this.count;
        var cache = this._pool[this.count];
        this._pool[this.count] = null;
        return cache;
      }
      return null;
    };
    Pool.prototype.put = function(obj) {
      var pool = this._pool;
      if (this.count < pool.length) {
        if (this._cleanup && false === this._cleanup(obj)) return;
        pool[this.count] = obj;
        ++this.count;
      }
    };
    Pool.prototype.resize = function(length) {
      if (length >= 0) {
        this._pool.length = length;
        this.count > length && (this.count = length);
      }
    };
    js.Pool = Pool;
    cc.js = js;
    module.exports = js;
  }), {
    "../utils/mutable-forward-iterator": 387,
    "./id-generater": 290
  } ],
  295: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    var Attrs = require("./attribute");
    var SerializableAttrs = {
      default: {},
      serializable: {},
      editorOnly: {},
      formerlySerializedAs: {}
    };
    var TYPO_TO_CORRECT_DEV = (true, {
      extend: "extends",
      property: "properties",
      static: "statics",
      constructor: "ctor"
    });
    function parseNotify(val, propName, notify, properties) {
      if (val.get || val.set) {
        true;
        cc.warnID(5500);
        return;
      }
      if (val.hasOwnProperty("default")) {
        var newKey = "_N$" + propName;
        val.get = function() {
          return this[newKey];
        };
        val.set = function(value) {
          var oldValue = this[newKey];
          this[newKey] = value;
          notify.call(this, oldValue);
        };
        false;
        var newValue = {};
        properties[newKey] = newValue;
        for (var attr in SerializableAttrs) {
          var v = SerializableAttrs[attr];
          if (val.hasOwnProperty(attr)) {
            newValue[attr] = val[attr];
            v.canUsedInGet || delete val[attr];
          }
        }
      } else {
        true;
        cc.warnID(5501);
      }
    }
    function parseType(val, type, className, propName) {
      var STATIC_CHECK = (false, false);
      if (Array.isArray(type)) {
        if (STATIC_CHECK && "default" in val) {
          var isArray = require("./CCClass").isArray;
          isArray(val["default"]) || cc.warnID(5507, className, propName);
        }
        if (!(type.length > 0)) return cc.errorID(5508, className, propName);
        val.type = type = type[0];
      }
      if ("function" === typeof type) {
        if (type === String) {
          val.type = cc.String;
          STATIC_CHECK && cc.warnID(3608, '"' + className + "." + propName + '"');
        } else if (type === Boolean) {
          val.type = cc.Boolean;
          STATIC_CHECK && cc.warnID(3609, '"' + className + "." + propName + '"');
        } else if (type === Number) {
          val.type = cc.Float;
          STATIC_CHECK && cc.warnID(3610, '"' + className + "." + propName + '"');
        }
      } else if (STATIC_CHECK) switch (type) {
       case "Number":
        cc.warnID(5510, className, propName);
        break;

       case "String":
        cc.warn('The type of "' + className + "." + propName + '" must be cc.String, not "String".');
        break;

       case "Boolean":
        cc.warn('The type of "' + className + "." + propName + '" must be cc.Boolean, not "Boolean".');
        break;

       case "Float":
        cc.warn('The type of "' + className + "." + propName + '" must be cc.Float, not "Float".');
        break;

       case "Integer":
        cc.warn('The type of "' + className + "." + propName + '" must be cc.Integer, not "Integer".');
        break;

       case null:
        cc.warnID(5511, className, propName);
      }
      false;
    }
    function getBaseClassWherePropertyDefined_DEV(propName, cls) {
      true;
      var res;
      for (;cls && cls.__props__ && -1 !== cls.__props__.indexOf(propName); cls = cls.$super) res = cls;
      res || cc.error("unknown error");
      return res;
    }
    function _wrapOptions(isES6Getset, _default, type) {
      var res = isES6Getset ? {
        _short: true
      } : {
        _short: true,
        default: _default
      };
      type && (res.type = type);
      return res;
    }
    exports.getFullFormOfProperty = function(options, isES6Getset) {
      var isLiteral = options && options.constructor === Object;
      if (isLiteral) return null;
      return Array.isArray(options) && options.length > 0 ? _wrapOptions(isES6Getset, [], options) : "function" === typeof options ? _wrapOptions(isES6Getset, js.isChildClassOf(options, cc.ValueType) ? new options() : null, options) : options instanceof Attrs.PrimitiveType ? _wrapOptions(isES6Getset, options["default"]) : _wrapOptions(isES6Getset, options);
    };
    exports.preprocessAttrs = function(properties, className, cls, es6) {
      for (var propName in properties) {
        var val = properties[propName];
        var fullForm = exports.getFullFormOfProperty(val, false);
        fullForm && (val = properties[propName] = fullForm);
        if (val) {
          var maybeTypeScript;
          false;
          if ((true, !val.override) && -1 !== cls.__props__.indexOf(propName)) {
            var baseClass = js.getClassName(getBaseClassWherePropertyDefined_DEV(propName, cls));
            cc.warnID(5517, className, propName, baseClass, propName);
          }
          var notify = val.notify;
          notify && (true, es6 ? cc.error("not yet support notify attribute for ES6 Classes") : parseNotify(val, propName, notify, properties));
          "type" in val && parseType(val, val.type, className, propName);
        }
      }
    };
    true;
    var CALL_SUPER_DESTROY_REG_DEV = /\b\._super\b|destroy\s*\.\s*call\s*\(\s*\w+\s*[,|)]/;
    exports.doValidateMethodWithProps_DEV = function(func, funcName, className, cls, base) {
      if (cls.__props__ && cls.__props__.indexOf(funcName) >= 0) {
        var baseClassName = js.getClassName(getBaseClassWherePropertyDefined_DEV(funcName, cls));
        cc.errorID(3648, className, funcName, baseClassName);
        return false;
      }
      "destroy" === funcName && js.isChildClassOf(base, cc.Component) && !CALL_SUPER_DESTROY_REG_DEV.test(func) && cc.error("Overwriting '" + funcName + "' function in '" + className + "' class without calling super is not allowed. Call the super function in '" + funcName + "' please.");
    };
    exports.validateMethodWithProps = function(func, funcName, className, cls, base) {
      if (true, "constructor" === funcName) {
        cc.errorID(3643, className);
        return false;
      }
      if ("function" !== typeof func && null !== func) {
        true;
        if (false === func && base && base.prototype) {
          var overrided = base.prototype[funcName];
          if ("function" === typeof overrided) {
            var baseFuc = js.getClassName(base) + "." + funcName;
            var subFuc = className + "." + funcName;
            cc.warnID(3624, subFuc, baseFuc, subFuc, subFuc);
          }
        }
        var correct = TYPO_TO_CORRECT_DEV[funcName];
        correct ? cc.warnID(3621, className, funcName, correct) : func && cc.errorID(3622, className, funcName);
        return false;
      }
      true;
      this.doValidateMethodWithProps_DEV(func, funcName, className, cls, base);
      return true;
    };
  }), {
    "./CCClass": 272,
    "./attribute": 284,
    "./js": 294
  } ],
  296: [ (function(require, module, exports) {
    "use strict";
    var requiringFrames = [];
    cc._RF = {
      push: function push(module, uuid, script) {
        if (void 0 === script) {
          script = uuid;
          uuid = "";
        }
        requiringFrames.push({
          uuid: uuid,
          script: script,
          module: module,
          exports: module.exports,
          beh: null
        });
      },
      pop: function pop() {
        var frameInfo = requiringFrames.pop();
        var module = frameInfo.module;
        var exports = module.exports;
        if (exports === frameInfo.exports) {
          for (var anyKey in exports) return;
          module.exports = exports = frameInfo.cls;
        }
      },
      peek: function peek() {
        return requiringFrames[requiringFrames.length - 1];
      }
    };
    false;
  }), {} ],
  297: [ (function(require, module, exports) {
    "use strict";
    var js = require("./js");
    module.exports = {
      contains: function contains(refNode, otherNode) {
        if ("function" == typeof refNode.contains) return refNode.contains(otherNode);
        if ("function" == typeof refNode.compareDocumentPosition) return !!(16 & refNode.compareDocumentPosition(otherNode));
        var node = otherNode.parentNode;
        if (node) do {
          if (node === refNode) return true;
          node = node.parentNode;
        } while (null !== node);
        return false;
      },
      isDomNode: "object" === typeof window && ("function" === typeof Node ? function(obj) {
        return obj instanceof Node;
      } : function(obj) {
        return obj && "object" === typeof obj && "number" === typeof obj.nodeType && "string" === typeof obj.nodeName;
      }),
      callInNextTick: function(callback, p1, p2) {
        callback && setTimeout((function() {
          callback(p1, p2);
        }), 0);
      }
    };
    true;
    module.exports.isPlainEmptyObj_DEV = function(obj) {
      if (!obj || obj.constructor !== Object) return false;
      return js.isEmptyObject(obj);
    };
    module.exports.cloneable_DEV = function(obj) {
      return obj && "function" === typeof obj.clone && (obj.constructor && obj.constructor.prototype.hasOwnProperty("clone") || obj.hasOwnProperty("clone"));
    };
    false;
  }), {
    "./js": 294
  } ],
  298: [ (function(require, module, exports) {
    "use strict";
    require("./platform/js");
    require("./value-types");
    require("./utils");
    require("./platform/CCInputManager");
    require("./platform/CCInputExtension");
    require("./event");
    require("./platform/CCSys");
    require("./platform/CCMacro");
    require("./asset-manager");
    require("./CCDirector");
    require("./renderer");
    true;
    require("./platform/CCView");
    require("./platform/CCScreen");
    require("./CCScheduler");
    require("./event-manager");
  }), {
    "./CCDirector": 102,
    "./CCScheduler": 107,
    "./asset-manager": 125,
    "./event": 221,
    "./event-manager": 217,
    "./platform/CCInputExtension": 275,
    "./platform/CCInputManager": 276,
    "./platform/CCMacro": 277,
    "./platform/CCScreen": 280,
    "./platform/CCSys": 281,
    "./platform/CCView": 282,
    "./platform/js": 294,
    "./renderer": 322,
    "./utils": 385,
    "./value-types": 401
  } ],
  299: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler = _interopRequireDefault(require("./assembler"));
    var _manager = _interopRequireDefault(require("./utils/dynamic-atlas/manager"));
    var _renderData = _interopRequireDefault(require("./webgl/render-data"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _assertThisInitialized(self) {
      if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return self;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Assembler2D = (function(_Assembler) {
      _inheritsLoose(Assembler2D, _Assembler);
      function Assembler2D() {
        var _this;
        _this = _Assembler.call(this) || this;
        _this._renderData = new _renderData["default"]();
        _this._renderData.init(_assertThisInitialized(_this));
        _this.initData();
        _this.initLocal();
        return _this;
      }
      var _proto = Assembler2D.prototype;
      _proto.initData = function initData() {
        var data = this._renderData;
        data.createQuadData(0, this.verticesFloats, this.indicesCount);
      };
      _proto.initLocal = function initLocal() {
        this._local = [];
        this._local.length = 4;
      };
      _proto.updateColor = function updateColor(comp, color) {
        var uintVerts = this._renderData.uintVDatas[0];
        if (!uintVerts) return;
        color = null != color ? color : comp.node.color._val;
        var floatsPerVert = this.floatsPerVert;
        var colorOffset = this.colorOffset;
        for (var i = colorOffset, l = uintVerts.length; i < l; i += floatsPerVert) uintVerts[i] = color;
      };
      _proto.getBuffer = function getBuffer() {
        return cc.renderer._handle._meshBuffer;
      };
      _proto.updateWorldVerts = function updateWorldVerts(comp) {
        var local = this._local;
        var verts = this._renderData.vDatas[0];
        var matrix = comp.node._worldMatrix;
        var matrixm = matrix.m, a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        var vl = local[0], vr = local[2], vb = local[1], vt = local[3];
        var floatsPerVert = this.floatsPerVert;
        var vertexOffset = 0;
        var justTranslate = 1 === a && 0 === b && 0 === c && 1 === d;
        if (justTranslate) {
          verts[vertexOffset] = vl + tx;
          verts[vertexOffset + 1] = vb + ty;
          vertexOffset += floatsPerVert;
          verts[vertexOffset] = vr + tx;
          verts[vertexOffset + 1] = vb + ty;
          vertexOffset += floatsPerVert;
          verts[vertexOffset] = vl + tx;
          verts[vertexOffset + 1] = vt + ty;
          vertexOffset += floatsPerVert;
          verts[vertexOffset] = vr + tx;
          verts[vertexOffset + 1] = vt + ty;
        } else {
          var al = a * vl, ar = a * vr, bl = b * vl, br = b * vr, cb = c * vb, ct = c * vt, db = d * vb, dt = d * vt;
          verts[vertexOffset] = al + cb + tx;
          verts[vertexOffset + 1] = bl + db + ty;
          vertexOffset += floatsPerVert;
          verts[vertexOffset] = ar + cb + tx;
          verts[vertexOffset + 1] = br + db + ty;
          vertexOffset += floatsPerVert;
          verts[vertexOffset] = al + ct + tx;
          verts[vertexOffset + 1] = bl + dt + ty;
          vertexOffset += floatsPerVert;
          verts[vertexOffset] = ar + ct + tx;
          verts[vertexOffset + 1] = br + dt + ty;
        }
      };
      _proto.fillBuffers = function fillBuffers(comp, renderer) {
        renderer.worldMatDirty && this.updateWorldVerts(comp);
        var renderData = this._renderData;
        var vData = renderData.vDatas[0];
        var iData = renderData.iDatas[0];
        var buffer = this.getBuffer(renderer);
        var offsetInfo = buffer.request(this.verticesCount, this.indicesCount);
        var vertexOffset = offsetInfo.byteOffset >> 2, vbuf = buffer._vData;
        vData.length + vertexOffset > vbuf.length ? vbuf.set(vData.subarray(0, vbuf.length - vertexOffset), vertexOffset) : vbuf.set(vData, vertexOffset);
        var ibuf = buffer._iData, indiceOffset = offsetInfo.indiceOffset, vertexId = offsetInfo.vertexOffset;
        for (var i = 0, l = iData.length; i < l; i++) ibuf[indiceOffset++] = vertexId + iData[i];
      };
      _proto.updateTexId = function updateTexId(comp) {
        var texId = comp._texId;
        var texIdOffset = this.texIdOffset;
        var floatsPerVert = this.floatsPerVert;
        var verts = this._renderData.vDatas[0];
        for (var i = 0, l = verts.length; i < l; i++) verts[floatsPerVert * i + texIdOffset] = texId;
      };
      _createClass(Assembler2D, [ {
        key: "verticesFloats",
        get: function get() {
          return this.verticesCount * this.floatsPerVert;
        }
      } ]);
      return Assembler2D;
    })(_assembler["default"]);
    exports["default"] = Assembler2D;
    cc.js.addon(Assembler2D.prototype, {
      floatsPerVert: 5,
      verticesCount: 4,
      indicesCount: 6,
      uvOffset: 2,
      colorOffset: 4,
      isMulti: false
    });
    cc.Assembler2D = Assembler2D;
    module.exports = exports["default"];
  }), {
    "./assembler": 302,
    "./utils/dynamic-atlas/manager": 324,
    "./webgl/render-data": 370
  } ],
  300: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vertexFormat = require("./webgl/vertex-format");
    var _vec = _interopRequireDefault(require("../value-types/vec3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var vec3_temps = [];
    for (var i = 0; i < 4; i++) vec3_temps.push(cc.v3());
    var Assembler3D = {
      floatsPerVert: 6,
      uvOffset: 3,
      colorOffset: 5,
      getBuffer: function getBuffer(renderer) {
        return renderer._meshBuffer3D;
      },
      getVfmt: function getVfmt() {
        return _vertexFormat.vfmt3D;
      },
      updateWorldVerts: function updateWorldVerts(comp) {
        var matrix = comp.node._worldMatrix;
        var local = this._local;
        var world = this._renderData.vDatas[0];
        _vec["default"].set(vec3_temps[0], local[0], local[1], 0);
        _vec["default"].set(vec3_temps[1], local[2], local[1], 0);
        _vec["default"].set(vec3_temps[2], local[0], local[3], 0);
        _vec["default"].set(vec3_temps[3], local[2], local[3], 0);
        var floatsPerVert = this.floatsPerVert;
        for (var _i = 0; _i < 4; _i++) {
          var vertex = vec3_temps[_i];
          _vec["default"].transformMat4(vertex, vertex, matrix);
          var dstOffset = floatsPerVert * _i;
          world[dstOffset] = vertex.x;
          world[dstOffset + 1] = vertex.y;
          world[dstOffset + 2] = vertex.z;
        }
      }
    };
    cc.Assembler3D = Assembler3D;
    var _default = Assembler3D;
    exports["default"] = _default;
    module.exports = exports["default"];
  }), {
    "../value-types/vec3": 411,
    "./webgl/vertex-format": 371
  } ],
  301: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _pool3 = _interopRequireDefault(require("../utils/pool"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var _assemblerId = 0;
    function getAssemblerId(assemblerCtor) {
      Object.getOwnPropertyDescriptor(assemblerCtor, "__assemblerId__") || (assemblerCtor.__assemblerId__ = ++_assemblerId);
      return assemblerCtor.__assemblerId__;
    }
    var AssemblerPool = (function(_Pool) {
      _inheritsLoose(AssemblerPool, _Pool);
      function AssemblerPool() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        _this = _Pool.call.apply(_Pool, [ this ].concat(args)) || this;
        _this._pool = {};
        return _this;
      }
      var _proto = AssemblerPool.prototype;
      _proto.put = function put(assembler) {
        if (!assembler) return;
        if (!this.enabled) {
          true, true;
          assembler.destroy && assembler.destroy();
          return;
        }
        var id = getAssemblerId(assembler.constructor);
        var pool = this._pool;
        pool[id] || (pool[id] = []);
        if (this.count > this.maxSize) return;
        this._clean(assembler);
        pool[id].push(assembler);
        this.count++;
      };
      _proto.get = function get(assemblerCtor) {
        var assembler;
        if (this.enabled) {
          var _pool = this._pool;
          var id = getAssemblerId(assemblerCtor);
          assembler = _pool[id] && _pool[id].pop();
        }
        assembler ? this.count-- : assembler = new assemblerCtor();
        return assembler;
      };
      _proto.clear = function clear() {
        true, true;
        var _pool2 = this._pool;
        for (var name in _pool2) {
          var assemblers = _pool2[name];
          if (!assemblers) continue;
          for (var i = 0; i < assemblers.length; i++) assemblers[i].destroy && assemblers[i].destroy();
        }
        this._pool = {};
        this.count = 0;
      };
      _proto._clean = function _clean(assembler) {
        true, true;
        assembler.reset();
        assembler._renderComp = null;
      };
      return AssemblerPool;
    })(_pool3["default"]);
    var pool = new AssemblerPool();
    _pool3["default"].register("assembler", pool);
    var _default = pool;
    exports["default"] = _default;
    module.exports = exports["default"];
  }), {
    "../utils/pool": 388
  } ],
  302: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vertexFormat = require("./webgl/vertex-format");
    var _assemblerPool = _interopRequireDefault(require("./assembler-pool"));
    var _manager = _interopRequireDefault(require("./utils/dynamic-atlas/manager"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Assembler = (function() {
      function Assembler() {
        this._extendNative && this._extendNative();
      }
      var _proto = Assembler.prototype;
      _proto.init = function init(renderComp) {
        this._renderComp = renderComp;
      };
      _proto.updateRenderData = function updateRenderData(comp) {};
      _proto.updateRenderDataForSwitchMaterial = function updateRenderDataForSwitchMaterial(comp) {};
      _proto.fillBuffers = function fillBuffers(comp, renderer) {};
      _proto.getVfmt = function getVfmt() {
        return _vertexFormat.vfmtPosUvColor;
      };
      _proto.packDynamicAtlasAndCheckMaterial = function packDynamicAtlasAndCheckMaterial(comp, frame) {
        false;
        var allowDynamicAtlas = comp.allowDynamicAtlas;
        if ((cc.sp.allowDynamicAtlas && 0 === allowDynamicAtlas || 1 === allowDynamicAtlas) && !frame._original && _manager["default"] && frame._texture.packable && frame._texture.loaded) {
          var packedFrame = _manager["default"].insertSpriteFrame(frame);
          packedFrame && frame._setDynamicAtlasFrame(packedFrame);
        }
        var material = comp._materials[0];
        if (!material) return false;
        if (this.checkAndSwitchMaterial(comp, frame._texture, material)) return true;
        if (material.material.isMultiSupport()) comp._texIdDirty = true; else if (material.getProperty("texture") !== frame._texture._texture) {
          comp._vertsDirty = true;
          comp._updateMaterial();
        }
        return false;
      };
      _proto.checkAndSwitchMaterial = function checkAndSwitchMaterial(comp, texture, material) {
        var autoSwitchMaterial = comp.autoSwitchMaterial;
        if ((cc.sp.autoSwitchMaterial && 0 === autoSwitchMaterial || 1 === autoSwitchMaterial) && texture._multiMaterial && material.material !== texture._multiMaterial) {
          true;
          comp.node._inJsbDirtyList = true;
          comp.setMaterial(0, texture._multiMaterial);
          true;
          comp.node._inJsbDirtyList = false;
          if (!this.isMulti) {
            comp._assembler && comp._assembler.updateRenderDataForSwitchMaterial(comp);
            return true;
          }
        }
      };
      return Assembler;
    })();
    exports["default"] = Assembler;
    Assembler.register = function(renderCompCtor, assembler) {
      renderCompCtor.__assembler__ = assembler;
    };
    Assembler.init = function(renderComp) {
      var renderCompCtor = renderComp.constructor;
      var assemblerCtor = renderCompCtor.__assembler__;
      while (!assemblerCtor) {
        renderCompCtor = renderCompCtor.$super;
        if (!renderCompCtor) {
          cc.warn("Can not find assembler for render component : [" + cc.js.getClassName(renderComp) + "]");
          return;
        }
        assemblerCtor = renderCompCtor.__assembler__;
      }
      assemblerCtor.getConstructor && (assemblerCtor = assemblerCtor.getConstructor(renderComp));
      if (!renderComp._assembler || renderComp._assembler.constructor !== assemblerCtor) {
        var assembler = _assemblerPool["default"].get(assemblerCtor);
        assembler.init(renderComp);
        renderComp._assembler = assembler;
      }
    };
    cc.Assembler = Assembler;
    module.exports = exports["default"];
  }), {
    "./assembler-pool": 301,
    "./utils/dynamic-atlas/manager": 324,
    "./webgl/vertex-format": 371
  } ],
  303: [ (function(require, module, exports) {
    "use strict";
    var Device = function Device(canvasEL) {
      var ctx;
      try {
        ctx = canvasEL.getContext("2d");
      } catch (err) {
        console.error(err);
        return;
      }
      this._canvas = canvasEL;
      this._ctx = ctx;
      this._caps = {};
      this._stats = {
        drawcalls: 0
      };
      this._vx = this._vy = this._vw = this._vh = 0;
      this._sx = this._sy = this._sw = this._sh = 0;
    };
    Device.prototype._restoreTexture = function _restoreTexture(unit) {};
    Device.prototype.setViewport = function setViewport(x, y, w, h) {
      if (this._vx !== x || this._vy !== y || this._vw !== w || this._vh !== h) {
        this._vx = x;
        this._vy = y;
        this._vw = w;
        this._vh = h;
      }
    };
    Device.prototype.setScissor = function setScissor(x, y, w, h) {
      if (this._sx !== x || this._sy !== y || this._sw !== w || this._sh !== h) {
        this._sx = x;
        this._sy = y;
        this._sw = w;
        this._sh = h;
      }
    };
    Device.prototype.clear = function clear(color) {
      var ctx = this._ctx;
      ctx.clearRect(this._vx, this._vy, this._vw, this._vh);
      if (color && (0 !== color[0] || 0 !== color[1] || 0 !== color[2])) {
        ctx.fillStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
        ctx.globalAlpha = color[3];
        ctx.fillRect(this._vx, this._vy, this._vw, this._vh);
      }
    };
    Device.prototype.resetDrawCalls = function() {
      this._stats.drawcalls = 0;
    };
    Device.prototype.getDrawCalls = function() {
      return this._stats.drawcalls;
    };
    module.exports = Device;
  }), {} ],
  304: [ (function(require, module, exports) {
    "use strict";
    var Texture2D = function Texture2D(device, options) {
      this._device = device;
      this._width = 4;
      this._height = 4;
      this._image = null;
      if (options) {
        void 0 !== options.width && (this._width = options.width);
        void 0 !== options.height && (this._height = options.height);
        this.updateImage(options);
      }
    };
    Texture2D.prototype.update = function update(options) {
      this.updateImage(options);
    };
    Texture2D.prototype.updateImage = function updateImage(options) {
      if (options.images && options.images[0]) {
        var image = options.images[0];
        image && image !== this._image && (this._image = image);
      }
    };
    Texture2D.prototype.destroy = function destroy() {
      this._image = null;
    };
    module.exports = Texture2D;
  }), {} ],
  305: [ (function(require, module, exports) {
    "use strict";
    var ForwardRenderer = function ForwardRenderer() {};
    ForwardRenderer.prototype = {
      constructor: ForwardRenderer,
      clear: function clear() {},
      render: function render() {}
    };
    module.exports = ForwardRenderer;
  }), {} ],
  306: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    require("./render-flow");
    require("./renderers");
    var _forwardRenderer = _interopRequireDefault(require("./forward-renderer"));
    var _renderComponentHandle = _interopRequireDefault(require("./render-component-handle"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _default = {
      ForwardRenderer: _forwardRenderer["default"],
      RenderComponentHandle: _renderComponentHandle["default"]
    };
    exports["default"] = _default;
    module.exports = exports["default"];
  }), {
    "./forward-renderer": 305,
    "./render-component-handle": 307,
    "./render-flow": 308,
    "./renderers": 311
  } ],
  307: [ (function(require, module, exports) {
    "use strict";
    var utils = require("./renderers/utils");
    var RenderComponentHandle = function RenderComponentHandle(device, defaultCamera) {
      this._device = device;
      this._camera = defaultCamera;
      this.parentOpacity = 1;
      this.parentOpacityDirty = 0;
      this.worldMatDirty = 0;
      this.walking = false;
    };
    RenderComponentHandle.prototype = {
      constructor: RenderComponentHandle,
      reset: function reset() {
        var ctx = this._device._ctx;
        var canvas = this._device._canvas;
        var color = cc.Camera.main ? cc.Camera.main.backgroundColor : cc.color();
        var rgba = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + color.a / 255 + ")";
        ctx.fillStyle = rgba;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        this._device._stats.drawcalls = 0;
        utils.context.reset();
      },
      terminate: function terminate() {}
    };
    module.exports = RenderComponentHandle;
  }), {
    "./renderers/utils": 321
  } ],
  308: [ (function(require, module, exports) {
    "use strict";
    var _renderFlow = _interopRequireDefault(require("../render-flow"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    _renderFlow["default"].prototype._draw = function(node, func) {
      var batcher = _renderFlow["default"].getBachther();
      var ctx = batcher._device._ctx;
      var cam = batcher._camera;
      ctx.setTransform(cam.a, cam.b, cam.c, cam.d, cam.tx, cam.ty);
      ctx.scale(1, -1);
      var comp = node._renderComponent;
      comp._assembler[func](ctx, comp);
      this._next._func(node);
    };
    _renderFlow["default"].prototype._render = function(node) {
      this._draw(node, "draw");
    };
    _renderFlow["default"].prototype._postRender = function(node) {
      this._draw(node, "postDraw");
    };
  }), {
    "../render-flow": 323
  } ],
  309: [ (function(require, module, exports) {
    "use strict";
    var Helper = require("../../../../graphics/helper");
    var Types = require("../../../../graphics/types");
    var js = require("../../../../platform/js");
    var LineJoin = Types.LineJoin;
    var LineCap = Types.LineCap;
    function Impl() {
      this.cmds = [];
      this.style = {
        strokeStyle: "black",
        fillStyle: "white",
        lineCap: "butt",
        lineJoin: "miter",
        miterLimit: 10
      };
    }
    var _proto = Impl.prototype;
    js.mixin(_proto, {
      moveTo: function moveTo(x, y) {
        this.cmds.push([ "moveTo", [ x, y ] ]);
      },
      lineTo: function lineTo(x, y) {
        this.cmds.push([ "lineTo", [ x, y ] ]);
      },
      bezierCurveTo: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
        this.cmds.push([ "bezierCurveTo", [ c1x, c1y, c2x, c2y, x, y ] ]);
      },
      quadraticCurveTo: function quadraticCurveTo(cx, cy, x, y) {
        this.cmds.push([ "quadraticCurveTo", [ cx, cy, x, y ] ]);
      },
      arc: function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
        Helper.arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
      },
      ellipse: function ellipse(cx, cy, rx, ry) {
        Helper.ellipse(this, cx, cy, rx, ry);
      },
      circle: function circle(cx, cy, r) {
        Helper.ellipse(this, cx, cy, r, r);
      },
      rect: function rect(x, y, w, h) {
        this.moveTo(x, y);
        this.lineTo(x, y + h);
        this.lineTo(x + w, y + h);
        this.lineTo(x + w, y);
        this.close();
      },
      roundRect: function roundRect(x, y, w, h, r) {
        Helper.roundRect(this, x, y, w, h, r);
      },
      clear: function clear(comp, clean) {
        this.cmds.length = 0;
      },
      close: function close() {
        this.cmds.push([ "closePath", [] ]);
      },
      stroke: function stroke() {
        this.cmds.push([ "stroke", [] ]);
      },
      fill: function fill() {
        this.cmds.push([ "fill", [] ]);
      }
    });
    js.set(_proto, "strokeColor", (function(v) {
      var strokeStyle = "rgba(" + (0 | v.r) + "," + (0 | v.g) + "," + (0 | v.b) + "," + v.a / 255 + ")";
      this.cmds.push([ "strokeStyle", strokeStyle ]);
      this.style.strokeStyle = strokeStyle;
    }));
    js.set(_proto, "fillColor", (function(v) {
      var fillStyle = "rgba(" + (0 | v.r) + "," + (0 | v.g) + "," + (0 | v.b) + "," + v.a / 255 + ")";
      this.cmds.push([ "fillStyle", fillStyle ]);
      this.style.fillStyle = fillStyle;
    }));
    js.set(_proto, "lineWidth", (function(v) {
      this.cmds.push([ "lineWidth", v ]);
      this.style.lineWidth = v;
    }));
    js.set(_proto, "lineCap", (function(v) {
      var lineCap = "butt";
      v === LineCap.BUTT ? lineCap = "butt" : v === LineCap.ROUND ? lineCap = "round" : v === LineCap.SQUARE && (lineCap = "square");
      this.cmds.push([ "lineCap", lineCap ]);
      this.style.lineCap = lineCap;
    }));
    js.set(_proto, "lineJoin", (function(v) {
      var lineJoin = "bevel";
      v === LineJoin.BEVEL ? lineJoin = "bevel" : v === LineJoin.ROUND ? lineJoin = "round" : v === LineJoin.MITER && (lineJoin = "miter");
      this.cmds.push([ "lineJoin", lineJoin ]);
      this.style.lineJoin = lineJoin;
    }));
    js.set(_proto, "miterLimit", (function(v) {
      this.cmds.push([ "miterLimit", v ]);
      this.style.miterLimit = v;
    }));
    cc.Graphics._Impl = Impl;
    module.exports = Impl;
  }), {
    "../../../../graphics/helper": 236,
    "../../../../graphics/types": 238,
    "../../../../platform/js": 294
  } ],
  310: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler = _interopRequireDefault(require("../../../assembler"));
    var _impl = _interopRequireDefault(require("./impl"));
    var _graphics = _interopRequireDefault(require("../../../../graphics/graphics"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CanvasGraphicsAssembler = (function() {
      function CanvasGraphicsAssembler() {}
      var _proto = CanvasGraphicsAssembler.prototype;
      _proto.init = function init() {};
      _proto.updateRenderData = function updateRenderData() {};
      _proto.draw = function draw(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var matrixm = matrix.m;
        var a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        ctx.transform(a, b, c, d, tx, ty);
        ctx.save();
        ctx.globalAlpha = node.opacity / 255;
        var style = comp._impl.style;
        ctx.strokeStyle = style.strokeStyle;
        ctx.fillStyle = style.fillStyle;
        ctx.lineWidth = style.lineWidth;
        ctx.lineJoin = style.lineJoin;
        ctx.miterLimit = style.miterLimit;
        var endPath = true;
        var cmds = comp._impl.cmds;
        for (var i = 0, l = cmds.length; i < l; i++) {
          var cmd = cmds[i];
          var ctxCmd = cmd[0], args = cmd[1];
          if ("moveTo" === ctxCmd && endPath) {
            ctx.beginPath();
            endPath = false;
          } else "fill" !== ctxCmd && "stroke" !== ctxCmd && "fillRect" !== ctxCmd || (endPath = true);
          "function" === typeof ctx[ctxCmd] ? ctx[ctxCmd].apply(ctx, args) : ctx[ctxCmd] = args;
        }
        ctx.restore();
        return 1;
      };
      _proto.stroke = function stroke(comp) {
        comp._impl.stroke();
      };
      _proto.fill = function fill(comp) {
        comp._impl.fill();
      };
      _proto.clear = function clear() {};
      return CanvasGraphicsAssembler;
    })();
    exports["default"] = CanvasGraphicsAssembler;
    _assembler["default"].register(_graphics["default"], CanvasGraphicsAssembler);
    module.exports = exports["default"];
  }), {
    "../../../../graphics/graphics": 235,
    "../../../assembler": 302,
    "./impl": 309
  } ],
  311: [ (function(require, module, exports) {
    "use strict";
    require("../../../components/CCSprite");
    require("../../../components/CCLabel");
    require("../../../components/CCMask");
    require("../../../graphics/graphics");
    require("./sprite");
    require("./label");
    require("./graphics");
    require("./mask");
  }), {
    "../../../components/CCLabel": 183,
    "../../../components/CCMask": 187,
    "../../../components/CCSprite": 198,
    "../../../graphics/graphics": 235,
    "./graphics": 310,
    "./label": 313,
    "./mask": 315,
    "./sprite": 317
  } ],
  312: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _bmfont = _interopRequireDefault(require("../../../utils/label/bmfont"));
    var _renderData = _interopRequireDefault(require("../render-data"));
    var _utils = _interopRequireDefault(require("../utils"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var CanvasBmfontAssembler = (function(_BmfontAssembler) {
      _inheritsLoose(CanvasBmfontAssembler, _BmfontAssembler);
      function CanvasBmfontAssembler() {
        return _BmfontAssembler.apply(this, arguments) || this;
      }
      var _proto = CanvasBmfontAssembler.prototype;
      _proto.init = function init() {
        this._renderData = new _renderData["default"]();
      };
      _proto.updateColor = function updateColor() {};
      _proto.appendQuad = function appendQuad(comp, texture, rect, rotated, x, y, scale) {
        var renderData = this._renderData;
        var dataOffset = renderData.dataLength;
        renderData.dataLength += 2;
        var verts = renderData.vertices;
        var rectWidth = rect.width, rectHeight = rect.height;
        var l, b, r, t;
        if (rotated) {
          l = rect.x;
          r = rect.x + rectHeight;
          b = rect.y;
          t = rect.y + rectWidth;
          verts[dataOffset].u = l;
          verts[dataOffset].v = t;
          verts[dataOffset + 1].u = l;
          verts[dataOffset + 1].v = b;
        } else {
          l = rect.x;
          r = rect.x + rectWidth;
          b = rect.y;
          t = rect.y + rectHeight;
          verts[dataOffset].u = l;
          verts[dataOffset].v = b;
          verts[dataOffset + 1].u = r;
          verts[dataOffset + 1].v = t;
        }
        verts[dataOffset].x = x;
        verts[dataOffset].y = y - rectHeight * scale;
        verts[dataOffset + 1].x = x + rectWidth * scale;
        verts[dataOffset + 1].y = y;
      };
      _proto.draw = function draw(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var matrixm = matrix.m;
        var a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        ctx.transform(a, b, c, d, tx, ty);
        ctx.scale(1, -1);
        _utils["default"].context.setGlobalAlpha(ctx, node.opacity / 255);
        var tex = comp._frame._texture, verts = this._renderData.vertices;
        var image = _utils["default"].getColorizedImage(tex, node._color);
        for (var i = 0, l = verts.length; i < l; i += 2) {
          var x = verts[i].x;
          var y = verts[i].y;
          var w = verts[i + 1].x - x;
          var h = verts[i + 1].y - y;
          y = -y - h;
          var sx = verts[i].u;
          var sy = verts[i].v;
          var sw = verts[i + 1].u - sx;
          var sh = verts[i + 1].v - sy;
          ctx.drawImage(image, sx, sy, sw, sh, x, y, w, h);
        }
        return 1;
      };
      return CanvasBmfontAssembler;
    })(_bmfont["default"]);
    exports["default"] = CanvasBmfontAssembler;
    module.exports = exports["default"];
  }), {
    "../../../utils/label/bmfont": 326,
    "../render-data": 316,
    "../utils": 321
  } ],
  313: [ (function(require, module, exports) {
    "use strict";
    var _assembler = _interopRequireDefault(require("../../../assembler"));
    var _CCLabel = _interopRequireDefault(require("../../../../components/CCLabel"));
    var _ttf = _interopRequireDefault(require("./ttf"));
    var _bmfont = _interopRequireDefault(require("./bmfont"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var canvasPool = {
      pool: [],
      get: function get() {
        var data = this.pool.pop();
        if (!data) {
          var canvas = document.createElement("canvas");
          var context = canvas.getContext("2d");
          data = {
            canvas: canvas,
            context: context
          };
          context.textBaseline = "alphabetic";
        }
        return data;
      },
      put: function put(canvas) {
        if (this.pool.length >= 32) return;
        this.pool.push(canvas);
      }
    };
    _CCLabel["default"]._canvasPool = canvasPool;
    _assembler["default"].register(_CCLabel["default"], {
      getConstructor: function getConstructor(label) {
        var ctor = _ttf["default"];
        label.font instanceof cc.BitmapFont ? ctor = _bmfont["default"] : label.cacheMode === _CCLabel["default"].CacheMode.CHAR && cc.warn("sorry, canvas mode does not support CHAR mode currently!");
        return ctor;
      },
      TTF: _ttf["default"],
      Bmfont: _bmfont["default"]
    });
  }), {
    "../../../../components/CCLabel": 183,
    "../../../assembler": 302,
    "./bmfont": 312,
    "./ttf": 314
  } ],
  314: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _ttf = _interopRequireDefault(require("../../../utils/label/ttf"));
    var _renderData = _interopRequireDefault(require("../render-data"));
    var _utils = _interopRequireDefault(require("../utils"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var CanvasTTFAssembler = (function(_TTFAssembler) {
      _inheritsLoose(CanvasTTFAssembler, _TTFAssembler);
      function CanvasTTFAssembler() {
        return _TTFAssembler.apply(this, arguments) || this;
      }
      var _proto = CanvasTTFAssembler.prototype;
      _proto.init = function init() {
        this._renderData = new _renderData["default"]();
        this._renderData.dataLength = 2;
      };
      _proto.updateColor = function updateColor() {};
      _proto.updateVerts = function updateVerts(comp) {
        var renderData = this._renderData;
        var node = comp.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var verts = renderData.vertices;
        verts[0].x = -appx;
        verts[0].y = -appy;
        verts[1].x = width - appx;
        verts[1].y = height - appy;
      };
      _proto._updateTexture = function _updateTexture(comp) {
        _ttf["default"].prototype._updateTexture.call(this, comp);
        var texture = comp._frame._texture;
        _utils["default"].dropColorizedImage(texture, comp.node.color);
      };
      _proto.draw = function draw(ctx, comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var matrixm = matrix.m;
        var a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        ctx.transform(a, b, c, d, tx, ty);
        ctx.scale(1, -1);
        _utils["default"].context.setGlobalAlpha(ctx, node.opacity / 255);
        var tex = comp._frame._texture, verts = this._renderData.vertices;
        var image = tex.getHtmlElementObj();
        var x = verts[0].x;
        var y = verts[0].y;
        var w = verts[1].x - x;
        var h = verts[1].y - y;
        y = -y - h;
        ctx.drawImage(image, x, y, w, h);
        return 1;
      };
      return CanvasTTFAssembler;
    })(_ttf["default"]);
    exports["default"] = CanvasTTFAssembler;
    module.exports = exports["default"];
  }), {
    "../../../utils/label/ttf": 329,
    "../render-data": 316,
    "../utils": 321
  } ],
  315: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler = _interopRequireDefault(require("../../assembler"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Mask = require("../../../components/CCMask");
    var graphicsHandler = require("./graphics");
    var CanvasMaskAssembler = (function(_Assembler) {
      _inheritsLoose(CanvasMaskAssembler, _Assembler);
      function CanvasMaskAssembler() {
        return _Assembler.apply(this, arguments) || this;
      }
      var _proto = CanvasMaskAssembler.prototype;
      _proto.draw = function draw(ctx, mask) {
        ctx.save();
        mask._graphics._assembler.draw(ctx, mask._graphics);
        ctx.clip();
      };
      _proto.postDraw = function postDraw(ctx, mask) {
        ctx.restore();
      };
      return CanvasMaskAssembler;
    })(_assembler["default"]);
    exports["default"] = CanvasMaskAssembler;
    _assembler["default"].register(Mask, CanvasMaskAssembler);
    module.exports = exports["default"];
  }), {
    "../../../components/CCMask": 187,
    "../../assembler": 302,
    "./graphics": 310
  } ],
  316: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var RenderData = (function() {
      function RenderData() {
        this.vertices = [];
      }
      _createClass(RenderData, [ {
        key: "dataLength",
        get: function get() {
          return this.vertices.length;
        },
        set: function set(v) {
          var old = this.vertices.length;
          this.vertices.length = v;
          for (var i = old; i < v; i++) this.vertices[i] = {
            x: 0,
            y: 0,
            u: 0,
            v: 0
          };
        }
      } ]);
      return RenderData;
    })();
    exports["default"] = RenderData;
    module.exports = exports["default"];
  }), {} ],
  317: [ (function(require, module, exports) {
    "use strict";
    var _assembler = _interopRequireDefault(require("../../../assembler"));
    var _CCSprite = require("../../../../components/CCSprite");
    var _simple = _interopRequireDefault(require("./simple"));
    var _sliced = _interopRequireDefault(require("./sliced"));
    var _tiled = _interopRequireDefault(require("./tiled"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ctor = {
      getConstructor: function getConstructor(sprite) {
        var ctor = _simple["default"];
        switch (sprite.type) {
         case _CCSprite.Type.SLICED:
          ctor = _sliced["default"];
          break;

         case _CCSprite.Type.TILED:
          ctor = _tiled["default"];
        }
        return ctor;
      },
      Simple: _simple["default"],
      Sliced: _sliced["default"],
      Tiled: _tiled["default"]
    };
    _assembler["default"].register(cc.Sprite, ctor);
  }), {
    "../../../../components/CCSprite": 198,
    "../../../assembler": 302,
    "./simple": 318,
    "./sliced": 319,
    "./tiled": 320
  } ],
  318: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler = _interopRequireDefault(require("../../../assembler"));
    var _renderData = _interopRequireDefault(require("../render-data"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var utils = require("../utils");
    var CanvasSimpleSprite = (function(_Assembler) {
      _inheritsLoose(CanvasSimpleSprite, _Assembler);
      function CanvasSimpleSprite() {
        return _Assembler.apply(this, arguments) || this;
      }
      var _proto = CanvasSimpleSprite.prototype;
      _proto.init = function init() {
        this._renderData = new _renderData["default"]();
        this._renderData.dataLength = 2;
      };
      _proto.updateRenderData = function updateRenderData(sprite) {
        if (sprite._vertsDirty) {
          this.updateUVs(sprite);
          this.updateVerts(sprite);
          sprite._vertsDirty = false;
        }
      };
      _proto.updateUVs = function updateUVs(sprite) {
        var frame = sprite.spriteFrame;
        var renderData = this._renderData;
        var verts = renderData.vertices;
        var rect = frame._rect;
        if (frame._rotated) {
          var l = rect.x;
          var r = rect.width;
          var b = rect.y;
          var t = rect.height;
          verts[0].u = l;
          verts[0].v = b;
          verts[1].u = t;
          verts[1].v = r;
        } else {
          var _l = rect.x;
          var _r = rect.width;
          var _b = rect.y;
          var _t = rect.height;
          verts[0].u = _l;
          verts[0].v = _b;
          verts[1].u = _r;
          verts[1].v = _t;
        }
      };
      _proto.updateVerts = function updateVerts(sprite) {
        var renderData = this._renderData, node = sprite.node, verts = renderData.vertices, frame = sprite.spriteFrame, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l, b, r, t;
        if (sprite.trim) {
          l = -appx;
          b = -appy;
          r = cw;
          t = ch;
        } else {
          var ow = frame._originalSize.width, oh = frame._originalSize.height, rw = frame._rect.width, rh = frame._rect.height, offset = frame._offset, scaleX = cw / ow, scaleY = ch / oh;
          var trimLeft = offset.x + (ow - rw) / 2;
          var trimBottom = offset.y + (oh - rh) / 2;
          l = trimLeft * scaleX - appx;
          b = trimBottom * scaleY - appy;
          r = cw;
          t = ch;
        }
        if (frame._rotated) {
          verts[0].y = l;
          verts[0].x = b;
          verts[1].y = r;
          verts[1].x = t;
        } else {
          verts[0].x = l;
          verts[0].y = b;
          verts[1].x = r;
          verts[1].y = t;
        }
        renderData.vertDirty = false;
      };
      _proto.draw = function draw(ctx, comp) {
        var node = comp.node;
        var frame = comp._spriteFrame;
        var matrix = node._worldMatrix;
        var matrixm = matrix.m;
        var a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        ctx.transform(a, b, c, d, tx, ty);
        ctx.scale(1, -1);
        frame._rotated && ctx.rotate(-Math.PI / 2);
        utils.context.setGlobalAlpha(ctx, node.opacity / 255);
        var tex = frame._texture, verts = this._renderData.vertices;
        var image = utils.getColorizedImage(tex, node._color);
        var x = verts[0].x;
        var y = verts[0].y;
        var w = verts[1].x;
        var h = verts[1].y;
        y = -y - h;
        var sx = verts[0].u;
        var sy = verts[0].v;
        var sw = verts[1].u;
        var sh = verts[1].v;
        ctx.drawImage(image, sx, sy, sw, sh, x, y, w, h);
        return 1;
      };
      return CanvasSimpleSprite;
    })(_assembler["default"]);
    exports["default"] = CanvasSimpleSprite;
    module.exports = exports["default"];
  }), {
    "../../../assembler": 302,
    "../render-data": 316,
    "../utils": 321
  } ],
  319: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler = _interopRequireDefault(require("../../../assembler"));
    var _renderData = _interopRequireDefault(require("../render-data"));
    var _simple = _interopRequireDefault(require("./simple"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var utils = require("../utils");
    var CanvasSlicedSprite = (function(_CanvasSimpleSprite) {
      _inheritsLoose(CanvasSlicedSprite, _CanvasSimpleSprite);
      function CanvasSlicedSprite() {
        return _CanvasSimpleSprite.apply(this, arguments) || this;
      }
      var _proto = CanvasSlicedSprite.prototype;
      _proto.init = function init() {
        this._renderData = new _renderData["default"]();
        this._renderData.dataLength = 4;
      };
      _proto.updateUVs = function updateUVs(sprite) {
        var frame = sprite.spriteFrame;
        var renderData = this._renderData;
        var rect = frame._rect;
        var leftWidth = frame.insetLeft;
        var rightWidth = frame.insetRight;
        var centerWidth = rect.width - leftWidth - rightWidth;
        var topHeight = frame.insetTop;
        var bottomHeight = frame.insetBottom;
        var centerHeight = rect.height - topHeight - bottomHeight;
        var verts = renderData.vertices;
        if (frame._rotated) {
          verts[0].u = rect.x;
          verts[1].u = bottomHeight + rect.x;
          verts[2].u = bottomHeight + centerHeight + rect.x;
          verts[3].u = rect.x + rect.height;
          verts[3].v = rect.y;
          verts[2].v = leftWidth + rect.y;
          verts[1].v = leftWidth + centerWidth + rect.y;
          verts[0].v = rect.y + rect.width;
        } else {
          verts[0].u = rect.x;
          verts[1].u = leftWidth + rect.x;
          verts[2].u = leftWidth + centerWidth + rect.x;
          verts[3].u = rect.x + rect.width;
          verts[3].v = rect.y;
          verts[2].v = topHeight + rect.y;
          verts[1].v = topHeight + centerHeight + rect.y;
          verts[0].v = rect.y + rect.height;
        }
      };
      _proto.updateVerts = function updateVerts(sprite) {
        var renderData = this._renderData, verts = renderData.vertices, node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var frame = sprite.spriteFrame;
        var leftWidth = frame.insetLeft;
        var rightWidth = frame.insetRight;
        var topHeight = frame.insetTop;
        var bottomHeight = frame.insetBottom;
        var sizableWidth = width - leftWidth - rightWidth;
        var sizableHeight = height - topHeight - bottomHeight;
        var xScale = width / (leftWidth + rightWidth);
        var yScale = height / (topHeight + bottomHeight);
        xScale = isNaN(xScale) || xScale > 1 ? 1 : xScale;
        yScale = isNaN(yScale) || yScale > 1 ? 1 : yScale;
        sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
        sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
        if (frame._rotated) {
          verts[0].y = -appx;
          verts[0].x = -appy;
          verts[1].y = rightWidth * xScale - appx;
          verts[1].x = bottomHeight * yScale - appy;
          verts[2].y = verts[1].y + sizableWidth;
          verts[2].x = verts[1].x + sizableHeight;
          verts[3].y = width - appx;
          verts[3].x = height - appy;
        } else {
          verts[0].x = -appx;
          verts[0].y = -appy;
          verts[1].x = leftWidth * xScale - appx;
          verts[1].y = bottomHeight * yScale - appy;
          verts[2].x = verts[1].x + sizableWidth;
          verts[2].y = verts[1].y + sizableHeight;
          verts[3].x = width - appx;
          verts[3].y = height - appy;
        }
        sprite._vertsDirty = false;
      };
      _proto.draw = function draw(ctx, comp) {
        var node = comp.node;
        var frame = comp._spriteFrame;
        var matrix = node._worldMatrix;
        var matrixm = matrix.m;
        var a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        ctx.transform(a, b, c, d, tx, ty);
        ctx.scale(1, -1);
        frame._rotated && ctx.rotate(-Math.PI / 2);
        utils.context.setGlobalAlpha(ctx, node.opacity / 255);
        var tex = frame._texture, verts = this._renderData.vertices;
        var image = utils.getColorizedImage(tex, node._color);
        var drawCall = 0;
        var off, ld, rd, td, bd, x, y, w, h, sx, sy, sw, sh;
        for (var r = 0; r < 3; ++r) {
          bd = verts[r];
          td = verts[r + 1];
          for (var _c = 0; _c < 3; ++_c) {
            ld = verts[_c];
            rd = verts[_c + 1];
            x = ld.x;
            y = bd.y;
            w = rd.x - x;
            h = td.y - y;
            y = -y - h;
            sx = ld.u;
            sy = td.v;
            sw = rd.u - sx;
            sh = bd.v - sy;
            if (sw > 0 && sh > 0 && w > 0 && h > 0) {
              ctx.drawImage(image, sx, sy, sw, sh, x, y, w, h);
              drawCall++;
            }
          }
        }
        return drawCall;
      };
      return CanvasSlicedSprite;
    })(_simple["default"]);
    exports["default"] = CanvasSlicedSprite;
    module.exports = exports["default"];
  }), {
    "../../../assembler": 302,
    "../render-data": 316,
    "../utils": 321,
    "./simple": 318
  } ],
  320: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler = _interopRequireDefault(require("../../../assembler"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var utils = require("../utils");
    var CanvasTiledSprite = (function(_Assembler) {
      _inheritsLoose(CanvasTiledSprite, _Assembler);
      function CanvasTiledSprite() {
        return _Assembler.apply(this, arguments) || this;
      }
      var _proto = CanvasTiledSprite.prototype;
      _proto.draw = function draw(ctx, sprite) {
        var node = sprite.node;
        var matrix = node._worldMatrix;
        var matrixm = matrix.m;
        var a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        ctx.transform(a, b, c, d, tx, ty);
        ctx.scale(1, -1);
        utils.context.setGlobalAlpha(ctx, node.opacity / 255);
        var frame = sprite.spriteFrame;
        var rect = frame._rect;
        var tex = frame._texture;
        var sx = rect.x;
        var sy = rect.y;
        var sw = frame._rotated ? rect.height : rect.width;
        var sh = frame._rotated ? rect.width : rect.height;
        var image = utils.getFrameCache(tex, node._color, sx, sy, sw, sh);
        var w = node.width, h = node.height, x = -node.anchorX * w, y = -node.anchorY * h;
        y = -y - h;
        ctx.translate(x, y);
        ctx.fillStyle = ctx.createPattern(image, "repeat");
        ctx.fillRect(0, 0, w, h);
        return 1;
      };
      return CanvasTiledSprite;
    })(_assembler["default"]);
    exports["default"] = CanvasTiledSprite;
    module.exports = exports["default"];
  }), {
    "../../../assembler": 302,
    "../utils": 321
  } ],
  321: [ (function(require, module, exports) {
    "use strict";
    var WHITE = 16777215;
    var MAX_CANVAS_COUNT = 32;
    function colorizedFrame(canvas, texture, color, sx, sy, sw, sh) {
      var image = texture._image;
      var ctx = canvas.getContext("2d");
      canvas.width = sw;
      canvas.height = sh;
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = "rgb(" + color.r + "," + color.g + "," + color.b + ")";
      ctx.fillRect(0, 0, sw, sh);
      ctx.globalCompositeOperation = "multiply";
      ctx.drawImage(image, sx, sy, sw, sh, 0, 0, sw, sh);
      ctx.globalCompositeOperation = "destination-atop";
      ctx.drawImage(image, sx, sy, sw, sh, 0, 0, sw, sh);
      return canvas;
    }
    var canvasMgr = {
      canvasMap: {},
      canvasUsed: {},
      canvasPool: [],
      checking: false,
      check: function check() {
        var exist = false;
        for (var key in this.canvasUsed) {
          exist = true;
          if (this.canvasUsed[key]) this.canvasUsed[key] = false; else {
            var canvas = this.canvasMap[key];
            canvas.width = 0;
            canvas.height = 0;
            this.canvasPool.length < 32 && this.canvasPool.push(canvas);
            delete this.canvasMap[key];
            delete this.canvasUsed[key];
          }
        }
        if (!exist) {
          cc.director.off(cc.Director.EVENT_AFTER_DRAW, this.check, this);
          this.checking = false;
        }
      },
      startCheck: function startCheck() {
        cc.director.on(cc.Director.EVENT_AFTER_DRAW, this.check, this);
        this.checking = true;
      },
      getCanvas: function getCanvas(key) {
        this.canvasUsed[key] = true;
        return this.canvasMap[key];
      },
      cacheCanvas: function cacheCanvas(canvas, key) {
        this.canvasMap[key] = canvas;
        this.canvasUsed[key] = true;
        this.checking || this.startCheck();
      },
      dropImage: function dropImage(key) {
        this.canvasMap[key] && delete this.canvasMap[key];
      }
    };
    module.exports = {
      getColorizedImage: function getColorizedImage(texture, color) {
        if (!texture) return null;
        if (0 === texture.width || 0 === texture.height) return texture._image;
        var cval = 16777215 & color._val;
        if (cval === WHITE) return texture._image;
        var key = texture.nativeUrl + cval;
        var cache = canvasMgr.getCanvas(key);
        if (!cache) {
          cache = canvasMgr.canvasPool.pop() || document.createElement("canvas");
          colorizedFrame(cache, texture, color, 0, 0, texture.width, texture.height);
          canvasMgr.cacheCanvas(cache, key);
        }
        return cache;
      },
      getFrameCache: function getFrameCache(texture, color, sx, sy, sw, sh) {
        if (!texture || !texture.nativeUrl || sx < 0 || sy < 0 || sw <= 0 || sh <= 0) return null;
        var key = texture.nativeUrl;
        var generate = false;
        var cval = 16777215 & color._val;
        if (cval !== WHITE) {
          key += cval;
          generate = true;
        }
        if (0 !== sx || 0 !== sy && sw !== texture.width && sh !== texture.height) {
          key += "_" + sx + "_" + sy + "_" + sw + "_" + sh;
          generate = true;
        }
        if (!generate) return texture._image;
        var cache = canvasMgr.getCanvas(key);
        if (!cache) {
          cache = canvasMgr.canvasPool.pop() || document.createElement("canvas");
          colorizedFrame(cache, texture, color, sx, sy, sw, sh);
          canvasMgr.cacheCanvas(cache, key);
        }
        return cache;
      },
      dropColorizedImage: function dropColorizedImage(texture, color) {
        var key = texture.nativeUrl + (16777215 & color._val);
        canvasMgr.dropImage(key);
      }
    };
    var _globalAlpha = -1;
    var context = {
      setGlobalAlpha: function setGlobalAlpha(ctx, alpha) {
        if (_globalAlpha === alpha) return;
        _globalAlpha = alpha;
        ctx.globalAlpha = _globalAlpha;
      },
      reset: function reset() {
        _globalAlpha = -1;
      }
    };
    module.exports.context = context;
  }), {} ],
  322: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _gfx = _interopRequireDefault(require("../../renderer/gfx"));
    var _inputAssembler = _interopRequireDefault(require("../../renderer/core/input-assembler"));
    var _pass = _interopRequireDefault(require("../../renderer/core/pass"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _initBuiltins(device) {
      var defaultTexture = new _gfx["default"].Texture2D(device, {
        images: [],
        width: 128,
        height: 128,
        wrapS: _gfx["default"].WRAP_REPEAT,
        wrapT: _gfx["default"].WRAP_REPEAT,
        format: _gfx["default"].TEXTURE_FMT_RGB8,
        genMipmaps: false
      });
      return {
        defaultTexture: defaultTexture,
        programTemplates: [],
        programChunks: {}
      };
    }
    var _default = cc.renderer = {
      Texture2D: null,
      InputAssembler: _inputAssembler["default"],
      Pass: _pass["default"],
      renderEngine: null,
      canvas: null,
      device: null,
      scene: null,
      drawCalls: 0,
      _handle: null,
      _cameraNode: null,
      _camera: null,
      _forward: null,
      _flow: null,
      initWebGL: function initWebGL(canvas, opts) {
        require("./webgl/assemblers");
        var ModelBatcher = require("./webgl/model-batcher");
        this.Texture2D = _gfx["default"].Texture2D;
        this.canvas = canvas;
        this._flow = cc.RenderFlow;
        var Scene;
        var ForwardRenderer;
        var _builtins;
        true, true;
        this.device = _gfx["default"].Device.getInstance();
        this.scene = new renderer.Scene();
        var builtins = _initBuiltins(this.device);
        this._forward = new renderer.ForwardRenderer(this.device, builtins);
        var nativeFlow = new renderer.RenderFlow(this.device, this.scene, this._forward);
        this._flow.init(nativeFlow);
      },
      initCanvas: function initCanvas(canvas) {
        var canvasRenderer = require("./canvas");
        var Texture2D = require("./canvas/Texture2D");
        var Device = require("./canvas/Device");
        this.Device = Device;
        this.Texture2D = Texture2D;
        this.canvas = canvas;
        this.device = new Device(canvas);
        this._camera = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          tx: 0,
          ty: 0
        };
        this._handle = new canvasRenderer.RenderComponentHandle(this.device, this._camera);
        this._forward = new canvasRenderer.ForwardRenderer();
        this._flow = cc.RenderFlow;
        this._flow.init(this._handle, this._forward);
      },
      updateCameraViewport: function updateCameraViewport() {
        if (true, cc.director) {
          var ecScene = cc.director.getScene();
          ecScene && ecScene.setScale(1, 1, 1);
        }
        if (cc.game.renderType === cc.game.RENDER_TYPE_CANVAS) {
          var vp = cc.view.getViewportRect();
          this.device.setViewport(vp.x, vp.y, vp.width, vp.height);
          this._camera.a = cc.view.getScaleX();
          this._camera.d = cc.view.getScaleY();
          this._camera.tx = vp.x;
          this._camera.ty = vp.y + vp.height;
        }
      },
      render: function render(ecScene, dt) {
        this.device.resetDrawCalls();
        if (ecScene) {
          this._flow.render(ecScene, dt);
          this.drawCalls = this.device.getDrawCalls();
        }
      },
      clear: function clear() {
        this._handle.reset();
        this._forward.clear();
      }
    };
    exports["default"] = _default;
    module.exports = exports["default"];
  }), {
    "../../renderer/core/input-assembler": 423,
    "../../renderer/core/pass": 424,
    "../../renderer/gfx": 427,
    "../../renderer/renderers/forward-renderer": void 0,
    "../../renderer/scene/scene": void 0,
    "./canvas": 306,
    "./canvas/Device": 303,
    "./canvas/Texture2D": 304,
    "./webgl/assemblers": 334,
    "./webgl/model-batcher": void 0
  } ],
  323: [ (function(require, module, exports) {
    "use strict";
    var FlagOfset = 0;
    var DONOTHING = 1 << FlagOfset++;
    var BREAK_FLOW = 1 << FlagOfset++;
    var LOCAL_TRANSFORM = 1 << FlagOfset++;
    var WORLD_TRANSFORM = 1 << FlagOfset++;
    var TRANSFORM = LOCAL_TRANSFORM | WORLD_TRANSFORM;
    var UPDATE_RENDER_DATA = 1 << FlagOfset++;
    var OPACITY = 1 << FlagOfset++;
    var COLOR = 1 << FlagOfset++;
    var OPACITY_COLOR = OPACITY | COLOR;
    var RENDER = 1 << FlagOfset++;
    var CHILDREN = 1 << FlagOfset++;
    var POST_RENDER = 1 << FlagOfset++;
    var FINAL = 1 << FlagOfset++;
    var _batcher, _forward;
    var _cullingMask = 0;
    function RenderFlow() {
      this._func = init;
      this._next = null;
    }
    var _proto = RenderFlow.prototype;
    _proto._doNothing = function() {};
    _proto._localTransform = function(node) {
      node._updateLocalMatrix();
      node._renderFlag &= ~LOCAL_TRANSFORM;
      this._next._func(node);
    };
    _proto._worldTransform = function(node) {
      _batcher.worldMatDirty++;
      var t = node._matrix;
      var trs = node._trs;
      var tm = t.m;
      tm[12] = trs[0];
      tm[13] = trs[1];
      tm[14] = trs[2];
      node._mulMat(node._worldMatrix, node._parent._worldMatrix, t);
      node._renderFlag &= ~WORLD_TRANSFORM;
      this._next._func(node);
      _batcher.worldMatDirty--;
    };
    _proto._updateRenderData = function(node) {
      var comp = node._renderComponent;
      comp._assembler.updateRenderData(comp);
      node._renderFlag &= ~UPDATE_RENDER_DATA;
      this._next._func(node);
    };
    _proto._opacity = function(node) {
      _batcher.parentOpacityDirty++;
      this._next._func(node);
      node._renderFlag &= ~OPACITY;
      _batcher.parentOpacityDirty--;
    };
    _proto._color = function(node) {
      var comp = node._renderComponent;
      comp && comp._updateColor();
      node._renderFlag &= ~COLOR;
      this._next._func(node);
    };
    _proto._render = function(node) {
      var comp = node._renderComponent;
      comp._checkBacth(_batcher, node._cullingMask);
      comp._assembler.fillBuffers(comp, _batcher);
      this._next._func(node);
    };
    _proto._children = function(node) {
      var cullingMask = _cullingMask;
      var batcher = _batcher;
      var parentOpacity = batcher.parentOpacity;
      var opacity = batcher.parentOpacity *= node._opacity / 255;
      var worldTransformFlag = batcher.worldMatDirty ? WORLD_TRANSFORM : 0;
      var worldOpacityFlag = batcher.parentOpacityDirty ? OPACITY_COLOR : 0;
      var worldDirtyFlag = worldTransformFlag | worldOpacityFlag;
      var children = node._children;
      for (var i = 0, l = children.length; i < l; i++) {
        var c = children[i];
        c._renderFlag |= worldDirtyFlag;
        if (!c._activeInHierarchy || 0 === c._opacity) continue;
        _cullingMask = c._cullingMask = 0 === c.groupIndex ? cullingMask : 1 << c.groupIndex;
        var colorVal = c._color._val;
        c._color._fastSetA(c._opacity * opacity);
        flows[c._renderFlag]._func(c);
        c._color._val = colorVal;
      }
      batcher.parentOpacity = parentOpacity;
      this._next._func(node);
    };
    _proto._postRender = function(node) {
      var comp = node._renderComponent;
      comp._checkBacth(_batcher, node._cullingMask);
      comp._assembler.postFillBuffers(comp, _batcher);
      this._next._func(node);
    };
    var EMPTY_FLOW = new RenderFlow();
    EMPTY_FLOW._func = EMPTY_FLOW._doNothing;
    EMPTY_FLOW._next = EMPTY_FLOW;
    var flows = {};
    function createFlow(flag, next) {
      if (flag === DONOTHING || flag === BREAK_FLOW) return EMPTY_FLOW;
      var flow = new RenderFlow();
      flow._next = next || EMPTY_FLOW;
      switch (flag) {
       case LOCAL_TRANSFORM:
        flow._func = flow._localTransform;
        break;

       case WORLD_TRANSFORM:
        flow._func = flow._worldTransform;
        break;

       case UPDATE_RENDER_DATA:
        flow._func = flow._updateRenderData;
        break;

       case OPACITY:
        flow._func = flow._opacity;
        break;

       case COLOR:
        flow._func = flow._color;
        break;

       case RENDER:
        flow._func = flow._render;
        break;

       case CHILDREN:
        flow._func = flow._children;
        break;

       case POST_RENDER:
        flow._func = flow._postRender;
      }
      return flow;
    }
    function getFlow(flag) {
      var flow = null;
      var tFlag = FINAL;
      while (tFlag > 0) {
        tFlag & flag && (flow = createFlow(tFlag, flow));
        tFlag >>= 1;
      }
      return flow;
    }
    function init(node) {
      var flag = node._renderFlag;
      var r = flows[flag] = getFlow(flag);
      r._func(node);
    }
    RenderFlow.flows = flows;
    RenderFlow.createFlow = createFlow;
    var _validateList = [];
    RenderFlow.registerValidate = function(renderComp) {
      if (renderComp._inValidateList) return;
      _validateList.push(renderComp);
      renderComp._inValidateList = true;
    };
    RenderFlow.validateRenderers = function() {
      for (var i = 0, l = _validateList.length; i < l; i++) {
        var renderComp = _validateList[i];
        if (!renderComp.isValid) continue;
        renderComp.enabledInHierarchy ? renderComp._validateRender() : renderComp.disableRender();
        renderComp._inValidateList = false;
      }
      _validateList.length = 0;
    };
    RenderFlow.visitRootNode = function(rootNode) {
      RenderFlow.validateRenderers();
      var preCullingMask = _cullingMask;
      _cullingMask = rootNode._cullingMask;
      if (rootNode._renderFlag & WORLD_TRANSFORM) {
        _batcher.worldMatDirty++;
        rootNode._calculWorldMatrix();
        rootNode._renderFlag &= ~WORLD_TRANSFORM;
        flows[rootNode._renderFlag]._func(rootNode);
        _batcher.worldMatDirty--;
      } else flows[rootNode._renderFlag]._func(rootNode);
      _cullingMask = preCullingMask;
    };
    RenderFlow.render = function(rootNode, dt) {
      _batcher.reset();
      _batcher.walking = true;
      RenderFlow.visitRootNode(rootNode);
      _batcher.terminate();
      _batcher.walking = false;
      _forward.render(_batcher._renderScene, dt);
    };
    RenderFlow.renderCamera = function(camera, rootNode) {
      _batcher.reset();
      _batcher.walking = true;
      RenderFlow.visitRootNode(rootNode);
      _batcher.terminate();
      _batcher.walking = false;
      _forward.renderCamera(camera, _batcher._renderScene);
    };
    RenderFlow.init = function(batcher, forwardRenderer) {
      _batcher = batcher;
      _forward = forwardRenderer;
      flows[0] = EMPTY_FLOW;
      for (var i = 1; i < FINAL; i++) flows[i] = new RenderFlow();
    };
    RenderFlow.getBachther = function() {
      return _batcher;
    };
    RenderFlow.FLAG_DONOTHING = DONOTHING;
    RenderFlow.FLAG_BREAK_FLOW = BREAK_FLOW;
    RenderFlow.FLAG_LOCAL_TRANSFORM = LOCAL_TRANSFORM;
    RenderFlow.FLAG_WORLD_TRANSFORM = WORLD_TRANSFORM;
    RenderFlow.FLAG_TRANSFORM = TRANSFORM;
    RenderFlow.FLAG_UPDATE_RENDER_DATA = UPDATE_RENDER_DATA;
    RenderFlow.FLAG_OPACITY = OPACITY;
    RenderFlow.FLAG_COLOR = COLOR;
    RenderFlow.FLAG_OPACITY_COLOR = OPACITY_COLOR;
    RenderFlow.FLAG_RENDER = RENDER;
    RenderFlow.FLAG_CHILDREN = CHILDREN;
    RenderFlow.FLAG_POST_RENDER = POST_RENDER;
    RenderFlow.FLAG_FINAL = FINAL;
    module.exports = cc.RenderFlow = RenderFlow;
  }), {} ],
  324: [ (function(require, module, exports) {
    "use strict";
    var _reusableAtlas = require("./reusable-atlas");
    var _atlases = [];
    var _atlasIndex = -1;
    var _maxAtlasCount = -1;
    var _textureSize = 2048;
    var _maxFrameSize = 512;
    var _textureBleeding = true;
    var _autoMultiBatch = true;
    var _autoResetBeforeSceneLoad = true;
    var _debugNode = null;
    function newAtlas() {
      var atlas = _atlases[++_atlasIndex];
      if (!atlas) {
        atlas = new _reusableAtlas.Atlas(_textureSize, _textureSize);
        _atlases.push(atlas);
        dynamicAtlasManager.autoMultiBatch && cc.sp.multiBatcher.requsetMaterial(atlas._texture);
      }
      return atlas;
    }
    function beforeSceneLoad() {
      _autoResetBeforeSceneLoad && dynamicAtlasManager.reset();
    }
    var _enabled = false;
    var dynamicAtlasManager = {
      Atlas: _reusableAtlas.Atlas,
      Rect: _reusableAtlas.Rect,
      get enabled() {
        return _enabled;
      },
      set enabled(value) {
        if (_enabled === value) return;
        if (value) {
          this.reset();
          cc.director.on(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, beforeSceneLoad);
        } else cc.director.off(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, beforeSceneLoad);
        _enabled = value;
      },
      get maxAtlasCount() {
        return _maxAtlasCount;
      },
      set maxAtlasCount(value) {
        _maxAtlasCount = value;
      },
      get atlasCount() {
        return _atlases.length;
      },
      get textureBleeding() {
        return _textureBleeding;
      },
      set textureBleeding(enable) {
        _textureBleeding = enable;
      },
      get textureSize() {
        return _textureSize;
      },
      set textureSize(value) {
        _textureSize = value;
      },
      get maxFrameSize() {
        return _maxFrameSize;
      },
      set maxFrameSize(value) {
        value > _textureSize && (value = _textureSize);
        _maxFrameSize = value;
      },
      get autoMultiBatch() {
        return _autoMultiBatch;
      },
      set autoMultiBatch(enable) {
        if (_autoMultiBatch === enable) return;
        if (enable) for (var i = 0, l = _atlases.length; i < l; i++) cc.sp.multiBatcher.requsetMaterial(_atlases[i]._texture);
        _autoMultiBatch = enable;
      },
      get autoResetBeforeSceneLoad() {
        return _autoResetBeforeSceneLoad;
      },
      set autoResetBeforeSceneLoad(enable) {
        if (_autoResetBeforeSceneLoad === enable) return;
        _autoResetBeforeSceneLoad = enable;
      },
      get atlases() {
        return _atlases;
      },
      rects: Object.create(null),
      insertSpriteFrame: function insertSpriteFrame(spriteFrame) {
        false;
        if (!_enabled || !spriteFrame || spriteFrame._original) return null;
        var atlas, frame;
        var rect = spriteFrame._rect, texture = spriteFrame._texture, info = this.rects[texture._uuid];
        var sx = rect.x, sy = rect.y;
        if (info) {
          sx += info.x;
          sy += info.y;
          info.spriteFrames.push(spriteFrame);
          frame = {
            x: sx,
            y: sy,
            texture: info.atlas._texture
          };
          return frame;
        }
        for (var i = 0; i <= _atlasIndex; i++) {
          atlas = _atlases[i];
          frame = atlas.insertSpriteFrame(spriteFrame);
          if (frame) return frame;
        }
        if (_atlasIndex + 1 < _maxAtlasCount) {
          atlas = newAtlas();
          return atlas.insertSpriteFrame(spriteFrame);
        }
        return frame;
      },
      deleteSpriteFrame: function deleteSpriteFrame(spriteFrame) {
        if (spriteFrame && true && spriteFrame._original) {
          this.deleteAtlasSpriteFrame(spriteFrame);
          spriteFrame._resetDynamicAtlasFrame();
        }
      },
      deleteTexture: function deleteTexture(texture) {
        this.deleteAtlasTexture(texture);
      },
      reset: function reset() {
        for (var i = 0, l = _atlases.length; i < l; i++) _atlases[i].destroy();
        _atlases.length = 0;
        _atlasIndex = -1;
      },
      deleteAtlasSpriteFrame: function deleteAtlasSpriteFrame(spriteFrame) {
        if (!spriteFrame._original) return;
        var texture = spriteFrame._original._texture;
        for (var i = _atlases.length - 1; i >= 0; i--) if (_atlases[i].deleteSpriteFrame(texture, spriteFrame)) return;
      },
      deleteAtlasTexture: function deleteAtlasTexture(texture) {
        if (texture) for (var i = _atlases.length - 1; i >= 0; i--) if (_atlases[i].deleteInnerTexture(texture, true)) return;
      },
      showDebug: function showDebug(show) {
        if (show) {
          if (!_debugNode || !_debugNode.isValid) {
            var width = cc.visibleRect.width;
            var height = cc.visibleRect.height;
            _debugNode = new cc.Node("DYNAMIC_ATLAS_DEBUG_NODE");
            _debugNode.width = width;
            _debugNode.height = height;
            _debugNode.x = width / 2;
            _debugNode.y = height / 2;
            _debugNode.zIndex = cc.macro.MAX_ZINDEX;
            _debugNode.parent = cc.director.getScene();
            _debugNode.groupIndex = cc.Node.BuiltinGroupIndex.DEBUG;
            cc.Camera._setupDebugCamera();
            var scroll = _debugNode.addComponent(cc.ScrollView);
            var content = new cc.Node("CONTENT");
            var layout = content.addComponent(cc.Layout);
            layout.type = cc.Layout.Type.VERTICAL;
            layout.resizeMode = cc.Layout.ResizeMode.CONTAINER;
            content.parent = _debugNode;
            content.width = _textureSize;
            content.anchorY = 1;
            content.x = _textureSize;
            scroll.content = content;
            for (var i = 0; i <= _atlasIndex; i++) {
              var node = new cc.Node("ATLAS");
              var texture = _atlases[i]._texture;
              var spriteFrame = new cc.SpriteFrame();
              spriteFrame.setTexture(_atlases[i]._texture);
              var sprite = node.addComponent(cc.Sprite);
              sprite.spriteFrame = spriteFrame;
              node.parent = content;
            }
          }
          return _debugNode;
        }
        if (_debugNode) {
          _debugNode.parent = null;
          _debugNode = null;
        }
      },
      update: function update() {
        if (!this.enabled) return;
        for (var i = 0; i <= _atlasIndex; i++) _atlases[i].update();
      }
    };
    module.exports = cc.dynamicAtlasManager = dynamicAtlasManager;
  }), {
    "./reusable-atlas": 325
  } ],
  325: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.Rect = exports.Atlas = void 0;
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = "undefined" !== typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" === typeof o.length) {
        it && (o = it);
        var i = 0;
        return function() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if ("string" === typeof o) return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      "Object" === n && o.constructor && (n = o.constructor.name);
      if ("Map" === n || "Set" === n) return Array.from(o);
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      (null == len || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var RenderTexture = require("../../../assets/CCRenderTexture");
    var Rect = (function() {
      Rect.reuse = function reuse(atlas, width, height, x, y) {
        if (0 === this.pointer) {
          for (var i = 0; i < 128; i++) Rect.pool[i] = new Rect(atlas, 0, 0, 0, 0);
          this.pointer += 128;
        }
        this.pointer--;
        var rect = this.pool[this.pointer];
        rect.atlas = atlas;
        rect.width = width;
        rect.height = height;
        rect.x = x;
        rect.y = y;
        return rect;
      };
      Rect.recycle = function recycle(rect) {
        rect.atlas = void 0;
        rect.uuid = "";
        rect.spriteFrames.length = 0;
        rect.parentRect = void 0;
        rect.subRectA = void 0;
        rect.subRectB = void 0;
        rect.subRectC = void 0;
        rect.cacheIndex = -1;
        this.pool[this.pointer] = rect;
        this.pointer++;
      };
      function Rect(atlas, width, height, x, y) {
        this.atlas = void 0;
        this.width = 0;
        this.height = 0;
        this.x = 0;
        this.y = 0;
        this.cacheIndex = -1;
        this.uuid = "";
        this.spriteFrames = [];
        this.parentRect = void 0;
        this.subRectA = void 0;
        this.subRectB = void 0;
        this.subRectC = void 0;
        this.used = 0;
        this.atlas = atlas;
        this.width = width;
        this.height = height;
        this.x = x;
        this.y = y;
      }
      _createClass(Rect, [ {
        key: "sizes",
        get: function get() {
          return this.width * this.height;
        }
      } ]);
      return Rect;
    })();
    exports.Rect = Rect;
    Rect.pool = [];
    Rect.pointer = 0;
    var Atlas = (function() {
      function Atlas(width, height, padding, border) {
        void 0 === padding && (padding = 2);
        void 0 === border && (border = 2);
        this.width = 0;
        this.height = 0;
        this.padding = 0;
        this.border = 0;
        this.rootRect = void 0;
        this.freeRects = [];
        this._count = 0;
        this._texture = void 0;
        this._dirty = false;
        var texture = new RenderTexture();
        texture.initWithSize(width, height);
        texture.update();
        this._texture = texture;
        this.width = width;
        this.height = height;
        this.padding = padding;
        this.border = border;
        this.rootRect = Rect.reuse(this, this.width + this.padding - 2 * this.border, this.height + this.padding - 2 * this.border, this.border, this.border);
        this.pushFreeRect(this.rootRect);
      }
      var _proto = Atlas.prototype;
      _proto.pushFreeRect = function pushFreeRect(rect) {
        var i = this.freeRects.push(rect) - 1;
        rect.cacheIndex = i;
      };
      _proto.removeFreeRect = function removeFreeRect(index) {
        var temp = this.freeRects[index];
        var temp2 = this.freeRects[this.freeRects.length - 1];
        temp2.cacheIndex = index;
        temp.cacheIndex = -1;
        this.freeRects[index] = temp2;
        this.freeRects.pop();
      };
      _proto.replaceFreeRect = function replaceFreeRect(index, rect) {
        this.freeRects[index].cacheIndex = -1;
        rect.cacheIndex = index;
        this.freeRects[index] = rect;
      };
      _proto.insertSpriteFrame = function insertSpriteFrame(spriteFrame) {
        var rect = spriteFrame._rect, texture = spriteFrame._texture;
        var sx = rect.x, sy = rect.y;
        var width = texture.width, height = texture.height;
        if (0 === this.rootRect.used && width > this.rootRect.width && height > this.rootRect.height) return this.insertSpriteFrameMax(spriteFrame);
        var result = this.insert(texture);
        if (!result) return null;
        if (cc.dynamicAtlasManager.textureBleeding) {
          if (width <= 8 || height <= 8) {
            this._texture.drawTextureAt(texture, result.x - 1, result.y - 1);
            this._texture.drawTextureAt(texture, result.x - 1, result.y + 1);
            this._texture.drawTextureAt(texture, result.x + 1, result.y - 1);
            this._texture.drawTextureAt(texture, result.x + 1, result.y + 1);
          }
          this._texture.drawTextureAt(texture, result.x - 1, result.y);
          this._texture.drawTextureAt(texture, result.x + 1, result.y);
          this._texture.drawTextureAt(texture, result.x, result.y - 1);
          this._texture.drawTextureAt(texture, result.x, result.y + 1);
        }
        this._texture.drawTextureAt(texture, result.x, result.y);
        this._count++;
        sx += result.x;
        sy += result.y;
        result.spriteFrames.push(spriteFrame);
        this._dirty = true;
        var frame = {
          x: sx,
          y: sy,
          texture: this._texture
        };
        return frame;
      };
      _proto.insertSpriteFrameMax = function insertSpriteFrameMax(spriteFrame) {
        var rect = spriteFrame._rect;
        var texture = spriteFrame._texture;
        var original = this.rootRect;
        original.uuid = texture._uuid;
        original.used++;
        original.parentRect && original.parentRect.used++;
        cc.dynamicAtlasManager.rects[texture._uuid] = original;
        this.removeFreeRect(0);
        this._texture.drawTextureAt(texture, 0, 0);
        this._count++;
        original.spriteFrames.push(spriteFrame);
        this._dirty = true;
        var frame = {
          x: rect.x,
          y: rect.y,
          texture: this._texture
        };
        return frame;
      };
      _proto.insert = function insert(texture) {
        var width = texture.width + this.padding, height = texture.height + this.padding;
        var score = Number.MAX_VALUE;
        var areaFit = 0;
        var original = void 0;
        var originalIndex = 0;
        for (var i = 0; i < this.freeRects.length; i++) {
          var rect = this.freeRects[i];
          if (rect.width >= width && rect.height >= height) {
            areaFit = rect.sizes - width * height;
            if (areaFit < score) {
              original = rect;
              originalIndex = i;
              score = areaFit;
            }
          }
        }
        if (original) {
          if (original.width === width && original.height === height) {
            original.uuid = texture._uuid;
            original.used++;
            original.parentRect && original.parentRect.used++;
            cc.dynamicAtlasManager.rects[texture._uuid] = original;
            this.removeFreeRect(originalIndex);
            return original;
          }
          var best = Rect.reuse(this, width, height, original.x, original.y);
          var tmp;
          if (best.y + best.height < original.y + original.height) {
            tmp = Rect.reuse(this, original.width, original.y + original.height - (best.y + best.height), original.x, best.y + best.height);
            tmp.parentRect = original;
            original.subRectB = tmp;
            if (tmp.width > Atlas.ignoreRectSize && tmp.height > Atlas.ignoreRectSize) {
              this.replaceFreeRect(originalIndex, tmp);
              originalIndex = -1;
            }
          }
          if (best.x + best.width < original.x + original.width) {
            tmp = Rect.reuse(this, original.x + original.width - (best.x + best.width), original.height - (original.y + original.height - (best.y + best.height)), best.x + best.width, original.y);
            tmp.parentRect = original;
            original.subRectC = tmp;
            if (tmp.width > Atlas.ignoreRectSize && tmp.height > Atlas.ignoreRectSize) if (-1 !== originalIndex) {
              this.replaceFreeRect(originalIndex, tmp);
              originalIndex = -1;
            } else this.pushFreeRect(tmp);
          }
          -1 !== originalIndex && this.removeFreeRect(originalIndex);
          best.parentRect = original;
          original.subRectA = best;
          best.used++;
          original.used++;
          1 === original.used && original.parentRect && original.parentRect.used++;
          best.uuid = texture._uuid;
          cc.dynamicAtlasManager.rects[texture._uuid] = best;
          return best;
        }
        return;
      };
      _proto.update = function update() {
        if (!this._dirty) return;
        this._texture.update();
        this._dirty = false;
      };
      _proto.deleteSpriteFrame = function deleteSpriteFrame(texture, frame) {
        if (texture) {
          var rect = cc.dynamicAtlasManager.rects[texture._uuid];
          if (rect) {
            var index = rect.spriteFrames.indexOf(frame);
            if (-1 !== index) {
              rect.spriteFrames.splice(index, 1);
              0 === rect.spriteFrames.length && rect.atlas.deleteInnerRect(rect);
            } else cc.warn("[Dynamic Atlas] can't find spriteFrame in Rect.");
            return true;
          }
        }
        return false;
      };
      _proto.deleteInnerRect = function deleteInnerRect(rect) {
        delete cc.dynamicAtlasManager.rects[rect.uuid];
        rect.uuid = "";
        this._count--;
        for (var _iterator = _createForOfIteratorHelperLoose(rect.spriteFrames), _step; !(_step = _iterator()).done; ) {
          var spriteFrame = _step.value;
          spriteFrame.isValid && spriteFrame._resetDynamicAtlasFrame();
        }
        rect.spriteFrames.length = 0;
        this.tryMergeRecycle(rect);
      };
      _proto.deleteInnerTexture = function deleteInnerTexture(texture) {
        if (texture) {
          var rect = cc.dynamicAtlasManager.rects[texture._uuid];
          if (rect) {
            rect.atlas.deleteInnerRect(rect);
            return true;
          }
        }
        return false;
      };
      _proto.tryMergeRecycle = function tryMergeRecycle(rect) {
        var old = void 0;
        var parent = rect;
        while (parent) {
          parent.used--;
          if (0 === parent.used) {
            if (parent.subRectA) {
              var i = parent.subRectA.cacheIndex;
              -1 !== i && this.removeFreeRect(i);
              Rect.recycle(parent.subRectA);
              parent.subRectA = void 0;
            }
            if (parent.subRectB) {
              var _i = parent.subRectB.cacheIndex;
              -1 !== _i && this.removeFreeRect(_i);
              Rect.recycle(parent.subRectB);
              parent.subRectB = void 0;
            }
            if (parent.subRectC) {
              var _i2 = parent.subRectC.cacheIndex;
              -1 !== _i2 && this.removeFreeRect(_i2);
              Rect.recycle(parent.subRectC);
              parent.subRectC = void 0;
            }
            old = parent;
            parent = parent.parentRect;
          } else {
            old && old.width > Atlas.ignoreRectSize && old.height > Atlas.ignoreRectSize && this.pushFreeRect(old);
            old = parent;
            parent = void 0;
          }
        }
        old === this.rootRect && 0 === old.used && this.pushFreeRect(old);
      };
      _proto.isEmpty = function isEmpty() {
        return this._count <= 0;
      };
      _proto.reset = function reset() {
        var rects = cc.dynamicAtlasManager.rects;
        for (var key in rects) {
          var rect = rects[key];
          if (rect.atlas === this) {
            delete rects[key];
            for (var _iterator2 = _createForOfIteratorHelperLoose(rect.spriteFrames), _step2; !(_step2 = _iterator2()).done; ) {
              var spriteFrame = _step2.value;
              spriteFrame.isValid && spriteFrame._resetDynamicAtlasFrame();
            }
            Rect.recycle(rect);
          }
        }
        for (var _iterator3 = _createForOfIteratorHelperLoose(this.freeRects), _step3; !(_step3 = _iterator3()).done; ) {
          var _rect = _step3.value;
          Rect.recycle(_rect);
        }
        this.freeRects.length = 0;
        this._count = 0;
        this.rootRect = Rect.reuse(this, this.width + this.padding - 2 * this.border, this.height + this.padding - 2 * this.border, this.border, this.border);
        this.pushFreeRect(this.rootRect);
      };
      _proto.destroy = function destroy() {
        this.reset();
        this._texture.destroy();
      };
      return Atlas;
    })();
    exports.Atlas = Atlas;
    Atlas.ignoreRectSize = 10;
    Atlas.DEFAULT_HASH = new RenderTexture()._getHash();
  }), {
    "../../../assets/CCRenderTexture": 145
  } ],
  326: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler2d = _interopRequireDefault(require("../../assembler-2d"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var textUtils = require("../../../utils/text-utils");
    var macro = require("../../../platform/CCMacro");
    var Label = require("../../../components/CCLabel");
    var Overflow = Label.Overflow;
    var shareLabelInfo = require("../utils").shareLabelInfo;
    var LetterInfo = function LetterInfo() {
      this["char"] = "";
      this.valid = true;
      this.x = 0;
      this.y = 0;
      this.line = 0;
      this.hash = "";
    };
    var _tmpRect = cc.rect();
    var _comp = null;
    var _horizontalKernings = [];
    var _lettersInfo = [];
    var _linesWidth = [];
    var _linesOffsetX = [];
    var _fntConfig = null;
    var _numberOfLines = 0;
    var _textDesiredHeight = 0;
    var _letterOffsetY = 0;
    var _tailoredTopY = 0;
    var _tailoredBottomY = 0;
    var _bmfontScale = 1;
    var _lineBreakWithoutSpaces = false;
    var _spriteFrame = null;
    var _lineSpacing = 0;
    var _contentSize = cc.size();
    var _string = "";
    var _fontSize = 0;
    var _originFontSize = 0;
    var _hAlign = 0;
    var _vAlign = 0;
    var _spacingX = 0;
    var _lineHeight = 0;
    var _overflow = 0;
    var _isWrapText = false;
    var _labelWidth = 0;
    var _labelHeight = 0;
    var _maxLineWidth = 0;
    var _isRetina = false;
    var _retinaScale = 1;
    var BmfontAssembler = (function(_Assembler2D) {
      _inheritsLoose(BmfontAssembler, _Assembler2D);
      function BmfontAssembler() {
        return _Assembler2D.apply(this, arguments) || this;
      }
      var _proto = BmfontAssembler.prototype;
      _proto.updateRenderData = function updateRenderData(comp) {
        if (!comp._vertsDirty) return;
        if (_comp === comp) return;
        _comp = comp;
        this._reserveQuads(comp, comp.string.toString().length);
        var assemblerChanged = this._updateFontFamily(comp);
        assemblerChanged || this._aftUpdateRenderData(comp);
        return assemblerChanged;
      };
      _proto._preUpdateRenderData = function _preUpdateRenderData(comp) {
        _comp = comp;
        this._reserveQuads(comp, comp.string.toString().length);
        var fontAsset = comp.font;
        _spriteFrame = fontAsset.spriteFrame;
        _fntConfig = fontAsset._fntConfig;
        shareLabelInfo.fontAtlas = fontAsset._fontDefDictionary;
      };
      _proto._aftUpdateRenderData = function _aftUpdateRenderData(comp) {
        this._updateProperties(comp);
        this._updateLabelInfo(comp);
        this._updateContent();
        this.updateWorldVerts(comp);
        if (_isRetina) {
          _contentSize.width /= _retinaScale;
          _contentSize.height /= _retinaScale;
          _fontSize /= _retinaScale;
        }
        _comp._actualFontSize = _fontSize;
        _comp.node.setContentSize(_contentSize);
        _comp._vertsDirty = false;
        _comp = null;
        this._resetProperties();
      };
      _proto._updateFontScale = function _updateFontScale() {
        _bmfontScale = _fontSize / _originFontSize;
      };
      _proto._updateFontFamily = function _updateFontFamily(comp) {
        var fontAsset = comp.font;
        _spriteFrame = fontAsset.spriteFrame;
        _fntConfig = fontAsset._fntConfig;
        shareLabelInfo.fontAtlas = fontAsset._fontDefDictionary;
        return this.packDynamicAtlasAndCheckMaterial(comp, _spriteFrame);
      };
      _proto._updateLabelInfo = function _updateLabelInfo() {
        shareLabelInfo.hash = "";
        shareLabelInfo.margin = 0;
      };
      _proto.getTTFTextureSizeScale = function getTTFTextureSizeScale() {
        return _isRetina ? _retinaScale : 1;
      };
      _proto._updateProperties = function _updateProperties(comp) {
        _string = comp.string.toString();
        _isRetina = !(comp.font instanceof cc.BitmapFont) && cc.sp.enableLabelRetina && 0 === comp.enableRetina || 1 === comp.enableRetina;
        _retinaScale = cc.sp.labelRetinaScale;
        _fontSize = comp.fontSize;
        _originFontSize = _fntConfig ? _fntConfig.fontSize : comp.fontSize;
        _hAlign = comp.horizontalAlign;
        _vAlign = comp.verticalAlign;
        _spacingX = comp.spacingX;
        _overflow = comp.overflow;
        _lineHeight = comp._lineHeight;
        _contentSize.width = comp.node.width;
        _contentSize.height = comp.node.height;
        if (_isRetina) {
          _fontSize *= _retinaScale;
          _fntConfig || (_originFontSize *= _retinaScale);
          _contentSize.width *= _retinaScale;
          _contentSize.height *= _retinaScale;
          _lineHeight *= _retinaScale;
          shareLabelInfo.margin *= _retinaScale;
        }
        if (_overflow === Overflow.NONE) {
          _isWrapText = false;
          _contentSize.width += 2 * shareLabelInfo.margin;
          _contentSize.height += 2 * shareLabelInfo.margin;
        } else if (_overflow === Overflow.RESIZE_HEIGHT) {
          _isWrapText = true;
          _contentSize.height += 2 * shareLabelInfo.margin;
        } else _isWrapText = comp.enableWrapText;
        shareLabelInfo.lineHeight = _lineHeight;
        shareLabelInfo.fontSize = _fontSize;
        this._setupBMFontOverflowMetrics();
      };
      _proto._resetProperties = function _resetProperties() {
        _fntConfig = null;
        _spriteFrame = null;
        shareLabelInfo.hash = "";
        shareLabelInfo.margin = 0;
      };
      _proto._updateContent = function _updateContent() {
        this._updateFontScale();
        this._computeHorizontalKerningForText();
        this._alignText();
      };
      _proto._computeHorizontalKerningForText = function _computeHorizontalKerningForText() {
        var string = _string;
        var stringLen = string.length;
        var horizontalKernings = _horizontalKernings;
        var kerningDict;
        _fntConfig && (kerningDict = _fntConfig.kerningDict);
        if (kerningDict && !cc.js.isEmptyObject(kerningDict)) {
          var prev = -1;
          for (var i = 0; i < stringLen; ++i) {
            var key = string.charCodeAt(i);
            var kerningAmount = kerningDict[prev << 16 | 65535 & key] || 0;
            horizontalKernings[i] = i < stringLen - 1 ? kerningAmount : 0;
            prev = key;
          }
        } else horizontalKernings.length = 0;
      };
      _proto._multilineTextWrap = function _multilineTextWrap(nextTokenFunc) {
        var textLen = _string.length;
        var lineIndex = 0;
        var nextTokenX = 0;
        var nextTokenY = 0;
        var longestLine = 0;
        var letterRight = 0;
        var highestY = 0;
        var lowestY = 0;
        var letterDef = null;
        var letterPosition = cc.v2(0, 0);
        for (var index = 0; index < textLen; ) {
          var character = _string.charAt(index);
          if ("\n" === character) {
            _linesWidth.push(letterRight);
            letterRight = 0;
            lineIndex++;
            nextTokenX = 0;
            nextTokenY -= _lineHeight * this._getFontScale() + _lineSpacing;
            this._recordPlaceholderInfo(index, character);
            index++;
            continue;
          }
          var tokenLen = nextTokenFunc(_string, index, textLen);
          var tokenHighestY = highestY;
          var tokenLowestY = lowestY;
          var tokenRight = letterRight;
          var nextLetterX = nextTokenX;
          var newLine = false;
          for (var tmp = 0; tmp < tokenLen; ++tmp) {
            var letterIndex = index + tmp;
            character = _string.charAt(letterIndex);
            if ("\r" === character) {
              this._recordPlaceholderInfo(letterIndex, character);
              continue;
            }
            letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);
            if (!letterDef) {
              this._recordPlaceholderInfo(letterIndex, character);
              var atlasName = "";
              _fntConfig && (atlasName = _fntConfig.atlasName);
              console.log("Can't find letter definition in texture atlas " + atlasName + " for letter:" + character);
              continue;
            }
            var letterX = nextLetterX + letterDef.offsetX * _bmfontScale - shareLabelInfo.margin;
            if (_isWrapText && _maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef.w * _bmfontScale > _maxLineWidth && !textUtils.isUnicodeSpace(character)) {
              _linesWidth.push(letterRight);
              letterRight = 0;
              lineIndex++;
              nextTokenX = 0;
              nextTokenY -= _lineHeight * this._getFontScale() + _lineSpacing;
              newLine = true;
              break;
            }
            letterPosition.x = letterX;
            letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale + shareLabelInfo.margin;
            this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex);
            letterIndex + 1 < _horizontalKernings.length && letterIndex < textLen - 1 && (nextLetterX += _horizontalKernings[letterIndex + 1]);
            nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX - 2 * shareLabelInfo.margin;
            tokenRight = letterPosition.x + letterDef.w * _bmfontScale - shareLabelInfo.margin;
            tokenHighestY < letterPosition.y && (tokenHighestY = letterPosition.y);
            tokenLowestY > letterPosition.y - letterDef.h * _bmfontScale && (tokenLowestY = letterPosition.y - letterDef.h * _bmfontScale);
          }
          if (newLine) continue;
          nextTokenX = nextLetterX;
          letterRight = tokenRight;
          highestY < tokenHighestY && (highestY = tokenHighestY);
          lowestY > tokenLowestY && (lowestY = tokenLowestY);
          longestLine < letterRight && (longestLine = letterRight);
          index += tokenLen;
        }
        this._finishMultilineTextWrap();
        _linesWidth.push(letterRight);
        _numberOfLines = lineIndex + 1;
        _textDesiredHeight = _numberOfLines * _lineHeight * this._getFontScale();
        _numberOfLines > 1 && (_textDesiredHeight += (_numberOfLines - 1) * _lineSpacing);
        _contentSize.width = _labelWidth;
        _contentSize.height = _labelHeight;
        _labelWidth <= 0 && (_contentSize.width = parseFloat(longestLine.toFixed(2)) + 2 * shareLabelInfo.margin);
        _labelHeight <= 0 && (_contentSize.height = parseFloat(_textDesiredHeight.toFixed(2)) + 2 * shareLabelInfo.margin);
        _tailoredTopY = _contentSize.height;
        _tailoredBottomY = 0;
        if (_overflow !== Overflow.CLAMP) {
          highestY > 0 && (_tailoredTopY = _contentSize.height + highestY);
          lowestY < -_textDesiredHeight && (_tailoredBottomY = _textDesiredHeight + lowestY);
        }
        return true;
      };
      _proto._getFirstCharLen = function _getFirstCharLen() {
        return 1;
      };
      _proto._getFontScale = function _getFontScale() {
        return _overflow === Overflow.SHRINK ? _bmfontScale : 1;
      };
      _proto._getFirstWordLen = function _getFirstWordLen(text, startIndex, textLen) {
        var character = text.charAt(startIndex);
        if (textUtils.isUnicodeCJK(character) || "\n" === character || textUtils.isUnicodeSpace(character)) return 1;
        var len = 1;
        var letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);
        if (!letterDef) return len;
        var nextLetterX = letterDef.xAdvance * _bmfontScale + _spacingX;
        var letterX;
        for (var index = startIndex + 1; index < textLen; ++index) {
          character = text.charAt(index);
          letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);
          if (!letterDef) break;
          letterX = nextLetterX + letterDef.offsetX * _bmfontScale;
          if (letterX + letterDef.w * _bmfontScale > _maxLineWidth && !textUtils.isUnicodeSpace(character) && _maxLineWidth > 0) return len;
          nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX;
          if ("\n" === character || textUtils.isUnicodeSpace(character) || textUtils.isUnicodeCJK(character)) break;
          len++;
        }
        return len;
      };
      _proto._multilineTextWrapByWord = function _multilineTextWrapByWord() {
        return this._multilineTextWrap(this._getFirstWordLen);
      };
      _proto._multilineTextWrapByChar = function _multilineTextWrapByChar() {
        return this._multilineTextWrap(this._getFirstCharLen);
      };
      _proto._recordPlaceholderInfo = function _recordPlaceholderInfo(letterIndex, _char) {
        if (letterIndex >= _lettersInfo.length) {
          var tmpInfo = new LetterInfo();
          _lettersInfo.push(tmpInfo);
        }
        _lettersInfo[letterIndex]["char"] = _char;
        _lettersInfo[letterIndex].hash = _char.charCodeAt(0) + shareLabelInfo.hash;
        _lettersInfo[letterIndex].valid = false;
      };
      _proto._recordLetterInfo = function _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
        if (letterIndex >= _lettersInfo.length) {
          var tmpInfo = new LetterInfo();
          _lettersInfo.push(tmpInfo);
        }
        var _char2 = character.charCodeAt(0);
        var key = _char2 + shareLabelInfo.hash;
        _lettersInfo[letterIndex].line = lineIndex;
        _lettersInfo[letterIndex]["char"] = character;
        _lettersInfo[letterIndex].hash = key;
        _lettersInfo[letterIndex].valid = shareLabelInfo.fontAtlas.getLetter(key).valid;
        _lettersInfo[letterIndex].x = letterPosition.x;
        _lettersInfo[letterIndex].y = letterPosition.y;
      };
      _proto._alignText = function _alignText() {
        _textDesiredHeight = 0;
        _linesWidth.length = 0;
        _lineBreakWithoutSpaces ? this._multilineTextWrapByChar() : this._multilineTextWrapByWord();
        this._computeAlignmentOffset();
        _overflow === Overflow.SHRINK && _fontSize > 0 && this._isVerticalClamp() && this._shrinkLabelToContentSize(this._isVerticalClamp);
        this._updateQuads() || _overflow === Overflow.SHRINK && this._shrinkLabelToContentSize(this._isHorizontalClamp);
      };
      _proto._scaleFontSizeDown = function _scaleFontSizeDown(fontSize) {
        var shouldUpdateContent = true;
        if (!fontSize) {
          fontSize = .1;
          shouldUpdateContent = false;
        }
        _fontSize = fontSize;
        shouldUpdateContent && this._updateContent();
      };
      _proto._shrinkLabelToContentSize = function _shrinkLabelToContentSize(lambda) {
        var fontSize = _fontSize;
        var left = 0, right = 0 | fontSize, mid = 0;
        while (left < right) {
          mid = left + right + 1 >> 1;
          var newFontSize = mid;
          if (newFontSize <= 0) break;
          _bmfontScale = newFontSize / _originFontSize;
          _lineBreakWithoutSpaces ? this._multilineTextWrapByChar() : this._multilineTextWrapByWord();
          this._computeAlignmentOffset();
          lambda() ? right = mid - 1 : left = mid;
        }
        var actualFontSize = left;
        actualFontSize >= 0 && this._scaleFontSizeDown(actualFontSize);
      };
      _proto._isVerticalClamp = function _isVerticalClamp() {
        return _textDesiredHeight > _contentSize.height;
      };
      _proto._isHorizontalClamp = function _isHorizontalClamp() {
        var letterClamp = false;
        for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
          var letterInfo = _lettersInfo[ctr];
          if (letterInfo.valid) {
            var letterDef = shareLabelInfo.fontAtlas.getLetter(letterInfo.hash);
            var px = letterInfo.x + letterDef.w * _bmfontScale;
            var lineIndex = letterInfo.line;
            if (_labelWidth > 0) if (_isWrapText) {
              var wordWidth = _linesWidth[lineIndex];
              if (wordWidth > _contentSize.width && (px > _contentSize.width || px < 0)) {
                letterClamp = true;
                break;
              }
            } else if (px > _contentSize.width) {
              letterClamp = true;
              break;
            }
          }
        }
        return letterClamp;
      };
      _proto._isHorizontalClamped = function _isHorizontalClamped(px, lineIndex) {
        var wordWidth = _linesWidth[lineIndex];
        var letterOverClamp = px > _contentSize.width || px < 0;
        return _isWrapText ? wordWidth > _contentSize.width && letterOverClamp : letterOverClamp;
      };
      _proto._updateQuads = function _updateQuads() {
        var texture = _spriteFrame ? _spriteFrame._texture : shareLabelInfo.fontAtlas.getTexture();
        var node = _comp.node;
        this.verticesCount = this.indicesCount = 0;
        this._renderData && (this._renderData.dataLength = 0);
        var contentSize = _contentSize, appx = node._anchorPoint.x * contentSize.width, appy = node._anchorPoint.y * contentSize.height;
        var ret = true;
        for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
          var letterInfo = _lettersInfo[ctr];
          if (!letterInfo.valid) continue;
          var letterDef = shareLabelInfo.fontAtlas.getLetter(letterInfo.hash);
          _tmpRect.height = letterDef.h;
          _tmpRect.width = letterDef.w;
          _tmpRect.x = letterDef.u;
          _tmpRect.y = letterDef.v;
          var py = letterInfo.y + _letterOffsetY;
          if (_labelHeight > 0) {
            if (py > _tailoredTopY) {
              var clipTop = py - _tailoredTopY;
              _tmpRect.y += clipTop;
              _tmpRect.height -= clipTop;
              py -= clipTop;
            }
            py - letterDef.h * _bmfontScale < _tailoredBottomY && _overflow === Overflow.CLAMP && (_tmpRect.height = py < _tailoredBottomY ? 0 : (py - _tailoredBottomY) / _bmfontScale);
          }
          var lineIndex = letterInfo.line;
          var px = letterInfo.x + letterDef.w / 2 * _bmfontScale + _linesOffsetX[lineIndex];
          if (_labelWidth > 0 && this._isHorizontalClamped(px, lineIndex)) if (_overflow === Overflow.CLAMP) _tmpRect.width = 0; else if (_overflow === Overflow.SHRINK) {
            if (_contentSize.width > letterDef.w) {
              ret = false;
              break;
            }
            _tmpRect.width = 0;
          }
          if (_tmpRect.height > 0 && _tmpRect.width > 0) {
            var isRotated = this._determineRect(_tmpRect);
            var letterPositionX = letterInfo.x + _linesOffsetX[letterInfo.line];
            this.appendQuad(_comp, texture, _tmpRect, isRotated, letterPositionX - appx, py - appy, _bmfontScale, letterDef);
          }
        }
        this._quadsUpdated(_comp);
        return ret;
      };
      _proto._determineRect = function _determineRect(tempRect) {
        var isRotated = _spriteFrame.isRotated();
        var originalSize = _spriteFrame._originalSize;
        var rect = _spriteFrame._rect;
        var offset = _spriteFrame._offset;
        var trimmedLeft = offset.x + (originalSize.width - rect.width) / 2;
        var trimmedTop = offset.y - (originalSize.height - rect.height) / 2;
        if (isRotated) {
          var originalX = tempRect.x;
          tempRect.x = rect.x + rect.height - tempRect.y - tempRect.height - trimmedTop;
          tempRect.y = originalX + rect.y - trimmedLeft;
          tempRect.y < 0 && (tempRect.height = tempRect.height + trimmedTop);
        } else {
          tempRect.x += rect.x - trimmedLeft;
          tempRect.y += rect.y + trimmedTop;
        }
        return isRotated;
      };
      _proto._computeAlignmentOffset = function _computeAlignmentOffset() {
        _linesOffsetX.length = 0;
        switch (_hAlign) {
         case macro.TextAlignment.LEFT:
          for (var i = 0; i < _numberOfLines; ++i) _linesOffsetX.push(0);
          break;

         case macro.TextAlignment.CENTER:
          for (var _i = 0, l = _linesWidth.length; _i < l; _i++) _linesOffsetX.push((_contentSize.width - _linesWidth[_i]) / 2);
          break;

         case macro.TextAlignment.RIGHT:
          for (var _i2 = 0, _l = _linesWidth.length; _i2 < _l; _i2++) _linesOffsetX.push(_contentSize.width - _linesWidth[_i2]);
        }
        _letterOffsetY = _contentSize.height;
        if (_vAlign !== macro.VerticalTextAlignment.TOP) {
          var blank = _contentSize.height - _textDesiredHeight + _lineHeight * this._getFontScale() - _originFontSize * _bmfontScale;
          _vAlign === macro.VerticalTextAlignment.BOTTOM ? _letterOffsetY -= blank : _letterOffsetY -= blank / 2;
        }
      };
      _proto._setupBMFontOverflowMetrics = function _setupBMFontOverflowMetrics() {
        var newWidth = _contentSize.width, newHeight = _contentSize.height;
        _overflow === Overflow.RESIZE_HEIGHT && (newHeight = 0);
        if (_overflow === Overflow.NONE) {
          newWidth = 0;
          newHeight = 0;
        }
        _labelWidth = newWidth;
        _labelHeight = newHeight;
        _maxLineWidth = newWidth;
      };
      _proto.updateWorldVerts = function updateWorldVerts() {};
      _proto.appendQuad = function appendQuad(comp, texture, rect, rotated, x, y, scale, letter) {};
      _proto._quadsUpdated = function _quadsUpdated(comp) {};
      _proto._reserveQuads = function _reserveQuads() {};
      _proto._finishMultilineTextWrap = function _finishMultilineTextWrap() {};
      return BmfontAssembler;
    })(_assembler2d["default"]);
    exports["default"] = BmfontAssembler;
    module.exports = exports["default"];
  }), {
    "../../../components/CCLabel": 183,
    "../../../platform/CCMacro": 277,
    "../../../utils/text-utils": 393,
    "../../assembler-2d": 299,
    "../utils": 330
  } ],
  327: [ (function(require, module, exports) {
    "use strict";
    function LabelFrame() {
      this._rect = null;
      this.uv = [];
      this._texture = null;
      this._original = null;
    }
    LabelFrame.prototype = {
      constructor: LabelFrame,
      getRect: function getRect() {
        return cc.rect(this._rect);
      },
      setRect: function setRect(rect) {
        this._rect = rect;
        this._texture && this._calculateUV();
      },
      _setDynamicAtlasFrame: function _setDynamicAtlasFrame(frame) {
        if (!frame) return;
        this._original = {
          _texture: this._texture,
          _x: this._rect.x,
          _y: this._rect.y
        };
        this._texture = frame.texture;
        this._rect.x = frame.x;
        this._rect.y = frame.y;
        this._calculateUV();
      },
      _resetDynamicAtlasFrame: function _resetDynamicAtlasFrame() {
        if (!this._original) return;
        this._rect.x = this._original._x;
        this._rect.y = this._original._y;
        this._texture = this._original._texture;
        this._original = null;
        this._calculateUV();
      },
      _refreshTexture: function _refreshTexture(texture) {
        this._texture = texture;
        this._rect = cc.rect(0, 0, texture.width, texture.height);
        this._calculateUV();
      },
      _calculateUV: function _calculateUV() {
        var rect = this._rect, texture = this._texture, uv = this.uv, texw = texture.width, texh = texture.height;
        var l = 0 === texw ? 0 : rect.x / texw;
        var r = 0 === texw ? 0 : (rect.x + rect.width) / texw;
        var b = 0 === texh ? 0 : (rect.y + rect.height) / texh;
        var t = 0 === texh ? 0 : rect.y / texh;
        uv[0] = l;
        uv[1] = b;
        uv[2] = r;
        uv[3] = b;
        uv[4] = l;
        uv[5] = t;
        uv[6] = r;
        uv[7] = t;
      }
    };
    module.exports = LabelFrame;
  }), {} ],
  328: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _bmfont = _interopRequireDefault(require("../../webgl/assemblers/label/2d/bmfont"));
    var _vertexFormat = require("../../webgl/vertex-format");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = "undefined" !== typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" === typeof o.length) {
        it && (o = it);
        var i = 0;
        return function() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if ("string" === typeof o) return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      "Object" === n && o.constructor && (n = o.constructor.name);
      if ("Map" === n || "Set" === n) return Array.from(o);
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      (null == len || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    var Label = require("../../../components/CCLabel");
    var LabelOutline = require("../../../components/CCLabelOutline");
    var textUtils = require("../../../utils/text-utils");
    var Component = require("../../../components/CCComponent");
    var RenderTexture = require("../../../assets/CCRenderTexture");
    var OUTLINE_SUPPORTED = cc.js.isChildClassOf(LabelOutline, Component);
    var getFontFamily = require("../utils").getFontFamily;
    var shareLabelInfo = require("../utils").shareLabelInfo;
    var FontLetterDefinition = cc.BitmapFont.FontLetterDefinition;
    var FontAtlas = cc.BitmapFont.FontAtlas;
    var WHITE = cc.Color.WHITE;
    var space = 0;
    var bleed = 2;
    var _invisibleAlpha = (1 / 255).toFixed(3);
    function LetterTexture(_char, labelInfo) {
      this._texture = null;
      this._labelInfo = labelInfo;
      this._char = _char;
      this._hash = null;
      this._data = null;
      this._canvas = null;
      this._context = null;
      this._width = 0;
      this._height = 0;
      this._offsetY = 0;
      this._hash = _char.charCodeAt(0) + labelInfo.hash;
    }
    LetterTexture.prototype = {
      constructor: LetterTexture,
      updateRenderData: function updateRenderData() {
        this._updateProperties();
        this._updateTexture();
      },
      _updateProperties: function _updateProperties() {
        this._texture = new cc.Texture2D();
        this._data = Label._canvasPool.get();
        this._canvas = this._data.canvas;
        this._context = this._data.context;
        this._context.font = this._labelInfo.fontDesc;
        var width = textUtils.safeMeasureText(this._context, this._char, this._labelInfo.fontDesc);
        var blank = 2 * this._labelInfo.margin + bleed;
        this._width = parseFloat(width.toFixed(2)) + blank;
        this._height = (1 + textUtils.BASELINE_RATIO) * this._labelInfo.fontSize + blank;
        this._offsetY = -this._labelInfo.fontSize * textUtils.BASELINE_RATIO / 2;
        this._canvas.width !== this._width && (this._canvas.width = this._width);
        this._canvas.height !== this._height && (this._canvas.height = this._height);
        this._texture.initWithElement(this._canvas);
      },
      _updateTexture: function _updateTexture() {
        var context = this._context;
        var labelInfo = this._labelInfo, width = this._canvas.width, height = this._canvas.height;
        var fontSize = this._labelInfo.fontSize;
        var startX = width / 2;
        var startY = height / 2 + fontSize * textUtils.MIDDLE_RATIO + fontSize * textUtils.BASELINE_OFFSET;
        var color = labelInfo.color;
        context.lineJoin = "round";
        context.textAlign = "center";
        context.clearRect(0, 0, width, height);
        context.fillStyle = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + _invisibleAlpha + ")";
        context.fillRect(0, 0, width, height);
        context.font = labelInfo.fontDesc;
        context.fillStyle = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", 1)";
        if (labelInfo.isOutlined && labelInfo.margin > 0) {
          var strokeColor = labelInfo.out || WHITE;
          context.strokeStyle = "rgba(" + strokeColor.r + ", " + strokeColor.g + ", " + strokeColor.b + ", " + strokeColor.a / 255 + ")";
          context.lineWidth = 2 * labelInfo.margin;
          context.strokeText(this._char, startX, startY);
        }
        context.fillText(this._char, startX, startY);
        this._texture.handleLoadedTexture();
      },
      destroy: function destroy() {
        this._texture._packable = false;
        this._texture.destroy();
        this._texture = null;
        Label._canvasPool.put(this._data);
      }
    };
    function LetterAtlas(atlases, width, height) {
      var texture = new RenderTexture();
      texture.initWithSize(width, height);
      texture.update();
      this._atlases = atlases;
      this._texture = texture;
      this._id = 0;
      this._tmpId = -1;
      this._x = space;
      this._y = space;
      this._nexty = space;
      this.frees = [];
      this.waitCleans = [];
      this._width = width;
      this._height = height;
    }
    cc.js.mixin(LetterAtlas.prototype, {
      insertLetterTexture: function insertLetterTexture(letterTexture) {
        var texture = letterTexture._texture;
        var width = texture.width, height = texture.height;
        if (this.frees.length > 0) {
          var score = Number.MAX_VALUE;
          var areaFit = 0;
          var original = null;
          var originalIndex = 0;
          for (var i = 0; i < this.frees.length; i++) {
            var freeLetter = this.frees[i];
            if (freeLetter._width === width && freeLetter._height === height) {
              areaFit = freeLetter._width * freeLetter._height - width * height;
              if (areaFit < score) {
                original = freeLetter;
                originalIndex = i;
                score = areaFit;
              }
            }
          }
          if (original) {
            original._hash = letterTexture._hash;
            original.w = letterTexture._width - bleed;
            original.h = letterTexture._height - bleed;
            original.xAdvance = original.w;
            original.offsetY = letterTexture._offsetY;
            this._texture.drawTextureAt(texture, original.u - bleed / 2, original.v - bleed / 2);
            this._dirty = true;
            this.removeFreeLetter(originalIndex);
            this._atlases._fontDefDictionary.addLetterDefinitions(letterTexture._hash, original);
            return original;
          }
        }
        var oldx = this._x, oldy = this._y, oldnexty = this._nexty;
        if (this._x + width + space > this._width) {
          this._x = space;
          this._y = this._nexty;
        }
        this._y + height > this._nexty && (this._nexty = this._y + height + space);
        if (this._nexty > this._height) {
          this._x = oldx;
          this._y = oldy;
          this._nexty = oldnexty;
          if (this.waitCleans.length > 0) {
            for (var _iterator = _createForOfIteratorHelperLoose(this.waitCleans), _step; !(_step = _iterator()).done; ) {
              var _letter = _step.value;
              _letter._inCleans = false;
              if (0 === _letter.ref) {
                delete this._atlases._fontDefDictionary._letterDefinitions[_letter._hash];
                this.frees.push(_letter);
              }
            }
            this.waitCleans.length = 0;
            return this.insertLetterTexture(letterTexture);
          }
          return null;
        }
        this._texture.drawTextureAt(texture, this._x, this._y);
        this._dirty = true;
        var letter = new FontLetterDefinition();
        letter.u = this._x + bleed / 2;
        letter.v = this._y + bleed / 2;
        letter.texture = this._texture;
        letter.atlas = this;
        letter.ref = 0;
        letter.valid = true;
        letter.w = letterTexture._width - bleed;
        letter.h = letterTexture._height - bleed;
        letter._inCleans = false;
        letter._hash = letterTexture._hash;
        letter._width = width;
        letter._height = height;
        letter.xAdvance = letter.w;
        letter.offsetY = letterTexture._offsetY;
        this._x += width + space;
        this._atlases._fontDefDictionary.addLetterDefinitions(letterTexture._hash, letter);
        return letter;
      },
      pushFreeLetter: function pushFreeLetter(letter) {
        var i = this.frees.push(letter) - 1;
      },
      removeFreeLetter: function removeFreeLetter(index) {
        var temp = this.frees[index];
        var temp2 = this.frees[this.frees.length - 1];
        this.frees[index] = temp2;
        this.frees.pop();
      },
      update: function update() {
        if (!this._dirty) return;
        this._texture.update();
        this._dirty = false;
      },
      reset: function reset() {
        this._x = space;
        this._y = space;
        this._nexty = space;
        var defs = this._atlases._fontDefDictionary._letterDefinitions;
        for (var key in defs) {
          var def = defs[key];
          def.atlas === this && delete defs[key];
        }
        this.frees.length = 0;
        this.waitCleans.length = 0;
      },
      destroy: function destroy() {
        this.reset();
        var handler = this._atlases.material.getMultiHandler();
        handler.removeTexture(this._texture);
        this._texture.destroy();
        this._texture = null;
      }
    });
    var LetterAtlases = (function() {
      function LetterAtlases() {
        this.atlases = [];
        this.material = null;
        this.fakeMaterial = {
          material: null
        };
        this._fontDefDictionary = new FontAtlas(null);
        var handler = new cc.sp.MultiHandler();
        this.material = handler.material;
        this.fakeMaterial.material = this.material;
        cc.director.on(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
      }
      var _proto = LetterAtlases.prototype;
      _proto.insertLetterTexture = function insertLetterTexture(letterTexture) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(this.atlases), _step2; !(_step2 = _iterator2()).done; ) {
          var _atlas = _step2.value;
          var letter = _atlas.insertLetterTexture(letterTexture);
          if (letter) return letter;
        }
        if (this.atlases.length >= 8) return null;
        var atlas = new LetterAtlas(this, _atlasWidth, _atlasHeight);
        var len = this.atlases.push(atlas);
        atlas._id = len - 1;
        var handler = this.material.getMultiHandler();
        handler.setTexture(atlas._id, atlas._texture);
        (true, cc.sp.charAtlasAutoBatchCount >= len) && cc.sp.multiBatcher.requsetMaterial(atlas._texture);
        return atlas.insertLetterTexture(letterTexture);
      };
      _proto.deleteLetter = function deleteLetter(letter) {
        letter.ref--;
        if (0 === letter.ref && !letter._inCleans) {
          letter._inCleans = true;
          letter.atlas.waitCleans.push(letter);
        }
      };
      _proto.update = function update() {
        for (var _iterator3 = _createForOfIteratorHelperLoose(this.atlases), _step3; !(_step3 = _iterator3()).done; ) {
          var atlas = _step3.value;
          atlas.update();
        }
      };
      _proto.reset = function reset() {
        this._fontDefDictionary.clear();
        for (var _iterator4 = _createForOfIteratorHelperLoose(this.atlases), _step4; !(_step4 = _iterator4()).done; ) {
          var atlas = _step4.value;
          atlas.reset();
        }
      };
      _proto.destroy = function destroy() {
        this._fontDefDictionary.clear();
        for (var _iterator5 = _createForOfIteratorHelperLoose(this.atlases), _step5; !(_step5 = _iterator5()).done; ) {
          var atlas = _step5.value;
          atlas.destroy();
        }
        this.atlases.length = 0;
      };
      _proto.beforeSceneLoad = function beforeSceneLoad() {
        cc.sp.charAtlasAutoResetBeforeSceneLoad && this.clearAllCache();
      };
      _proto.clearAllCache = function clearAllCache() {
        this.reset();
      };
      _proto.getTexture = function getTexture() {
        if (!_emptyTexture) {
          _emptyTexture = new RenderTexture();
          _emptyTexture.initWithSize(_atlasWidth, _atlasHeight);
          _emptyTexture.update();
        }
        return _emptyTexture;
      };
      _proto.getLetter = function getLetter(key) {
        return this._fontDefDictionary._letterDefinitions[key];
      };
      _proto.getLetterDefinitionForChar = function getLetterDefinitionForChar(_char2, labelInfo) {
        var hash = _char2.charCodeAt(0) + labelInfo.hash;
        var letter = this._fontDefDictionary._letterDefinitions[hash];
        if (!letter) {
          var temp = new LetterTexture(_char2, labelInfo);
          temp.updateRenderData();
          letter = this.insertLetterTexture(temp);
          temp.destroy();
        }
        if (letter && _firstTraverse) {
          letter.ref++;
          _assembler._letterRefs.push(letter);
          this.checkMaterialAndUpdateTexId(letter);
        }
        return letter;
      };
      _proto.checkMaterialAndUpdateTexId = function checkMaterialAndUpdateTexId(letter) {
        var atlas = letter.atlas;
        var comp = _assembler._renderComp;
        if (!_usedMaterial) return;
        if (_needCheckMaterial) {
          _needCheckMaterial = false;
          if (_usedMaterial.material !== _shareAtlas.material) {
            _assembler.checkAndSwitchMaterial(comp, atlas._texture, _usedMaterial);
            _usedMaterial = comp._materials[0];
          }
        }
        if (_usedMaterial.material !== _shareAtlas.material && -1 === atlas._tmpId) {
          var handler = _usedMaterial.material.getMultiHandler();
          if (handler) {
            var index = handler.getIndex(atlas._texture.getImpl());
            if (-1 !== index) {
              atlas._tmpId = index;
              return;
            }
          }
          comp.setMaterial(0, _shareAtlas.material);
          _usedMaterial = _shareAtlas.fakeMaterial;
        }
      };
      return LetterAtlases;
    })();
    function computeHash(labelInfo) {
      var hashData = "|";
      var color = labelInfo.color.toHEX();
      var out = "";
      labelInfo.isOutlined && labelInfo.margin > 0 && (out = out + labelInfo.margin + labelInfo.out.toHEX());
      return hashData + labelInfo.fontSize + labelInfo.fontFamily + color + out;
    }
    var _shareAtlas = null;
    var _atlasWidth = 2048;
    var _atlasHeight = 2048;
    var _isBold = false;
    var _usedMaterial = null;
    var _needCheckMaterial = false;
    var _firstTraverse = false;
    var _assembler = null;
    var _emptyTexture = null;
    var LetterFontAssembler = (function(_WebglBmfontAssembler) {
      _inheritsLoose(LetterFontAssembler, _WebglBmfontAssembler);
      function LetterFontAssembler() {
        var _this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        _this = _WebglBmfontAssembler.call.apply(_WebglBmfontAssembler, [ this ].concat(args)) || this;
        _this._letterRefs = [];
        return _this;
      }
      var _proto2 = LetterFontAssembler.prototype;
      _proto2.initData = function initData() {
        var data = this._renderData;
        data.createFlexData(0, this.verticesCount, this.indicesCount, this.getVfmt());
      };
      _proto2.getVfmt = function getVfmt() {
        return _vertexFormat.vfmtPosUvColorTexId;
      };
      _proto2.getBuffer = function getBuffer() {
        return cc.renderer._handle.getBuffer("mesh", this.getVfmt());
      };
      _proto2._getAssemblerData = function _getAssemblerData() {
        if (!_shareAtlas) {
          _shareAtlas = new LetterAtlases();
          cc.Label._shareAtlas = _shareAtlas;
        }
        return _shareAtlas.getTexture();
      };
      _proto2._updateFontFamily = function _updateFontFamily(comp) {
        shareLabelInfo.fontAtlas = _shareAtlas;
        shareLabelInfo.fontFamily = getFontFamily(comp);
        var outline = OUTLINE_SUPPORTED && comp.getComponent(LabelOutline);
        if (outline && outline.enabled) {
          shareLabelInfo.isOutlined = true;
          shareLabelInfo.margin = outline.width;
          shareLabelInfo.out = outline.color.clone();
          shareLabelInfo.out.a = outline.color.a * comp.node.color.a / 255;
        } else {
          shareLabelInfo.isOutlined = false;
          shareLabelInfo.margin = 0;
        }
      };
      _proto2._updateLabelInfo = function _updateLabelInfo(comp) {
        shareLabelInfo.fontDesc = this._getFontDesc();
        shareLabelInfo.color = comp.node.color;
        shareLabelInfo.hash = computeHash(shareLabelInfo);
      };
      _proto2._getFontDesc = function _getFontDesc() {
        var fontDesc = shareLabelInfo.fontSize.toString() + "px ";
        fontDesc += shareLabelInfo.fontFamily;
        _isBold && (fontDesc = "bold " + fontDesc);
        return fontDesc;
      };
      _proto2._computeHorizontalKerningForText = function _computeHorizontalKerningForText() {};
      _proto2._determineRect = function _determineRect(tempRect) {
        return false;
      };
      _proto2._aftUpdateRenderData = function _aftUpdateRenderData(comp) {
        _assembler = this;
        _usedMaterial = _assembler._renderComp._materials[0];
        _needCheckMaterial = true;
        _firstTraverse = true;
        for (var _iterator6 = _createForOfIteratorHelperLoose(_shareAtlas.atlases), _step6; !(_step6 = _iterator6()).done; ) {
          var atlas = _step6.value;
          atlas._tmpId = -1;
        }
        this._recycleLetterRef();
        _WebglBmfontAssembler.prototype._aftUpdateRenderData.call(this, comp);
        _usedMaterial = null;
        _assembler = null;
      };
      _proto2._finishMultilineTextWrap = function _finishMultilineTextWrap() {
        _firstTraverse = false;
      };
      _proto2._recycleLetterRef = function _recycleLetterRef() {
        for (var _iterator7 = _createForOfIteratorHelperLoose(this._letterRefs), _step7; !(_step7 = _iterator7()).done; ) {
          var letter = _step7.value;
          _shareAtlas.deleteLetter(letter);
        }
        this._letterRefs.length = 0;
      };
      _proto2._resetAssemblerData = function _resetAssemblerData(assemblerData) {
        0 !== this._letterRefs.length && this._recycleLetterRef();
      };
      _proto2.appendVerts = function appendVerts(comp, offset, l, r, b, t, letter) {
        _WebglBmfontAssembler.prototype.appendVerts.call(this, comp, offset, l, r, b, t, letter);
        var renderData = this._renderData;
        var verts = renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        var texIdOffset = offset + this.texIdOffset;
        var id = _usedMaterial ? _usedMaterial.material !== _shareAtlas.material ? letter.atlas._tmpId : letter.atlas._id : 0;
        verts[texIdOffset] = id;
        texIdOffset += floatsPerVert;
        verts[texIdOffset] = id;
        texIdOffset += floatsPerVert;
        verts[texIdOffset] = id;
        texIdOffset += floatsPerVert;
        verts[texIdOffset] = id;
      };
      return LetterFontAssembler;
    })(_bmfont["default"]);
    exports["default"] = LetterFontAssembler;
    LetterFontAssembler.prototype.floatsPerVert = 6;
    LetterFontAssembler.prototype.texIdOffset = 5;
    LetterFontAssembler.prototype.isMulti = true;
    module.exports = exports["default"];
  }), {
    "../../../assets/CCRenderTexture": 145,
    "../../../components/CCComponent": 181,
    "../../../components/CCLabel": 183,
    "../../../components/CCLabelOutline": 184,
    "../../../utils/text-utils": 393,
    "../../webgl/assemblers/label/2d/bmfont": 337,
    "../../webgl/vertex-format": 371,
    "../utils": 330
  } ],
  329: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler2d = _interopRequireDefault(require("../../assembler-2d"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var textUtils = require("../../../utils/text-utils");
    var macro = require("../../../platform/CCMacro");
    var Label = require("../../../components/CCLabel");
    var LabelOutline = require("../../../components/CCLabelOutline");
    var LabelShadow = require("../../../components/CCLabelShadow");
    var Overflow = Label.Overflow;
    var deleteFromDynamicAtlas = require("../utils").deleteFromDynamicAtlas;
    var getFontFamily = require("../utils").getFontFamily;
    var _invisibleAlpha = (1 / 255).toFixed(3);
    var MAX_SIZE = 2048;
    var _context = null;
    var _canvas = null;
    var _texture = null;
    var _fontDesc = "";
    var _string = "";
    var _fontSize = 0;
    var _drawFontSize = 0;
    var _splitedStrings = [];
    var _canvasSize = cc.Size.ZERO;
    var _lineHeight = 0;
    var _hAlign = 0;
    var _vAlign = 0;
    var _color = null;
    var _fontFamily = "";
    var _overflow = Overflow.NONE;
    var _isWrapText = false;
    var _premultiply = false;
    var _isRetina = false;
    var _retinaScale = 1;
    var _outlineComp = null;
    var _outlineColor = cc.Color.WHITE;
    var _shadowComp = null;
    var _shadowColor = cc.Color.BLACK;
    var _canvasPadding = cc.rect();
    var _contentSizeExtend = cc.Size.ZERO;
    var _nodeContentSize = cc.Size.ZERO;
    var _enableBold = false;
    var _enableItalic = false;
    var _enableUnderline = false;
    var _underlineThickness = 0;
    var _drawUnderlinePos = cc.Vec2.ZERO;
    var _drawUnderlineWidth = 0;
    var _sharedLabelData;
    var Alignment = [ "left", "center", "right" ];
    var TTFAssembler = (function(_Assembler2D) {
      _inheritsLoose(TTFAssembler, _Assembler2D);
      function TTFAssembler() {
        return _Assembler2D.apply(this, arguments) || this;
      }
      var _proto = TTFAssembler.prototype;
      _proto._getAssemblerData = function _getAssemblerData() {
        _sharedLabelData = Label._canvasPool.get();
        _sharedLabelData.canvas.width = _sharedLabelData.canvas.height = 1;
        return _sharedLabelData;
      };
      _proto._resetAssemblerData = function _resetAssemblerData(assemblerData) {
        assemblerData && Label._canvasPool.put(assemblerData);
      };
      _proto.updateRenderData = function updateRenderData(comp) {
        _Assembler2D.prototype.updateRenderData.call(this, comp);
        if (!comp._vertsDirty) return false;
        this._updateProperties(comp);
        this._calculateLabelFont();
        this._updateLabelDimensions();
        this._updateTexture(comp);
        var assemblerChanged = this._calDynamicAtlas(comp);
        assemblerChanged || this._aftUpdateRenderData(comp);
        return assemblerChanged;
      };
      _proto._aftUpdateRenderData = function _aftUpdateRenderData(comp) {
        if (_isRetina) {
          _fontSize /= _retinaScale;
          _nodeContentSize.width /= _retinaScale;
          _nodeContentSize.height /= _retinaScale;
        }
        comp._actualFontSize = _fontSize;
        comp.node.setContentSize(_nodeContentSize);
        this.updateVerts(comp);
        comp._vertsDirty = false;
        _context = null;
        _canvas = null;
        _texture = null;
      };
      _proto.getTTFTextureSizeScale = function getTTFTextureSizeScale() {
        return _isRetina ? _retinaScale : 1;
      };
      _proto.updateVerts = function updateVerts() {};
      _proto._updatePaddingRect = function _updatePaddingRect() {
        var top = 0, bottom = 0, left = 0, right = 0;
        var outlineWidth = 0;
        _contentSizeExtend.width = _contentSizeExtend.height = 0;
        if (_outlineComp) {
          outlineWidth = _outlineComp.width;
          _isRetina && (outlineWidth *= _retinaScale);
          top = bottom = left = right = outlineWidth;
          _contentSizeExtend.width = _contentSizeExtend.height = 2 * outlineWidth;
        }
        if (_shadowComp) {
          var shadowWidth = _shadowComp.blur + outlineWidth;
          left = Math.max(left, -_shadowComp._offset.x + shadowWidth);
          right = Math.max(right, _shadowComp._offset.x + shadowWidth);
          top = Math.max(top, _shadowComp._offset.y + shadowWidth);
          bottom = Math.max(bottom, -_shadowComp._offset.y + shadowWidth);
        }
        if (_enableItalic) {
          var offset = _drawFontSize * Math.tan(.20943951);
          right += offset;
          _contentSizeExtend.width += offset;
        }
        _canvasPadding.x = left;
        _canvasPadding.y = top;
        _canvasPadding.width = left + right;
        _canvasPadding.height = top + bottom;
      };
      _proto._updateProperties = function _updateProperties(comp) {
        var assemblerData = comp._assemblerData;
        _context = assemblerData.context;
        _canvas = assemblerData.canvas;
        _texture = comp._frame._original ? comp._frame._original._texture : comp._frame._texture;
        _isRetina = cc.sp.enableLabelRetina && 0 === comp.enableRetina || 1 === comp.enableRetina;
        _retinaScale = cc.sp.labelRetinaScale;
        _string = comp.string.toString();
        _fontSize = comp._fontSize;
        _nodeContentSize = comp.node.getContentSize();
        _lineHeight = comp._lineHeight;
        _drawFontSize = _fontSize;
        _underlineThickness = comp.underlineHeight || _drawFontSize / 8;
        if (_isRetina) {
          _fontSize *= _retinaScale;
          _nodeContentSize.width *= _retinaScale;
          _nodeContentSize.height *= _retinaScale;
          _lineHeight *= _retinaScale;
          comp.underlineHeight && (_underlineThickness *= _retinaScale);
          _drawFontSize = _fontSize;
        }
        _overflow = comp.overflow;
        _canvasSize.width = _nodeContentSize.width;
        _canvasSize.height = _nodeContentSize.height;
        _hAlign = comp.horizontalAlign;
        _vAlign = comp.verticalAlign;
        _color = comp.node.color;
        _enableBold = comp.enableBold;
        _enableItalic = comp.enableItalic;
        _enableUnderline = comp.enableUnderline;
        _fontFamily = getFontFamily(comp);
        _premultiply = comp.srcBlendFactor === cc.macro.BlendFactor.ONE;
        true;
        _context._setPremultiply(_premultiply);
        _isWrapText = _overflow !== Overflow.NONE && (_overflow === Overflow.RESIZE_HEIGHT || comp.enableWrapText);
        _outlineComp = LabelOutline && comp.getComponent(LabelOutline);
        _outlineComp = _outlineComp && _outlineComp.enabled && _outlineComp.width > 0 ? _outlineComp : null;
        _outlineComp && _outlineColor.set(_outlineComp.color);
        _shadowComp = LabelShadow && comp.getComponent(LabelShadow);
        _shadowComp = _shadowComp && _shadowComp.enabled ? _shadowComp : null;
        if (_shadowComp) {
          _shadowColor.set(_shadowComp.color);
          _shadowColor.a = _shadowColor.a * comp.node.color.a / 255;
        }
        this._updatePaddingRect();
      };
      _proto._calculateFillTextStartPosition = function _calculateFillTextStartPosition() {
        var labelX = 0;
        _hAlign === macro.TextAlignment.RIGHT ? labelX = _canvasSize.width - _canvasPadding.width : _hAlign === macro.TextAlignment.CENTER && (labelX = (_canvasSize.width - _canvasPadding.width) / 2);
        var lineHeight = this._getLineHeight();
        var drawStartY = lineHeight * (_splitedStrings.length - 1);
        var firstLinelabelY = _fontSize * (1 - textUtils.BASELINE_RATIO / 2);
        if (_vAlign !== macro.VerticalTextAlignment.TOP) {
          var blank = drawStartY + _canvasPadding.height + _fontSize - _canvasSize.height;
          if (_vAlign === macro.VerticalTextAlignment.BOTTOM) {
            blank += textUtils.BASELINE_RATIO / 2 * _fontSize;
            firstLinelabelY -= blank;
          } else firstLinelabelY -= blank / 2;
        }
        firstLinelabelY += textUtils.BASELINE_OFFSET * _fontSize;
        return cc.v2(labelX + _canvasPadding.x, firstLinelabelY + _canvasPadding.y);
      };
      _proto._setupOutline = function _setupOutline() {
        _context.strokeStyle = "rgba(" + _outlineColor.r + ", " + _outlineColor.g + ", " + _outlineColor.b + ", " + _outlineColor.a / 255 + ")";
        _context.lineWidth = 2 * _outlineComp.width * (_isRetina ? _retinaScale : 1);
      };
      _proto._setupShadow = function _setupShadow() {
        _context.shadowColor = "rgba(" + _shadowColor.r + ", " + _shadowColor.g + ", " + _shadowColor.b + ", " + _shadowColor.a / 255 + ")";
        _context.shadowBlur = _shadowComp.blur * (_isRetina ? _retinaScale : 1);
        _context.shadowOffsetX = _shadowComp.offset.x * (_isRetina ? _retinaScale : 1);
        _context.shadowOffsetY = -_shadowComp.offset.y * (_isRetina ? _retinaScale : 1);
      };
      _proto._drawTextEffect = function _drawTextEffect(startPosition, lineHeight) {
        if (!_shadowComp && !_outlineComp && !_enableUnderline) return;
        var isMultiple = _splitedStrings.length > 1 && _shadowComp;
        var measureText = this._measureText(_context, _fontDesc);
        var drawTextPosX = 0, drawTextPosY = 0;
        _shadowComp && this._setupShadow();
        _outlineComp && this._setupOutline();
        for (var i = 0; i < _splitedStrings.length; ++i) {
          drawTextPosX = startPosition.x;
          drawTextPosY = startPosition.y + i * lineHeight;
          if (isMultiple) {
            _outlineComp && _context.strokeText(_splitedStrings[i], drawTextPosX, drawTextPosY);
            _context.fillText(_splitedStrings[i], drawTextPosX, drawTextPosY);
          }
          if (_enableUnderline) {
            _drawUnderlineWidth = measureText(_splitedStrings[i]);
            _hAlign === macro.TextAlignment.RIGHT ? _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth : _hAlign === macro.TextAlignment.CENTER ? _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth / 2 : _drawUnderlinePos.x = startPosition.x;
            _drawUnderlinePos.y = drawTextPosY + _drawFontSize / 8;
            _context.fillRect(_drawUnderlinePos.x, _drawUnderlinePos.y, _drawUnderlineWidth, _underlineThickness);
          }
        }
        isMultiple && (_context.shadowColor = "transparent");
      };
      _proto._updateTexture = function _updateTexture() {
        _context.clearRect(0, 0, _canvas.width, _canvas.height);
        _context.lineJoin = "round";
        if (_premultiply) _context.fillStyle = "rgba(" + _color.r + ", " + _color.g + ", " + _color.b + ", " + _color.a / 255 + ")"; else {
          var _fillColor = _outlineComp ? _outlineColor : _color;
          _context.fillStyle = "rgba(" + _fillColor.r + ", " + _fillColor.g + ", " + _fillColor.b + ", " + _invisibleAlpha + ")";
          _context.fillRect(0, 0, _canvas.width, _canvas.height);
          _context.fillStyle = "rgba(" + _color.r + ", " + _color.g + ", " + _color.b + ", 1)";
        }
        var startPosition = this._calculateFillTextStartPosition();
        var lineHeight = this._getLineHeight();
        var drawTextPosX = startPosition.x, drawTextPosY = 0;
        this._drawTextEffect(startPosition, lineHeight);
        for (var i = 0; i < _splitedStrings.length; ++i) {
          drawTextPosY = startPosition.y + i * lineHeight;
          _outlineComp && _context.strokeText(_splitedStrings[i], drawTextPosX, drawTextPosY);
          _context.fillText(_splitedStrings[i], drawTextPosX, drawTextPosY);
        }
        _shadowComp && (_context.shadowColor = "transparent");
        _texture.handleLoadedTexture();
      };
      _proto._calDynamicAtlas = function _calDynamicAtlas(comp) {
        if (comp.cacheMode !== Label.CacheMode.BITMAP) return false;
        var frame = comp._frame;
        deleteFromDynamicAtlas(comp, frame);
        frame._original || frame.setRect(cc.rect(0, 0, _canvas.width, _canvas.height));
        return this.packDynamicAtlasAndCheckMaterial(comp, frame);
      };
      _proto.packDynamicAtlasAndCheckMaterial = function packDynamicAtlasAndCheckMaterial(comp, frame) {
        var allowDynamicAtlas = comp.allowDynamicAtlas;
        if (cc.sp.allowDynamicAtlas && 0 === allowDynamicAtlas || 1 === allowDynamicAtlas) {
          frame._texture._uuid = _fontDesc + _overflow + (_premultiply ? "P" : "NP") + comp.node.color.toHEX() + (_enableUnderline ? "UL" : "NUL") + _string;
          _outlineComp && (frame._texture._uuid += _outlineComp.color.toHEX() + "," + _outlineComp.width + ",");
          _shadowComp && (frame._texture._uuid += _shadowComp.color.toHEX() + _shadowComp.offset.x + "," + _shadowComp.offset.y + "," + _shadowComp.blur);
        }
        return _Assembler2D.prototype.packDynamicAtlasAndCheckMaterial.call(this, comp, frame);
      };
      _proto._updateLabelDimensions = function _updateLabelDimensions() {
        var maxTextureSize = cc.renderer.device.caps ? cc.renderer.device.caps.maxTextureSize : MAX_SIZE;
        (_canvasSize.width > maxTextureSize || _canvasSize.height > maxTextureSize) && cc.warn("The maximum texture size supported by the device is " + maxTextureSize);
        _canvasSize.width = Math.min(_canvasSize.width, maxTextureSize);
        _canvasSize.height = Math.min(_canvasSize.height, maxTextureSize);
        var recreate = false;
        if (_canvas.width !== _canvasSize.width) {
          _canvas.width = _canvasSize.width;
          recreate = true;
        }
        if (_canvas.height !== _canvasSize.height) {
          _canvas.height = _canvasSize.height;
          recreate = true;
        }
        recreate && (_context.font = _fontDesc);
        _context.textAlign = Alignment[_hAlign];
      };
      _proto._getFontDesc = function _getFontDesc() {
        var fontDesc = _fontSize.toString() + "px ";
        fontDesc += _fontFamily;
        _enableBold && (fontDesc = "bold " + fontDesc);
        _enableItalic && (fontDesc = "italic " + fontDesc);
        return fontDesc;
      };
      _proto._getLineHeight = function _getLineHeight() {
        var nodeSpacingY = _lineHeight;
        nodeSpacingY = 0 === nodeSpacingY ? _fontSize : nodeSpacingY * _fontSize / _drawFontSize;
        return 0 | nodeSpacingY;
      };
      _proto._calculateParagraphLength = function _calculateParagraphLength(paragraphedStrings, ctx) {
        var paragraphLength = [];
        for (var i = 0; i < paragraphedStrings.length; ++i) {
          var width = textUtils.safeMeasureText(ctx, paragraphedStrings[i], _fontDesc);
          paragraphLength.push(width);
        }
        return paragraphLength;
      };
      _proto._measureText = function _measureText(ctx, fontDesc) {
        return function(string) {
          return textUtils.safeMeasureText(ctx, string, fontDesc);
        };
      };
      _proto._calculateShrinkFont = function _calculateShrinkFont(paragraphedStrings) {
        var paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);
        var i = 0;
        var totalHeight = 0;
        var maxLength = 0;
        if (_isWrapText) {
          var canvasWidthNoMargin = _nodeContentSize.width;
          var canvasHeightNoMargin = _nodeContentSize.height;
          if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) return;
          totalHeight = canvasHeightNoMargin + 1;
          var actualFontSize = _fontSize + 1;
          var textFragment = "";
          var left = 0, right = 0 | actualFontSize, mid = 0;
          while (left < right) {
            mid = left + right + 1 >> 1;
            if (mid <= 0) {
              cc.logID(4003);
              break;
            }
            _fontSize = mid;
            _fontDesc = this._getFontDesc();
            _context.font = _fontDesc;
            var lineHeight = this._getLineHeight();
            totalHeight = 0;
            for (i = 0; i < paragraphedStrings.length; ++i) {
              var allWidth = textUtils.safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
              textFragment = textUtils.fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context, _fontDesc));
              totalHeight += textFragment.length * lineHeight;
            }
            totalHeight > canvasHeightNoMargin ? right = mid - 1 : left = mid;
          }
          if (0 === left) cc.logID(4003); else {
            _fontSize = left;
            _fontDesc = this._getFontDesc();
            _context.font = _fontDesc;
          }
        } else {
          totalHeight = paragraphedStrings.length * this._getLineHeight();
          for (i = 0; i < paragraphedStrings.length; ++i) maxLength < paragraphLength[i] && (maxLength = paragraphLength[i]);
          var scaleX = (_canvasSize.width - _canvasPadding.width) / maxLength;
          var scaleY = _canvasSize.height / totalHeight;
          _fontSize = _drawFontSize * Math.min(1, scaleX, scaleY) | 0;
          _fontDesc = this._getFontDesc();
          _context.font = _fontDesc;
        }
      };
      _proto._calculateWrapText = function _calculateWrapText(paragraphedStrings) {
        if (!_isWrapText) return;
        _splitedStrings = [];
        var canvasWidthNoMargin = _nodeContentSize.width;
        for (var i = 0; i < paragraphedStrings.length; ++i) {
          var allWidth = textUtils.safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
          var textFragment = textUtils.fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context, _fontDesc));
          _splitedStrings = _splitedStrings.concat(textFragment);
        }
      };
      _proto._calculateLabelFont = function _calculateLabelFont() {
        var paragraphedStrings = _string.split("\n");
        _splitedStrings = paragraphedStrings;
        _fontDesc = this._getFontDesc();
        _context.font = _fontDesc;
        switch (_overflow) {
         case Overflow.NONE:
          var canvasSizeX = 0;
          var canvasSizeY = 0;
          for (var i = 0; i < paragraphedStrings.length; ++i) {
            var paraLength = textUtils.safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
            canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
          }
          canvasSizeY = (_splitedStrings.length + textUtils.BASELINE_RATIO) * this._getLineHeight();
          var rawWidth = parseFloat(canvasSizeX.toFixed(2));
          var rawHeight = parseFloat(canvasSizeY.toFixed(2));
          _canvasSize.width = rawWidth + _canvasPadding.width;
          _canvasSize.height = rawHeight + _canvasPadding.height;
          _nodeContentSize.width = rawWidth + _contentSizeExtend.width;
          _nodeContentSize.height = rawHeight + _contentSizeExtend.height;
          break;

         case Overflow.SHRINK:
          this._calculateShrinkFont(paragraphedStrings);
          this._calculateWrapText(paragraphedStrings);
          break;

         case Overflow.CLAMP:
          this._calculateWrapText(paragraphedStrings);
          break;

         case Overflow.RESIZE_HEIGHT:
          this._calculateWrapText(paragraphedStrings);
          var _rawHeight = (_splitedStrings.length + textUtils.BASELINE_RATIO) * this._getLineHeight();
          _canvasSize.height = _rawHeight + _canvasPadding.height;
          _nodeContentSize.height = _rawHeight + _contentSizeExtend.height;
        }
      };
      return TTFAssembler;
    })(_assembler2d["default"]);
    exports["default"] = TTFAssembler;
    module.exports = exports["default"];
  }), {
    "../../../components/CCLabel": 183,
    "../../../components/CCLabelOutline": 184,
    "../../../components/CCLabelShadow": 185,
    "../../../platform/CCMacro": 277,
    "../../../utils/text-utils": 393,
    "../../assembler-2d": 299,
    "../utils": 330
  } ],
  330: [ (function(require, module, exports) {
    "use strict";
    var dynamicAtlasManager = require("./dynamic-atlas/manager");
    var WHITE = cc.Color.WHITE;
    var shareLabelInfo = {
      fontAtlas: null,
      fontSize: 0,
      lineHeight: 0,
      hAlign: 0,
      vAlign: 0,
      hash: "",
      fontFamily: "",
      fontDesc: "Arial",
      color: WHITE,
      isOutlined: false,
      out: WHITE,
      margin: 0
    };
    module.exports = {
      deleteFromDynamicAtlas: function deleteFromDynamicAtlas(comp, frame) {
        if (frame && true && frame._original && dynamicAtlasManager) {
          dynamicAtlasManager.deleteAtlasSpriteFrame(frame);
          frame._resetDynamicAtlasFrame();
        }
      },
      getFontFamily: function getFontFamily(comp) {
        if (comp.useSystemFont) return comp.fontFamily || "Arial";
        if (comp.font) {
          if (comp.font._nativeAsset) return comp.font._nativeAsset;
          cc.assetManager.postLoadNative(comp.font, (function(err) {
            comp.isValid && comp.setVertsDirty();
          }));
          return "Arial";
        }
        return "Arial";
      },
      shareLabelInfo: shareLabelInfo
    };
  }), {
    "./dynamic-atlas/manager": 324
  } ],
  331: [ (function(require, module, exports) {
    "use strict";
    cc.Graphics.earcut = module.exports = earcut;
    function earcut(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode) return triangles;
      var minX, minY, maxX, maxY, x, y, size;
      hasHoles && (outerNode = eliminateHoles(data, holeIndices, outerNode, dim));
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          x < minX && (minX = x);
          y < minY && (minY = y);
          x > maxX && (maxX = x);
          y > maxY && (maxY = y);
        }
        size = Math.max(maxX - minX, maxY - minY);
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, size);
      return triangles;
    }
    function linkedList(data, start, end, dim, clockwise) {
      var i, last;
      if (clockwise === signedArea(data, start, end, dim) > 0) for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last); else for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
      if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
      }
      return last;
    }
    function filterPoints(start, end) {
      if (!start) return start;
      end || (end = start);
      var p = start, again;
      do {
        again = false;
        if (p.steiner || !equals(p, p.next) && 0 !== area(p.prev, p, p.next)) p = p.next; else {
          removeNode(p);
          p = end = p.prev;
          if (p === p.next) return null;
          again = true;
        }
      } while (again || p !== end);
      return end;
    }
    function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
      if (!ear) return;
      !pass && size && indexCurve(ear, minX, minY, size);
      var stop = ear, prev, next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
          triangles.push(prev.i / dim);
          triangles.push(ear.i / dim);
          triangles.push(next.i / dim);
          removeNode(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (pass) if (1 === pass) {
            ear = cureLocalIntersections(ear, triangles, dim);
            earcutLinked(ear, triangles, dim, minX, minY, size, 2);
          } else 2 === pass && splitEarcut(ear, triangles, dim, minX, minY, size); else earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
          break;
        }
      }
    }
    function isEar(ear) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0) return false;
      var p = ear.next.next;
      while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
      }
      return true;
    }
    function isEarHashed(ear, minX, minY, size) {
      var a = ear.prev, b = ear, c = ear.next;
      if (area(a, b, c) >= 0) return false;
      var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
      var minZ = zOrder(minTX, minTY, minX, minY, size), maxZ = zOrder(maxTX, maxTY, minX, minY, size);
      var p = ear.nextZ;
      while (p && p.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.nextZ;
      }
      p = ear.prevZ;
      while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
      }
      return true;
    }
    function cureLocalIntersections(start, triangles, dim) {
      var p = start;
      do {
        var a = p.prev, b = p.next.next;
        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
          triangles.push(a.i / dim);
          triangles.push(p.i / dim);
          triangles.push(b.i / dim);
          removeNode(p);
          removeNode(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return p;
    }
    function splitEarcut(start, triangles, dim, minX, minY, size) {
      var a = start;
      do {
        var b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal(a, b)) {
            var c = splitPolygon(a, b);
            a = filterPoints(a, a.next);
            c = filterPoints(c, c.next);
            earcutLinked(a, triangles, dim, minX, minY, size);
            earcutLinked(c, triangles, dim, minX, minY, size);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    }
    function eliminateHoles(data, holeIndices, outerNode, dim) {
      var queue = [], i, len, start, end, list;
      for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        list === list.next && (list.steiner = true);
        queue.push(getLeftmost(list));
      }
      queue.sort(compareX);
      for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
      }
      return outerNode;
    }
    function compareX(a, b) {
      return a.x - b.x;
    }
    function eliminateHole(hole, outerNode) {
      outerNode = findHoleBridge(hole, outerNode);
      if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
      }
    }
    function findHoleBridge(hole, outerNode) {
      var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
      do {
        if (hy <= p.y && hy >= p.next.y) {
          var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            if (x === hx) {
              if (hy === p.y) return p;
              if (hy === p.next.y) return p.next;
            }
            m = p.x < p.next.x ? p : p.next;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m) return null;
      if (hx === qx) return m.prev;
      var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
      p = m.next;
      while (p !== stop) {
        if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          tan = Math.abs(hy - p.y) / (hx - p.x);
          if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      }
      return m;
    }
    function indexCurve(start, minX, minY, size) {
      var p = start;
      do {
        null === p.z && (p.z = zOrder(p.x, p.y, minX, minY, size));
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked(p);
    }
    function sortLinked(list) {
      var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
      do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q) break;
          }
          qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (0 === pSize) {
              e = q;
              q = q.nextZ;
              qSize--;
            } else if (0 !== qSize && q) if (p.z <= q.z) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            } else {
              e = p;
              p = p.nextZ;
              pSize--;
            }
            tail ? tail.nextZ = e : list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    }
    function zOrder(x, y, minX, minY, size) {
      x = 32767 * (x - minX) / size;
      y = 32767 * (y - minY) / size;
      x = 16711935 & (x | x << 8);
      x = 252645135 & (x | x << 4);
      x = 858993459 & (x | x << 2);
      x = 1431655765 & (x | x << 1);
      y = 16711935 & (y | y << 8);
      y = 252645135 & (y | y << 4);
      y = 858993459 & (y | y << 2);
      y = 1431655765 & (y | y << 1);
      return x | y << 1;
    }
    function getLeftmost(start) {
      var p = start, leftmost = start;
      do {
        p.x < leftmost.x && (leftmost = p);
        p = p.next;
      } while (p !== start);
      return leftmost;
    }
    function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
      return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    function isValidDiagonal(a, b) {
      return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
    }
    function area(p, q, r) {
      return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    function equals(p1, p2) {
      return p1.x === p2.x && p1.y === p2.y;
    }
    function intersects(p1, q1, p2, q2) {
      if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) return true;
      return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
    }
    function intersectsPolygon(a, b) {
      var p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
        p = p.next;
      } while (p !== a);
      return false;
    }
    function locallyInside(a, b) {
      return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
    }
    function middleInside(a, b) {
      var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
      do {
        p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x && (inside = !inside);
        p = p.next;
      } while (p !== a);
      return inside;
    }
    function splitPolygon(a, b) {
      var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    }
    function insertNode(i, x, y, last) {
      var p = new Node(i, x, y);
      if (last) {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      } else {
        p.prev = p;
        p.next = p;
      }
      return p;
    }
    function removeNode(p) {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      p.prevZ && (p.prevZ.nextZ = p.nextZ);
      p.nextZ && (p.nextZ.prevZ = p.prevZ);
    }
    function Node(i, x, y) {
      this.i = i;
      this.x = x;
      this.y = y;
      this.prev = null;
      this.next = null;
      this.z = null;
      this.prevZ = null;
      this.nextZ = null;
      this.steiner = false;
    }
    earcut.deviation = function(data, holeIndices, dim, triangles) {
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
      if (hasHoles) for (var i = 0, len = holeIndices.length; i < len; i++) {
        var start = holeIndices[i] * dim;
        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
      }
      var trianglesArea = 0;
      for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
      }
      return 0 === polygonArea && 0 === trianglesArea ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
    };
    function signedArea(data, start, end, dim) {
      var sum = 0;
      for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum;
    }
    earcut.flatten = function(data) {
      var dim = data[0][0].length, result = {
        vertices: [],
        holes: [],
        dimensions: dim
      }, holeIndex = 0;
      for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        if (i > 0) {
          holeIndex += data[i - 1].length;
          result.holes.push(holeIndex);
        }
      }
      return result;
    };
  }), {} ],
  332: [ (function(require, module, exports) {
    "use strict";
    var Helper = require("../../../../graphics/helper");
    var PointFlags = require("../../../../graphics/types").PointFlags;
    var Point = cc.Graphics.Point = cc.Class({
      name: "cc.GraphicsPoint",
      extends: cc.Vec2,
      ctor: function ctor(x, y) {
        this.reset();
      },
      reset: function reset() {
        this.dx = 0;
        this.dy = 0;
        this.dmx = 0;
        this.dmy = 0;
        this.flags = 0;
        this.len = 0;
      }
    });
    function Path() {
      this.reset();
    }
    cc.js.mixin(Path.prototype, {
      reset: function reset() {
        this.closed = false;
        this.nbevel = 0;
        this.complex = true;
        this.points ? this.points.length = 0 : this.points = [];
      }
    });
    function Impl(graphics) {
      this._tessTol = .25;
      this._distTol = .01;
      this._updatePathOffset = false;
      this._paths = null;
      this._pathLength = 0;
      this._pathOffset = 0;
      this._points = null;
      this._pointsOffset = 0;
      this._commandx = 0;
      this._commandy = 0;
      this._paths = [];
      this._points = [];
    }
    cc.js.mixin(Impl.prototype, {
      moveTo: function moveTo(x, y) {
        if (this._updatePathOffset) {
          this._pathOffset = this._pathLength;
          this._updatePathOffset = false;
        }
        this._addPath();
        this._addPoint(x, y, PointFlags.PT_CORNER);
        this._commandx = x;
        this._commandy = y;
      },
      lineTo: function lineTo(x, y) {
        this._addPoint(x, y, PointFlags.PT_CORNER);
        this._commandx = x;
        this._commandy = y;
      },
      bezierCurveTo: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
        var path = this._curPath;
        var last = path.points[path.points.length - 1];
        if (last.x === c1x && last.y === c1y && c2x === x && c2y === y) {
          this.lineTo(x, y);
          return;
        }
        Helper.tesselateBezier(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER);
        this._commandx = x;
        this._commandy = y;
      },
      quadraticCurveTo: function quadraticCurveTo(cx, cy, x, y) {
        var x0 = this._commandx;
        var y0 = this._commandy;
        this.bezierCurveTo(x0 + 2 / 3 * (cx - x0), y0 + 2 / 3 * (cy - y0), x + 2 / 3 * (cx - x), y + 2 / 3 * (cy - y), x, y);
      },
      arc: function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
        Helper.arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
      },
      ellipse: function ellipse(cx, cy, rx, ry) {
        Helper.ellipse(this, cx, cy, rx, ry);
        this._curPath.complex = false;
      },
      circle: function circle(cx, cy, r) {
        Helper.ellipse(this, cx, cy, r, r);
        this._curPath.complex = false;
      },
      rect: function rect(x, y, w, h) {
        this.moveTo(x, y);
        this.lineTo(x, y + h);
        this.lineTo(x + w, y + h);
        this.lineTo(x + w, y);
        this.close();
        this._curPath.complex = false;
      },
      roundRect: function roundRect(x, y, w, h, r) {
        Helper.roundRect(this, x, y, w, h, r);
        this._curPath.complex = false;
      },
      clear: function clear(clean) {
        this._pathLength = 0;
        this._pathOffset = 0;
        this._pointsOffset = 0;
        this._curPath = null;
        if (clean) {
          this._paths.length = 0;
          this._points.length = 0;
        }
      },
      close: function close() {
        this._curPath.closed = true;
      },
      _addPath: function _addPath() {
        var offset = this._pathLength;
        var path = this._paths[offset];
        if (path) path.reset(); else {
          path = new Path();
          this._paths.push(path);
        }
        this._pathLength++;
        this._curPath = path;
        return path;
      },
      _addPoint: function _addPoint(x, y, flags) {
        var path = this._curPath;
        if (!path) return;
        var pt;
        var points = this._points;
        var pathPoints = path.points;
        var offset = this._pointsOffset++;
        pt = points[offset];
        if (pt) {
          pt.x = x;
          pt.y = y;
        } else {
          pt = new Point(x, y);
          points.push(pt);
        }
        pt.flags = flags;
        pathPoints.push(pt);
      }
    });
    cc.Graphics._Impl = Impl;
    module.exports = Impl;
  }), {
    "../../../../graphics/helper": 236,
    "../../../../graphics/types": 238
  } ],
  333: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler = _interopRequireDefault(require("../../../assembler"));
    var _inputAssembler = _interopRequireDefault(require("../../../../../renderer/core/input-assembler"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var MeshBuffer = require("../../mesh-buffer");
    var renderer = require("../../../index");
    var Graphics = require("../../../../graphics/graphics");
    var PointFlags = require("../../../../graphics/types").PointFlags;
    var LineJoin = Graphics.LineJoin;
    var LineCap = Graphics.LineCap;
    var Earcut = require("./earcut");
    require("./impl");
    var MAX_VERTEX = 65535;
    var MAX_INDICE = 2 * MAX_VERTEX;
    var PI = Math.PI;
    var min = Math.min;
    var max = Math.max;
    var ceil = Math.ceil;
    var acos = Math.acos;
    var cos = Math.cos;
    var sin = Math.sin;
    var atan2 = Math.atan2;
    function curveDivs(r, arc, tol) {
      var da = 2 * acos(r / (r + tol));
      return max(2, ceil(arc / da));
    }
    function clamp(v, min, max) {
      if (v < min) return min;
      if (v > max) return max;
      return v;
    }
    var gfx = cc.gfx;
    var vfmtPosColorSdf = new gfx.VertexFormat([ {
      name: gfx.ATTR_POSITION,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: gfx.ATTR_COLOR,
      type: gfx.ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    }, {
      name: "a_dist",
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 1
    } ]);
    vfmtPosColorSdf.name = "vfmtPosColorSdf";
    var GraphicsAssembler = (function(_Assembler) {
      _inheritsLoose(GraphicsAssembler, _Assembler);
      function GraphicsAssembler(graphics) {
        var _this;
        _this = _Assembler.call(this, graphics) || this;
        _this._buffer = null;
        _this._buffers = [];
        _this._bufferOffset = 0;
        return _this;
      }
      var _proto = GraphicsAssembler.prototype;
      _proto.getVfmt = function getVfmt() {
        return vfmtPosColorSdf;
      };
      _proto.getVfmtFloatCount = function getVfmtFloatCount() {
        return 4;
      };
      _proto.requestBuffer = function requestBuffer() {
        var buffer = {
          indiceStart: 0,
          vertexStart: 0
        };
        var meshbuffer = new MeshBuffer(renderer._handle, this.getVfmt());
        buffer.meshbuffer = meshbuffer;
        var ia = new _inputAssembler["default"](meshbuffer._vb, meshbuffer._ib);
        buffer.ia = ia;
        this._buffers.push(buffer);
        return buffer;
      };
      _proto.getBuffers = function getBuffers() {
        0 === this._buffers.length && this.requestBuffer();
        return this._buffers;
      };
      _proto.clear = function clear(clean) {
        this._bufferOffset = 0;
        var datas = this._buffers;
        if (clean) {
          for (var i = 0, l = datas.length; i < l; i++) {
            var data = datas[i];
            data.meshbuffer.destroy();
            data.meshbuffer = null;
          }
          datas.length = 0;
        } else for (var _i = 0, _l = datas.length; _i < _l; _i++) {
          var _data = datas[_i];
          _data.indiceStart = 0;
          _data.vertexStart = 0;
          var meshbuffer = _data.meshbuffer;
          meshbuffer.reset();
        }
      };
      _proto.fillBuffers = function fillBuffers(graphics, renderer) {
        renderer._flush();
        renderer.node = graphics.node;
        renderer.material = graphics._materials[0];
        var buffers = this.getBuffers();
        for (var index = 0, length = buffers.length; index < length; index++) {
          var buffer = buffers[index];
          var meshbuffer = buffer.meshbuffer;
          buffer.ia._count = buffer.indiceStart;
          renderer._flushIA(buffer.ia);
          meshbuffer.uploadData();
        }
      };
      _proto.genBuffer = function genBuffer(graphics, cverts) {
        var buffers = this.getBuffers();
        var buffer = buffers[this._bufferOffset];
        var meshbuffer = buffer.meshbuffer;
        var maxVertsCount = buffer.vertexStart + cverts;
        if (maxVertsCount > MAX_VERTEX || 3 * maxVertsCount > MAX_INDICE) {
          ++this._bufferOffset;
          maxVertsCount = cverts;
          if (this._bufferOffset < buffers.length) buffer = buffers[this._bufferOffset]; else {
            buffer = this.requestBuffer(graphics);
            buffers[this._bufferOffset] = buffer;
          }
          meshbuffer = buffer.meshbuffer;
        }
        maxVertsCount > meshbuffer.vertexOffset && meshbuffer.requestStatic(cverts, 3 * cverts);
        this._buffer = buffer;
        return buffer;
      };
      _proto.stroke = function stroke(graphics) {
        this._curColor = graphics._strokeColor._val;
        this._flattenPaths(graphics._impl);
        this._expandStroke(graphics);
        graphics._impl._updatePathOffset = true;
      };
      _proto.fill = function fill(graphics) {
        this._curColor = graphics._fillColor._val;
        this._expandFill(graphics);
        graphics._impl._updatePathOffset = true;
      };
      _proto._expandStroke = function _expandStroke(graphics) {
        var w = .5 * graphics.lineWidth, lineCap = graphics.lineCap, lineJoin = graphics.lineJoin, miterLimit = graphics.miterLimit;
        var impl = graphics._impl;
        var ncap = curveDivs(w, PI, impl._tessTol);
        this._calculateJoins(impl, w, lineJoin, miterLimit);
        var paths = impl._paths;
        var cverts = 0;
        for (var i = impl._pathOffset, l = impl._pathLength; i < l; i++) {
          var path = paths[i];
          var pointsLength = path.points.length;
          lineJoin === LineJoin.ROUND ? cverts += 2 * (pointsLength + path.nbevel * (ncap + 2) + 1) : cverts += 2 * (pointsLength + 5 * path.nbevel + 1);
          path.closed || (lineCap === LineCap.ROUND ? cverts += 2 * (2 * ncap + 2) : cverts += 12);
        }
        var buffer = this.genBuffer(graphics, cverts), meshbuffer = buffer.meshbuffer, vData = meshbuffer._vData, iData = meshbuffer._iData;
        for (var _i2 = impl._pathOffset, _l2 = impl._pathLength; _i2 < _l2; _i2++) {
          var _path = paths[_i2];
          var pts = _path.points;
          var _pointsLength = pts.length;
          var offset = buffer.vertexStart;
          var p0 = void 0, p1 = void 0;
          var start = void 0, end = void 0, loop = void 0;
          loop = _path.closed;
          if (loop) {
            p0 = pts[_pointsLength - 1];
            p1 = pts[0];
            start = 0;
            end = _pointsLength;
          } else {
            p0 = pts[0];
            p1 = pts[1];
            start = 1;
            end = _pointsLength - 1;
          }
          p1 = p1 || p0;
          if (!loop) {
            var dPos = p1.sub(p0);
            dPos.normalizeSelf();
            var dx = dPos.x;
            var dy = dPos.y;
            lineCap === LineCap.BUTT ? this._buttCapStart(p0, dx, dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCapStart(p0, dx, dy, w, w) : lineCap === LineCap.ROUND && this._roundCapStart(p0, dx, dy, w, ncap);
          }
          for (var j = start; j < end; ++j) {
            if (lineJoin === LineJoin.ROUND) this._roundJoin(p0, p1, w, w, ncap); else if (0 !== (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL))) this._bevelJoin(p0, p1, w, w); else {
              this._vset(p1.x + p1.dmx * w, p1.y + p1.dmy * w, 1);
              this._vset(p1.x - p1.dmx * w, p1.y - p1.dmy * w, -1);
            }
            p0 = p1;
            p1 = pts[j + 1];
          }
          if (loop) {
            var floatCount = this.getVfmtFloatCount();
            var vDataoOfset = offset * floatCount;
            this._vset(vData[vDataoOfset], vData[vDataoOfset + 1], 1);
            this._vset(vData[vDataoOfset + floatCount], vData[vDataoOfset + floatCount + 1], -1);
          } else {
            var _dPos = p1.sub(p0);
            _dPos.normalizeSelf();
            var _dx = _dPos.x;
            var _dy = _dPos.y;
            lineCap === LineCap.BUTT ? this._buttCapEnd(p1, _dx, _dy, w, 0) : lineCap === LineCap.SQUARE ? this._buttCapEnd(p1, _dx, _dy, w, w) : lineCap === LineCap.ROUND && this._roundCapEnd(p1, _dx, _dy, w, ncap);
          }
          var indicesOffset = buffer.indiceStart;
          for (var _start = offset + 2, _end = buffer.vertexStart; _start < _end; _start++) {
            iData[indicesOffset++] = _start - 2;
            iData[indicesOffset++] = _start - 1;
            iData[indicesOffset++] = _start;
          }
          buffer.indiceStart = indicesOffset;
        }
      };
      _proto._expandFill = function _expandFill(graphics) {
        var impl = graphics._impl;
        var paths = impl._paths;
        var cverts = 0;
        for (var i = impl._pathOffset, l = impl._pathLength; i < l; i++) {
          var path = paths[i];
          var pointsLength = path.points.length;
          cverts += pointsLength;
        }
        var buffer = this.genBuffer(graphics, cverts), meshbuffer = buffer.meshbuffer, vData = meshbuffer._vData, iData = meshbuffer._iData;
        for (var _i3 = impl._pathOffset, _l3 = impl._pathLength; _i3 < _l3; _i3++) {
          var _path2 = paths[_i3];
          var pts = _path2.points;
          var _pointsLength2 = pts.length;
          if (0 === _pointsLength2) continue;
          var offset = buffer.vertexStart;
          for (var j = 0; j < _pointsLength2; ++j) this._vset(pts[j].x, pts[j].y);
          var indicesOffset = buffer.indiceStart;
          if (_path2.complex) {
            var earcutData = [];
            var floatCount = this.getVfmtFloatCount();
            for (var _j = offset, end = buffer.vertexStart; _j < end; _j++) {
              var vDataOffset = _j * floatCount;
              earcutData.push(vData[vDataOffset]);
              earcutData.push(vData[vDataOffset + 1]);
            }
            var newIndices = Earcut(earcutData, null, 2);
            if (!newIndices || 0 === newIndices.length) continue;
            for (var _j2 = 0, nIndices = newIndices.length; _j2 < nIndices; _j2++) iData[indicesOffset++] = newIndices[_j2] + offset;
          } else {
            var first = offset;
            for (var start = offset + 2, _end2 = buffer.vertexStart; start < _end2; start++) {
              iData[indicesOffset++] = first;
              iData[indicesOffset++] = start - 1;
              iData[indicesOffset++] = start;
            }
          }
          buffer.indiceStart = indicesOffset;
        }
      };
      _proto._calculateJoins = function _calculateJoins(impl, w, lineJoin, miterLimit) {
        var iw = 0;
        var w2 = w * w;
        w > 0 && (iw = 1 / w);
        var paths = impl._paths;
        for (var i = impl._pathOffset, l = impl._pathLength; i < l; i++) {
          var path = paths[i];
          var pts = path.points;
          var ptsLength = pts.length;
          var p0 = pts[ptsLength - 1];
          var p1 = pts[0];
          var nleft = 0;
          path.nbevel = 0;
          for (var j = 0; j < ptsLength; j++) {
            var dmr2 = void 0, cross = void 0, limit = void 0;
            var dlx0 = p0.dy;
            var dly0 = -p0.dx;
            var dlx1 = p1.dy;
            var dly1 = -p1.dx;
            p1.dmx = .5 * (dlx0 + dlx1);
            p1.dmy = .5 * (dly0 + dly1);
            dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy;
            if (dmr2 > 1e-6) {
              var scale = 1 / dmr2;
              scale > 600 && (scale = 600);
              p1.dmx *= scale;
              p1.dmy *= scale;
            }
            cross = p1.dx * p0.dy - p0.dx * p1.dy;
            if (cross > 0) {
              nleft++;
              p1.flags |= PointFlags.PT_LEFT;
            }
            limit = max(11, min(p0.len, p1.len) * iw);
            dmr2 * limit * limit < 1 && (p1.flags |= PointFlags.PT_INNERBEVEL);
            var dmwx = p1.dmx * w;
            var dmwy = p1.dmy * w;
            var dmlen2 = dmwx * dmwx + dmwy * dmwy;
            dmlen2 > p1.len * p1.len + w2 && dmlen2 > p0.len * p0.len + w2 && (p1.flags |= PointFlags.PT_INNERBEVEL);
            p1.flags & PointFlags.PT_CORNER && (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) && (p1.flags |= PointFlags.PT_BEVEL);
            0 !== (p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) && path.nbevel++;
            p0 = p1;
            p1 = pts[j + 1];
          }
        }
      };
      _proto._flattenPaths = function _flattenPaths(impl) {
        var paths = impl._paths;
        for (var i = impl._pathOffset, l = impl._pathLength; i < l; i++) {
          var path = paths[i];
          var pts = path.points;
          var p0 = pts[pts.length - 1];
          var p1 = pts[0];
          if (pts.length > 2 && p0.equals(p1)) {
            path.closed = true;
            pts.pop();
            p0 = pts[pts.length - 1];
          }
          for (var j = 0, size = pts.length; j < size; j++) {
            var dPos = p1.sub(p0);
            p0.len = dPos.mag();
            (dPos.x || dPos.y) && dPos.normalizeSelf();
            p0.dx = dPos.x;
            p0.dy = dPos.y;
            p0 = p1;
            p1 = pts[j + 1];
          }
        }
      };
      _proto._chooseBevel = function _chooseBevel(bevel, p0, p1, w) {
        var x = p1.x;
        var y = p1.y;
        var x0, y0, x1, y1;
        if (0 !== bevel) {
          x0 = x + p0.dy * w;
          y0 = y - p0.dx * w;
          x1 = x + p1.dy * w;
          y1 = y - p1.dx * w;
        } else {
          x0 = x1 = x + p1.dmx * w;
          y0 = y1 = y + p1.dmy * w;
        }
        return [ x0, y0, x1, y1 ];
      };
      _proto._buttCapStart = function _buttCapStart(p, dx, dy, w, d) {
        var px = p.x - dx * d;
        var py = p.y - dy * d;
        var dlx = dy;
        var dly = -dx;
        this._vset(px + dlx * w, py + dly * w, 1);
        this._vset(px - dlx * w, py - dly * w, -1);
      };
      _proto._buttCapEnd = function _buttCapEnd(p, dx, dy, w, d) {
        var px = p.x + dx * d;
        var py = p.y + dy * d;
        var dlx = dy;
        var dly = -dx;
        this._vset(px + dlx * w, py + dly * w, 1);
        this._vset(px - dlx * w, py - dly * w, -1);
      };
      _proto._roundCapStart = function _roundCapStart(p, dx, dy, w, ncap) {
        var px = p.x;
        var py = p.y;
        var dlx = dy;
        var dly = -dx;
        for (var i = 0; i < ncap; i++) {
          var a = i / (ncap - 1) * PI;
          var ax = cos(a) * w, ay = sin(a) * w;
          this._vset(px - dlx * ax - dx * ay, py - dly * ax - dy * ay, 1);
          this._vset(px, py, 0);
        }
        this._vset(px + dlx * w, py + dly * w, 1);
        this._vset(px - dlx * w, py - dly * w, -1);
      };
      _proto._roundCapEnd = function _roundCapEnd(p, dx, dy, w, ncap) {
        var px = p.x;
        var py = p.y;
        var dlx = dy;
        var dly = -dx;
        this._vset(px + dlx * w, py + dly * w, 1);
        this._vset(px - dlx * w, py - dly * w, -1);
        for (var i = 0; i < ncap; i++) {
          var a = i / (ncap - 1) * PI;
          var ax = cos(a) * w, ay = sin(a) * w;
          this._vset(px, py, 0);
          this._vset(px - dlx * ax + dx * ay, py - dly * ax + dy * ay, 1);
        }
      };
      _proto._roundJoin = function _roundJoin(p0, p1, lw, rw, ncap) {
        var dlx0 = p0.dy;
        var dly0 = -p0.dx;
        var dlx1 = p1.dy;
        var dly1 = -p1.dx;
        var p1x = p1.x;
        var p1y = p1.y;
        if (0 !== (p1.flags & PointFlags.PT_LEFT)) {
          var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
          var lx0 = out[0];
          var ly0 = out[1];
          var lx1 = out[2];
          var ly1 = out[3];
          var a0 = atan2(-dly0, -dlx0);
          var a1 = atan2(-dly1, -dlx1);
          a1 > a0 && (a1 -= 2 * PI);
          this._vset(lx0, ly0, 1);
          this._vset(p1x - dlx0 * rw, p1.y - dly0 * rw, -1);
          var n = clamp(ceil((a0 - a1) / PI) * ncap, 2, ncap);
          for (var i = 0; i < n; i++) {
            var u = i / (n - 1);
            var a = a0 + u * (a1 - a0);
            var rx = p1x + cos(a) * rw;
            var ry = p1y + sin(a) * rw;
            this._vset(p1x, p1y, 0);
            this._vset(rx, ry, -1);
          }
          this._vset(lx1, ly1, 1);
          this._vset(p1x - dlx1 * rw, p1y - dly1 * rw, -1);
        } else {
          var _out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
          var rx0 = _out[0];
          var ry0 = _out[1];
          var rx1 = _out[2];
          var ry1 = _out[3];
          var _a = atan2(dly0, dlx0);
          var _a2 = atan2(dly1, dlx1);
          _a2 < _a && (_a2 += 2 * PI);
          this._vset(p1x + dlx0 * rw, p1y + dly0 * rw, 1);
          this._vset(rx0, ry0, -1);
          var _n = clamp(ceil((_a2 - _a) / PI) * ncap, 2, ncap);
          for (var _i4 = 0; _i4 < _n; _i4++) {
            var _u = _i4 / (_n - 1);
            var _a3 = _a + _u * (_a2 - _a);
            var lx = p1x + cos(_a3) * lw;
            var ly = p1y + sin(_a3) * lw;
            this._vset(lx, ly, 1);
            this._vset(p1x, p1y, 0);
          }
          this._vset(p1x + dlx1 * rw, p1y + dly1 * rw, 1);
          this._vset(rx1, ry1, -1);
        }
      };
      _proto._bevelJoin = function _bevelJoin(p0, p1, lw, rw) {
        var rx0, ry0, rx1, ry1;
        var lx0, ly0, lx1, ly1;
        var dlx0 = p0.dy;
        var dly0 = -p0.dx;
        var dlx1 = p1.dy;
        var dly1 = -p1.dx;
        if (p1.flags & PointFlags.PT_LEFT) {
          var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);
          lx0 = out[0];
          ly0 = out[1];
          lx1 = out[2];
          ly1 = out[3];
          this._vset(lx0, ly0, 1);
          this._vset(p1.x - dlx0 * rw, p1.y - dly0 * rw, -1);
          this._vset(lx1, ly1, 1);
          this._vset(p1.x - dlx1 * rw, p1.y - dly1 * rw, -1);
        } else {
          var _out2 = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);
          rx0 = _out2[0];
          ry0 = _out2[1];
          rx1 = _out2[2];
          ry1 = _out2[3];
          this._vset(p1.x + dlx0 * lw, p1.y + dly0 * lw, 1);
          this._vset(rx0, ry0, -1);
          this._vset(p1.x + dlx1 * lw, p1.y + dly1 * lw, 1);
          this._vset(rx1, ry1, -1);
        }
      };
      _proto._vset = function _vset(x, y, distance) {
        void 0 === distance && (distance = 0);
        var buffer = this._buffer;
        var meshbuffer = buffer.meshbuffer;
        var dataOffset = buffer.vertexStart * this.getVfmtFloatCount();
        var vData = meshbuffer._vData;
        var uintVData = meshbuffer._uintVData;
        vData[dataOffset] = x;
        vData[dataOffset + 1] = y;
        uintVData[dataOffset + 2] = this._curColor;
        vData[dataOffset + 3] = distance;
        buffer.vertexStart++;
        meshbuffer._dirty = true;
      };
      return GraphicsAssembler;
    })(_assembler["default"]);
    exports["default"] = GraphicsAssembler;
    _assembler["default"].register(cc.Graphics, GraphicsAssembler);
    module.exports = exports["default"];
  }), {
    "../../../../../renderer/core/input-assembler": 423,
    "../../../../graphics/graphics": 235,
    "../../../../graphics/types": 238,
    "../../../assembler": 302,
    "../../../index": 322,
    "../../mesh-buffer": 368,
    "./earcut": 331,
    "./impl": 332
  } ],
  334: [ (function(require, module, exports) {
    "use strict";
    cc.assemblers = {};
    require("./sprite");
    require("./mask-assembler");
    require("./graphics");
    require("./label");
    require("./motion-streak");
    require("./motion-streak-multi");
  }), {
    "./graphics": 333,
    "./label": 344,
    "./mask-assembler": 345,
    "./motion-streak": 347,
    "./motion-streak-multi": 346,
    "./sprite": 366
  } ],
  335: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _bmfont = _interopRequireDefault(require("../2d/bmfont"));
    var _vertexFormat = require("../../../../webgl/vertex-format");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var MultiWebglBmfontAssembler = (function(_WebglBmfontAssembler) {
      _inheritsLoose(MultiWebglBmfontAssembler, _WebglBmfontAssembler);
      function MultiWebglBmfontAssembler() {
        return _WebglBmfontAssembler.apply(this, arguments) || this;
      }
      var _proto = MultiWebglBmfontAssembler.prototype;
      _proto.initData = function initData() {
        var data = this._renderData;
        data.createFlexData(0, this.verticesCount, this.indicesCount, this.getVfmt());
      };
      _proto.getVfmt = function getVfmt() {
        return _vertexFormat.vfmtPosUvColorTexId;
      };
      _proto.getBuffer = function getBuffer() {
        return cc.renderer._handle.getBuffer("mesh", this.getVfmt());
      };
      _proto.updateRenderData = function updateRenderData(comp) {
        _WebglBmfontAssembler.prototype.updateRenderData.call(this, comp);
        comp._texIdDirty && comp._updateMultiTexId(comp.getMaterial(0), comp._frame._texture);
        this.updateTexId(comp);
        comp._texIdDirty = false;
      };
      _proto.updateRenderDataForSwitchMaterial = function updateRenderDataForSwitchMaterial(comp) {
        _WebglBmfontAssembler.prototype._preUpdateRenderData.call(this, comp);
        _WebglBmfontAssembler.prototype._aftUpdateRenderData.call(this, comp);
        comp._texIdDirty && comp._updateMultiTexId(comp.getMaterial(0), comp._frame._texture);
        this.updateTexId(comp);
        comp._texIdDirty = false;
        true;
        this._aftUpdateRenderDataForNative();
      };
      return MultiWebglBmfontAssembler;
    })(_bmfont["default"]);
    exports["default"] = MultiWebglBmfontAssembler;
    MultiWebglBmfontAssembler.prototype.floatsPerVert = 6;
    MultiWebglBmfontAssembler.prototype.texIdOffset = 5;
    MultiWebglBmfontAssembler.prototype.isMulti = true;
    module.exports = exports["default"];
  }), {
    "../../../../webgl/vertex-format": 371,
    "../2d/bmfont": 337
  } ],
  336: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _ttf = _interopRequireDefault(require("../2d/ttf"));
    var _vertexFormat = require("../../../../webgl/vertex-format");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var MultiWebglTTFAssembler = (function(_WebglTTFAssembler) {
      _inheritsLoose(MultiWebglTTFAssembler, _WebglTTFAssembler);
      function MultiWebglTTFAssembler() {
        return _WebglTTFAssembler.apply(this, arguments) || this;
      }
      var _proto = MultiWebglTTFAssembler.prototype;
      _proto.initData = function initData() {
        var data = this._renderData;
        data.createFlexData(0, this.verticesCount, this.indicesCount, this.getVfmt());
        var indices = data.iDatas[0];
        data.initQuadIndices(indices);
      };
      _proto.getVfmt = function getVfmt() {
        return _vertexFormat.vfmtPosUvColorTexId;
      };
      _proto.getBuffer = function getBuffer() {
        return cc.renderer._handle.getBuffer("mesh", this.getVfmt());
      };
      _proto.updateRenderData = function updateRenderData(comp) {
        _WebglTTFAssembler.prototype.updateRenderData.call(this, comp);
        comp._texIdDirty && comp._updateMultiTexId(comp.getMaterial(0), comp._frame._texture);
        this.updateTexId(comp);
        comp._texIdDirty = false;
      };
      _proto.updateRenderDataForSwitchMaterial = function updateRenderDataForSwitchMaterial(comp) {
        _WebglTTFAssembler.prototype._aftUpdateRenderData.call(this, comp);
        comp._texIdDirty && comp._updateMultiTexId(comp.getMaterial(0), comp._frame._texture);
        this.updateTexId(comp);
        comp._texIdDirty = false;
        true;
        this._aftUpdateRenderDataForNative();
      };
      return MultiWebglTTFAssembler;
    })(_ttf["default"]);
    exports["default"] = MultiWebglTTFAssembler;
    MultiWebglTTFAssembler.prototype.floatsPerVert = 6;
    MultiWebglTTFAssembler.prototype.texIdOffset = 5;
    MultiWebglTTFAssembler.prototype.isMulti = true;
    module.exports = exports["default"];
  }), {
    "../../../../webgl/vertex-format": 371,
    "../2d/ttf": 340
  } ],
  337: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _bmfont = _interopRequireDefault(require("../../../../utils/label/bmfont"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var _dataOffset = 0;
    var WebglBmfontAssembler = (function(_BmfontAssembler) {
      _inheritsLoose(WebglBmfontAssembler, _BmfontAssembler);
      function WebglBmfontAssembler() {
        return _BmfontAssembler.apply(this, arguments) || this;
      }
      var _proto = WebglBmfontAssembler.prototype;
      _proto.initData = function initData() {
        this._renderData.createFlexData(0, 4, 6, this.getVfmt());
      };
      _proto._reserveQuads = function _reserveQuads(comp, count) {
        var verticesCount = 4 * count;
        var indicesCount = 6 * count;
        var flexBuffer = this._renderData._flexBuffer;
        flexBuffer.reserve(verticesCount, indicesCount);
        flexBuffer.used(verticesCount, indicesCount);
        var iData = this._renderData.iDatas[0];
        for (var i = 0, vid = 0, l = indicesCount; i < l; i += 6, vid += 4) {
          iData[i] = vid;
          iData[i + 1] = vid + 1;
          iData[i + 2] = vid + 2;
          iData[i + 3] = vid + 1;
          iData[i + 4] = vid + 3;
          iData[i + 5] = vid + 2;
        }
        _dataOffset = 0;
      };
      _proto._quadsUpdated = function _quadsUpdated(comp) {
        _dataOffset = 0;
        var flexBuffer = this._renderData._flexBuffer;
        flexBuffer.used(this.verticesCount, this.indicesCount);
      };
      _proto._getColor = function _getColor(comp) {
        return comp.node._color._val;
      };
      _proto.appendQuad = function appendQuad(comp, texture, rect, rotated, x, y, scale, letter) {
        var renderData = this._renderData;
        var verts = renderData.vDatas[0], uintVerts = renderData.uintVDatas[0];
        this.verticesCount += 4;
        this.indicesCount = this.verticesCount / 2 * 3;
        var texw = texture.width, texh = texture.height, rectWidth = rect.width, rectHeight = rect.height, color = this._getColor(comp);
        var l, b, r, t;
        var floatsPerVert = this.floatsPerVert;
        var uvDataOffset = _dataOffset + this.uvOffset;
        if (rotated) {
          l = rect.x / texw;
          r = (rect.x + rectHeight) / texw;
          b = (rect.y + rectWidth) / texh;
          t = rect.y / texh;
          verts[uvDataOffset] = l;
          verts[uvDataOffset + 1] = t;
          uvDataOffset += floatsPerVert;
          verts[uvDataOffset] = l;
          verts[uvDataOffset + 1] = b;
          uvDataOffset += floatsPerVert;
          verts[uvDataOffset] = r;
          verts[uvDataOffset + 1] = t;
          uvDataOffset += floatsPerVert;
          verts[uvDataOffset] = r;
          verts[uvDataOffset + 1] = b;
        } else {
          l = rect.x / texw;
          r = (rect.x + rectWidth) / texw;
          b = (rect.y + rectHeight) / texh;
          t = rect.y / texh;
          verts[uvDataOffset] = l;
          verts[uvDataOffset + 1] = b;
          uvDataOffset += floatsPerVert;
          verts[uvDataOffset] = r;
          verts[uvDataOffset + 1] = b;
          uvDataOffset += floatsPerVert;
          verts[uvDataOffset] = l;
          verts[uvDataOffset + 1] = t;
          uvDataOffset += floatsPerVert;
          verts[uvDataOffset] = r;
          verts[uvDataOffset + 1] = t;
        }
        var retinaScale = this.getTTFTextureSizeScale();
        x /= retinaScale;
        y /= retinaScale;
        rectWidth /= retinaScale;
        rectHeight /= retinaScale;
        l = x;
        r = x + rectWidth * scale;
        b = y - rectHeight * scale;
        t = y;
        this.appendVerts(comp, _dataOffset, l, r, b, t, letter);
        var colorOffset = _dataOffset + this.colorOffset;
        for (var i = 0; i < 4; i++) {
          uintVerts[colorOffset] = color;
          colorOffset += floatsPerVert;
        }
        _dataOffset += 4 * this.floatsPerVert;
      };
      _proto.appendVerts = function appendVerts(comp, offset, l, r, b, t, letter) {
        var local = this._local;
        var floatsPerVert = this.floatsPerVert;
        local[offset] = l;
        local[offset + 1] = b;
        offset += floatsPerVert;
        local[offset] = r;
        local[offset + 1] = b;
        offset += floatsPerVert;
        local[offset] = l;
        local[offset + 1] = t;
        offset += floatsPerVert;
        local[offset] = r;
        local[offset + 1] = t;
      };
      _proto.updateWorldVerts = function updateWorldVerts(comp) {
        var node = comp.node;
        var matrix = node._worldMatrix;
        var matrixm = matrix.m, a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        var local = this._local;
        var world = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        for (var offset = 0; offset < local.length; offset += floatsPerVert) {
          var x = local[offset];
          var y = local[offset + 1];
          world[offset] = x * a + y * c + tx;
          world[offset + 1] = x * b + y * d + ty;
        }
      };
      return WebglBmfontAssembler;
    })(_bmfont["default"]);
    exports["default"] = WebglBmfontAssembler;
    module.exports = exports["default"];
  }), {
    "../../../../utils/label/bmfont": 326
  } ],
  338: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var js = require("../../../../../platform/js");
    var WebglBmfontAssembler = require("./bmfont");
    var LetterFontAssembler = require("../../../../utils/label/letter-font");
    var WHITE = cc.color(255, 255, 255, 255);
    var WebglLetterFontAssembler = (function(_LetterFontAssembler) {
      _inheritsLoose(WebglLetterFontAssembler, _LetterFontAssembler);
      function WebglLetterFontAssembler() {
        return _LetterFontAssembler.apply(this, arguments) || this;
      }
      var _proto = WebglLetterFontAssembler.prototype;
      _proto.createData = function createData(comp) {
        return comp.requestRenderData();
      };
      _proto._getColor = function _getColor(comp) {
        WHITE._fastSetA(comp.node._color.a);
        return WHITE._val;
      };
      _proto.updateColor = function updateColor(comp) {
        var color = this._getColor(comp);
        _LetterFontAssembler.prototype.updateColor.call(this, comp, color);
      };
      return WebglLetterFontAssembler;
    })(LetterFontAssembler);
    exports["default"] = WebglLetterFontAssembler;
    module.exports = exports["default"];
  }), {
    "../../../../../platform/js": 294,
    "../../../../utils/label/letter-font": 328,
    "./bmfont": 337
  } ],
  339: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _materialVariant = _interopRequireDefault(require("../../../../../assets/material/material-variant"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Label = require("../../../../../components/CCLabel");
    var LabelShadow = require("../../../../../components/CCLabelShadow");
    var LabelOutline = require("../../../../../components/CCLabelOutline");
    var Material = require("../../../../../assets/material/CCMaterial");
    var UPDATE_CONTENT = 1;
    var UPDATE_FONT = 2;
    var UPDATE_EFFECT = 4;
    var NativeTTF = (function() {
      function NativeTTF() {}
      var _proto = NativeTTF.prototype;
      _proto.init = function init(comp) {
        this.labelMaterial = null;
        this._label = this._renderComp = comp;
        renderer.CustomAssembler.prototype.ctor.call(this);
        comp.node._proxy.setAssembler(this);
        this._layout = new jsb.LabelRenderer();
        this._layout.init(comp);
        this._cfg = new DataView(this._layout._cfg);
        this._layoutInfo = new DataView(this._layout._layout);
        this._cfgFields = jsb.LabelRenderer._cfgFields;
        this._layoutFields = jsb.LabelRenderer._layoutFields;
        this._layout.bindNodeProxy(comp.node._proxy);
        this._bindMaterial(comp);
      };
      _proto._setBufferFlag = function _setBufferFlag(dv, offset, size, type, flag) {
        if ("int8" == type && 1 == size) {
          var v = dv.getInt8(offset);
          dv.setInt8(offset, flag | v);
        } else if ("int32" == type && 4 == size) {
          var _v = dv.getInt32(offset, jsb.__isLittleEndian__);
          dv.setInt32(offset, flag | _v, jsb.__isLittleEndian__);
        } else cc.warn("flag storage type should be int8/int32 only, type/size -> " + type + "/" + size + ".");
      };
      _proto._updateCfgFlag = function _updateCfgFlag(flag) {
        var field = this._cfgFields.updateFlags;
        this._setBufferFlag(this._cfg, field.offset, field.size, field.type, flag);
      };
      _proto._setBufferValue = function _setBufferValue(dv, offset, size, type, value) {
        if ("float" == type && 4 == size) dv.setFloat32(offset, value, jsb.__isLittleEndian__); else if ("int32" == type && 4 == size) dv.setInt32(offset, value, jsb.__isLittleEndian__); else if ("bool" == type && 1 == size) dv.setInt8(offset, !value ? 0 : 1, jsb.__isLittleEndian__); else if ("Color4B" == type && 4 == size) {
          dv.setUint8(offset, value.r);
          dv.setUint8(offset + 1, value.g);
          dv.setUint8(offset + 2, value.b);
          dv.setUint8(offset + 3, value.a);
        } else "int8" == type && 1 == size ? dv.setUint8(offset, value) : cc.warn("dont know how to set value to buffer, type/size -> " + type + "/" + size + ".");
      };
      _proto._setFieldValue = function _setFieldValue(dv, desc, field_name, value) {
        var field = desc[field_name];
        this._setBufferValue(dv, field.offset, field.size, field.type, value);
      };
      _proto._getBufferValue = function _getBufferValue(dv, offset, size, type) {
        if ("float" == type && 4 == size) return dv.getFloat32(offset, jsb.__isLittleEndian__);
        if ("int32" == type && 4 == size) return dv.getInt32(offset, jsb.__isLittleEndian__);
        if ("bool" == type && 1 == size) return 0 != dv.getInt8(offset, jsb.__isLittleEndian__);
        if ("Color4B" == type && 4 == size) {
          var r = dv.getUint8(offset);
          var g = dv.getUint8(offset + 1);
          var b = dv.getUint8(offset + 2);
          var a = dv.getUint8(offset + 3);
          return {
            r: r,
            g: g,
            b: b,
            a: a
          };
        }
        if ("int8" == type && 1 == size) return dv.getUint8(offset);
        cc.warn("dont know how to get value from buffer, type/size -> " + type + "/" + size + ".");
        return;
      };
      _proto._getFieldValue = function _getFieldValue(dv, desc, field_name) {
        var field = desc[field_name];
        return this._getBufferValue(dv, field.offset, field.size, field.type);
      };
      _proto._getLayoutValue = function _getLayoutValue(field_name) {
        return this._getFieldValue(this._layoutInfo, this._layoutFields, field_name);
      };
      _proto._setLayoutValue = function _setLayoutValue(field_name, value) {
        return this._setFieldValue(this._layoutInfo, this._layoutFields, field_name, value);
      };
      _proto._updateCfgFlag_Content = function _updateCfgFlag_Content() {
        this._updateCfgFlag(UPDATE_CONTENT);
      };
      _proto._updateCfgFlag_Font = function _updateCfgFlag_Font() {
        this._updateCfgFlag(UPDATE_FONT);
      };
      _proto._colorEqual = function _colorEqual(a, b) {
        return a.r == b.r && a.g == b.g && a.b == b.b && a.a == b.a;
      };
      _proto._colorToObj = function _colorToObj(r, g, b, a) {
        return {
          r: r,
          g: g,
          b: b,
          a: a
        };
      };
      _proto.setString = function setString(str) {
        if (str != this._layout.string) {
          this._layout.string = str;
          this._updateCfgFlag_Content();
        }
      };
      _proto.setFontPath = function setFontPath(path) {
        if (path != this._layout.fontPath) {
          this._layout.fontPath = path;
          this._updateCfgFlag_Font();
        }
      };
      _proto.setFontSize = function setFontSize(fontSize, fontSizeRetina) {
        var oldfontsize = this._getFieldValue(this._cfg, this._cfgFields, "fontSize");
        if (oldfontsize != fontSize) {
          this._setFieldValue(this._cfg, this._cfgFields, "fontSize", fontSize);
          this._setFieldValue(this._cfg, this._cfgFields, "fontSizeRetina", fontSizeRetina);
          this._updateCfgFlag_Font();
        }
      };
      _proto.setOutline = function setOutline(outline) {
        var oldOutline = this._getLayoutValue("outlineSize");
        oldOutline > 0 != outline > 0 && this._updateCfgFlag_Font();
        if (oldOutline != outline) {
          this._updateCfgFlag_Content();
          this._setLayoutValue("outlineSize", outline);
        }
      };
      _proto.setOutlineColor = function setOutlineColor(color) {
        var oldColor = this._getLayoutValue("outlineColor");
        if (!this._colorEqual(oldColor, color)) {
          this._setLayoutValue("outlineColor", color);
          this._updateCfgFlag_Content();
        }
      };
      _proto.setLineHeight = function setLineHeight(lineHeight) {
        var oldLineHeight = this._getLayoutValue("lineHeight");
        if (oldLineHeight != lineHeight) {
          this._setLayoutValue("lineHeight", lineHeight);
          this._updateCfgFlag_Content();
        }
      };
      _proto.setOverFlow = function setOverFlow(overflow) {
        var oldValue = this._getLayoutValue("overflow");
        if (oldValue != overflow) {
          this._setLayoutValue("overflow", overflow);
          this._updateCfgFlag_Content();
        }
      };
      _proto.setEnableWrap = function setEnableWrap(value) {
        var oldValue = this._getLayoutValue("wrap");
        if (oldValue != value) {
          this._setLayoutValue("wrap", value);
          this._updateCfgFlag_Content();
        }
      };
      _proto.setVerticalAlign = function setVerticalAlign(value) {
        var oldValue = this._getLayoutValue("valign");
        if (oldValue != value) {
          this._setLayoutValue("valign", value);
          this._updateCfgFlag_Content();
        }
      };
      _proto.setHorizontalAlign = function setHorizontalAlign(value) {
        var oldValue = this._getLayoutValue("halign");
        if (oldValue != value) {
          this._setLayoutValue("halign", value);
          this._updateCfgFlag_Content();
        }
      };
      _proto.setContentSize = function setContentSize(width, height) {
        var oldWidth = this._getLayoutValue("width");
        var oldHeight = this._getLayoutValue("height");
        if (oldWidth != width || oldHeight != height) {
          this._setLayoutValue("height", height);
          this._setLayoutValue("width", width);
          this._updateCfgFlag_Content();
        }
      };
      _proto.setAnchorPoint = function setAnchorPoint(x, y) {
        var oldX = this._getLayoutValue("anchorX");
        var oldY = this._getLayoutValue("anchorY");
        if (oldX != x || oldY != y) {
          this._setLayoutValue("anchorX", x);
          this._setLayoutValue("anchorY", y);
          this._updateCfgFlag_Content();
        }
      };
      _proto.setColor = function setColor(color) {
        var oldColor = this._getLayoutValue("color");
        if (!this._colorEqual(oldColor, color)) {
          this._setLayoutValue("color", color);
          this._updateCfgFlag_Content();
        }
      };
      _proto.setShadow = function setShadow(x, y, blur) {
        var oldBlur = this._getLayoutValue("shadowBlur");
        var oldX = this._getLayoutValue("shadowX");
        var oldY = this._getLayoutValue("shadowY");
        oldBlur > 0 != blur > 0 && this._updateCfgFlag_Font();
        var updateContent = false;
        if (oldBlur != blur) {
          this._setLayoutValue("shadowBlur", blur);
          updateContent = true;
        }
        if (oldX != x) {
          this._setLayoutValue("shadowX", x);
          updateContent = true;
        }
        if (oldY != y) {
          this._setLayoutValue("shadowY", y);
          updateContent = true;
        }
        updateContent && this._updateCfgFlag_Content();
      };
      _proto.setShadowColor = function setShadowColor(color) {
        var oldColor = this._getLayoutValue("shadowColor");
        if (!this._colorEqual(oldColor, color)) {
          this._setLayoutValue("shadowColor", color);
          this._updateCfgFlag_Content();
        }
      };
      _proto.setItalic = function setItalic(enabled) {
        var oldItalic = this._getLayoutValue("italic");
        if (oldItalic != enabled) {
          this._setLayoutValue("italic", enabled);
          this._updateCfgFlag_Content();
        }
      };
      _proto.setBold = function setBold(bold) {
        var oldBold = this._getLayoutValue("bold");
        if (oldBold != bold) {
          this._setLayoutValue("bold", bold);
          this._updateCfgFlag_Content();
          this._updateCfgFlag_Font();
        }
      };
      _proto.setUnderline = function setUnderline(underline) {
        var oldBold = this._getLayoutValue("underline");
        if (oldBold != underline) {
          this._setLayoutValue("underline", underline);
          this._updateCfgFlag_Content();
        }
      };
      _proto.setSpacingX = function setSpacingX(x) {
        var oldX = this._getLayoutValue("spaceX");
        if (oldX != x && "number" == typeof x && !isNaN(x)) {
          this._setLayoutValue("spaceX", x);
          this._updateCfgFlag_Content();
        }
      };
      _proto.updateRenderData = function updateRenderData(comp) {
        if (!comp._vertsDirty) return;
        comp.font && comp.font.nativeUrl && this.setFontPath(cc.assetManager.cacheManager.getCache(comp.font.nativeUrl) || comp.font.nativeUrl);
        var layout = this._layout;
        var c = comp.node.color;
        var node = comp.node;
        var retinaSize = comp.fontSize;
        this.setString(comp.string);
        this.setFontSize(comp.fontSize, retinaSize / 72 * comp.fontSize);
        this.setLineHeight(comp.lineHeight);
        this.setEnableWrap(comp.enableWrapText);
        this.setItalic(comp.enableItalic);
        this.setUnderline(comp.enableUnderline);
        this.setBold(comp.enableBold);
        this.setOverFlow(comp.overflow);
        this.setVerticalAlign(comp.verticalAlign);
        this.setHorizontalAlign(comp.horizontalAlign);
        this.setSpacingX(comp.spacingX);
        this.setContentSize(node.getContentSize().width, node.getContentSize().height);
        this.setAnchorPoint(node.anchorX, node.anchorY);
        this.setColor(this._colorToObj(c.getR(), c.getG(), c.getB(), Math.ceil(c.getA() * node.opacity / 255)));
        var shadow = node.getComponent(cc.LabelShadow);
        if (shadow && shadow.enabled) {
          var shadowColor = shadow.color;
          this.setShadow(shadow.offset.x, shadow.offset.y, shadow.blur);
          this.setShadowColor(this._colorToObj(shadowColor.getR(), shadowColor.getG(), shadowColor.getB(), Math.ceil(shadowColor.getA() * node.opacity / 255)));
        } else this.setShadow(0, 0, -1);
        this._updateTTFMaterial(comp);
        layout.render();
      };
      _proto._bindMaterial = function _bindMaterial(comp) {
        var material = this.labelMaterial;
        if (!material) {
          material = _materialVariant["default"].createWithBuiltin("2d-label", comp);
          this.labelMaterial = material;
        }
        return material;
      };
      _proto._updateTTFMaterial = function _updateTTFMaterial(comp) {
        var material = this._bindMaterial(comp);
        var node = this._label.node;
        var layout = this._layout;
        var outline = node.getComponent(cc.LabelOutline);
        var outlineSize = 0;
        if (outline && outline.enabled && outline.width > 0) {
          outlineSize = Math.max(Math.min(outline.width / 10, .4), .1);
          var c = outline.color;
          this.setOutlineColor(this._colorToObj(c.getR(), c.getG(), c.getB(), Math.ceil(c.getA() * node.opacity / 255)));
        }
        this.setOutline(outlineSize);
        material.define("CC_USE_MODEL", true);
        material.define("USE_TEXTURE_ALPHAONLY", true);
        material.define("USE_SDF", outlineSize > 0 || comp.enableBold);
        material.define("USE_SDF_EXTEND", comp.enableBold ? 1 : 0);
        void 0 !== material.getDefine("CC_SUPPORT_standard_derivatives") && cc.sys.glExtension("OES_standard_derivatives") && material.define("CC_SUPPORT_standard_derivatives", true);
        layout.setEffect(material.effect._nativeObj);
      };
      _proto.fillBuffers = function fillBuffers(comp, renderer) {
        this._layout.render();
      };
      _proto.getVfmt = function getVfmt() {};
      return NativeTTF;
    })();
    exports["default"] = NativeTTF;
    module.exports = exports["default"];
  }), {
    "../../../../../assets/material/CCMaterial": 156,
    "../../../../../assets/material/material-variant": 163,
    "../../../../../components/CCLabel": 183,
    "../../../../../components/CCLabelOutline": 184,
    "../../../../../components/CCLabelShadow": 185
  } ],
  340: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _ttf = _interopRequireDefault(require("../../../../utils/label/ttf"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var LabelShadow = require("../../../../../components/CCLabelShadow");
    var WHITE = cc.color(255, 255, 255, 255);
    var WebglTTFAssembler = (function(_TTFAssembler) {
      _inheritsLoose(WebglTTFAssembler, _TTFAssembler);
      function WebglTTFAssembler() {
        return _TTFAssembler.apply(this, arguments) || this;
      }
      var _proto = WebglTTFAssembler.prototype;
      _proto.updateUVs = function updateUVs(comp) {
        var verts = this._renderData.vDatas[0];
        var uv = comp._frame.uv;
        var uvOffset = this.uvOffset;
        var floatsPerVert = this.floatsPerVert;
        for (var i = 0; i < 4; i++) {
          var srcOffset = 2 * i;
          var dstOffset = floatsPerVert * i + uvOffset;
          verts[dstOffset] = uv[srcOffset];
          verts[dstOffset + 1] = uv[srcOffset + 1];
        }
      };
      _proto.updateColor = function updateColor(comp) {
        WHITE._fastSetA(comp.node._color.a);
        var color = WHITE._val;
        _TTFAssembler.prototype.updateColor.call(this, comp, color);
      };
      _proto.updateVerts = function updateVerts(comp) {
        var scale = this.getTTFTextureSizeScale();
        var node = comp.node, canvasWidth = comp._ttfTexture.width / scale, canvasHeight = comp._ttfTexture.height / scale, appx = node.anchorX * node.width, appy = node.anchorY * node.height;
        var shadow = LabelShadow && comp.getComponent(LabelShadow);
        if (shadow && shadow._enabled) {
          var offsetX = (canvasWidth - node.width) / 2;
          var offsetY = (canvasHeight - node.height) / 2;
          var shadowOffset = shadow.offset;
          -shadowOffset.x > offsetX ? appx += canvasWidth - node.width : offsetX > shadowOffset.x && (appx += offsetX - shadowOffset.x);
          -shadowOffset.y > offsetY ? appy += canvasHeight - node.height : offsetY > shadowOffset.y && (appy += offsetY - shadowOffset.y);
        }
        var local = this._local;
        local[0] = -appx;
        local[1] = -appy;
        local[2] = canvasWidth - appx;
        local[3] = canvasHeight - appy;
        this.updateUVs(comp);
        this.updateWorldVerts(comp);
      };
      return WebglTTFAssembler;
    })(_ttf["default"]);
    exports["default"] = WebglTTFAssembler;
    module.exports = exports["default"];
  }), {
    "../../../../../components/CCLabelShadow": 185,
    "../../../../utils/label/ttf": 329
  } ],
  341: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vec = _interopRequireDefault(require("../../../../../value-types/vec3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Assembler3D = require("../../../../assembler-3d");
    var WebglBmfontAssembler = require("../2d/bmfont");
    var vec3_temp_local = new _vec["default"]();
    var vec3_temp_world = new _vec["default"]();
    var WebglBmfontAssembler3D = (function(_WebglBmfontAssembler) {
      _inheritsLoose(WebglBmfontAssembler3D, _WebglBmfontAssembler);
      function WebglBmfontAssembler3D() {
        return _WebglBmfontAssembler.apply(this, arguments) || this;
      }
      return WebglBmfontAssembler3D;
    })(WebglBmfontAssembler);
    exports["default"] = WebglBmfontAssembler3D;
    cc.js.mixin(WebglBmfontAssembler3D.prototype, Assembler3D, {
      updateWorldVerts: function updateWorldVerts(comp) {
        var matrix = comp.node._worldMatrix;
        var local = this._local;
        var world = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        for (var offset = 0; offset < world.length; offset += floatsPerVert) {
          _vec["default"].set(vec3_temp_local, local[offset], local[offset + 1], 0);
          _vec["default"].transformMat4(vec3_temp_world, vec3_temp_local, matrix);
          world[offset] = vec3_temp_world.x;
          world[offset + 1] = vec3_temp_world.y;
          world[offset + 2] = vec3_temp_world.z;
        }
      }
    });
    module.exports = exports["default"];
  }), {
    "../../../../../value-types/vec3": 411,
    "../../../../assembler-3d": 300,
    "../2d/bmfont": 337
  } ],
  342: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vec = _interopRequireDefault(require("../../../../../value-types/vec3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Assembler3D = require("../../../../assembler-3d");
    var WebglLetterFontAssembler = require("../2d/letter");
    var vec3_temp_local = new _vec["default"]();
    var vec3_temp_world = new _vec["default"]();
    var WebglLetterFontAssembler3D = (function(_WebglLetterFontAssem) {
      _inheritsLoose(WebglLetterFontAssembler3D, _WebglLetterFontAssem);
      function WebglLetterFontAssembler3D() {
        return _WebglLetterFontAssem.apply(this, arguments) || this;
      }
      return WebglLetterFontAssembler3D;
    })(WebglLetterFontAssembler);
    exports["default"] = WebglLetterFontAssembler3D;
    cc.js.mixin(WebglLetterFontAssembler3D.prototype, Assembler3D, {
      updateWorldVerts: function updateWorldVerts(comp) {
        var matrix = comp.node._worldMatrix;
        var local = this._local;
        var world = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        for (var offset = 0; offset < world.length; offset += floatsPerVert) {
          _vec["default"].set(vec3_temp_local, local[offset], local[offset + 1], 0);
          _vec["default"].transformMat4(vec3_temp_world, vec3_temp_local, matrix);
          world[offset] = vec3_temp_world.x;
          world[offset + 1] = vec3_temp_world.y;
          world[offset + 2] = vec3_temp_world.z;
        }
      }
    });
    module.exports = exports["default"];
  }), {
    "../../../../../value-types/vec3": 411,
    "../../../../assembler-3d": 300,
    "../2d/letter": 338
  } ],
  343: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Assembler3D = require("../../../../assembler-3d");
    var WebglTTFAssembler = require("../2d/ttf");
    var WebglTTFAssembler3D = (function(_WebglTTFAssembler) {
      _inheritsLoose(WebglTTFAssembler3D, _WebglTTFAssembler);
      function WebglTTFAssembler3D() {
        return _WebglTTFAssembler.apply(this, arguments) || this;
      }
      return WebglTTFAssembler3D;
    })(WebglTTFAssembler);
    exports["default"] = WebglTTFAssembler3D;
    cc.js.mixin(WebglTTFAssembler3D.prototype, Assembler3D);
    module.exports = exports["default"];
  }), {
    "../../../../assembler-3d": 300,
    "../2d/ttf": 340
  } ],
  344: [ (function(require, module, exports) {
    "use strict";
    var _assembler = _interopRequireDefault(require("../../../assembler"));
    var _CCLabel = _interopRequireDefault(require("../../../../components/CCLabel"));
    var _ttf = _interopRequireDefault(require("./2d/ttf"));
    var _bmfont = _interopRequireDefault(require("./2d/bmfont"));
    var _letter = _interopRequireDefault(require("./2d/letter"));
    var _ttf2 = _interopRequireDefault(require("./3d/ttf"));
    var _bmfont2 = _interopRequireDefault(require("./3d/bmfont"));
    var _letter2 = _interopRequireDefault(require("./3d/letter"));
    var _ttf3 = _interopRequireDefault(require("./2d-multi/ttf"));
    var _bmfont3 = _interopRequireDefault(require("./2d-multi/bmfont"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var NativeTTF = void 0;
    true;
    NativeTTF = require("./2d/nativeTTF");
    _CCLabel["default"]._canvasPool = {
      pool: [],
      get: function get() {
        var data = this.pool.pop();
        if (!data) {
          var canvas = document.createElement("canvas");
          var context = canvas.getContext("2d");
          data = {
            canvas: canvas,
            context: context
          };
          context.textBaseline = "alphabetic";
        }
        return data;
      },
      put: function put(canvas) {
        if (this.pool.length >= 32) return;
        this.pool.push(canvas);
      }
    };
    _assembler["default"].register(cc.Label, {
      getConstructor: function getConstructor(label) {
        var is3DNode = label.node.is3DNode;
        var material = label.getMaterials()[0];
        var isMultiMaterial = material && material.material.isMultiSupport();
        var ctor = is3DNode ? _ttf2["default"] : isMultiMaterial ? _ttf3["default"] : _ttf["default"];
        label.font instanceof cc.BitmapFont ? ctor = is3DNode ? _bmfont2["default"] : isMultiMaterial ? _bmfont3["default"] : _bmfont["default"] : label.cacheMode === _CCLabel["default"].CacheMode.CHAR && ((true, 
        !is3DNode) && !!jsb.LabelRenderer && label.font instanceof cc.TTFFont && label._useNativeTTF() ? ctor = NativeTTF : cc.sys.platform === cc.sys.WECHAT_GAME_SUB ? cc.warn("sorry, subdomain does not support CHAR mode currently!") : ctor = is3DNode ? _letter2["default"] : _letter["default"]);
        return ctor;
      },
      TTF: _ttf["default"],
      Bmfont: _bmfont["default"],
      Letter: _letter["default"],
      TTF3D: _ttf2["default"],
      Bmfont3D: _bmfont2["default"],
      Letter3D: _letter2["default"],
      NativeTTF: NativeTTF,
      TTFMulti: _ttf3["default"],
      BmfontMulti: _bmfont3["default"]
    });
  }), {
    "../../../../components/CCLabel": 183,
    "../../../assembler": 302,
    "./2d-multi/bmfont": 335,
    "./2d-multi/ttf": 336,
    "./2d/bmfont": 337,
    "./2d/letter": 338,
    "./2d/nativeTTF": 339,
    "./2d/ttf": 340,
    "./3d/bmfont": 341,
    "./3d/letter": 342,
    "./3d/ttf": 343
  } ],
  345: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.MaskAssembler = void 0;
    var _assembler = _interopRequireDefault(require("../../assembler"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Mask = require("../../../components/CCMask");
    var RenderFlow = require("../../render-flow");
    var SimpleSpriteAssembler = require("./sprite/2d/simple");
    var GraphicsAssembler = require("./graphics");
    var gfx = require("../../../../renderer/gfx");
    var vfmtPos = require("../vertex-format").vfmtPos;
    var _maxLevel = 8;
    var _maskStack = [];
    function getWriteMask() {
      return 1 << _maskStack.length - 1;
    }
    function getStencilRef() {
      var result = 0;
      for (var i = 0; i < _maskStack.length; ++i) result += 1 << i;
      return result;
    }
    function applyStencil(material, func, failOp, ref, stencilMask, writeMask) {
      var effect = material.effect;
      var zFailOp = gfx.STENCIL_OP_KEEP, zPassOp = gfx.STENCIL_OP_KEEP;
      effect.setStencil(gfx.STENCIL_ENABLE, func, ref, stencilMask, failOp, zFailOp, zPassOp, writeMask);
    }
    function pushMask(mask) {
      _maskStack.length + 1 > _maxLevel && cc.errorID(9e3, _maxLevel);
      _maskStack.push(mask);
    }
    function exitMask(mask, renderer) {
      0 === _maskStack.length && cc.errorID(9001);
      _maskStack.pop();
      0 === _maskStack.length ? renderer._flushMaterial(mask._exitMaterial) : enableMask(renderer);
    }
    function applyClearMask(mask, renderer) {
      var func = gfx.DS_FUNC_NEVER;
      var ref = getWriteMask();
      var stencilMask = ref;
      var writeMask = ref;
      var failOp = mask.inverted ? gfx.STENCIL_OP_REPLACE : gfx.STENCIL_OP_ZERO;
      applyStencil(mask._clearMaterial, func, failOp, ref, stencilMask, writeMask);
      var buffer = renderer.getBuffer("mesh", vfmtPos);
      var offsetInfo = buffer.request(4, 6);
      var indiceOffset = offsetInfo.indiceOffset, vertexOffset = offsetInfo.byteOffset >> 2, vertexId = offsetInfo.vertexOffset, vbuf = buffer._vData, ibuf = buffer._iData;
      vbuf[vertexOffset++] = -1;
      vbuf[vertexOffset++] = -1;
      vbuf[vertexOffset++] = -1;
      vbuf[vertexOffset++] = 1;
      vbuf[vertexOffset++] = 1;
      vbuf[vertexOffset++] = 1;
      vbuf[vertexOffset++] = 1;
      vbuf[vertexOffset++] = -1;
      ibuf[indiceOffset++] = vertexId;
      ibuf[indiceOffset++] = vertexId + 3;
      ibuf[indiceOffset++] = vertexId + 1;
      ibuf[indiceOffset++] = vertexId + 1;
      ibuf[indiceOffset++] = vertexId + 3;
      ibuf[indiceOffset++] = vertexId + 2;
      renderer.node = renderer._dummyNode;
      renderer.material = mask._clearMaterial;
      renderer._flush();
    }
    function applyAreaMask(mask, renderer) {
      var func = gfx.DS_FUNC_NEVER;
      var ref = getWriteMask();
      var stencilMask = ref;
      var writeMask = ref;
      var failOp = mask.inverted ? gfx.STENCIL_OP_ZERO : gfx.STENCIL_OP_REPLACE;
      applyStencil(mask._materials[0], func, failOp, ref, stencilMask, writeMask);
      renderer.material = mask._materials[0];
      if (mask._type === Mask.Type.IMAGE_STENCIL) {
        renderer.node = renderer._dummyNode;
        SimpleSpriteAssembler.prototype.fillBuffers.call(mask._assembler, mask, renderer);
        renderer._flush();
      } else {
        renderer.node = mask.node;
        GraphicsAssembler.prototype.fillBuffers.call(mask._graphics._assembler, mask._graphics, renderer);
      }
    }
    function enableMask(renderer) {
      var func = gfx.DS_FUNC_EQUAL;
      var failOp = gfx.STENCIL_OP_KEEP;
      var ref = getStencilRef();
      var stencilMask = ref;
      var writeMask = getWriteMask();
      var mask = _maskStack[_maskStack.length - 1];
      applyStencil(mask._enableMaterial, func, failOp, ref, stencilMask, writeMask);
      renderer._flushMaterial(mask._enableMaterial);
    }
    var MaskAssembler = (function(_SimpleSpriteAssemble) {
      _inheritsLoose(MaskAssembler, _SimpleSpriteAssemble);
      function MaskAssembler() {
        return _SimpleSpriteAssemble.apply(this, arguments) || this;
      }
      var _proto = MaskAssembler.prototype;
      _proto.updateRenderData = function updateRenderData(mask) {
        if (mask._type === Mask.Type.IMAGE_STENCIL) mask.spriteFrame ? SimpleSpriteAssembler.prototype.updateRenderData.call(this, mask) : mask.setMaterial(0, null); else {
          mask._graphics.setMaterial(0, mask._materials[0]);
          GraphicsAssembler.prototype.updateRenderData.call(mask._graphics._assembler, mask._graphics, mask._graphics);
        }
      };
      _proto.fillBuffers = function fillBuffers(mask, renderer) {
        if (mask._type !== Mask.Type.IMAGE_STENCIL || mask.spriteFrame) {
          pushMask(mask);
          applyClearMask(mask, renderer);
          applyAreaMask(mask, renderer);
          enableMask(renderer);
        }
        mask.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
      };
      _proto.postFillBuffers = function postFillBuffers(mask, renderer) {
        (mask._type !== Mask.Type.IMAGE_STENCIL || mask.spriteFrame) && exitMask(mask, renderer);
        mask.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
      };
      return MaskAssembler;
    })(SimpleSpriteAssembler);
    exports.MaskAssembler = MaskAssembler;
    _assembler["default"].register(Mask, MaskAssembler);
  }), {
    "../../../../renderer/gfx": 427,
    "../../../components/CCMask": 187,
    "../../assembler": 302,
    "../../render-flow": 323,
    "../vertex-format": 371,
    "./graphics": 333,
    "./sprite/2d/simple": 357
  } ],
  346: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _motionStreak = _interopRequireDefault(require("./motion-streak"));
    var _vertexFormat = require("../../webgl/vertex-format");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var MotionStreak = require("../../../components/CCMotionStreak");
    var RenderFlow = require("../../render-flow");
    function Point(point, dir) {
      this.point = point || cc.v2();
      this.dir = dir || cc.v2();
      this.distance = 0;
      this.time = 0;
    }
    Point.prototype.setPoint = function(x, y) {
      this.point.x = x;
      this.point.y = y;
    };
    Point.prototype.setDir = function(x, y) {
      this.dir.x = x;
      this.dir.y = y;
    };
    var _normal = cc.v2();
    var _vec2 = cc.v2();
    function normal(out, dir) {
      out.x = -dir.y;
      out.y = dir.x;
      return out;
    }
    var MultiMotionStreakAssembler = (function(_MotionStreakAssemble) {
      _inheritsLoose(MultiMotionStreakAssembler, _MotionStreakAssemble);
      function MultiMotionStreakAssembler() {
        return _MotionStreakAssemble.apply(this, arguments) || this;
      }
      var _proto = MultiMotionStreakAssembler.prototype;
      _proto.initData = function initData() {
        this._renderData.createFlexData(0, 16, 42, this.getVfmt());
      };
      _proto.getVfmt = function getVfmt() {
        return _vertexFormat.vfmtPosUvColorTexId;
      };
      _proto.getBuffer = function getBuffer() {
        return cc.renderer._handle.getBuffer("mesh", this.getVfmt());
      };
      _proto.update = function update(comp, dt) {
        false;
        var stroke = comp._stroke / 2;
        var node = comp.node;
        var matrix = node._worldMatrix.m;
        var tx = matrix[12], ty = matrix[13];
        var points = comp._points;
        var lastPos = comp._lastWPos;
        var fadeTime = comp._fadeTime;
        var moved = lastPos.x !== tx || lastPos.y !== ty;
        if (moved) {
          var cur;
          var newHead = false;
          if (0 === points.length) {
            var _prev = new Point();
            _prev.setPoint(lastPos.x, lastPos.y);
            this._tailShortenTime = _prev.time = fadeTime;
            points.push(_prev);
            cur = new Point();
            points.unshift(cur);
          } else {
            cur = points[0];
            var _prev2 = points[1];
            var difx = _prev2.point.x - tx;
            var dify = _prev2.point.y - ty;
            newHead = difx * difx + dify * dify >= comp.minSeg * comp.minSeg;
          }
          cur.setPoint(tx, ty);
          cur.time = fadeTime + dt;
          var prev = points[1];
          cur.distance = cur.point.sub(prev.point, _vec2).mag();
          _vec2.normalizeSelf();
          cur.setDir(_vec2.x, _vec2.y);
          var prevIsTail = 2 === points.length;
          prevIsTail && prev.setDir(_vec2.x, _vec2.y);
          if (newHead) {
            var point = new Point(cur.point.clone(), cur.dir.clone());
            point.distance = cur.distance;
            point.time = cur.time;
            points.unshift(point);
          }
        }
        lastPos.x = tx;
        lastPos.y = ty;
        if (points.length < 2) return;
        var color = comp._color, ca = color.a;
        var crgb = color.b << 16 | color.g << 8 | color.r;
        var verticesCount = 0;
        var indicesCount = 0;
        var flexBuffer = this._renderData._flexBuffer;
        flexBuffer.reserve(2 * points.length, 6 * (points.length - 1));
        var vData = flexBuffer.vData;
        var uintVData = flexBuffer.uintVData;
        var vertsOffset = 6;
        for (var i = points.length - 1; i >= 0; i--) {
          var p = points[i];
          var _point = p.point;
          var dir = p.dir;
          p.time -= dt;
          var isLast = i === points.length - 1;
          if (p.time <= 0) {
            isLast && i - 1 >= 0 && (this._tailShortenTime = points[i - 1].time - dt);
            points.splice(i, 1);
            continue;
          }
          var progress = p.time / fadeTime;
          if (isLast) {
            var next = points[i - 1];
            if (!next) {
              points.splice(i, 1);
              continue;
            }
            var nextIsStatic = points.length >= 3;
            if (nextIsStatic) {
              var segmentProgress = p.time / this._tailShortenTime;
              if (segmentProgress <= 1) {
                _point.x = next.point.x - next.distance * next.dir.x * segmentProgress;
                _point.y = next.point.y - next.distance * next.dir.y * segmentProgress;
              }
            } else this._tailShortenTime = p.time;
          }
          normal(_normal, dir);
          var da = progress * ca;
          var c = da << 24 >>> 0 | crgb;
          var offset = verticesCount * vertsOffset;
          vData[offset] = _point.x + _normal.x * stroke;
          vData[offset + 1] = _point.y + _normal.y * stroke;
          vData[offset + 2] = 1;
          vData[offset + 3] = progress;
          uintVData[offset + 4] = c;
          vData[offset + 5] = comp._texId;
          offset += vertsOffset;
          vData[offset] = _point.x - _normal.x * stroke;
          vData[offset + 1] = _point.y - _normal.y * stroke;
          vData[offset + 2] = 0;
          vData[offset + 3] = progress;
          uintVData[offset + 4] = c;
          vData[offset + 5] = comp._texId;
          verticesCount += 2;
        }
        indicesCount = verticesCount <= 2 ? 0 : 3 * (verticesCount - 2);
        flexBuffer.used(verticesCount, indicesCount);
      };
      _proto.fillBuffers = function fillBuffers(comp, renderer) {
        var _this$_renderData$_fl = this._renderData._flexBuffer, vData = _this$_renderData$_fl.vData, usedVertices = _this$_renderData$_fl.usedVertices, usedIndices = _this$_renderData$_fl.usedIndices, usedVerticesFloats = _this$_renderData$_fl.usedVerticesFloats;
        var buffer = this.getBuffer(renderer);
        var offsetInfo = buffer.request(usedVertices, usedIndices);
        var vertexOffset = offsetInfo.byteOffset >> 2, vbuf = buffer._vData;
        vData.length + vertexOffset > vbuf.length ? vbuf.set(vData.subarray(0, usedVerticesFloats), vertexOffset) : vbuf.set(vData, vertexOffset);
        var ibuf = buffer._iData, indiceOffset = offsetInfo.indiceOffset, vertexId = offsetInfo.vertexOffset;
        for (var i = 0, l = usedVertices; i < l; i += 2) {
          var start = vertexId + i;
          ibuf[indiceOffset++] = start;
          ibuf[indiceOffset++] = start + 2;
          ibuf[indiceOffset++] = start + 1;
          ibuf[indiceOffset++] = start + 1;
          ibuf[indiceOffset++] = start + 2;
          ibuf[indiceOffset++] = start + 3;
        }
        comp.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
      };
      return MultiMotionStreakAssembler;
    })(_motionStreak["default"]);
    exports["default"] = MultiMotionStreakAssembler;
    _motionStreak["default"].register(MotionStreak, {
      getConstructor: function getConstructor(comp) {
        var material = comp.getMaterials()[0];
        var isMultiMaterial = material && material.material.isMultiSupport();
        return isMultiMaterial ? MultiMotionStreakAssembler : _motionStreak["default"];
      },
      MotionStreakAssembler: _motionStreak["default"],
      MultiMotionStreakAssembler: MultiMotionStreakAssembler
    });
    MultiMotionStreakAssembler.prototype.floatsPerVert = 6;
    MultiMotionStreakAssembler.prototype.texIdOffset = 5;
    MultiMotionStreakAssembler.prototype.isMulti = true;
    module.exports = exports["default"];
  }), {
    "../../../components/CCMotionStreak": 188,
    "../../render-flow": 323,
    "../../webgl/vertex-format": 371,
    "./motion-streak": 347
  } ],
  347: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler2d = _interopRequireDefault(require("../../assembler-2d"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var RenderFlow = require("../../render-flow");
    function Point(point, dir) {
      this.point = point || cc.v2();
      this.dir = dir || cc.v2();
      this.distance = 0;
      this.time = 0;
    }
    Point.prototype.setPoint = function(x, y) {
      this.point.x = x;
      this.point.y = y;
    };
    Point.prototype.setDir = function(x, y) {
      this.dir.x = x;
      this.dir.y = y;
    };
    var _tangent = cc.v2();
    var _miter = cc.v2();
    var _normal = cc.v2();
    var _vec2 = cc.v2();
    function normal(out, dir) {
      out.x = -dir.y;
      out.y = dir.x;
      return out;
    }
    function computeMiter(miter, lineA, lineB, halfThick, maxMultiple) {
      lineA.add(lineB, _tangent);
      _tangent.normalizeSelf();
      miter.x = -_tangent.y;
      miter.y = _tangent.x;
      _vec2.x = -lineA.y;
      _vec2.y = lineA.x;
      var multiple = 1 / miter.dot(_vec2);
      maxMultiple && (multiple = Math.min(multiple, maxMultiple));
      return halfThick * multiple;
    }
    var MotionStreakAssembler = (function(_Assembler2D) {
      _inheritsLoose(MotionStreakAssembler, _Assembler2D);
      function MotionStreakAssembler() {
        var _this;
        _this = _Assembler2D.call(this) || this;
        _this._tailShortenTime = 0;
        return _this;
      }
      var _proto = MotionStreakAssembler.prototype;
      _proto.initData = function initData() {
        this._renderData.createFlexData(0, 16, 42);
      };
      _proto.update = function update(comp, dt) {
        false;
        var stroke = comp._stroke / 2;
        var node = comp.node;
        var matrix = node._worldMatrix.m;
        var tx = matrix[12], ty = matrix[13];
        var points = comp._points;
        var lastPos = comp._lastWPos;
        var fadeTime = comp._fadeTime;
        var moved = lastPos.x !== tx || lastPos.y !== ty;
        if (moved) {
          var cur;
          var newHead = false;
          if (0 === points.length) {
            var _prev = new Point();
            _prev.setPoint(lastPos.x, lastPos.y);
            this._tailShortenTime = _prev.time = fadeTime;
            points.push(_prev);
            cur = new Point();
            points.unshift(cur);
          } else {
            cur = points[0];
            var _prev2 = points[1];
            var difx = _prev2.point.x - tx;
            var dify = _prev2.point.y - ty;
            newHead = difx * difx + dify * dify >= comp.minSeg * comp.minSeg;
          }
          cur.setPoint(tx, ty);
          cur.time = fadeTime + dt;
          var prev = points[1];
          cur.distance = cur.point.sub(prev.point, _vec2).mag();
          _vec2.normalizeSelf();
          cur.setDir(_vec2.x, _vec2.y);
          var prevIsTail = 2 === points.length;
          prevIsTail && prev.setDir(_vec2.x, _vec2.y);
          if (newHead) {
            var point = new Point(cur.point.clone(), cur.dir.clone());
            point.distance = cur.distance;
            point.time = cur.time;
            points.unshift(point);
          }
        }
        lastPos.x = tx;
        lastPos.y = ty;
        if (points.length < 2) return;
        var color = comp._color, ca = color.a;
        var crgb = color.b << 16 | color.g << 8 | color.r;
        var verticesCount = 0;
        var indicesCount = 0;
        var flexBuffer = this._renderData._flexBuffer;
        flexBuffer.reserve(2 * points.length, 6 * (points.length - 1));
        var vData = flexBuffer.vData;
        var uintVData = flexBuffer.uintVData;
        var vertsOffset = 5;
        for (var i = points.length - 1; i >= 0; i--) {
          var p = points[i];
          var _point = p.point;
          var dir = p.dir;
          p.time -= dt;
          var isLast = i === points.length - 1;
          if (p.time <= 0) {
            isLast && i - 1 >= 0 && (this._tailShortenTime = points[i - 1].time - dt);
            points.splice(i, 1);
            continue;
          }
          var progress = p.time / fadeTime;
          if (isLast) {
            var next = points[i - 1];
            if (!next) {
              points.splice(i, 1);
              continue;
            }
            var nextIsStatic = points.length >= 3;
            if (nextIsStatic) {
              var segmentProgress = p.time / this._tailShortenTime;
              if (segmentProgress <= 1) {
                _point.x = next.point.x - next.distance * next.dir.x * segmentProgress;
                _point.y = next.point.y - next.distance * next.dir.y * segmentProgress;
              }
            } else this._tailShortenTime = p.time;
          }
          normal(_normal, dir);
          var da = progress * ca;
          var c = da << 24 >>> 0 | crgb;
          var offset = verticesCount * vertsOffset;
          vData[offset] = _point.x + _normal.x * stroke;
          vData[offset + 1] = _point.y + _normal.y * stroke;
          vData[offset + 2] = 1;
          vData[offset + 3] = progress;
          uintVData[offset + 4] = c;
          offset += vertsOffset;
          vData[offset] = _point.x - _normal.x * stroke;
          vData[offset + 1] = _point.y - _normal.y * stroke;
          vData[offset + 2] = 0;
          vData[offset + 3] = progress;
          uintVData[offset + 4] = c;
          verticesCount += 2;
        }
        indicesCount = verticesCount <= 2 ? 0 : 3 * (verticesCount - 2);
        flexBuffer.used(verticesCount, indicesCount);
      };
      _proto.fillBuffers = function fillBuffers(comp, renderer) {
        var _this$_renderData$_fl = this._renderData._flexBuffer, vData = _this$_renderData$_fl.vData, usedVertices = _this$_renderData$_fl.usedVertices, usedIndices = _this$_renderData$_fl.usedIndices, usedVerticesFloats = _this$_renderData$_fl.usedVerticesFloats;
        var buffer = renderer._meshBuffer;
        var offsetInfo = buffer.request(usedVertices, usedIndices);
        var vertexOffset = offsetInfo.byteOffset >> 2, vbuf = buffer._vData;
        vData.length + vertexOffset > vbuf.length ? vbuf.set(vData.subarray(0, usedVerticesFloats), vertexOffset) : vbuf.set(vData, vertexOffset);
        var ibuf = buffer._iData, indiceOffset = offsetInfo.indiceOffset, vertexId = offsetInfo.vertexOffset;
        for (var i = 0, l = usedVertices; i < l; i += 2) {
          var start = vertexId + i;
          ibuf[indiceOffset++] = start;
          ibuf[indiceOffset++] = start + 2;
          ibuf[indiceOffset++] = start + 1;
          ibuf[indiceOffset++] = start + 1;
          ibuf[indiceOffset++] = start + 2;
          ibuf[indiceOffset++] = start + 3;
        }
        comp.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
      };
      return MotionStreakAssembler;
    })(_assembler2d["default"]);
    exports["default"] = MotionStreakAssembler;
    module.exports = exports["default"];
  }), {
    "../../assembler-2d": 299,
    "../../render-flow": 323
  } ],
  348: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vertexFormat = require("../../../../webgl/vertex-format");
    var _barFilled = _interopRequireDefault(require("../2d/bar-filled"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var BarFilledAssemblerMulti = (function(_BarFilledAssembler) {
      _inheritsLoose(BarFilledAssemblerMulti, _BarFilledAssembler);
      function BarFilledAssemblerMulti() {
        return _BarFilledAssembler.apply(this, arguments) || this;
      }
      var _proto = BarFilledAssemblerMulti.prototype;
      _proto.initData = function initData() {
        var data = this._renderData;
        data.createFlexData(0, this.verticesCount, this.indicesCount, this.getVfmt());
        var indices = data.iDatas[0];
        data.initQuadIndices(indices);
      };
      _proto.getVfmt = function getVfmt() {
        return _vertexFormat.vfmtPosUvColorTexId;
      };
      _proto.getBuffer = function getBuffer() {
        return cc.renderer._handle.getBuffer("mesh", this.getVfmt());
      };
      _proto.updateRenderData = function updateRenderData(sprite) {
        _BarFilledAssembler.prototype.updateRenderData.call(this, sprite);
        if (sprite._texIdDirty) {
          sprite._updateMultiTexId(sprite.getMaterial(0), sprite._spriteFrame._texture);
          if (sprite._texIdDirty) {
            this.updateTexId(sprite);
            sprite._texIdDirty = false;
          }
        }
      };
      _proto.updateRenderDataForSwitchMaterial = function updateRenderDataForSwitchMaterial(sprite) {
        if (sprite._vertsDirty) {
          var fillStart = sprite._fillStart;
          var fillRange = sprite._fillRange;
          if (fillRange < 0) {
            fillStart += fillRange;
            fillRange = -fillRange;
          }
          fillRange = fillStart + fillRange;
          fillStart = fillStart > 1 ? 1 : fillStart;
          fillStart = fillStart < 0 ? 0 : fillStart;
          fillRange = fillRange > 1 ? 1 : fillRange;
          fillRange = fillRange < 0 ? 0 : fillRange;
          fillRange -= fillStart;
          fillRange = fillRange < 0 ? 0 : fillRange;
          var fillEnd = fillStart + fillRange;
          fillEnd = fillEnd > 1 ? 1 : fillEnd;
          this.updateUVs(sprite, fillStart, fillEnd);
          this.updateVerts(sprite, fillStart, fillEnd);
          sprite._vertsDirty = false;
        }
        if (sprite._texIdDirty) {
          sprite._updateMultiTexId(sprite.getMaterial(0), sprite._spriteFrame._texture);
          if (sprite._texIdDirty) {
            this.updateTexId(sprite);
            sprite._texIdDirty = false;
          }
        }
        true;
        this._aftUpdateRenderDataForNative();
      };
      return BarFilledAssemblerMulti;
    })(_barFilled["default"]);
    exports["default"] = BarFilledAssemblerMulti;
    BarFilledAssemblerMulti.prototype.floatsPerVert = 6;
    BarFilledAssemblerMulti.prototype.texIdOffset = 5;
    BarFilledAssemblerMulti.prototype.isMulti = true;
    module.exports = exports["default"];
  }), {
    "../../../../webgl/vertex-format": 371,
    "../2d/bar-filled": 354
  } ],
  349: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vertexFormat = require("../../../../webgl/vertex-format");
    var _mesh = _interopRequireDefault(require("../2d/mesh"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var MultiMeshSpriteAssembler = (function(_MeshSpriteAssembler) {
      _inheritsLoose(MultiMeshSpriteAssembler, _MeshSpriteAssembler);
      function MultiMeshSpriteAssembler() {
        return _MeshSpriteAssembler.apply(this, arguments) || this;
      }
      var _proto = MultiMeshSpriteAssembler.prototype;
      _proto.getVfmt = function getVfmt() {
        return _vertexFormat.vfmtPosUvColorTexId;
      };
      _proto.getBuffer = function getBuffer() {
        return cc.renderer._handle.getBuffer("mesh", this.getVfmt());
      };
      _proto.updateRenderData = function updateRenderData(sprite) {
        var frame = sprite.spriteFrame;
        _MeshSpriteAssembler.prototype.updateRenderData.call(this, sprite);
        if (frame) {
          sprite._texIdDirty && sprite._updateMultiTexId(sprite.getMaterial(0), frame._texture);
          this.updateTexId(sprite);
          sprite._texIdDirty = false;
        }
      };
      _proto.updateRenderDataForSwitchMaterial = function updateRenderDataForSwitchMaterial(sprite) {
        var frame = sprite.spriteFrame;
        if (frame) {
          var vertices = frame.vertices;
          if (vertices) {
            this.verticesCount = vertices.x.length;
            this.indicesCount = vertices.triangles.length;
            var renderData = this._renderData;
            var flexBuffer = renderData._flexBuffer;
            if (flexBuffer.reserve(this.verticesCount, this.indicesCount)) {
              this.updateColor(sprite);
              sprite._vertsDirty = true;
            }
            flexBuffer.used(this.verticesCount, this.indicesCount);
            this.updateIndices(vertices.triangles);
            if (sprite._vertsDirty) {
              this.updateUVs(sprite);
              this.updateVerts(sprite);
              this.updateWorldVerts(sprite);
              sprite._vertsDirty = false;
            }
          }
        }
        sprite._texIdDirty && sprite._updateMultiTexId(sprite.getMaterial(0), frame._texture);
        this.updateTexId(sprite);
        sprite._texIdDirty = false;
        true;
        this._aftUpdateRenderDataForNative();
      };
      return MultiMeshSpriteAssembler;
    })(_mesh["default"]);
    exports["default"] = MultiMeshSpriteAssembler;
    MultiMeshSpriteAssembler.prototype.floatsPerVert = 6;
    MultiMeshSpriteAssembler.prototype.texIdOffset = 5;
    MultiMeshSpriteAssembler.prototype.isMulti = true;
    module.exports = exports["default"];
  }), {
    "../../../../webgl/vertex-format": 371,
    "../2d/mesh": 355
  } ],
  350: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vertexFormat = require("../../../../webgl/vertex-format");
    var _radialFilled = _interopRequireDefault(require("../2d/radial-filled"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var MultiRadialFilledAssembler = (function(_RadialFilledAssemble) {
      _inheritsLoose(MultiRadialFilledAssembler, _RadialFilledAssemble);
      function MultiRadialFilledAssembler() {
        return _RadialFilledAssemble.apply(this, arguments) || this;
      }
      var _proto = MultiRadialFilledAssembler.prototype;
      _proto.initData = function initData(sprite) {
        this._renderData.createFlexData(0, 4, 6, this.getVfmt());
        this.updateIndices();
      };
      _proto.getVfmt = function getVfmt() {
        return _vertexFormat.vfmtPosUvColorTexId;
      };
      _proto.getBuffer = function getBuffer() {
        return cc.renderer._handle.getBuffer("mesh", this.getVfmt());
      };
      _proto.updateRenderData = function updateRenderData(sprite) {
        _RadialFilledAssemble.prototype.updateRenderData.call(this, sprite);
        sprite._texIdDirty && sprite._updateMultiTexId(sprite.getMaterial(0), sprite.spriteFrame._texture);
        this.updateTexId(sprite);
        sprite._texIdDirty = false;
      };
      _proto.updateRenderDataForSwitchMaterial = function updateRenderDataForSwitchMaterial(sprite) {
        this._aftUpdateRenderData(sprite);
        sprite._texIdDirty && sprite._updateMultiTexId(sprite.getMaterial(0), sprite.spriteFrame._texture);
        this.updateTexId(sprite);
        sprite._texIdDirty = false;
        true;
        this._aftUpdateRenderDataForNative();
      };
      return MultiRadialFilledAssembler;
    })(_radialFilled["default"]);
    exports["default"] = MultiRadialFilledAssembler;
    MultiRadialFilledAssembler.prototype.floatsPerVert = 6;
    MultiRadialFilledAssembler.prototype.texIdOffset = 5;
    MultiRadialFilledAssembler.prototype.isMulti = true;
    module.exports = exports["default"];
  }), {
    "../../../../webgl/vertex-format": 371,
    "../2d/radial-filled": 356
  } ],
  351: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vertexFormat = require("../../../../webgl/vertex-format");
    var _simple = _interopRequireDefault(require("../2d/simple"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var MultiSimpleSpriteAssembler = (function(_SimpleSpriteAssemble) {
      _inheritsLoose(MultiSimpleSpriteAssembler, _SimpleSpriteAssemble);
      function MultiSimpleSpriteAssembler() {
        return _SimpleSpriteAssemble.apply(this, arguments) || this;
      }
      var _proto = MultiSimpleSpriteAssembler.prototype;
      _proto.initData = function initData() {
        var data = this._renderData;
        data.createFlexData(0, this.verticesCount, this.indicesCount, this.getVfmt());
        var indices = data.iDatas[0];
        data.initQuadIndices(indices);
      };
      _proto.getVfmt = function getVfmt() {
        return _vertexFormat.vfmtPosUvColorTexId;
      };
      _proto.getBuffer = function getBuffer() {
        return cc.renderer._handle.getBuffer("mesh", this.getVfmt());
      };
      _proto.updateRenderData = function updateRenderData(sprite) {
        _SimpleSpriteAssemble.prototype.updateRenderData.call(this, sprite);
        if (sprite._texIdDirty) {
          sprite._updateMultiTexId(sprite.getMaterial(0), sprite._spriteFrame._texture);
          if (sprite._texIdDirty) {
            this.updateTexId(sprite);
            sprite._texIdDirty = false;
          }
        }
      };
      _proto.updateRenderDataForSwitchMaterial = function updateRenderDataForSwitchMaterial(sprite) {
        if (sprite._vertsDirty) {
          this.updateUVs(sprite);
          this.updateVerts(sprite);
          sprite._vertsDirty = false;
        }
        if (sprite._texIdDirty) {
          sprite._updateMultiTexId(sprite.getMaterial(0), sprite._spriteFrame._texture);
          if (sprite._texIdDirty) {
            this.updateTexId(sprite);
            sprite._texIdDirty = false;
          }
        }
        true;
        this._aftUpdateRenderDataForNative();
      };
      return MultiSimpleSpriteAssembler;
    })(_simple["default"]);
    exports["default"] = MultiSimpleSpriteAssembler;
    MultiSimpleSpriteAssembler.prototype.floatsPerVert = 6;
    MultiSimpleSpriteAssembler.prototype.texIdOffset = 5;
    MultiSimpleSpriteAssembler.prototype.isMulti = true;
    module.exports = exports["default"];
  }), {
    "../../../../webgl/vertex-format": 371,
    "../2d/simple": 357
  } ],
  352: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vertexFormat = require("../../../../webgl/vertex-format");
    var _sliced = _interopRequireDefault(require("../2d/sliced"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var MultiSlicedAssembler = (function(_SlicedAssembler) {
      _inheritsLoose(MultiSlicedAssembler, _SlicedAssembler);
      function MultiSlicedAssembler() {
        return _SlicedAssembler.apply(this, arguments) || this;
      }
      var _proto = MultiSlicedAssembler.prototype;
      _proto.initData = function initData(sprite) {
        if (this._renderData.meshCount > 0) return;
        this._renderData.createFlexData(0, this.verticesCount, this.indicesCount, this.getVfmt());
        var indices = this._renderData.iDatas[0];
        var indexOffset = 0;
        for (var r = 0; r < 3; ++r) for (var c = 0; c < 3; ++c) {
          var start = 4 * r + c;
          indices[indexOffset++] = start;
          indices[indexOffset++] = start + 1;
          indices[indexOffset++] = start + 4;
          indices[indexOffset++] = start + 1;
          indices[indexOffset++] = start + 5;
          indices[indexOffset++] = start + 4;
        }
      };
      _proto.getVfmt = function getVfmt() {
        return _vertexFormat.vfmtPosUvColorTexId;
      };
      _proto.getBuffer = function getBuffer() {
        return cc.renderer._handle.getBuffer("mesh", this.getVfmt());
      };
      _proto.updateRenderData = function updateRenderData(sprite) {
        _SlicedAssembler.prototype.updateRenderData.call(this, sprite);
        if (sprite._texIdDirty) {
          sprite._updateMultiTexId(sprite.getMaterial(0), sprite._spriteFrame._texture);
          if (sprite._texIdDirty) {
            this.updateTexId(sprite);
            sprite._texIdDirty = false;
          }
        }
      };
      _proto.updateRenderDataForSwitchMaterial = function updateRenderDataForSwitchMaterial(sprite) {
        if (sprite._vertsDirty) {
          this.updateUVs(sprite);
          this.updateVerts(sprite);
          sprite._vertsDirty = false;
        }
        if (sprite._texIdDirty) {
          sprite._updateMultiTexId(sprite.getMaterial(0), sprite._spriteFrame._texture);
          if (sprite._texIdDirty) {
            this.updateTexId(sprite);
            sprite._texIdDirty = false;
          }
        }
        true;
        this._aftUpdateRenderDataForNative();
      };
      return MultiSlicedAssembler;
    })(_sliced["default"]);
    exports["default"] = MultiSlicedAssembler;
    MultiSlicedAssembler.prototype.floatsPerVert = 6;
    MultiSlicedAssembler.prototype.texIdOffset = 5;
    MultiSlicedAssembler.prototype.isMulti = true;
    module.exports = exports["default"];
  }), {
    "../../../../webgl/vertex-format": 371,
    "../2d/sliced": 358
  } ],
  353: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vertexFormat = require("../../../../webgl/vertex-format");
    var _tiled = _interopRequireDefault(require("../2d/tiled"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var MultiTiledAssembler = (function(_TiledAssembler) {
      _inheritsLoose(MultiTiledAssembler, _TiledAssembler);
      function MultiTiledAssembler() {
        return _TiledAssembler.apply(this, arguments) || this;
      }
      var _proto = MultiTiledAssembler.prototype;
      _proto.getVfmt = function getVfmt() {
        return _vertexFormat.vfmtPosUvColorTexId;
      };
      _proto.getBuffer = function getBuffer() {
        return cc.renderer._handle.getBuffer("mesh", this.getVfmt());
      };
      _proto.updateRenderData = function updateRenderData(sprite) {
        _TiledAssembler.prototype.updateRenderData.call(this, sprite);
        sprite._texIdDirty && sprite._updateMultiTexId(sprite.getMaterial(0), sprite.spriteFrame._texture);
        this.updateTexId(sprite);
        sprite._texIdDirty = false;
      };
      _proto.updateRenderDataForSwitchMaterial = function updateRenderDataForSwitchMaterial(sprite) {
        var frame = sprite._spriteFrame;
        var node = sprite.node;
        var contentWidth = this.contentWidth = Math.abs(node.width);
        var contentHeight = this.contentHeight = Math.abs(node.height);
        var rect = frame._rect;
        var leftWidth = frame.insetLeft, rightWidth = frame.insetRight, centerWidth = rect.width - leftWidth - rightWidth, topHeight = frame.insetTop, bottomHeight = frame.insetBottom, centerHeight = rect.height - topHeight - bottomHeight;
        this.sizableWidth = contentWidth - leftWidth - rightWidth;
        this.sizableHeight = contentHeight - topHeight - bottomHeight;
        this.sizableWidth = this.sizableWidth > 0 ? this.sizableWidth : 0;
        this.sizableHeight = this.sizableHeight > 0 ? this.sizableHeight : 0;
        var hRepeat = this.hRepeat = 0 === centerWidth ? this.sizableWidth : this.sizableWidth / centerWidth;
        var vRepeat = this.vRepeat = 0 === centerHeight ? this.sizableHeight : this.sizableHeight / centerHeight;
        var row = this.row = Math.ceil(vRepeat + 2);
        var col = this.col = Math.ceil(hRepeat + 2);
        var count = row * col;
        this.verticesCount = 4 * count;
        this.indicesCount = 6 * count;
        var renderData = this._renderData;
        var flexBuffer = renderData._flexBuffer;
        if (flexBuffer.reserve(this.verticesCount, this.indicesCount)) {
          this._updateIndices();
          this.updateColor(sprite);
        }
        flexBuffer.used(this.verticesCount, this.indicesCount);
        if (sprite._vertsDirty) {
          this.updateUVs(sprite);
          this.updateVerts(sprite);
          sprite._vertsDirty = false;
        }
        sprite._texIdDirty && sprite._updateMultiTexId(sprite.getMaterial(0), sprite.spriteFrame._texture);
        this.updateTexId(sprite);
        sprite._texIdDirty = false;
        true;
        this._aftUpdateRenderDataForNative();
      };
      return MultiTiledAssembler;
    })(_tiled["default"]);
    exports["default"] = MultiTiledAssembler;
    MultiTiledAssembler.prototype.floatsPerVert = 6;
    MultiTiledAssembler.prototype.texIdOffset = 5;
    MultiTiledAssembler.prototype.isMulti = true;
    module.exports = exports["default"];
  }), {
    "../../../../webgl/vertex-format": 371,
    "../2d/tiled": 359
  } ],
  354: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler2d = _interopRequireDefault(require("../../../../assembler-2d"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Sprite = require("../../../../../components/CCSprite");
    var FillType = Sprite.FillType;
    var BarFilledAssembler = (function(_Assembler2D) {
      _inheritsLoose(BarFilledAssembler, _Assembler2D);
      function BarFilledAssembler() {
        return _Assembler2D.apply(this, arguments) || this;
      }
      var _proto = BarFilledAssembler.prototype;
      _proto.updateRenderData = function updateRenderData(sprite) {
        var frame = sprite._spriteFrame;
        var assemblerChanged = this.packDynamicAtlasAndCheckMaterial(sprite, frame);
        if (!assemblerChanged && sprite._vertsDirty) {
          var fillStart = sprite._fillStart;
          var fillRange = sprite._fillRange;
          if (fillRange < 0) {
            fillStart += fillRange;
            fillRange = -fillRange;
          }
          fillRange = fillStart + fillRange;
          fillStart = fillStart > 1 ? 1 : fillStart;
          fillStart = fillStart < 0 ? 0 : fillStart;
          fillRange = fillRange > 1 ? 1 : fillRange;
          fillRange = fillRange < 0 ? 0 : fillRange;
          fillRange -= fillStart;
          fillRange = fillRange < 0 ? 0 : fillRange;
          var fillEnd = fillStart + fillRange;
          fillEnd = fillEnd > 1 ? 1 : fillEnd;
          this.updateUVs(sprite, fillStart, fillEnd);
          this.updateVerts(sprite, fillStart, fillEnd);
          sprite._vertsDirty = false;
        }
        return assemblerChanged;
      };
      _proto.updateUVs = function updateUVs(sprite, fillStart, fillEnd) {
        var spriteFrame = sprite._spriteFrame;
        var atlasWidth = spriteFrame._texture.width;
        var atlasHeight = spriteFrame._texture.height;
        var textureRect = spriteFrame._rect;
        var ul, vb, ur, vt;
        var quadUV0, quadUV1, quadUV2, quadUV3, quadUV4, quadUV5, quadUV6, quadUV7;
        if (spriteFrame._rotated) {
          ul = textureRect.x / atlasWidth;
          vb = (textureRect.y + textureRect.width) / atlasHeight;
          ur = (textureRect.x + textureRect.height) / atlasWidth;
          vt = textureRect.y / atlasHeight;
          quadUV0 = quadUV2 = ul;
          quadUV4 = quadUV6 = ur;
          quadUV3 = quadUV7 = vb;
          quadUV1 = quadUV5 = vt;
        } else {
          ul = textureRect.x / atlasWidth;
          vb = (textureRect.y + textureRect.height) / atlasHeight;
          ur = (textureRect.x + textureRect.width) / atlasWidth;
          vt = textureRect.y / atlasHeight;
          quadUV0 = quadUV4 = ul;
          quadUV2 = quadUV6 = ur;
          quadUV1 = quadUV3 = vb;
          quadUV5 = quadUV7 = vt;
        }
        var verts = this._renderData.vDatas[0];
        var uvOffset = this.uvOffset;
        var floatsPerVert = this.floatsPerVert;
        switch (sprite._fillType) {
         case FillType.HORIZONTAL:
          verts[uvOffset] = quadUV0 + (quadUV2 - quadUV0) * fillStart;
          verts[uvOffset + 1] = quadUV1 + (quadUV3 - quadUV1) * fillStart;
          verts[uvOffset + floatsPerVert] = quadUV0 + (quadUV2 - quadUV0) * fillEnd;
          verts[uvOffset + floatsPerVert + 1] = quadUV1 + (quadUV3 - quadUV1) * fillEnd;
          verts[uvOffset + 2 * floatsPerVert] = quadUV4 + (quadUV6 - quadUV4) * fillStart;
          verts[uvOffset + 2 * floatsPerVert + 1] = quadUV5 + (quadUV7 - quadUV5) * fillStart;
          verts[uvOffset + 3 * floatsPerVert] = quadUV4 + (quadUV6 - quadUV4) * fillEnd;
          verts[uvOffset + 3 * floatsPerVert + 1] = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
          break;

         case FillType.VERTICAL:
          verts[uvOffset] = quadUV0 + (quadUV4 - quadUV0) * fillStart;
          verts[uvOffset + 1] = quadUV1 + (quadUV5 - quadUV1) * fillStart;
          verts[uvOffset + floatsPerVert] = quadUV2 + (quadUV6 - quadUV2) * fillStart;
          verts[uvOffset + floatsPerVert + 1] = quadUV3 + (quadUV7 - quadUV3) * fillStart;
          verts[uvOffset + 2 * floatsPerVert] = quadUV0 + (quadUV4 - quadUV0) * fillEnd;
          verts[uvOffset + 2 * floatsPerVert + 1] = quadUV1 + (quadUV5 - quadUV1) * fillEnd;
          verts[uvOffset + 3 * floatsPerVert] = quadUV2 + (quadUV6 - quadUV2) * fillEnd;
          verts[uvOffset + 3 * floatsPerVert + 1] = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
          break;

         default:
          cc.errorID(2626);
        }
      };
      _proto.updateVerts = function updateVerts(sprite, fillStart, fillEnd) {
        var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var l = -appx, b = -appy, r = width - appx, t = height - appy;
        var progressStart, progressEnd;
        switch (sprite._fillType) {
         case FillType.HORIZONTAL:
          progressStart = l + (r - l) * fillStart;
          progressEnd = l + (r - l) * fillEnd;
          l = progressStart;
          r = progressEnd;
          break;

         case FillType.VERTICAL:
          progressStart = b + (t - b) * fillStart;
          progressEnd = b + (t - b) * fillEnd;
          b = progressStart;
          t = progressEnd;
          break;

         default:
          cc.errorID(2626);
        }
        var local = this._local;
        local[0] = l;
        local[1] = b;
        local[2] = r;
        local[3] = t;
        this.updateWorldVerts(sprite);
      };
      return BarFilledAssembler;
    })(_assembler2d["default"]);
    exports["default"] = BarFilledAssembler;
    module.exports = exports["default"];
  }), {
    "../../../../../components/CCSprite": 198,
    "../../../../assembler-2d": 299
  } ],
  355: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler2d = _interopRequireDefault(require("../../../../assembler-2d"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var MeshSpriteAssembler = (function(_Assembler2D) {
      _inheritsLoose(MeshSpriteAssembler, _Assembler2D);
      function MeshSpriteAssembler() {
        return _Assembler2D.apply(this, arguments) || this;
      }
      var _proto = MeshSpriteAssembler.prototype;
      _proto.initData = function initData(sprite) {
        this._renderData.createFlexData(0, 4, 6, this.getVfmt());
      };
      _proto.updateRenderData = function updateRenderData(sprite) {
        var frame = sprite.spriteFrame;
        var assemblerChanged = this.packDynamicAtlasAndCheckMaterial(sprite, frame);
        if (!assemblerChanged && frame) {
          var vertices = frame.vertices;
          if (vertices) {
            this.verticesCount = vertices.x.length;
            this.indicesCount = vertices.triangles.length;
            var renderData = this._renderData;
            var flexBuffer = renderData._flexBuffer;
            if (flexBuffer.reserve(this.verticesCount, this.indicesCount)) {
              this.updateColor(sprite);
              sprite._vertsDirty = true;
            }
            flexBuffer.used(this.verticesCount, this.indicesCount);
            this.updateIndices(vertices.triangles);
            if (sprite._vertsDirty) {
              this.updateUVs(sprite);
              this.updateVerts(sprite);
              this.updateWorldVerts(sprite);
              sprite._vertsDirty = false;
            }
          }
        }
        return assemblerChanged;
      };
      _proto.updateIndices = function updateIndices(triangles) {
        this._renderData.iDatas[0].set(triangles);
      };
      _proto.updateUVs = function updateUVs(sprite) {
        var vertices = sprite.spriteFrame.vertices, u = vertices.nu, v = vertices.nv;
        var uvOffset = this.uvOffset;
        var floatsPerVert = this.floatsPerVert;
        var verts = this._renderData.vDatas[0];
        for (var i = 0; i < u.length; i++) {
          var dstOffset = floatsPerVert * i + uvOffset;
          verts[dstOffset] = u[i];
          verts[dstOffset + 1] = v[i];
        }
      };
      _proto.updateVerts = function updateVerts(sprite) {
        var node = sprite.node, contentWidth = Math.abs(node.width), contentHeight = Math.abs(node.height), appx = node.anchorX * contentWidth, appy = node.anchorY * contentHeight;
        var frame = sprite.spriteFrame, vertices = frame.vertices, x = vertices.x, y = vertices.y, originalWidth = frame._originalSize.width, originalHeight = frame._originalSize.height, rectWidth = frame._rect.width, rectHeight = frame._rect.height, offsetX = frame._offset.x, offsetY = frame._offset.y, trimX = offsetX + (originalWidth - rectWidth) / 2, trimY = offsetY + (originalHeight - rectHeight) / 2;
        var scaleX = contentWidth / (sprite.trim ? rectWidth : originalWidth), scaleY = contentHeight / (sprite.trim ? rectHeight : originalHeight);
        var local = this._local;
        if (sprite.trim) for (var _i = 0, _l = x.length; _i < _l; _i++) {
          var _offset = 2 * _i;
          local[_offset] = (x[_i] - trimX) * scaleX - appx;
          local[_offset + 1] = (originalHeight - y[_i] - trimY) * scaleY - appy;
        } else for (var i = 0, l = x.length; i < l; i++) {
          var offset = 2 * i;
          local[offset] = x[i] * scaleX - appx;
          local[offset + 1] = (originalHeight - y[i]) * scaleY - appy;
        }
        if (frame._flipX) for (var _i2 = 0, _l2 = this.verticesCount; _i2 < _l2; _i2++) local[2 * _i2] = contentWidth - local[2 * _i2] - 2 * appx;
        if (frame._flipY) for (var _i3 = 0, _l3 = this.verticesCount; _i3 < _l3; _i3++) local[2 * _i3 + 1] = contentHeight - local[2 * _i3 + 1] - 2 * appy;
      };
      _proto.updateWorldVerts = function updateWorldVerts(sprite) {
        var node = sprite.node;
        var matrix = node._worldMatrix;
        var matrixm = matrix.m;
        var a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        var local = this._local;
        var world = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        for (var i = 0, l = this.verticesCount; i < l; i++) {
          var lx = local[2 * i];
          var ly = local[2 * i + 1];
          world[floatsPerVert * i] = lx * a + ly * c + tx;
          world[floatsPerVert * i + 1] = lx * b + ly * d + ty;
        }
      };
      return MeshSpriteAssembler;
    })(_assembler2d["default"]);
    exports["default"] = MeshSpriteAssembler;
    module.exports = exports["default"];
  }), {
    "../../../../assembler-2d": 299
  } ],
  356: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler2d = _interopRequireDefault(require("../../../../assembler-2d"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var PI_2 = 2 * Math.PI;
    var _vertPos = [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ];
    var _vertices = [ 0, 0, 0, 0 ];
    var _uvs = [ 0, 0, 0, 0, 0, 0, 0, 0 ];
    var _intersectPoint_1 = [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ];
    var _intersectPoint_2 = [ cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0), cc.v2(0, 0) ];
    var _center = cc.v2(0, 0);
    var _triangles = [];
    function _calcInsectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
      var sinAngle = Math.sin(angle);
      var cosAngle = Math.cos(angle);
      var tanAngle, cotAngle;
      if (0 !== Math.cos(angle)) {
        tanAngle = sinAngle / cosAngle;
        if ((left - center.x) * cosAngle > 0) {
          var yleft = center.y + tanAngle * (left - center.x);
          intersectPoints[0].x = left;
          intersectPoints[0].y = yleft;
        }
        if ((right - center.x) * cosAngle > 0) {
          var yright = center.y + tanAngle * (right - center.x);
          intersectPoints[2].x = right;
          intersectPoints[2].y = yright;
        }
      }
      if (0 !== Math.sin(angle)) {
        cotAngle = cosAngle / sinAngle;
        if ((top - center.y) * sinAngle > 0) {
          var xtop = center.x + cotAngle * (top - center.y);
          intersectPoints[3].x = xtop;
          intersectPoints[3].y = top;
        }
        if ((bottom - center.y) * sinAngle > 0) {
          var xbottom = center.x + cotAngle * (bottom - center.y);
          intersectPoints[1].x = xbottom;
          intersectPoints[1].y = bottom;
        }
      }
    }
    function _calculateVertices(sprite) {
      var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
      var l = -appx, b = -appy, r = width - appx, t = height - appy;
      var vertices = _vertices;
      vertices[0] = l;
      vertices[1] = b;
      vertices[2] = r;
      vertices[3] = t;
      var fillCenter = sprite._fillCenter, cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l, cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
      _vertPos[0].x = _vertPos[3].x = l;
      _vertPos[1].x = _vertPos[2].x = r;
      _vertPos[0].y = _vertPos[1].y = b;
      _vertPos[2].y = _vertPos[3].y = t;
      _triangles.length = 0;
      cx !== vertices[0] && (_triangles[0] = [ 3, 0 ]);
      cx !== vertices[2] && (_triangles[2] = [ 1, 2 ]);
      cy !== vertices[1] && (_triangles[1] = [ 0, 1 ]);
      cy !== vertices[3] && (_triangles[3] = [ 2, 3 ]);
    }
    function _calculateUVs(spriteFrame) {
      var atlasWidth = spriteFrame._texture.width;
      var atlasHeight = spriteFrame._texture.height;
      var textureRect = spriteFrame._rect;
      var u0, u1, v0, v1;
      var uvs = _uvs;
      if (spriteFrame._rotated) {
        u0 = textureRect.x / atlasWidth;
        u1 = (textureRect.x + textureRect.height) / atlasWidth;
        v0 = textureRect.y / atlasHeight;
        v1 = (textureRect.y + textureRect.width) / atlasHeight;
        uvs[0] = uvs[2] = u0;
        uvs[4] = uvs[6] = u1;
        uvs[3] = uvs[7] = v1;
        uvs[1] = uvs[5] = v0;
      } else {
        u0 = textureRect.x / atlasWidth;
        u1 = (textureRect.x + textureRect.width) / atlasWidth;
        v0 = textureRect.y / atlasHeight;
        v1 = (textureRect.y + textureRect.height) / atlasHeight;
        uvs[0] = uvs[4] = u0;
        uvs[2] = uvs[6] = u1;
        uvs[1] = uvs[3] = v1;
        uvs[5] = uvs[7] = v0;
      }
    }
    function _getVertAngle(start, end) {
      var placementX, placementY;
      placementX = end.x - start.x;
      placementY = end.y - start.y;
      if (0 === placementX && 0 === placementY) return;
      if (0 === placementX) return placementY > 0 ? .5 * Math.PI : 1.5 * Math.PI;
      var angle = Math.atan(placementY / placementX);
      placementX < 0 && (angle += Math.PI);
      return angle;
    }
    var RadialFilledAssembler = (function(_Assembler2D) {
      _inheritsLoose(RadialFilledAssembler, _Assembler2D);
      function RadialFilledAssembler() {
        return _Assembler2D.apply(this, arguments) || this;
      }
      var _proto = RadialFilledAssembler.prototype;
      _proto.initData = function initData(sprite) {
        this._renderData.createFlexData(0, 4, 6, this.getVfmt());
        this.updateIndices();
      };
      _proto.updateRenderData = function updateRenderData(sprite) {
        _Assembler2D.prototype.updateRenderData.call(this, sprite);
        var frame = sprite.spriteFrame;
        var assemblerChanged = this.packDynamicAtlasAndCheckMaterial(sprite, frame);
        assemblerChanged || this._aftUpdateRenderData(sprite);
        return assemblerChanged;
      };
      _proto._aftUpdateRenderData = function _aftUpdateRenderData(sprite) {
        var frame = sprite.spriteFrame;
        if (sprite._vertsDirty) {
          var fillStart = sprite._fillStart;
          var fillRange = sprite._fillRange;
          if (fillRange < 0) {
            fillStart += fillRange;
            fillRange = -fillRange;
          }
          while (fillStart >= 1) fillStart -= 1;
          while (fillStart < 0) fillStart += 1;
          fillStart *= PI_2;
          fillRange *= PI_2;
          _calculateVertices(sprite);
          _calculateUVs(frame);
          _calcInsectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1);
          _calcInsectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);
          this.updateVerts(sprite, fillStart, fillRange);
          sprite._vertsDirty = false;
        }
      };
      _proto.updateVerts = function updateVerts(sprite, fillStart, fillRange) {
        var fillEnd = fillStart + fillRange;
        var local = this._local;
        local.length = 0;
        var offset = 0;
        var floatsPerTriangle = 3 * this.floatsPerVert;
        for (var triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
          var triangle = _triangles[triangleIndex];
          if (!triangle) continue;
          if (fillRange >= PI_2) {
            local.length = offset + floatsPerTriangle;
            this._generateTriangle(local, offset, _center, _vertPos[triangle[0]], _vertPos[triangle[1]]);
            offset += floatsPerTriangle;
            continue;
          }
          var startAngle = _getVertAngle(_center, _vertPos[triangle[0]]);
          var endAngle = _getVertAngle(_center, _vertPos[triangle[1]]);
          endAngle < startAngle && (endAngle += PI_2);
          startAngle -= PI_2;
          endAngle -= PI_2;
          for (var testIndex = 0; testIndex < 3; ++testIndex) {
            if (startAngle >= fillEnd) ; else if (startAngle >= fillStart) {
              local.length = offset + floatsPerTriangle;
              endAngle >= fillEnd ? this._generateTriangle(local, offset, _center, _vertPos[triangle[0]], _intersectPoint_2[triangleIndex]) : this._generateTriangle(local, offset, _center, _vertPos[triangle[0]], _vertPos[triangle[1]]);
              offset += floatsPerTriangle;
            } else if (endAngle <= fillStart) ; else if (endAngle <= fillEnd) {
              local.length = offset + floatsPerTriangle;
              this._generateTriangle(local, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle[1]]);
              offset += floatsPerTriangle;
            } else {
              local.length = offset + floatsPerTriangle;
              this._generateTriangle(local, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]);
              offset += floatsPerTriangle;
            }
            startAngle += PI_2;
            endAngle += PI_2;
          }
        }
        this.allocWorldVerts(sprite);
        this.updateWorldVerts(sprite);
      };
      _proto.allocWorldVerts = function allocWorldVerts(sprite) {
        var color = sprite.node._color._val;
        var renderData = this._renderData;
        var floatsPerVert = this.floatsPerVert;
        var local = this._local;
        var verticesCount = local.length / floatsPerVert;
        this.verticesCount = this.indicesCount = verticesCount;
        var flexBuffer = renderData._flexBuffer;
        flexBuffer.reserve(verticesCount, verticesCount) && this.updateIndices();
        flexBuffer.used(this.verticesCount, this.indicesCount);
        var verts = renderData.vDatas[0], uintVerts = renderData.uintVDatas[0];
        var uvOffset = this.uvOffset;
        for (var offset = 0; offset < local.length; offset += floatsPerVert) {
          var start = offset + uvOffset;
          verts[start] = local[start];
          verts[start + 1] = local[start + 1];
          uintVerts[start + 2] = color;
        }
      };
      _proto.updateIndices = function updateIndices() {
        var iData = this._renderData.iDatas[0];
        for (var i = 0; i < iData.length; i++) iData[i] = i;
      };
      _proto.updateWorldVerts = function updateWorldVerts(sprite) {
        var node = sprite.node;
        var matrix = node._worldMatrix;
        var matrixm = matrix.m, a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        var local = this._local;
        var world = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        for (var offset = 0; offset < local.length; offset += floatsPerVert) {
          var x = local[offset];
          var y = local[offset + 1];
          world[offset] = x * a + y * c + tx;
          world[offset + 1] = x * b + y * d + ty;
        }
      };
      _proto._generateTriangle = function _generateTriangle(verts, offset, vert0, vert1, vert2) {
        var vertices = _vertices;
        var v0x = vertices[0];
        var v0y = vertices[1];
        var v1x = vertices[2];
        var v1y = vertices[3];
        var floatsPerVert = this.floatsPerVert;
        verts[offset] = vert0.x;
        verts[offset + 1] = vert0.y;
        verts[offset + floatsPerVert] = vert1.x;
        verts[offset + floatsPerVert + 1] = vert1.y;
        verts[offset + 2 * floatsPerVert] = vert2.x;
        verts[offset + 2 * floatsPerVert + 1] = vert2.y;
        var uvOffset = this.uvOffset;
        var progressX, progressY;
        progressX = (vert0.x - v0x) / (v1x - v0x);
        progressY = (vert0.y - v0y) / (v1y - v0y);
        this._generateUV(progressX, progressY, verts, offset + uvOffset);
        progressX = (vert1.x - v0x) / (v1x - v0x);
        progressY = (vert1.y - v0y) / (v1y - v0y);
        this._generateUV(progressX, progressY, verts, offset + floatsPerVert + uvOffset);
        progressX = (vert2.x - v0x) / (v1x - v0x);
        progressY = (vert2.y - v0y) / (v1y - v0y);
        this._generateUV(progressX, progressY, verts, offset + 2 * floatsPerVert + uvOffset);
      };
      _proto._generateUV = function _generateUV(progressX, progressY, verts, offset) {
        var uvs = _uvs;
        var px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
        var px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
        var py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
        var py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
        verts[offset] = px1 + (px2 - px1) * progressY;
        verts[offset + 1] = py1 + (py2 - py1) * progressY;
      };
      return RadialFilledAssembler;
    })(_assembler2d["default"]);
    exports["default"] = RadialFilledAssembler;
    module.exports = exports["default"];
  }), {
    "../../../../assembler-2d": 299
  } ],
  357: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler2d = _interopRequireDefault(require("../../../../assembler-2d"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var SimpleSpriteAssembler = (function(_Assembler2D) {
      _inheritsLoose(SimpleSpriteAssembler, _Assembler2D);
      function SimpleSpriteAssembler() {
        return _Assembler2D.apply(this, arguments) || this;
      }
      var _proto = SimpleSpriteAssembler.prototype;
      _proto.updateRenderData = function updateRenderData(sprite) {
        var assemblerChanged = this.packDynamicAtlasAndCheckMaterial(sprite, sprite._spriteFrame);
        if (!assemblerChanged && sprite._vertsDirty) {
          this.updateUVs(sprite);
          this.updateVerts(sprite);
          sprite._vertsDirty = false;
        }
        return assemblerChanged;
      };
      _proto.updateUVs = function updateUVs(sprite) {
        var uv = sprite._spriteFrame.uv;
        var uvOffset = this.uvOffset;
        var floatsPerVert = this.floatsPerVert;
        var verts = this._renderData.vDatas[0];
        for (var i = 0; i < 4; i++) {
          var srcOffset = 2 * i;
          var dstOffset = floatsPerVert * i + uvOffset;
          verts[dstOffset] = uv[srcOffset];
          verts[dstOffset + 1] = uv[srcOffset + 1];
        }
      };
      _proto.updateVerts = function updateVerts(sprite) {
        var node = sprite.node, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l, b, r, t;
        if (sprite.trim) {
          l = -appx;
          b = -appy;
          r = cw - appx;
          t = ch - appy;
        } else {
          var frame = sprite.spriteFrame, ow = frame._originalSize.width, oh = frame._originalSize.height, rw = frame._rect.width, rh = frame._rect.height, offset = frame._offset, scaleX = cw / ow, scaleY = ch / oh;
          var trimLeft = offset.x + (ow - rw) / 2;
          var trimRight = offset.x - (ow - rw) / 2;
          var trimBottom = offset.y + (oh - rh) / 2;
          var trimTop = offset.y - (oh - rh) / 2;
          l = trimLeft * scaleX - appx;
          b = trimBottom * scaleY - appy;
          r = cw + trimRight * scaleX - appx;
          t = ch + trimTop * scaleY - appy;
        }
        var local = this._local;
        local[0] = l;
        local[1] = b;
        local[2] = r;
        local[3] = t;
        this.updateWorldVerts(sprite);
      };
      return SimpleSpriteAssembler;
    })(_assembler2d["default"]);
    exports["default"] = SimpleSpriteAssembler;
    module.exports = exports["default"];
  }), {
    "../../../../assembler-2d": 299
  } ],
  358: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler2d = _interopRequireDefault(require("../../../../assembler-2d"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var SlicedAssembler = (function(_Assembler2D) {
      _inheritsLoose(SlicedAssembler, _Assembler2D);
      function SlicedAssembler() {
        return _Assembler2D.apply(this, arguments) || this;
      }
      var _proto = SlicedAssembler.prototype;
      _proto.initData = function initData(sprite) {
        if (this._renderData.meshCount > 0) return;
        this._renderData.createData(0, this.verticesFloats, this.indicesCount);
        var indices = this._renderData.iDatas[0];
        var indexOffset = 0;
        for (var r = 0; r < 3; ++r) for (var c = 0; c < 3; ++c) {
          var start = 4 * r + c;
          indices[indexOffset++] = start;
          indices[indexOffset++] = start + 1;
          indices[indexOffset++] = start + 4;
          indices[indexOffset++] = start + 1;
          indices[indexOffset++] = start + 5;
          indices[indexOffset++] = start + 4;
        }
      };
      _proto.initLocal = function initLocal() {
        this._local = [];
        this._local.length = 8;
      };
      _proto.updateRenderData = function updateRenderData(sprite) {
        var frame = sprite._spriteFrame;
        var assemblerChanged = this.packDynamicAtlasAndCheckMaterial(sprite, frame);
        if (!assemblerChanged && sprite._vertsDirty) {
          this.updateUVs(sprite);
          this.updateVerts(sprite);
          sprite._vertsDirty = false;
        }
        return assemblerChanged;
      };
      _proto.updateVerts = function updateVerts(sprite) {
        var node = sprite.node, width = node.width, height = node.height, appx = node.anchorX * width, appy = node.anchorY * height;
        var frame = sprite.spriteFrame;
        var leftWidth = frame.insetLeft;
        var rightWidth = frame.insetRight;
        var topHeight = frame.insetTop;
        var bottomHeight = frame.insetBottom;
        var sizableWidth = width - leftWidth - rightWidth;
        var sizableHeight = height - topHeight - bottomHeight;
        var xScale = width / (leftWidth + rightWidth);
        var yScale = height / (topHeight + bottomHeight);
        xScale = isNaN(xScale) || xScale > 1 ? 1 : xScale;
        yScale = isNaN(yScale) || yScale > 1 ? 1 : yScale;
        sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
        sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
        var local = this._local;
        local[0] = -appx;
        local[1] = -appy;
        local[2] = leftWidth * xScale - appx;
        local[3] = bottomHeight * yScale - appy;
        local[4] = local[2] + sizableWidth;
        local[5] = local[3] + sizableHeight;
        local[6] = width - appx;
        local[7] = height - appy;
        this.updateWorldVerts(sprite);
      };
      _proto.updateUVs = function updateUVs(sprite) {
        var verts = this._renderData.vDatas[0];
        var uvSliced = sprite.spriteFrame.uvSliced;
        var uvOffset = this.uvOffset;
        var floatsPerVert = this.floatsPerVert;
        for (var row = 0; row < 4; ++row) for (var col = 0; col < 4; ++col) {
          var vid = 4 * row + col;
          var uv = uvSliced[vid];
          var voffset = vid * floatsPerVert;
          verts[voffset + uvOffset] = uv.u;
          verts[voffset + uvOffset + 1] = uv.v;
        }
      };
      _proto.updateWorldVerts = function updateWorldVerts(sprite) {
        var matrix = sprite.node._worldMatrix;
        var matrixm = matrix.m, a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        var local = this._local;
        var world = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        for (var row = 0; row < 4; ++row) {
          var localRowY = local[2 * row + 1];
          for (var col = 0; col < 4; ++col) {
            var localColX = local[2 * col];
            var worldIndex = (4 * row + col) * floatsPerVert;
            world[worldIndex] = localColX * a + localRowY * c + tx;
            world[worldIndex + 1] = localColX * b + localRowY * d + ty;
          }
        }
      };
      return SlicedAssembler;
    })(_assembler2d["default"]);
    exports["default"] = SlicedAssembler;
    Object.assign(SlicedAssembler.prototype, {
      verticesCount: 16,
      indicesCount: 54
    });
    module.exports = exports["default"];
  }), {
    "../../../../assembler-2d": 299
  } ],
  359: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler2d = _interopRequireDefault(require("../../../../assembler-2d"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var TiledAssembler = (function(_Assembler2D) {
      _inheritsLoose(TiledAssembler, _Assembler2D);
      function TiledAssembler() {
        return _Assembler2D.apply(this, arguments) || this;
      }
      var _proto = TiledAssembler.prototype;
      _proto.initData = function initData(sprite) {
        this.verticesCount = 0;
        this.contentWidth = 0;
        this.contentHeight = 0;
        this.rectWidth = 0;
        this.rectHeight = 0;
        this.hRepeat = 0;
        this.vRepeat = 0;
        this.row = 0;
        this.col = 0;
        this._renderData.createFlexData(0, 4, 6, this.getVfmt());
        this._updateIndices();
      };
      _proto.initLocal = function initLocal() {
        this._local = {
          x: [],
          y: []
        };
      };
      _proto._updateIndices = function _updateIndices() {
        var iData = this._renderData.iDatas[0];
        for (var i = 0, vid = 0, l = iData.length; i < l; i += 6, vid += 4) {
          iData[i] = vid;
          iData[i + 1] = vid + 1;
          iData[i + 2] = vid + 2;
          iData[i + 3] = vid + 1;
          iData[i + 4] = vid + 3;
          iData[i + 5] = vid + 2;
        }
      };
      _proto.updateRenderData = function updateRenderData(sprite) {
        var frame = sprite._spriteFrame;
        var assemblerChanged = this.packDynamicAtlasAndCheckMaterial(sprite, frame);
        if (!assemblerChanged) {
          var node = sprite.node;
          var contentWidth = this.contentWidth = Math.abs(node.width);
          var contentHeight = this.contentHeight = Math.abs(node.height);
          var rect = frame._rect;
          var leftWidth = frame.insetLeft, rightWidth = frame.insetRight, centerWidth = rect.width - leftWidth - rightWidth, topHeight = frame.insetTop, bottomHeight = frame.insetBottom, centerHeight = rect.height - topHeight - bottomHeight;
          this.sizableWidth = contentWidth - leftWidth - rightWidth;
          this.sizableHeight = contentHeight - topHeight - bottomHeight;
          this.sizableWidth = this.sizableWidth > 0 ? this.sizableWidth : 0;
          this.sizableHeight = this.sizableHeight > 0 ? this.sizableHeight : 0;
          var hRepeat = this.hRepeat = 0 === centerWidth ? this.sizableWidth : this.sizableWidth / centerWidth;
          var vRepeat = this.vRepeat = 0 === centerHeight ? this.sizableHeight : this.sizableHeight / centerHeight;
          var row = this.row = Math.ceil(vRepeat + 2);
          var col = this.col = Math.ceil(hRepeat + 2);
          var count = row * col;
          this.verticesCount = 4 * count;
          this.indicesCount = 6 * count;
          var renderData = this._renderData;
          var flexBuffer = renderData._flexBuffer;
          if (flexBuffer.reserve(this.verticesCount, this.indicesCount)) {
            this._updateIndices();
            this.updateColor(sprite);
          }
          flexBuffer.used(this.verticesCount, this.indicesCount);
          if (sprite._vertsDirty) {
            this.updateUVs(sprite);
            this.updateVerts(sprite);
            sprite._vertsDirty = false;
          }
        }
        return assemblerChanged;
      };
      _proto.updateVerts = function updateVerts(sprite) {
        var frame = sprite._spriteFrame;
        var rect = frame._rect;
        var node = sprite.node, appx = node.anchorX * node.width, appy = node.anchorY * node.height;
        var row = this.row, col = this.col, contentWidth = this.contentWidth, contentHeight = this.contentHeight;
        var _this$_local = this._local, x = _this$_local.x, y = _this$_local.y;
        x.length = y.length = 0;
        var leftWidth = frame.insetLeft, rightWidth = frame.insetRight, centerWidth = rect.width - leftWidth - rightWidth, topHeight = frame.insetTop, bottomHeight = frame.insetBottom, centerHeight = rect.height - topHeight - bottomHeight;
        var xScale = node.width / (leftWidth + rightWidth) > 1 ? 1 : node.width / (leftWidth + rightWidth);
        var yScale = node.height / (topHeight + bottomHeight) > 1 ? 1 : node.height / (topHeight + bottomHeight);
        var offsetWidth = 0, offsetHeight = 0;
        offsetWidth = centerWidth > 0 ? Math.floor(1e3 * this.sizableWidth) / 1e3 % centerWidth === 0 ? centerWidth : this.sizableWidth % centerWidth : this.sizableWidth;
        offsetHeight = centerHeight > 0 ? Math.floor(1e3 * this.sizableHeight) / 1e3 % centerHeight === 0 ? centerHeight : this.sizableHeight % centerHeight : this.sizableHeight;
        for (var i = 0; i <= col; i++) 0 === i ? x[i] = -appx : i > 0 && i < col ? x[i] = 1 === i ? leftWidth * xScale + Math.min(centerWidth, this.sizableWidth) - appx : centerWidth > 0 ? i === col - 1 ? leftWidth + offsetWidth + centerWidth * (i - 2) - appx : leftWidth + Math.min(centerWidth, this.sizableWidth) + centerWidth * (i - 2) - appx : leftWidth + this.sizableWidth - appx : i === col && (x[i] = Math.min(leftWidth + this.sizableWidth + rightWidth, contentWidth) - appx);
        for (var _i = 0; _i <= row; _i++) 0 === _i ? y[_i] = -appy : _i > 0 && _i < row ? y[_i] = 1 === _i ? bottomHeight * yScale + Math.min(centerHeight, this.sizableHeight) - appy : centerHeight > 0 ? _i === row - 1 ? bottomHeight + offsetHeight + (_i - 2) * centerHeight - appy : bottomHeight + Math.min(centerHeight, this.sizableHeight) + (_i - 2) * centerHeight - appy : bottomHeight + this.sizableHeight - appy : _i === row && (y[_i] = Math.min(bottomHeight + this.sizableHeight + topHeight, contentHeight) - appy);
        this.updateWorldVerts(sprite);
      };
      _proto.updateWorldVerts = function updateWorldVerts(sprite) {
        var renderData = this._renderData;
        var local = this._local;
        var localX = local.x, localY = local.y;
        var world = renderData.vDatas[0];
        var row = this.row, col = this.col;
        var matrix = sprite.node._worldMatrix;
        var matrixm = matrix.m;
        var a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        var x, x1, y, y1;
        var floatsPerVert = this.floatsPerVert;
        var vertexOffset = 0;
        for (var yindex = 0, ylength = row; yindex < ylength; ++yindex) {
          y = localY[yindex];
          y1 = localY[yindex + 1];
          for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
            x = localX[xindex];
            x1 = localX[xindex + 1];
            world[vertexOffset] = x * a + y * c + tx;
            world[vertexOffset + 1] = x * b + y * d + ty;
            vertexOffset += floatsPerVert;
            world[vertexOffset] = x1 * a + y * c + tx;
            world[vertexOffset + 1] = x1 * b + y * d + ty;
            vertexOffset += floatsPerVert;
            world[vertexOffset] = x * a + y1 * c + tx;
            world[vertexOffset + 1] = x * b + y1 * d + ty;
            vertexOffset += floatsPerVert;
            world[vertexOffset] = x1 * a + y1 * c + tx;
            world[vertexOffset + 1] = x1 * b + y1 * d + ty;
            vertexOffset += floatsPerVert;
          }
        }
      };
      _proto.updateUVs = function updateUVs(sprite) {
        var verts = this._renderData.vDatas[0];
        if (!verts) return;
        var frame = sprite._spriteFrame;
        var rect = frame._rect;
        var leftWidth = frame.insetLeft, rightWidth = frame.insetRight, centerWidth = rect.width - leftWidth - rightWidth, topHeight = frame.insetTop, bottomHeight = frame.insetBottom, centerHeight = rect.height - topHeight - bottomHeight;
        var row = this.row, col = this.col, hRepeat = this.hRepeat, vRepeat = this.vRepeat;
        var coefu = 0, coefv = 0;
        var uv = sprite.spriteFrame.uv;
        var uvSliced = sprite.spriteFrame.uvSliced;
        var rotated = sprite.spriteFrame._rotated;
        var floatsPerVert = this.floatsPerVert, uvOffset = this.uvOffset;
        var tempXVerts = [], tempYVerts = [];
        for (var yindex = 0, ylength = row; yindex < ylength; ++yindex) {
          coefv = this.sizableHeight > centerHeight ? this.sizableHeight >= yindex * centerHeight ? 1 : vRepeat % 1 : vRepeat;
          for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
            coefu = this.sizableWidth > centerWidth ? this.sizableWidth >= xindex * centerWidth ? 1 : hRepeat % 1 : hRepeat;
            if (rotated) {
              if (0 === yindex) {
                tempXVerts[0] = uvSliced[0].u;
                tempXVerts[1] = uvSliced[0].u;
                tempXVerts[2] = uvSliced[4].u + (uvSliced[8].u - uvSliced[4].u) * coefv;
              } else if (yindex < row - 1) {
                tempXVerts[0] = uvSliced[4].u;
                tempXVerts[1] = uvSliced[4].u;
                tempXVerts[2] = uvSliced[4].u + (uvSliced[8].u - uvSliced[4].u) * coefv;
              } else if (yindex === row - 1) {
                tempXVerts[0] = uvSliced[8].u;
                tempXVerts[1] = uvSliced[8].u;
                tempXVerts[2] = uvSliced[12].u;
              }
              if (0 === xindex) {
                tempYVerts[0] = uvSliced[0].v;
                tempYVerts[1] = uvSliced[1].v + (uvSliced[2].v - uvSliced[1].v) * coefu;
                tempYVerts[2] = uvSliced[0].v;
              } else if (xindex < col - 1) {
                tempYVerts[0] = uvSliced[1].v;
                tempYVerts[1] = uvSliced[1].v + (uvSliced[2].v - uvSliced[1].v) * coefu;
                tempYVerts[2] = uvSliced[1].v;
              } else if (xindex === col - 1) {
                tempYVerts[0] = uvSliced[2].v;
                tempYVerts[1] = uvSliced[3].v;
                tempYVerts[2] = uvSliced[2].v;
              }
              tempXVerts[3] = tempXVerts[2];
              tempYVerts[3] = tempYVerts[1];
            } else {
              if (0 === xindex) {
                tempXVerts[0] = uvSliced[0].u;
                tempXVerts[1] = uvSliced[1].u + (uvSliced[2].u - uvSliced[1].u) * coefu;
                tempXVerts[2] = uv[0];
              } else if (xindex < col - 1) {
                tempXVerts[0] = uvSliced[1].u;
                tempXVerts[1] = uvSliced[1].u + (uvSliced[2].u - uvSliced[1].u) * coefu;
                tempXVerts[2] = uvSliced[1].u;
              } else if (xindex === col - 1) {
                tempXVerts[0] = uvSliced[2].u;
                tempXVerts[1] = uvSliced[3].u;
                tempXVerts[2] = uvSliced[2].u;
              }
              if (0 === yindex) {
                tempYVerts[0] = uvSliced[0].v;
                tempYVerts[1] = uvSliced[0].v;
                tempYVerts[2] = uvSliced[4].v + (uvSliced[8].v - uvSliced[4].v) * coefv;
              } else if (yindex < row - 1) {
                tempYVerts[0] = uvSliced[4].v;
                tempYVerts[1] = uvSliced[4].v;
                tempYVerts[2] = uvSliced[4].v + (uvSliced[8].v - uvSliced[4].v) * coefv;
              } else if (yindex === row - 1) {
                tempYVerts[0] = uvSliced[8].v;
                tempYVerts[1] = uvSliced[8].v;
                tempYVerts[2] = uvSliced[12].v;
              }
              tempXVerts[3] = tempXVerts[1];
              tempYVerts[3] = tempYVerts[2];
            }
            verts[uvOffset] = tempXVerts[0];
            verts[uvOffset + 1] = tempYVerts[0];
            uvOffset += floatsPerVert;
            verts[uvOffset] = tempXVerts[1];
            verts[uvOffset + 1] = tempYVerts[1];
            uvOffset += floatsPerVert;
            verts[uvOffset] = tempXVerts[2];
            verts[uvOffset + 1] = tempYVerts[2];
            uvOffset += floatsPerVert;
            verts[uvOffset] = tempXVerts[3];
            verts[uvOffset + 1] = tempYVerts[3];
            uvOffset += floatsPerVert;
          }
        }
      };
      return TiledAssembler;
    })(_assembler2d["default"]);
    exports["default"] = TiledAssembler;
    module.exports = exports["default"];
  }), {
    "../../../../assembler-2d": 299
  } ],
  360: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Assembler3D = require("../../../../assembler-3d");
    var BarFilledAssembler = require("../2d/bar-filled");
    var BarFilledAssembler3D = (function(_BarFilledAssembler) {
      _inheritsLoose(BarFilledAssembler3D, _BarFilledAssembler);
      function BarFilledAssembler3D() {
        return _BarFilledAssembler.apply(this, arguments) || this;
      }
      return BarFilledAssembler3D;
    })(BarFilledAssembler);
    exports["default"] = BarFilledAssembler3D;
    cc.js.mixin(BarFilledAssembler3D.prototype, Assembler3D);
    module.exports = exports["default"];
  }), {
    "../../../../assembler-3d": 300,
    "../2d/bar-filled": 354
  } ],
  361: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vec = _interopRequireDefault(require("../../../../../value-types/vec3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Assembler3D = require("../../../../assembler-3d");
    var MeshAssembler = require("../2d/mesh");
    var vec3_temp = new _vec["default"]();
    var MeshAssembler3D = (function(_MeshAssembler) {
      _inheritsLoose(MeshAssembler3D, _MeshAssembler);
      function MeshAssembler3D() {
        return _MeshAssembler.apply(this, arguments) || this;
      }
      return MeshAssembler3D;
    })(MeshAssembler);
    exports["default"] = MeshAssembler3D;
    cc.js.mixin(MeshAssembler3D.prototype, Assembler3D, {
      updateWorldVerts: function updateWorldVerts(comp) {
        var matrix = comp.node._worldMatrix;
        var local = this._local;
        var world = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        for (var i = 0, l = local.length / 2; i < l; i++) {
          _vec["default"].set(vec3_temp, local[2 * i], local[2 * i + 1], 0);
          _vec["default"].transformMat4(vec3_temp, vec3_temp, matrix);
          var dstOffset = floatsPerVert * i;
          world[dstOffset] = vec3_temp.x;
          world[dstOffset + 1] = vec3_temp.y;
          world[dstOffset + 2] = vec3_temp.z;
        }
      }
    });
    module.exports = exports["default"];
  }), {
    "../../../../../value-types/vec3": 411,
    "../../../../assembler-3d": 300,
    "../2d/mesh": 355
  } ],
  362: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vec = _interopRequireDefault(require("../../../../../value-types/vec3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Assembler3D = require("../../../../assembler-3d");
    var RadialFilledAssembler = require("../2d/radial-filled");
    var vec3_temp_local = new _vec["default"]();
    var vec3_temp_world = new _vec["default"]();
    var RadialFilledAssembler3D = (function(_RadialFilledAssemble) {
      _inheritsLoose(RadialFilledAssembler3D, _RadialFilledAssemble);
      function RadialFilledAssembler3D() {
        return _RadialFilledAssemble.apply(this, arguments) || this;
      }
      return RadialFilledAssembler3D;
    })(RadialFilledAssembler);
    exports["default"] = RadialFilledAssembler3D;
    cc.js.mixin(RadialFilledAssembler3D.prototype, Assembler3D, {
      updateWorldVerts: function updateWorldVerts(sprite) {
        var matrix = sprite.node._worldMatrix;
        var local = this._local;
        var world = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        for (var offset = 0; offset < world.length; offset += floatsPerVert) {
          _vec["default"].set(vec3_temp_local, local[offset], local[offset + 1], 0);
          _vec["default"].transformMat4(vec3_temp_world, vec3_temp_local, matrix);
          world[offset] = vec3_temp_world.x;
          world[offset + 1] = vec3_temp_world.y;
          world[offset + 2] = vec3_temp_world.z;
        }
      }
    });
    module.exports = exports["default"];
  }), {
    "../../../../../value-types/vec3": 411,
    "../../../../assembler-3d": 300,
    "../2d/radial-filled": 356
  } ],
  363: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Assembler3D = require("../../../../assembler-3d");
    var SimpleAssembler = require("../2d/simple");
    var SimpleAssembler3D = (function(_SimpleAssembler) {
      _inheritsLoose(SimpleAssembler3D, _SimpleAssembler);
      function SimpleAssembler3D() {
        return _SimpleAssembler.apply(this, arguments) || this;
      }
      return SimpleAssembler3D;
    })(SimpleAssembler);
    exports["default"] = SimpleAssembler3D;
    cc.js.mixin(SimpleAssembler3D.prototype, Assembler3D);
    module.exports = exports["default"];
  }), {
    "../../../../assembler-3d": 300,
    "../2d/simple": 357
  } ],
  364: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vec = _interopRequireDefault(require("../../../../../value-types/vec3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Assembler3D = require("../../../../assembler-3d");
    var SlicedAssembler = require("../2d/sliced");
    var vec3_temp_local = new _vec["default"]();
    var vec3_temp_world = new _vec["default"]();
    var SlicedAssembler3D = (function(_SlicedAssembler) {
      _inheritsLoose(SlicedAssembler3D, _SlicedAssembler);
      function SlicedAssembler3D() {
        return _SlicedAssembler.apply(this, arguments) || this;
      }
      return SlicedAssembler3D;
    })(SlicedAssembler);
    exports["default"] = SlicedAssembler3D;
    cc.js.mixin(SlicedAssembler3D.prototype, Assembler3D, {
      updateWorldVerts: function updateWorldVerts(sprite) {
        var matrix = sprite.node._worldMatrix;
        var local = this._local;
        var world = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        for (var row = 0; row < 4; ++row) {
          var localRowY = local[2 * row + 1];
          for (var col = 0; col < 4; ++col) {
            var localColX = local[2 * col];
            _vec["default"].set(vec3_temp_local, localColX, localRowY, 0);
            _vec["default"].transformMat4(vec3_temp_world, vec3_temp_local, matrix);
            var worldIndex = (4 * row + col) * floatsPerVert;
            world[worldIndex] = vec3_temp_world.x;
            world[worldIndex + 1] = vec3_temp_world.y;
            world[worldIndex + 2] = vec3_temp_world.z;
          }
        }
      }
    });
    module.exports = exports["default"];
  }), {
    "../../../../../value-types/vec3": 411,
    "../../../../assembler-3d": 300,
    "../2d/sliced": 358
  } ],
  365: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _vec = _interopRequireDefault(require("../../../../../value-types/vec3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Assembler3D = require("../../../../assembler-3d");
    var TiledAssembler = require("../2d/tiled");
    var vec3_temps = [];
    for (var i = 0; i < 4; i++) vec3_temps.push(new _vec["default"]());
    var TiledAssembler3D = (function(_TiledAssembler) {
      _inheritsLoose(TiledAssembler3D, _TiledAssembler);
      function TiledAssembler3D() {
        return _TiledAssembler.apply(this, arguments) || this;
      }
      return TiledAssembler3D;
    })(TiledAssembler);
    exports["default"] = TiledAssembler3D;
    cc.js.mixin(TiledAssembler3D.prototype, Assembler3D, {
      updateWorldVerts: function updateWorldVerts(sprite) {
        var local = this._local;
        var localX = local.x, localY = local.y;
        var world = this._renderData.vDatas[0];
        var row = this.row, col = this.col;
        var matrix = sprite.node._worldMatrix;
        var x, x1, y, y1;
        var vertexOffset = 0;
        for (var yindex = 0, ylength = row; yindex < ylength; ++yindex) {
          y = localY[yindex];
          y1 = localY[yindex + 1];
          for (var xindex = 0, xlength = col; xindex < xlength; ++xindex) {
            x = localX[xindex];
            x1 = localX[xindex + 1];
            _vec["default"].set(vec3_temps[0], x, y, 0);
            _vec["default"].set(vec3_temps[1], x1, y, 0);
            _vec["default"].set(vec3_temps[2], x, y1, 0);
            _vec["default"].set(vec3_temps[3], x1, y1, 0);
            for (var _i = 0; _i < 4; _i++) {
              var vec3_temp = vec3_temps[_i];
              _vec["default"].transformMat4(vec3_temp, vec3_temp, matrix);
              var offset = 6 * _i;
              world[vertexOffset + offset] = vec3_temp.x;
              world[vertexOffset + offset + 1] = vec3_temp.y;
              world[vertexOffset + offset + 2] = vec3_temp.z;
            }
            vertexOffset += 24;
          }
        }
      }
    });
    module.exports = exports["default"];
  }), {
    "../../../../../value-types/vec3": 411,
    "../../../../assembler-3d": 300,
    "../2d/tiled": 359
  } ],
  366: [ (function(require, module, exports) {
    "use strict";
    var _assembler = _interopRequireDefault(require("../../../assembler"));
    var _CCSprite = require("../../../../components/CCSprite");
    var _simple = _interopRequireDefault(require("./2d/simple"));
    var _sliced = _interopRequireDefault(require("./2d/sliced"));
    var _tiled = _interopRequireDefault(require("./2d/tiled"));
    var _radialFilled = _interopRequireDefault(require("./2d/radial-filled"));
    var _barFilled = _interopRequireDefault(require("./2d/bar-filled"));
    var _mesh = _interopRequireDefault(require("./2d/mesh"));
    var _simple2 = _interopRequireDefault(require("./3d/simple"));
    var _sliced2 = _interopRequireDefault(require("./3d/sliced"));
    var _tiled2 = _interopRequireDefault(require("./3d/tiled"));
    var _radialFilled2 = _interopRequireDefault(require("./3d/radial-filled"));
    var _barFilled2 = _interopRequireDefault(require("./3d/bar-filled"));
    var _mesh2 = _interopRequireDefault(require("./3d/mesh"));
    var _simple3 = _interopRequireDefault(require("./2d-multi/simple"));
    var _sliced3 = _interopRequireDefault(require("./2d-multi/sliced"));
    var _tiled3 = _interopRequireDefault(require("./2d-multi/tiled"));
    var _radialFilled3 = _interopRequireDefault(require("./2d-multi/radial-filled"));
    var _barFilled3 = _interopRequireDefault(require("./2d-multi/bar-filled"));
    var _mesh3 = _interopRequireDefault(require("./2d-multi/mesh"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ctor = {
      getConstructor: function getConstructor(sprite) {
        var is3DNode = sprite.node.is3DNode;
        var material = sprite.getMaterials()[0];
        var isMultiMaterial = material && material.material.isMultiSupport();
        var ctor = is3DNode ? _simple2["default"] : isMultiMaterial ? _simple3["default"] : _simple["default"];
        switch (sprite.type) {
         case _CCSprite.Type.SLICED:
          ctor = is3DNode ? _sliced2["default"] : isMultiMaterial ? _sliced3["default"] : _sliced["default"];
          break;

         case _CCSprite.Type.TILED:
          ctor = is3DNode ? _tiled2["default"] : isMultiMaterial ? _tiled3["default"] : _tiled["default"];
          break;

         case _CCSprite.Type.FILLED:
          ctor = sprite._fillType === _CCSprite.FillType.RADIAL ? is3DNode ? _radialFilled2["default"] : isMultiMaterial ? _radialFilled3["default"] : _radialFilled["default"] : is3DNode ? _barFilled2["default"] : isMultiMaterial ? _barFilled3["default"] : _barFilled["default"];
          break;

         case _CCSprite.Type.MESH:
          ctor = is3DNode ? _mesh2["default"] : isMultiMaterial ? _mesh3["default"] : _mesh["default"];
        }
        return ctor;
      },
      Simple: _simple["default"],
      Sliced: _sliced["default"],
      Tiled: _tiled["default"],
      RadialFilled: _radialFilled["default"],
      BarFilled: _barFilled["default"],
      Mesh: _mesh["default"],
      Simple3D: _simple2["default"],
      Sliced3D: _sliced2["default"],
      Tiled3D: _tiled2["default"],
      RadialFilled3D: _radialFilled2["default"],
      BarFilled3D: _barFilled2["default"],
      Mesh3D: _mesh2["default"],
      SimpleMulti: _simple3["default"],
      SlicedMulti: _sliced3["default"],
      TiledMulti: _tiled3["default"],
      RadialFilledMulti: _radialFilled3["default"],
      BarFilledMulti: _barFilled3["default"],
      MeshMulti: _mesh3["default"]
    };
    _assembler["default"].register(cc.Sprite, ctor);
  }), {
    "../../../../components/CCSprite": 198,
    "../../../assembler": 302,
    "./2d-multi/bar-filled": 348,
    "./2d-multi/mesh": 349,
    "./2d-multi/radial-filled": 350,
    "./2d-multi/simple": 351,
    "./2d-multi/sliced": 352,
    "./2d-multi/tiled": 353,
    "./2d/bar-filled": 354,
    "./2d/mesh": 355,
    "./2d/radial-filled": 356,
    "./2d/simple": 357,
    "./2d/sliced": 358,
    "./2d/tiled": 359,
    "./3d/bar-filled": 360,
    "./3d/mesh": 361,
    "./3d/radial-filled": 362,
    "./3d/simple": 363,
    "./3d/sliced": 364,
    "./3d/tiled": 365
  } ],
  367: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var FlexBuffer = (function() {
      function FlexBuffer(handler, index, verticesCount, indicesCount, vfmt) {
        this._handler = handler;
        this._index = index;
        this._vfmt = vfmt;
        this._verticesBytes = vfmt._bytes;
        this._initVerticesCount = verticesCount;
        this._initIndicesCount = indicesCount;
        this.reset();
      }
      var _proto = FlexBuffer.prototype;
      _proto._reallocVData = function _reallocVData(floatsCount, oldData) {
        this.vData = new Float32Array(floatsCount);
        this.uintVData = new Uint32Array(this.vData.buffer);
        oldData && this.vData.set(oldData);
        this._handler.updateMesh(this._index, this.vData, this.iData);
      };
      _proto._reallocIData = function _reallocIData(indicesCount, oldData) {
        this.iData = new Uint16Array(indicesCount);
        oldData && this.iData.set(oldData);
        this._handler.updateMesh(this._index, this.vData, this.iData);
      };
      _proto.reserve = function reserve(verticesCount, indicesCount) {
        var floatsCount = verticesCount * this._verticesBytes >> 2;
        var newFloatsCount = this.vData.length;
        var realloced = false;
        if (floatsCount > newFloatsCount) {
          while (newFloatsCount < floatsCount) newFloatsCount *= 2;
          this._reallocVData(newFloatsCount, this.vData);
          realloced = true;
        }
        var newIndicesCount = this.iData.length;
        if (indicesCount > newIndicesCount) {
          while (newIndicesCount < indicesCount) newIndicesCount *= 2;
          this._reallocIData(indicesCount, this.iData);
          realloced = true;
        }
        return realloced;
      };
      _proto.used = function used(verticesCount, indicesCount) {
        this.usedVertices = verticesCount;
        this.usedIndices = indicesCount;
        this.usedVerticesFloats = verticesCount * this._verticesBytes >> 2;
        this._handler.updateMeshRange(verticesCount, indicesCount);
      };
      _proto.reset = function reset() {
        var floatsCount = this._initVerticesCount * this._verticesBytes >> 2;
        this._reallocVData(floatsCount);
        this._reallocIData(this._initIndicesCount);
        this.usedVertices = 0;
        this.usedVerticesFloats = 0;
        this.usedIndices = 0;
      };
      return FlexBuffer;
    })();
    exports["default"] = FlexBuffer;
    cc.FlexBuffer = FlexBuffer;
    module.exports = exports["default"];
  }), {} ],
  368: [ (function(require, module, exports) {
    "use strict";
    var _gfx = _interopRequireDefault(require("../../../renderer/gfx"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var FIX_IOS14_BUFFER;
    if (cc.sys.platform === cc.sys.WECHAT_GAME) {
      var _GameGlobal;
      FIX_IOS14_BUFFER = (cc.sys.os === cc.sys.OS_IOS || cc.sys.os === cc.sys.OS_OSX) && (null == (_GameGlobal = GameGlobal) ? void 0 : _GameGlobal.isIOSHighPerformanceMode) && /(OS 1[4-9])|(Version\/1[4-9])/.test(window.navigator.userAgent);
    } else FIX_IOS14_BUFFER = (cc.sys.os === cc.sys.OS_IOS || cc.sys.os === cc.sys.OS_OSX) && cc.sys.isBrowser && /(OS 1[4-9])|(Version\/1[4-9])/.test(window.navigator.userAgent);
    var MeshBuffer = cc.Class({
      name: "cc.MeshBuffer",
      ctor: function ctor(batcher, vertexFormat) {
        this.init(batcher, vertexFormat);
      },
      init: function init(batcher, vertexFormat) {
        this.byteOffset = 0;
        this.indiceOffset = 0;
        this.vertexOffset = 0;
        this.indiceStart = 0;
        this._dirty = false;
        this._vertexFormat = vertexFormat;
        this._vertexBytes = this._vertexFormat._bytes;
        this._arrOffset = 0;
        this._vbArr = [];
        this._vb = new _gfx["default"].VertexBuffer(batcher._device, vertexFormat, _gfx["default"].USAGE_DYNAMIC, new ArrayBuffer(), 0);
        this._vbArr[0] = this._vb;
        this._ibArr = [];
        this._ib = new _gfx["default"].IndexBuffer(batcher._device, _gfx["default"].INDEX_FMT_UINT16, _gfx["default"].USAGE_STATIC, new ArrayBuffer(), 0);
        this._ibArr[0] = this._ib;
        this._vData = null;
        this._uintVData = null;
        this._iData = null;
        this._batcher = batcher;
        this._initVDataCount = 256 * vertexFormat._bytes;
        this._initIDataCount = 1536;
        this._offsetInfo = {
          byteOffset: 0,
          vertexOffset: 0,
          indiceOffset: 0
        };
        this._reallocBuffer();
      },
      uploadData: function uploadData() {
        if (0 === this.byteOffset || !this._dirty) return;
        var vertexsData = new Float32Array(this._vData.buffer, 0, this.byteOffset >> 2);
        var indicesData = new Uint16Array(this._iData.buffer, 0, this.indiceOffset);
        var vb = this._vb;
        vb.update(0, vertexsData);
        var ib = this._ib;
        ib.update(0, indicesData);
        this._dirty = false;
      },
      switchBuffer: function switchBuffer() {
        var offset = ++this._arrOffset;
        this.byteOffset = 0;
        this.vertexOffset = 0;
        this.indiceOffset = 0;
        this.indiceStart = 0;
        if (offset < this._vbArr.length) {
          this._vb = this._vbArr[offset];
          this._ib = this._ibArr[offset];
        } else {
          this._vb = new _gfx["default"].VertexBuffer(this._batcher._device, this._vertexFormat, _gfx["default"].USAGE_DYNAMIC, new ArrayBuffer(), 0);
          this._vbArr[offset] = this._vb;
          this._ib = new _gfx["default"].IndexBuffer(this._batcher._device, _gfx["default"].INDEX_FMT_UINT16, _gfx["default"].USAGE_STATIC, new ArrayBuffer(), 0);
          this._ibArr[offset] = this._ib;
        }
      },
      checkAndSwitchBuffer: function checkAndSwitchBuffer(vertexCount) {
        if (this.vertexOffset + vertexCount > 65535) {
          this.uploadData();
          this._batcher._flush();
          this.switchBuffer();
        }
      },
      requestStatic: function requestStatic(vertexCount, indiceCount) {
        this.checkAndSwitchBuffer(vertexCount);
        var byteOffset = this.byteOffset + vertexCount * this._vertexBytes;
        var indiceOffset = this.indiceOffset + indiceCount;
        var byteLength = this._vData.byteLength;
        var indiceLength = this._iData.length;
        if (byteOffset > byteLength || indiceOffset > indiceLength) {
          while (byteLength < byteOffset || indiceLength < indiceOffset) {
            this._initVDataCount *= 2;
            this._initIDataCount *= 2;
            byteLength = 4 * this._initVDataCount;
            indiceLength = this._initIDataCount;
          }
          this._reallocBuffer();
        }
        this._updateOffset(vertexCount, indiceCount, byteOffset);
      },
      _updateOffset: function _updateOffset(vertexCount, indiceCount, byteOffset) {
        var offsetInfo = this._offsetInfo;
        offsetInfo.vertexOffset = this.vertexOffset;
        this.vertexOffset += vertexCount;
        offsetInfo.indiceOffset = this.indiceOffset;
        this.indiceOffset += indiceCount;
        offsetInfo.byteOffset = this.byteOffset;
        this.byteOffset = byteOffset;
        this._dirty = true;
      },
      request: function request(vertexCount, indiceCount) {
        if (this._batcher._buffer !== this) {
          this._batcher._flush();
          this._batcher._buffer = this;
        }
        this.requestStatic(vertexCount, indiceCount);
        return this._offsetInfo;
      },
      requestForSpine: function requestForSpine(vertexCount, indiceCount) {
        if (this._batcher._buffer !== this) {
          this._batcher._flush();
          this._batcher._buffer = this;
        }
        this.requestStaticForSpine(vertexCount, indiceCount);
        return this._offsetInfo;
      },
      requestStaticForSpine: function requestStaticForSpine(vertexCount, indiceCount) {
        this.checkAndSwitchBuffer(vertexCount);
        var byteOffset = this.byteOffset + vertexCount * this._vertexBytes;
        var indiceOffset = this.indiceOffset + indiceCount;
        var byteLength = this._vData.byteLength;
        var indiceLength = this._iData.length;
        if (byteOffset > byteLength || indiceOffset > indiceLength) {
          while (byteLength < byteOffset || indiceLength < indiceOffset) {
            this._initVDataCount *= 2;
            this._initIDataCount *= 2;
            byteLength = 4 * this._initVDataCount;
            indiceLength = this._initIDataCount;
          }
          this._reallocBuffer();
        }
        var offsetInfo = this._offsetInfo;
        offsetInfo.vertexOffset = this.vertexOffset;
        offsetInfo.indiceOffset = this.indiceOffset;
        offsetInfo.byteOffset = this.byteOffset;
      },
      adjustForSpine: function adjustForSpine(vertexCount, indiceCount) {
        this.vertexOffset += vertexCount;
        this.indiceOffset += indiceCount;
        this.byteOffset = this.byteOffset + vertexCount * this._vertexBytes;
        this._dirty = true;
      },
      _reallocBuffer: function _reallocBuffer() {
        this._reallocVData(true);
        this._reallocIData(true);
      },
      _reallocVData: function _reallocVData(copyOldData) {
        var oldVData;
        this._vData && (oldVData = new Uint8Array(this._vData.buffer));
        this._vData = new Float32Array(this._initVDataCount);
        this._uintVData = new Uint32Array(this._vData.buffer);
        var newData = new Uint8Array(this._uintVData.buffer);
        if (oldVData && copyOldData) for (var i = 0, l = oldVData.length; i < l; i++) newData[i] = oldVData[i];
      },
      _reallocIData: function _reallocIData(copyOldData) {
        var oldIData = this._iData;
        this._iData = new Uint16Array(this._initIDataCount);
        if (oldIData && copyOldData) {
          var iData = this._iData;
          for (var i = 0, l = oldIData.length; i < l; i++) iData[i] = oldIData[i];
        }
      },
      reset: function reset() {
        this._arrOffset = 0;
        this._vb = this._vbArr[0];
        this._ib = this._ibArr[0];
        this.byteOffset = 0;
        this.indiceOffset = 0;
        this.vertexOffset = 0;
        this.indiceStart = 0;
        this._dirty = false;
      },
      destroy: function destroy() {
        this.reset();
        for (var i = 0; i < this._vbArr.length; i++) {
          var vb = this._vbArr[i];
          vb.destroy();
        }
        this._vbArr = null;
        for (var _i = 0; _i < this._ibArr.length; _i++) {
          var ib = this._ibArr[_i];
          ib.destroy();
        }
        this._ibArr = null;
        this._ib = null;
        this._vb = null;
      },
      forwardIndiceStartToOffset: function forwardIndiceStartToOffset() {
        this.indiceStart = this.indiceOffset;
      }
    });
    if (FIX_IOS14_BUFFER) {
      MeshBuffer.prototype.checkAndSwitchBuffer = function(vertexCount) {
        if (this.vertexOffset + vertexCount > 65535) {
          this.uploadData();
          this._batcher._flush();
        }
      };
      MeshBuffer.prototype.forwardIndiceStartToOffset = function() {
        this.uploadData();
        this.switchBuffer();
      };
    }
    cc.MeshBuffer = module.exports = MeshBuffer;
  }), {
    "../../../renderer/gfx": 427
  } ],
  369: [ (function(require, module, exports) {
    "use strict";
    var MeshBuffer = require("./mesh-buffer");
    var QuadBuffer = cc.Class({
      name: "cc.QuadBuffer",
      extends: MeshBuffer,
      _fillQuadBuffer: function _fillQuadBuffer() {
        var count = this._initIDataCount / 6;
        var buffer = this._iData;
        for (var i = 0, idx = 0; i < count; i++) {
          var vertextID = 4 * i;
          buffer[idx++] = vertextID;
          buffer[idx++] = vertextID + 1;
          buffer[idx++] = vertextID + 2;
          buffer[idx++] = vertextID + 1;
          buffer[idx++] = vertextID + 3;
          buffer[idx++] = vertextID + 2;
        }
        var indicesData = new Uint16Array(this._iData.buffer, 0, 6 * count);
        this._ib.update(0, indicesData);
      },
      uploadData: function uploadData() {
        if (0 === this.byteOffset || !this._dirty) return;
        var vertexsData = new Float32Array(this._vData.buffer, 0, this.byteOffset >> 2);
        this._vb.update(0, vertexsData);
        this._dirty = false;
      },
      switchBuffer: function switchBuffer() {
        this._super();
        var indicesData = new Uint16Array(this._iData.buffer, 0, this._initIDataCount);
        this._ib.update(0, indicesData);
      },
      _reallocBuffer: function _reallocBuffer() {
        this._reallocVData(true);
        this._reallocIData();
        this._fillQuadBuffer();
      }
    });
    cc.QuadBuffer = module.exports = QuadBuffer;
  }), {
    "./mesh-buffer": 368
  } ],
  370: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = RenderData;
    var _flexBuffer = _interopRequireDefault(require("./flex-buffer"));
    var _vertexFormat = require("./vertex-format");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function RenderData() {
      this.vDatas = [];
      this.uintVDatas = [];
      this.iDatas = [];
      this.meshCount = 0;
      this._infos = null;
      this._flexBuffer = null;
    }
    cc.js.mixin(RenderData.prototype, {
      init: function init(assembler) {},
      clear: function clear() {
        this.vDatas.length = 0;
        this.iDatas.length = 0;
        this.uintVDatas.length = 0;
        this.meshCount = 0;
        this._infos = null;
        this._flexBuffer && this._flexBuffer.reset();
      },
      updateMesh: function updateMesh(index, vertices, indices) {
        this.vDatas[index] = vertices;
        this.uintVDatas[index] = new Uint32Array(vertices.buffer, 0, vertices.length);
        this.iDatas[index] = indices;
        this.meshCount = this.vDatas.length;
      },
      updateMeshRange: function updateMeshRange(verticesCount, indicesCount) {},
      createData: function createData(index, verticesFloats, indicesCount) {
        var vertices = new Float32Array(verticesFloats);
        var indices = new Uint16Array(indicesCount);
        this.updateMesh(index, vertices, indices);
      },
      createQuadData: function createQuadData(index, verticesFloats, indicesCount) {
        this.createData(index, verticesFloats, indicesCount);
        this.initQuadIndices(this.iDatas[index]);
      },
      createFlexData: function createFlexData(index, verticesFloats, indicesCount, vfmt) {
        vfmt = vfmt || _vertexFormat.vfmtPosUvColor;
        this._flexBuffer = new _flexBuffer["default"](this, index, verticesFloats, indicesCount, vfmt);
      },
      initQuadIndices: function initQuadIndices(indices) {
        var count = indices.length / 6;
        for (var i = 0, idx = 0; i < count; i++) {
          var vertextID = 4 * i;
          indices[idx++] = vertextID;
          indices[idx++] = vertextID + 1;
          indices[idx++] = vertextID + 2;
          indices[idx++] = vertextID + 1;
          indices[idx++] = vertextID + 3;
          indices[idx++] = vertextID + 2;
        }
      }
    });
    cc.RenderData = RenderData;
    module.exports = exports["default"];
  }), {
    "./flex-buffer": 367,
    "./vertex-format": 371
  } ],
  371: [ (function(require, module, exports) {
    "use strict";
    var _gfx = _interopRequireDefault(require("../../../renderer/gfx"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var vfmt3D = new _gfx["default"].VertexFormat([ {
      name: _gfx["default"].ATTR_POSITION,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 3
    }, {
      name: _gfx["default"].ATTR_UV0,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx["default"].ATTR_COLOR,
      type: _gfx["default"].ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    vfmt3D.name = "vfmt3D";
    _gfx["default"].VertexFormat.XYZ_UV_Color = vfmt3D;
    var vfmtPosUvColor = new _gfx["default"].VertexFormat([ {
      name: _gfx["default"].ATTR_POSITION,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx["default"].ATTR_UV0,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx["default"].ATTR_COLOR,
      type: _gfx["default"].ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    vfmtPosUvColor.name = "vfmtPosUvColor";
    _gfx["default"].VertexFormat.XY_UV_Color = vfmtPosUvColor;
    var vfmtPosUvColorTexId = new _gfx["default"].VertexFormat([ {
      name: _gfx["default"].ATTR_POSITION,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx["default"].ATTR_UV0,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx["default"].ATTR_COLOR,
      type: _gfx["default"].ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    }, {
      name: _gfx["default"].ATTR_TEX_ID,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 1
    } ]);
    vfmtPosUvColorTexId.name = "vfmtPosUvColorTexId";
    _gfx["default"].VertexFormat.XY_UV_Color_TexId = vfmtPosUvColorTexId;
    var vfmtPosUvTwoColor = new _gfx["default"].VertexFormat([ {
      name: _gfx["default"].ATTR_POSITION,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx["default"].ATTR_UV0,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx["default"].ATTR_COLOR,
      type: _gfx["default"].ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    }, {
      name: _gfx["default"].ATTR_COLOR0,
      type: _gfx["default"].ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    vfmtPosUvTwoColor.name = "vfmtPosUvTwoColor";
    _gfx["default"].VertexFormat.XY_UV_Two_Color = vfmtPosUvTwoColor;
    var vfmtPosUvTwoColorTexId = new _gfx["default"].VertexFormat([ {
      name: _gfx["default"].ATTR_POSITION,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx["default"].ATTR_UV0,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx["default"].ATTR_COLOR,
      type: _gfx["default"].ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    }, {
      name: _gfx["default"].ATTR_COLOR0,
      type: _gfx["default"].ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    }, {
      name: _gfx["default"].ATTR_TEX_ID,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 1
    } ]);
    vfmtPosUvTwoColorTexId.name = "vfmtPosUvTwoColorTexId";
    _gfx["default"].VertexFormat.XY_UV_Two_Color_TexId = vfmtPosUvTwoColorTexId;
    var vfmtPosUv = new _gfx["default"].VertexFormat([ {
      name: _gfx["default"].ATTR_POSITION,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx["default"].ATTR_UV0,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    } ]);
    vfmtPosUv.name = "vfmtPosUv";
    _gfx["default"].VertexFormat.XY_UV = vfmtPosUv;
    var vfmtPosColor = new _gfx["default"].VertexFormat([ {
      name: _gfx["default"].ATTR_POSITION,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: _gfx["default"].ATTR_COLOR,
      type: _gfx["default"].ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    vfmtPosColor.name = "vfmtPosColor";
    _gfx["default"].VertexFormat.XY_Color = vfmtPosColor;
    var vfmtPos = new _gfx["default"].VertexFormat([ {
      name: _gfx["default"].ATTR_POSITION,
      type: _gfx["default"].ATTR_TYPE_FLOAT32,
      num: 2
    } ]);
    vfmtPos.name = "vfmtPos";
    _gfx["default"].VertexFormat.XY = vfmtPos;
    module.exports = {
      vfmt3D: vfmt3D,
      vfmtPosUvColor: vfmtPosUvColor,
      vfmtPosUvTwoColor: vfmtPosUvTwoColor,
      vfmtPosUv: vfmtPosUv,
      vfmtPosColor: vfmtPosColor,
      vfmtPos: vfmtPos,
      vfmtPosUvColorTexId: vfmtPosUvColorTexId,
      vfmtPosUvTwoColorTexId: vfmtPosUvTwoColorTexId
    };
  }), {
    "../../../renderer/gfx": 427
  } ],
  372: [ (function(require, module, exports) {
    "use strict";
    require("./sp");
    require("./multi-handler");
    require("./multi-batcher");
  }), {
    "./multi-batcher": 373,
    "./multi-handler": 374,
    "./sp": 375
  } ],
  373: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.MultiBatcher = void 0;
    var _multiHandler = require("./multi-handler");
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = "undefined" !== typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" === typeof o.length) {
        it && (o = it);
        var i = 0;
        return function() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if ("string" === typeof o) return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      "Object" === n && o.constructor && (n = o.constructor.name);
      if ("Map" === n || "Set" === n) return Array.from(o);
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      (null == len || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    var MultiBatcher = (function() {
      function MultiBatcher() {
        this.handlers = [];
        this.nextHandler = void 0;
      }
      var _proto = MultiBatcher.prototype;
      _proto.init = function init() {
        var handler = new _multiHandler.MultiHandler();
        this.handlers.push(handler);
        this.nextHandler = handler;
      };
      _proto.requsetMaterial = function requsetMaterial(texture) {
        if (!texture._multiMaterial) {
          var handler = this.nextHandler;
          var index = handler.getEmptyIndex();
          if (-1 === index) {
            for (var _iterator = _createForOfIteratorHelperLoose(this.handlers), _step; !(_step = _iterator()).done; ) {
              var _handler = _step.value;
              index = _handler.getEmptyIndex();
              if (-1 !== index) {
                handler = _handler;
                this.nextHandler = handler;
                break;
              }
            }
            if (-1 === index) {
              handler = new _multiHandler.MultiHandler();
              this.handlers.push(handler);
              this.nextHandler = handler;
              index = 0;
            }
          }
          texture.linkMaterial(handler.material, index);
        }
        return texture._multiMaterial;
      };
      _proto.reset = function reset() {
        this.handlers.length = 0;
      };
      return MultiBatcher;
    })();
    exports.MultiBatcher = MultiBatcher;
    cc.sp.multiBatcher = new MultiBatcher();
    cc.sp.MultiBatcher = MultiBatcher;
  }), {
    "./multi-handler": 374
  } ],
  374: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.MultiHandler = void 0;
    var MultiHandler = (function() {
      function MultiHandler(material) {
        this.material = void 0;
        this.textures = [];
        this.hasEmptySlot = false;
        if (material) this.material = material; else {
          this.material = cc.Material.create(cc.sp.multi2dSpriteEffectAsset);
          this.material.name = "multi-2d-universal";
          this.material.define("USE_TEXTURE", true);
          this.material.define("USE_MULTI_TEXTURE", true);
        }
        this.material._multiHandler = this;
        this.syncTextures();
      }
      var _proto = MultiHandler.prototype;
      _proto.syncTextures = function syncTextures() {
        var effect = this.material["effect"];
        var properties = effect.passes[0]._properties;
        this.textures[0] = properties.texture.value;
        this.textures[1] = properties.texture2.value;
        this.textures[2] = properties.texture3.value;
        this.textures[3] = properties.texture4.value;
        this.textures[4] = properties.texture5.value;
        this.textures[5] = properties.texture6.value;
        this.textures[6] = properties.texture7.value;
        this.textures[7] = properties.texture8.value;
        this.hasEmptySlot = true;
        this.getEmptyIndex();
      };
      _proto.setTexture = function setTexture(index, texture) {
        this.textures[index] = texture ? texture.getImpl() : null;
        this.material.setProperty(cc.sp.propertyIndex2Name(index), texture);
        null == texture && (this.hasEmptySlot = true);
      };
      _proto.removeTexture = function removeTexture(texture) {
        var index = this.getIndex(texture);
        -1 !== index && this.setTexture(index, null);
      };
      _proto.hasTexture = function hasTexture(texture) {
        return -1 !== this.textures.indexOf(texture);
      };
      _proto.getIndex = function getIndex(texture) {
        return this.textures.indexOf(texture);
      };
      _proto.getTexture = function getTexture(index) {
        return this.textures[index];
      };
      _proto.getEmptyIndex = function getEmptyIndex() {
        if (!this.hasEmptySlot) return -1;
        var index = this.textures.indexOf(null);
        if (-1 !== index) return index;
        this.hasEmptySlot = false;
        return -1;
      };
      _proto.autoSetTexture = function autoSetTexture(texture) {
        var index = this.getEmptyIndex();
        if (-1 === index) return -1;
        this.setTexture(index, texture);
        return index;
      };
      return MultiHandler;
    })();
    exports.MultiHandler = MultiHandler;
    cc.sp.MultiHandler = MultiHandler;
  }), {} ],
  375: [ (function(require, module, exports) {
    "use strict";
    cc.sp = {
      inited: false,
      version: "1.1.0",
      MAX_MULTITEXTURE_NUM: -1,
      autoSwitchMaterial: true,
      allowDynamicAtlas: true,
      enableLabelRetina: true,
      labelRetinaScale: 1,
      charAtlasAutoBatchCount: 1,
      charAtlasAutoResetBeforeSceneLoad: true,
      multi2dSpriteEffectAsset: null,
      i2nMap: [ "texture" ],
      n2iMap: {
        texture: 0
      },
      propertyIndex2Name: function propertyIndex2Name(index) {
        return this.i2nMap[index];
      },
      propertyName2Index: function propertyName2Index(name) {
        return this.n2iMap[name];
      }
    };
    for (var i = 1; i < 8; i++) {
      var name = "texture" + (i + 1);
      cc.sp.i2nMap[i] = name;
      cc.sp.n2iMap[name] = i;
    }
  }), {} ],
  376: [ (function(require, module, exports) {
    "use strict";
    require("../platform/CCSys");
    var EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/;
    var DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/;
    var NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
    cc.path = {
      join: function join() {
        var l = arguments.length;
        var result = "";
        for (var i = 0; i < l; i++) result = (result + ("" === result ? "" : "/") + arguments[i]).replace(/(\/|\\\\)$/, "");
        return result;
      },
      extname: function extname(pathStr) {
        var temp = EXTNAME_RE.exec(pathStr);
        return temp ? temp[1] : "";
      },
      mainFileName: function mainFileName(fileName) {
        if (fileName) {
          var idx = fileName.lastIndexOf(".");
          if (-1 !== idx) return fileName.substring(0, idx);
        }
        return fileName;
      },
      basename: function basename(pathStr, extname) {
        var index = pathStr.indexOf("?");
        index > 0 && (pathStr = pathStr.substring(0, index));
        var reg = /(\/|\\)([^\/\\]+)$/g;
        var result = reg.exec(pathStr.replace(/(\/|\\)$/, ""));
        if (!result) return pathStr;
        var baseName = result[2];
        if (extname && pathStr.substring(pathStr.length - extname.length).toLowerCase() === extname.toLowerCase()) return baseName.substring(0, baseName.length - extname.length);
        return baseName;
      },
      dirname: function dirname(pathStr) {
        var temp = DIRNAME_RE.exec(pathStr);
        return temp ? temp[2] : "";
      },
      changeExtname: function changeExtname(pathStr, extname) {
        extname = extname || "";
        var index = pathStr.indexOf("?");
        var tempStr = "";
        if (index > 0) {
          tempStr = pathStr.substring(index);
          pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf(".");
        if (index < 0) return pathStr + extname + tempStr;
        return pathStr.substring(0, index) + extname + tempStr;
      },
      changeBasename: function changeBasename(pathStr, basename, isSameExt) {
        if (0 === basename.indexOf(".")) return this.changeExtname(pathStr, basename);
        var index = pathStr.indexOf("?");
        var tempStr = "";
        var ext = isSameExt ? this.extname(pathStr) : "";
        if (index > 0) {
          tempStr = pathStr.substring(index);
          pathStr = pathStr.substring(0, index);
        }
        index = pathStr.lastIndexOf("/");
        index = index <= 0 ? 0 : index + 1;
        return pathStr.substring(0, index) + basename + ext + tempStr;
      },
      _normalize: function _normalize(url) {
        var oldUrl = url = String(url);
        do {
          oldUrl = url;
          url = url.replace(NORMALIZE_RE, "");
        } while (oldUrl.length !== url.length);
        return url;
      },
      sep: cc.sys.os === cc.sys.OS_WINDOWS ? "\\" : "/",
      stripSep: function stripSep(path) {
        return path.replace(/[\/\\]$/, "");
      }
    };
    module.exports = cc.path;
  }), {
    "../platform/CCSys": 281
  } ],
  377: [ (function(require, module, exports) {
    "use strict";
    var AffineTransform = function AffineTransform(a, b, c, d, tx, ty) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
    };
    AffineTransform.create = function(a, b, c, d, tx, ty) {
      return {
        a: a,
        b: b,
        c: c,
        d: d,
        tx: tx,
        ty: ty
      };
    };
    AffineTransform.identity = function() {
      return {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        tx: 0,
        ty: 0
      };
    };
    AffineTransform.clone = function(t) {
      return {
        a: t.a,
        b: t.b,
        c: t.c,
        d: t.d,
        tx: t.tx,
        ty: t.ty
      };
    };
    AffineTransform.concat = function(out, t1, t2) {
      var a = t1.a, b = t1.b, c = t1.c, d = t1.d, tx = t1.tx, ty = t1.ty;
      out.a = a * t2.a + b * t2.c;
      out.b = a * t2.b + b * t2.d;
      out.c = c * t2.a + d * t2.c;
      out.d = c * t2.b + d * t2.d;
      out.tx = tx * t2.a + ty * t2.c + t2.tx;
      out.ty = tx * t2.b + ty * t2.d + t2.ty;
      return out;
    };
    AffineTransform.invert = function(out, t) {
      var a = t.a, b = t.b, c = t.c, d = t.d;
      var determinant = 1 / (a * d - b * c);
      var tx = t.tx, ty = t.ty;
      out.a = determinant * d;
      out.b = -determinant * b;
      out.c = -determinant * c;
      out.d = determinant * a;
      out.tx = determinant * (c * ty - d * tx);
      out.ty = determinant * (b * tx - a * ty);
      return out;
    };
    AffineTransform.fromMat4 = function(out, mat) {
      var matm = mat.m;
      out.a = matm[0];
      out.b = matm[1];
      out.c = matm[4];
      out.d = matm[5];
      out.tx = matm[12];
      out.ty = matm[13];
      return out;
    };
    AffineTransform.transformVec2 = function(out, point, transOrY, t) {
      var x, y;
      if (void 0 === t) {
        t = transOrY;
        x = point.x;
        y = point.y;
      } else {
        x = point;
        y = transOrY;
      }
      out.x = t.a * x + t.c * y + t.tx;
      out.y = t.b * x + t.d * y + t.ty;
      return out;
    };
    AffineTransform.transformSize = function(out, size, t) {
      out.width = t.a * size.width + t.c * size.height;
      out.height = t.b * size.width + t.d * size.height;
      return out;
    };
    AffineTransform.transformRect = function(out, rect, t) {
      var ol = rect.x;
      var ob = rect.y;
      var or = ol + rect.width;
      var ot = ob + rect.height;
      var lbx = t.a * ol + t.c * ob + t.tx;
      var lby = t.b * ol + t.d * ob + t.ty;
      var rbx = t.a * or + t.c * ob + t.tx;
      var rby = t.b * or + t.d * ob + t.ty;
      var ltx = t.a * ol + t.c * ot + t.tx;
      var lty = t.b * ol + t.d * ot + t.ty;
      var rtx = t.a * or + t.c * ot + t.tx;
      var rty = t.b * or + t.d * ot + t.ty;
      var minX = Math.min(lbx, rbx, ltx, rtx);
      var maxX = Math.max(lbx, rbx, ltx, rtx);
      var minY = Math.min(lby, rby, lty, rty);
      var maxY = Math.max(lby, rby, lty, rty);
      out.x = minX;
      out.y = minY;
      out.width = maxX - minX;
      out.height = maxY - minY;
      return out;
    };
    AffineTransform.transformObb = function(out_bl, out_tl, out_tr, out_br, rect, anAffineTransform) {
      var x = rect.x;
      var y = rect.y;
      var width = rect.width;
      var height = rect.height;
      var tx = anAffineTransform.a * x + anAffineTransform.c * y + anAffineTransform.tx;
      var ty = anAffineTransform.b * x + anAffineTransform.d * y + anAffineTransform.ty;
      var xa = anAffineTransform.a * width;
      var xb = anAffineTransform.b * width;
      var yc = anAffineTransform.c * height;
      var yd = anAffineTransform.d * height;
      out_tl.x = tx;
      out_tl.y = ty;
      out_tr.x = xa + tx;
      out_tr.y = xb + ty;
      out_bl.x = yc + tx;
      out_bl.y = yd + ty;
      out_br.x = xa + yc + tx;
      out_br.y = xb + yd + ty;
    };
    cc.AffineTransform = module.exports = AffineTransform;
  }), {} ],
  378: [ (function(require, module, exports) {
    "use strict";
    var Flags = require("../platform/CCObject").Flags;
    var misc = require("./misc");
    var js = require("../platform/js");
    var IdGenerater = require("../platform/id-generater");
    var eventManager = require("../event-manager");
    var RenderFlow = require("../renderer/render-flow");
    var Destroying = Flags.Destroying;
    var DontDestroy = Flags.DontDestroy;
    var Deactivating = Flags.Deactivating;
    var CHILD_ADDED = "child-added";
    var CHILD_REMOVED = "child-removed";
    var idGenerater = new IdGenerater("Node");
    function getConstructor(typeOrClassName) {
      if (!typeOrClassName) {
        cc.errorID(3804);
        return null;
      }
      if ("string" === typeof typeOrClassName) return js.getClassByName(typeOrClassName);
      return typeOrClassName;
    }
    function findComponent(node, constructor) {
      if (constructor._sealed) for (var i = 0; i < node._components.length; ++i) {
        var comp = node._components[i];
        if (comp.constructor === constructor) return comp;
      } else for (var _i = 0; _i < node._components.length; ++_i) {
        var _comp = node._components[_i];
        if (_comp instanceof constructor) return _comp;
      }
      return null;
    }
    function findComponents(node, constructor, components) {
      if (constructor._sealed) for (var i = 0; i < node._components.length; ++i) {
        var comp = node._components[i];
        comp.constructor === constructor && components.push(comp);
      } else for (var _i2 = 0; _i2 < node._components.length; ++_i2) {
        var _comp2 = node._components[_i2];
        _comp2 instanceof constructor && components.push(_comp2);
      }
    }
    function findChildComponent(children, constructor) {
      for (var i = 0; i < children.length; ++i) {
        var node = children[i];
        var comp = findComponent(node, constructor);
        if (comp) return comp;
        if (node._children.length > 0) {
          comp = findChildComponent(node._children, constructor);
          if (comp) return comp;
        }
      }
      return null;
    }
    function findChildComponents(children, constructor, components) {
      for (var i = 0; i < children.length; ++i) {
        var node = children[i];
        findComponents(node, constructor, components);
        node._children.length > 0 && findChildComponents(node._children, constructor, components);
      }
    }
    var BaseNode = cc.Class({
      name: "cc._BaseNode",
      extends: cc.Object,
      properties: {
        _parent: null,
        _children: [],
        _active: true,
        _components: [],
        _prefab: null,
        _persistNode: {
          get: function get() {
            return (this._objFlags & DontDestroy) > 0;
          },
          set: function set(value) {
            value ? this._objFlags |= DontDestroy : this._objFlags &= ~DontDestroy;
          }
        },
        name: {
          get: function get() {
            return this._name;
          },
          set: function set(value) {
            if (true, -1 !== value.indexOf("/")) {
              cc.errorID(1632);
              return;
            }
            this._name = value;
            true, true;
            this._proxy.setName(this._name);
          }
        },
        uuid: {
          get: function get() {
            return this._id;
          }
        },
        children: {
          get: function get() {
            return this._children;
          }
        },
        childrenCount: {
          get: function get() {
            return this._children.length;
          }
        },
        active: {
          get: function get() {
            return this._active;
          },
          set: function set(value) {
            value = !!value;
            if (this._active !== value) {
              this._active = value;
              var parent = this._parent;
              if (parent) {
                var couldActiveInScene = parent._activeInHierarchy;
                couldActiveInScene && cc.director._nodeActivator.activateNode(this, value);
              }
            }
          }
        },
        activeInHierarchy: {
          get: function get() {
            return this._activeInHierarchy;
          }
        }
      },
      ctor: function ctor(name) {
        this._name = void 0 !== name ? name : "New Node";
        this._activeInHierarchy = false;
        this._id = idGenerater.getNewId();
        cc.director._scheduler && cc.director._scheduler.enableForTarget(this);
        this.__eventTargets = [];
      },
      getParent: function getParent() {
        return this._parent;
      },
      setParent: function setParent(value) {
        if (this._parent === value) return;
        false;
        var oldParent = this._parent;
        (true, oldParent) && oldParent._objFlags & Deactivating && cc.errorID(3821);
        this._parent = value || null;
        this._onSetParent(value);
        if (value) {
          (true, value._objFlags & Deactivating) && cc.errorID(3821);
          eventManager._setDirtyForNode(this);
          value._children.push(this);
          value.emit && value.emit(CHILD_ADDED, this);
          value._renderFlag |= RenderFlow.FLAG_CHILDREN;
        }
        if (oldParent) {
          if (!(oldParent._objFlags & Destroying)) {
            var removeAt = oldParent._children.indexOf(this);
            if (true, removeAt < 0) return cc.errorID(1633);
            oldParent._children.splice(removeAt, 1);
            oldParent.emit && oldParent.emit(CHILD_REMOVED, this);
            this._onHierarchyChanged(oldParent);
            0 === oldParent._children.length && (oldParent._renderFlag &= ~RenderFlow.FLAG_CHILDREN);
          }
        } else value && this._onHierarchyChanged(null);
      },
      attr: function attr(attrs) {
        js.mixin(this, attrs);
      },
      getChildByUuid: function getChildByUuid(uuid) {
        if (!uuid) {
          cc.log("Invalid uuid");
          return null;
        }
        var locChildren = this._children;
        for (var i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._id === uuid) return locChildren[i];
        return null;
      },
      getChildByName: function getChildByName(name) {
        if (!name) {
          cc.log("Invalid name");
          return null;
        }
        var locChildren = this._children;
        for (var i = 0, len = locChildren.length; i < len; i++) if (locChildren[i]._name === name) return locChildren[i];
        return null;
      },
      addChild: function addChild(child) {
        if (true, !(child instanceof cc._BaseNode)) return cc.errorID(1634, cc.js.getClassName(child));
        cc.assertID(child, 1606);
        cc.assertID(null === child._parent, 1605);
        child.setParent(this);
      },
      insertChild: function insertChild(child, siblingIndex) {
        child.parent = this;
        child.setSiblingIndex(siblingIndex);
      },
      getSiblingIndex: function getSiblingIndex() {
        return this._parent ? this._parent._children.indexOf(this) : 0;
      },
      setSiblingIndex: function setSiblingIndex(index) {
        if (!this._parent) return;
        if (this._parent._objFlags & Deactivating) {
          cc.errorID(3821);
          return;
        }
        var siblings = this._parent._children;
        index = -1 !== index ? index : siblings.length - 1;
        var oldIndex = siblings.indexOf(this);
        if (index !== oldIndex) {
          siblings.splice(oldIndex, 1);
          index < siblings.length ? siblings.splice(index, 0, this) : siblings.push(this);
          this._onSiblingIndexChanged && this._onSiblingIndexChanged(index);
        }
      },
      walk: function walk(prefunc, postfunc) {
        var BaseNode = cc._BaseNode;
        var index = 1;
        var children, child, curr, i, afterChildren;
        var stack = BaseNode._stacks[BaseNode._stackId];
        if (!stack) {
          stack = [];
          BaseNode._stacks.push(stack);
        }
        BaseNode._stackId++;
        stack.length = 0;
        stack[0] = this;
        var parent = null;
        afterChildren = false;
        while (index) {
          index--;
          curr = stack[index];
          if (!curr) continue;
          !afterChildren && prefunc ? prefunc(curr) : afterChildren && postfunc && postfunc(curr);
          stack[index] = null;
          if (!afterChildren) {
            if (curr._children.length > 0) {
              parent = curr;
              children = curr._children;
              i = 0;
              stack[index] = children[i];
              index++;
            } else {
              stack[index] = curr;
              index++;
              afterChildren = true;
            }
            continue;
          }
          if (parent === this._parent) break;
          afterChildren = false;
          if (children) {
            i++;
            if (children[i]) {
              stack[index] = children[i];
              index++;
            } else if (parent) {
              stack[index] = parent;
              index++;
              afterChildren = true;
              if (parent._parent) {
                children = parent._parent._children;
                i = children.indexOf(parent);
                parent = parent._parent;
              } else {
                parent = null;
                children = null;
              }
              if (i < 0) break;
            }
          }
        }
        stack.length = 0;
        BaseNode._stackId--;
      },
      cleanup: function cleanup() {},
      removeFromParent: function removeFromParent(cleanup) {
        if (this._parent) {
          void 0 === cleanup && (cleanup = true);
          this._parent.removeChild(this, cleanup);
        }
      },
      removeChild: function removeChild(child, cleanup) {
        if (this._children.indexOf(child) > -1) {
          (cleanup || void 0 === cleanup) && child.cleanup();
          child.parent = null;
        }
      },
      removeAllChildren: function removeAllChildren(cleanup) {
        var children = this._children;
        void 0 === cleanup && (cleanup = true);
        for (var i = children.length - 1; i >= 0; i--) {
          var node = children[i];
          if (node) {
            cleanup && node.cleanup();
            node.parent = null;
          }
        }
        this._children.length = 0;
      },
      isChildOf: function isChildOf(parent) {
        var child = this;
        do {
          if (child === parent) return true;
          child = child._parent;
        } while (child);
        return false;
      },
      getComponent: function getComponent(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName);
        if (constructor) return findComponent(this, constructor);
        return null;
      },
      getComponents: function getComponents(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName), components = [];
        constructor && findComponents(this, constructor, components);
        return components;
      },
      getComponentInChildren: function getComponentInChildren(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName);
        if (constructor) return findChildComponent(this._children, constructor);
        return null;
      },
      getComponentsInChildren: function getComponentsInChildren(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName), components = [];
        if (constructor) {
          findComponents(this, constructor, components);
          findChildComponents(this._children, constructor, components);
        }
        return components;
      },
      _checkMultipleComp: (false, true) && function(ctor) {
        var existing = this.getComponent(ctor._disallowMultiple);
        if (existing) {
          existing.constructor === ctor ? cc.errorID(3805, js.getClassName(ctor), this._name) : cc.errorID(3806, js.getClassName(ctor), this._name, js.getClassName(existing));
          return false;
        }
        return true;
      },
      addComponent: function addComponent(typeOrClassName) {
        false;
        var constructor;
        if ("string" === typeof typeOrClassName) {
          constructor = js.getClassByName(typeOrClassName);
          if (!constructor) {
            cc.errorID(3807, typeOrClassName);
            cc._RFpeek() && cc.errorID(3808, typeOrClassName);
            return null;
          }
        } else {
          if (!typeOrClassName) {
            cc.errorID(3804);
            return null;
          }
          constructor = typeOrClassName;
        }
        if ("function" !== typeof constructor) {
          cc.errorID(3809);
          return null;
        }
        if (!js.isChildClassOf(constructor, cc.Component)) {
          cc.errorID(3810);
          return null;
        }
        if ((false, true) && constructor._disallowMultiple && !this._checkMultipleComp(constructor)) return null;
        var ReqComp = constructor._requireComponent;
        if (ReqComp && !this.getComponent(ReqComp)) {
          var depended = this.addComponent(ReqComp);
          if (!depended) return null;
        }
        var component = new constructor();
        component.node = this;
        this._components.push(component);
        (false, false) && cc.engine && this._id in cc.engine.attachedObjsForEditor && (cc.engine.attachedObjsForEditor[component._id] = component);
        this._activeInHierarchy && cc.director._nodeActivator.activateComp(component);
        return component;
      },
      _addComponentAt: false,
      removeComponent: function removeComponent(component) {
        if (!component) {
          cc.errorID(3813);
          return;
        }
        component instanceof cc.Component || (component = this.getComponent(component));
        component && component.destroy();
      },
      _getDependComponent: false,
      _removeComponent: function _removeComponent(component) {
        if (!component) {
          cc.errorID(3814);
          return;
        }
        if (!(this._objFlags & Destroying)) {
          var i = this._components.indexOf(component);
          if (-1 !== i) {
            this._components.splice(i, 1);
            (false, false) && cc.engine && delete cc.engine.attachedObjsForEditor[component._id];
          } else component.node !== this && cc.errorID(3815);
        }
      },
      destroy: function destroy() {
        cc.Object.prototype.destroy.call(this) && (this.active = false);
      },
      destroyAllChildren: function destroyAllChildren() {
        var children = this._children;
        for (var i = 0; i < children.length; ++i) children[i].destroy();
      },
      _onSetParent: function _onSetParent(value) {},
      _onPostActivated: function _onPostActivated() {},
      _onBatchCreated: function _onBatchCreated(dontSyncChildPrefab) {},
      _onHierarchyChanged: function _onHierarchyChanged(oldParent) {
        var newParent = this._parent;
        if (this._persistNode && !(newParent instanceof cc.Scene)) {
          cc.game.removePersistRootNode(this);
          false;
        }
        var scene;
        var inCurrentSceneBefore;
        var inCurrentSceneNow;
        var newPrefabRoot;
        var myPrefabInfo;
        var PrefabUtils;
        false, false;
        var shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);
        this._activeInHierarchy !== shouldActiveNow && cc.director._nodeActivator.activateNode(this, shouldActiveNow);
      },
      _instantiate: function _instantiate(cloned, isSyncedNode) {
        cloned || (cloned = cc.instantiate._clone(this, this));
        var newPrefabInfo = cloned._prefab;
        var PrefabUtils;
        false;
        var syncing;
        false;
        cloned._parent = null;
        cloned._onBatchCreated(isSyncedNode);
        return cloned;
      },
      _registerIfAttached: (false, false) && function(register) {
        var attachedObjsForEditor = cc.engine.attachedObjsForEditor;
        if (register) {
          attachedObjsForEditor[this._id] = this;
          for (var i = 0; i < this._components.length; i++) {
            var comp = this._components[i];
            attachedObjsForEditor[comp._id] = comp;
          }
          cc.engine.emit("node-attach-to-scene", this);
        } else {
          cc.engine.emit("node-detach-from-scene", this);
          delete attachedObjsForEditor[this._id];
          for (var _i3 = 0; _i3 < this._components.length; _i3++) {
            var _comp3 = this._components[_i3];
            delete attachedObjsForEditor[_comp3._id];
          }
        }
        var children = this._children;
        for (var _i4 = 0, len = children.length; _i4 < len; ++_i4) {
          var child = children[_i4];
          child._registerIfAttached(register);
        }
      },
      _onPreDestroy: function _onPreDestroy() {
        var i, len;
        this._objFlags |= Destroying;
        var parent = this._parent;
        var destroyByParent = parent && parent._objFlags & Destroying;
        !destroyByParent && (false, false) && this._registerIfAttached(false);
        var children = this._children;
        for (i = 0, len = children.length; i < len; ++i) children[i]._destroyImmediate();
        for (i = 0, len = this._components.length; i < len; ++i) {
          var component = this._components[i];
          component._destroyImmediate();
        }
        var eventTargets = this.__eventTargets;
        for (i = 0, len = eventTargets.length; i < len; ++i) {
          var target = eventTargets[i];
          target && target.targetOff(this);
        }
        eventTargets.length = 0;
        this._persistNode && cc.game.removePersistRootNode(this);
        if (!destroyByParent && parent) {
          var childIndex = parent._children.indexOf(this);
          parent._children.splice(childIndex, 1);
          parent.emit && parent.emit("child-removed", this);
        }
        return destroyByParent;
      },
      onRestore: false
    });
    BaseNode.idGenerater = idGenerater;
    BaseNode._stacks = [ [] ];
    BaseNode._stackId = 0;
    BaseNode.prototype._onPreDestroyBase = BaseNode.prototype._onPreDestroy;
    false;
    BaseNode.prototype._onHierarchyChangedBase = BaseNode.prototype._onHierarchyChanged;
    false;
    var SameNameGetSets = [ "parent", "name", "children", "childrenCount" ];
    misc.propertyDefine(BaseNode, SameNameGetSets, {});
    true;
    js.get(BaseNode.prototype, " INFO ", (function() {
      var path = "";
      var node = this;
      while (node && !(node instanceof cc.Scene)) {
        path = path ? node.name + "/" + path : node.name;
        node = node._parent;
      }
      return this.name + ", path: " + path;
    }));
    cc._BaseNode = module.exports = BaseNode;
  }), {
    "../event-manager": 217,
    "../platform/CCObject": 278,
    "../platform/id-generater": 290,
    "../platform/js": 294,
    "../renderer/render-flow": 323,
    "./misc": 386
  } ],
  379: [ (function(require, module, exports) {
    "use strict";
    var EPSILON = 1e-6;
    function binarySearchEpsilon(array, value) {
      for (var l = 0, h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
        var test = array[m];
        if (test > value + EPSILON) h = m - 1; else {
          if (!(test < value - EPSILON)) return m;
          l = m + 1;
        }
      }
      return ~l;
    }
    module.exports = {
      binarySearchEpsilon: binarySearchEpsilon
    };
  }), {} ],
  380: [ (function(require, module, exports) {
    "use strict";
    var RenderComponent = require("../components/CCRenderComponent");
    var BlendFactor = require("../platform/CCMacro").BlendFactor;
    var gfx = require("../../renderer/gfx");
    var BlendFunc = cc.Class({
      properties: {
        _srcBlendFactor: BlendFactor.SRC_ALPHA,
        _dstBlendFactor: BlendFactor.ONE_MINUS_SRC_ALPHA,
        srcBlendFactor: {
          get: function get() {
            return this._srcBlendFactor;
          },
          set: function set(value) {
            if (this._srcBlendFactor === value) return;
            this._srcBlendFactor = value;
            this._updateBlendFunc(true);
            this._onBlendChanged && this._onBlendChanged();
          },
          animatable: false,
          type: BlendFactor,
          tooltip: (true, "i18n:COMPONENT.sprite.src_blend_factor"),
          visible: true
        },
        dstBlendFactor: {
          get: function get() {
            return this._dstBlendFactor;
          },
          set: function set(value) {
            if (this._dstBlendFactor === value) return;
            this._dstBlendFactor = value;
            this._updateBlendFunc(true);
          },
          animatable: false,
          type: BlendFactor,
          tooltip: (true, "i18n:COMPONENT.sprite.dst_blend_factor"),
          visible: true
        }
      },
      setMaterial: function setMaterial(index, material) {
        var materialVar = RenderComponent.prototype.setMaterial.call(this, index, material);
        this._srcBlendFactor === BlendFactor.SRC_ALPHA && this._dstBlendFactor === BlendFactor.ONE_MINUS_SRC_ALPHA || this._updateMaterialBlendFunc(materialVar);
        return materialVar;
      },
      _updateMaterial: function _updateMaterial() {
        this._updateBlendFunc();
      },
      _updateBlendFunc: function _updateBlendFunc(force) {
        if (!force && this._srcBlendFactor === BlendFactor.SRC_ALPHA && this._dstBlendFactor === BlendFactor.ONE_MINUS_SRC_ALPHA) return;
        var materials = this.getMaterials();
        for (var i = 0; i < materials.length; i++) {
          var material = materials[i];
          this._updateMaterialBlendFunc(material);
        }
      },
      _updateMaterialBlendFunc: function _updateMaterialBlendFunc(material) {
        material.setBlend(true, gfx.BLEND_FUNC_ADD, this._srcBlendFactor, this._dstBlendFactor, gfx.BLEND_FUNC_ADD, this._srcBlendFactor, this._dstBlendFactor);
        true;
        RenderComponent.prototype.markForRender.call(this, true);
      }
    });
    module.exports = cc.BlendFunc = BlendFunc;
  }), {
    "../../renderer/gfx": 427,
    "../components/CCRenderComponent": 192,
    "../platform/CCMacro": 277
  } ],
  381: [ (function(require, module, exports) {
    "use strict";
    var Base64Values = require("./misc").BASE64_VALUES;
    var HexChars = "0123456789abcdef".split("");
    var _t = [ "", "", "", "" ];
    var UuidTemplate = _t.concat(_t, "-", _t, "-", _t, "-", _t, "-", _t, _t, _t);
    var Indices = UuidTemplate.map((function(x, i) {
      return "-" === x ? NaN : i;
    })).filter(isFinite);
    module.exports = function(base64) {
      if (22 !== base64.length) return base64;
      UuidTemplate[0] = base64[0];
      UuidTemplate[1] = base64[1];
      for (var i = 2, j = 2; i < 22; i += 2) {
        var lhs = Base64Values[base64.charCodeAt(i)];
        var rhs = Base64Values[base64.charCodeAt(i + 1)];
        UuidTemplate[Indices[j++]] = HexChars[lhs >> 2];
        UuidTemplate[Indices[j++]] = HexChars[(3 & lhs) << 2 | rhs >> 4];
        UuidTemplate[Indices[j++]] = HexChars[15 & rhs];
      }
      return UuidTemplate.join("");
    };
    false;
  }), {
    "./misc": 386
  } ],
  382: [ (function(require, module, exports) {
    "use strict";
    cc.find = module.exports = function(path, referenceNode) {
      if (null == path) {
        cc.errorID(3814);
        return null;
      }
      if (referenceNode) {
        if (true, !referenceNode.isValid) {
          cc.warnID(5603);
          return null;
        }
      } else {
        var scene = cc.director.getScene();
        if (!scene) {
          true;
          cc.warnID(5601);
          return null;
        }
        if (true, !scene.isValid) {
          cc.warnID(5602);
          return null;
        }
        referenceNode = scene;
      }
      var match = referenceNode;
      var startIndex = "/" !== path[0] ? 0 : 1;
      var nameList = path.split("/");
      for (var n = startIndex; n < nameList.length; n++) {
        var name = nameList[n];
        var children = match._children;
        match = null;
        for (var t = 0, len = children.length; t < len; ++t) {
          var subChild = children[t];
          if (subChild.name === name) {
            match = subChild;
            break;
          }
        }
        if (!match) return null;
      }
      return match;
    };
  }), {} ],
  383: [ (function(require, module, exports) {
    "use strict";
    var _materialVariant = _interopRequireDefault(require("../assets/material/material-variant"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Material = require("../assets/material/CCMaterial");
    var GraySpriteState = cc.Class({
      properties: {
        _normalMaterial: null,
        normalMaterial: {
          get: function get() {
            return this._normalMaterial;
          },
          set: function set(val) {
            this._normalMaterial = val;
            this._updateDisabledState && this._updateDisabledState();
          },
          type: Material,
          tooltip: (true, "i18n:COMPONENT.button.normal_material"),
          animatable: false
        },
        _grayMaterial: null,
        grayMaterial: {
          get: function get() {
            return this._grayMaterial;
          },
          set: function set(val) {
            this._grayMaterial = val;
            this._updateDisabledState && this._updateDisabledState();
          },
          type: Material,
          tooltip: (true, "i18n:COMPONENT.button.gray_material"),
          animatable: false
        }
      },
      _switchGrayMaterial: function _switchGrayMaterial(useGrayMaterial, renderComp) {
        var material;
        if (useGrayMaterial) {
          material = this._grayMaterial;
          material || (material = Material.getBuiltinMaterial("2d-gray-sprite"));
          material = this._grayMaterial = _materialVariant["default"].create(material, renderComp);
        } else {
          material = this._normalMaterial;
          material || (material = Material.getBuiltinMaterial("2d-sprite", renderComp));
          material = this._normalMaterial = _materialVariant["default"].create(material, renderComp);
        }
        renderComp.setMaterial(0, material);
      }
    });
    module.exports = GraySpriteState;
  }), {
    "../assets/material/CCMaterial": 156,
    "../assets/material/material-variant": 163
  } ],
  384: [ (function(require, module, exports) {
    "use strict";
    var eventRegx = /^(click)(\s)*=|(param)(\s)*=/;
    var imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*align(\s)*=|(\s)*offset(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
    var HtmlTextParser = function HtmlTextParser() {
      this._parsedObject = {};
      this._specialSymbolArray = [];
      this._specialSymbolArray.push([ /&lt;/g, "<" ]);
      this._specialSymbolArray.push([ /&gt;/g, ">" ]);
      this._specialSymbolArray.push([ /&amp;/g, "&" ]);
      this._specialSymbolArray.push([ /&quot;/g, '"' ]);
      this._specialSymbolArray.push([ /&apos;/g, "'" ]);
      this._specialSymbolArray.push([ /&nbsp;/g, " " ]);
    };
    HtmlTextParser.prototype = {
      constructor: HtmlTextParser,
      parse: function parse(htmlString) {
        this._resultObjectArray = [];
        if (!htmlString) return this._resultObjectArray;
        this._stack = [];
        var startIndex = 0;
        var length = htmlString.length;
        while (startIndex < length) {
          var tagEndIndex = htmlString.indexOf(">", startIndex);
          var tagBeginIndex = -1;
          if (tagEndIndex >= 0) {
            tagBeginIndex = htmlString.lastIndexOf("<", tagEndIndex);
            var noTagBegin = tagBeginIndex < startIndex - 1;
            if (noTagBegin) {
              tagBeginIndex = htmlString.indexOf("<", tagEndIndex + 1);
              tagEndIndex = htmlString.indexOf(">", tagBeginIndex + 1);
            }
          }
          if (tagBeginIndex < 0) {
            this._stack.pop();
            this._processResult(htmlString.substring(startIndex));
            startIndex = length;
          } else {
            var newStr = htmlString.substring(startIndex, tagBeginIndex);
            var tagStr = htmlString.substring(tagBeginIndex + 1, tagEndIndex);
            "" === tagStr && (newStr = htmlString.substring(startIndex, tagEndIndex + 1));
            this._processResult(newStr);
            -1 === tagEndIndex ? tagEndIndex = tagBeginIndex : "/" === htmlString.charAt(tagBeginIndex + 1) ? this._stack.pop() : this._addToStack(tagStr);
            startIndex = tagEndIndex + 1;
          }
        }
        return this._resultObjectArray;
      },
      _attributeToObject: function _attributeToObject(attribute) {
        attribute = attribute.trim();
        var obj = {};
        var header = attribute.match(/^(color|size)(\s)*=/);
        var tagName;
        var nextSpace;
        var eventObj;
        var eventHanlderString;
        if (header) {
          tagName = header[0];
          attribute = attribute.substring(tagName.length).trim();
          if ("" === attribute) return obj;
          nextSpace = attribute.indexOf(" ");
          switch (tagName[0]) {
           case "c":
            obj.color = nextSpace > -1 ? attribute.substring(0, nextSpace).trim() : attribute;
            break;

           case "s":
            obj.size = parseInt(attribute);
          }
          if (nextSpace > -1) {
            eventHanlderString = attribute.substring(nextSpace + 1).trim();
            eventObj = this._processEventHandler(eventHanlderString);
            obj.event = eventObj;
          }
          return obj;
        }
        header = attribute.match(/^(br(\s)*\/)/);
        if (header && header[0].length > 0) {
          tagName = header[0].trim();
          if (tagName.startsWith("br") && "/" === tagName[tagName.length - 1]) {
            obj.isNewLine = true;
            this._resultObjectArray.push({
              text: "",
              style: {
                newline: true
              }
            });
            return obj;
          }
        }
        header = attribute.match(/^(img(\s)*src(\s)*=[^>]+\/)/);
        if (header && header[0].length > 0) {
          tagName = header[0].trim();
          if (tagName.startsWith("img") && "/" === tagName[tagName.length - 1]) {
            header = attribute.match(imageAttrReg);
            var tagValue;
            var remainingArgument;
            var isValidImageTag = false;
            while (header) {
              attribute = attribute.substring(attribute.indexOf(header[0]));
              tagName = attribute.substr(0, header[0].length);
              remainingArgument = attribute.substring(tagName.length).trim();
              nextSpace = remainingArgument.indexOf(" ");
              tagValue = nextSpace > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument;
              tagName = tagName.replace(/[^a-zA-Z]/g, "").trim();
              tagName = tagName.toLocaleLowerCase();
              attribute = remainingArgument.substring(nextSpace).trim();
              tagValue.endsWith("/") && (tagValue = tagValue.slice(0, -1));
              if ("src" === tagName) {
                switch (tagValue.charCodeAt(0)) {
                 case 34:
                 case 39:
                  isValidImageTag = true;
                  tagValue = tagValue.slice(1, -1);
                }
                obj.isImage = true;
                obj.src = tagValue;
              } else if ("height" === tagName) obj.imageHeight = parseInt(tagValue); else if ("width" === tagName) obj.imageWidth = parseInt(tagValue); else if ("align" === tagName) {
                switch (tagValue.charCodeAt(0)) {
                 case 34:
                 case 39:
                  tagValue = tagValue.slice(1, -1);
                }
                obj.imageAlign = tagValue.toLocaleLowerCase();
              } else "offset" === tagName ? obj.imageOffset = tagValue : "click" === tagName && (obj.event = this._processEventHandler(tagName + "=" + tagValue));
              obj.event && "param" === tagName && (obj.event.param = tagValue.replace(/^\"|\"$/g, ""));
              header = attribute.match(imageAttrReg);
            }
            isValidImageTag && obj.isImage && this._resultObjectArray.push({
              text: "",
              style: obj
            });
            return {};
          }
        }
        header = attribute.match(/^(outline(\s)*[^>]*)/);
        if (header) {
          attribute = header[0].substring("outline".length).trim();
          var defaultOutlineObject = {
            color: "#ffffff",
            width: 1
          };
          if (attribute) {
            var outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
            header = attribute.match(outlineAttrReg);
            var tagValue;
            while (header) {
              attribute = attribute.substring(attribute.indexOf(header[0]));
              tagName = attribute.substr(0, header[0].length);
              remainingArgument = attribute.substring(tagName.length).trim();
              nextSpace = remainingArgument.indexOf(" ");
              tagValue = nextSpace > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument;
              tagName = tagName.replace(/[^a-zA-Z]/g, "").trim();
              tagName = tagName.toLocaleLowerCase();
              attribute = remainingArgument.substring(nextSpace).trim();
              "click" === tagName ? obj.event = this._processEventHandler(tagName + "=" + tagValue) : "color" === tagName ? defaultOutlineObject.color = tagValue : "width" === tagName && (defaultOutlineObject.width = parseInt(tagValue));
              obj.event && "param" === tagName && (obj.event.param = tagValue.replace(/^\"|\"$/g, ""));
              header = attribute.match(outlineAttrReg);
            }
          }
          obj.outline = defaultOutlineObject;
        }
        header = attribute.match(/^(on|u|b|i)(\s)*/);
        if (header && header[0].length > 0) {
          tagName = header[0];
          attribute = attribute.substring(tagName.length).trim();
          switch (tagName[0]) {
           case "u":
            obj.underline = true;
            break;

           case "i":
            obj.italic = true;
            break;

           case "b":
            obj.bold = true;
          }
          if ("" === attribute) return obj;
          eventObj = this._processEventHandler(attribute);
          obj.event = eventObj;
        }
        return obj;
      },
      _processEventHandler: function _processEventHandler(eventString) {
        var index = 0;
        var obj = {};
        var eventNames = eventString.match(eventRegx);
        var isValidTag = false;
        while (eventNames) {
          var eventName = eventNames[0];
          var eventValue = "";
          isValidTag = false;
          eventString = eventString.substring(eventName.length).trim();
          if ('"' === eventString.charAt(0)) {
            index = eventString.indexOf('"', 1);
            if (index > -1) {
              eventValue = eventString.substring(1, index).trim();
              isValidTag = true;
            }
            index++;
          } else if ("'" === eventString.charAt(0)) {
            index = eventString.indexOf("'", 1);
            if (index > -1) {
              eventValue = eventString.substring(1, index).trim();
              isValidTag = true;
            }
            index++;
          } else {
            var match = eventString.match(/(\S)+/);
            eventValue = match ? match[0] : "";
            index = eventValue.length;
          }
          if (isValidTag) {
            eventName = eventName.substring(0, eventName.length - 1).trim();
            obj[eventName] = eventValue;
          }
          eventString = eventString.substring(index).trim();
          eventNames = eventString.match(eventRegx);
        }
        return obj;
      },
      _addToStack: function _addToStack(attribute) {
        var obj = this._attributeToObject(attribute);
        if (0 === this._stack.length) this._stack.push(obj); else {
          if (obj.isNewLine || obj.isImage) return;
          var previousTagObj = this._stack[this._stack.length - 1];
          for (var key in previousTagObj) obj[key] || (obj[key] = previousTagObj[key]);
          this._stack.push(obj);
        }
      },
      _processResult: function _processResult(value) {
        if ("" === value) return;
        value = this._escapeSpecialSymbol(value);
        this._stack.length > 0 ? this._resultObjectArray.push({
          text: value,
          style: this._stack[this._stack.length - 1]
        }) : this._resultObjectArray.push({
          text: value
        });
      },
      _escapeSpecialSymbol: function _escapeSpecialSymbol(str) {
        for (var i = 0; i < this._specialSymbolArray.length; ++i) {
          var key = this._specialSymbolArray[i][0];
          var value = this._specialSymbolArray[i][1];
          str = str.replace(key, value);
        }
        return str;
      }
    };
    false;
    module.exports = HtmlTextParser;
  }), {} ],
  385: [ (function(require, module, exports) {
    "use strict";
    require("./CCPath");
    true;
    require("./profiler/CCProfiler");
    require("./find");
    require("./mutable-forward-iterator");
  }), {
    "./CCPath": 376,
    "./find": 382,
    "./mutable-forward-iterator": 387,
    "./profiler/CCProfiler": 390
  } ],
  386: [ (function(require, module, exports) {
    "use strict";
    var js = require("../platform/js");
    var misc = {};
    misc.propertyDefine = function(ctor, sameNameGetSets, diffNameGetSets) {
      function define(np, propName, getter, setter) {
        var pd = Object.getOwnPropertyDescriptor(np, propName);
        if (pd) {
          pd.get && (np[getter] = pd.get);
          pd.set && setter && (np[setter] = pd.set);
        } else {
          var getterFunc = np[getter];
          if (true, getterFunc) js.getset(np, propName, getterFunc, np[setter]); else {
            var clsName = cc.Class._isCCClass(ctor) && js.getClassName(ctor) || ctor.name || "(anonymous class)";
            cc.warnID(5700, propName, getter, clsName);
          }
        }
      }
      var propName, np = ctor.prototype;
      for (var i = 0; i < sameNameGetSets.length; i++) {
        propName = sameNameGetSets[i];
        var suffix = propName[0].toUpperCase() + propName.slice(1);
        define(np, propName, "get" + suffix, "set" + suffix);
      }
      for (propName in diffNameGetSets) {
        var getset = diffNameGetSets[propName];
        define(np, propName, getset[0], getset[1]);
      }
    };
    misc.NextPOT = function(x) {
      x -= 1;
      x |= x >> 1;
      x |= x >> 2;
      x |= x >> 4;
      x |= x >> 8;
      x |= x >> 16;
      return x + 1;
    };
    false;
    misc.BUILTIN_CLASSID_RE = /^(?:cc|dragonBones|sp|ccsg)\..+/;
    var BASE64_KEYS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var BASE64_VALUES = new Array(123);
    for (var i = 0; i < 123; ++i) BASE64_VALUES[i] = 64;
    for (var _i = 0; _i < 64; ++_i) BASE64_VALUES[BASE64_KEYS.charCodeAt(_i)] = _i;
    misc.BASE64_VALUES = BASE64_VALUES;
    misc.pushToMap = function(map, key, value, pushFront) {
      var exists = map[key];
      if (exists) if (Array.isArray(exists)) if (pushFront) {
        exists.push(exists[0]);
        exists[0] = value;
      } else exists.push(value); else map[key] = pushFront ? [ value, exists ] : [ exists, value ]; else map[key] = value;
    };
    misc.clampf = function(value, min_inclusive, max_inclusive) {
      if (min_inclusive > max_inclusive) {
        var temp = min_inclusive;
        min_inclusive = max_inclusive;
        max_inclusive = temp;
      }
      return value < min_inclusive ? min_inclusive : value < max_inclusive ? value : max_inclusive;
    };
    misc.clamp01 = function(value) {
      return value < 0 ? 0 : value < 1 ? value : 1;
    };
    misc.lerp = function(a, b, r) {
      return a + (b - a) * r;
    };
    misc.degreesToRadians = function(angle) {
      return angle * cc.macro.RAD;
    };
    misc.radiansToDegrees = function(angle) {
      return angle * cc.macro.DEG;
    };
    cc.misc = module.exports = misc;
  }), {
    "../platform/js": 294
  } ],
  387: [ (function(require, module, exports) {
    "use strict";
    function MutableForwardIterator(array) {
      this.i = 0;
      this.array = array;
    }
    var proto = MutableForwardIterator.prototype;
    proto.remove = function(value) {
      var index = this.array.indexOf(value);
      index >= 0 && this.removeAt(index);
    };
    proto.removeAt = function(i) {
      this.array.splice(i, 1);
      i <= this.i && --this.i;
    };
    proto.fastRemove = function(value) {
      var index = this.array.indexOf(value);
      index >= 0 && this.fastRemoveAt(index);
    };
    proto.fastRemoveAt = function(i) {
      var array = this.array;
      array[i] = array[array.length - 1];
      --array.length;
      i <= this.i && --this.i;
    };
    proto.push = function(item) {
      this.array.push(item);
    };
    module.exports = MutableForwardIterator;
  }), {} ],
  388: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var Pool = (function() {
      function Pool() {
        this.enabled = false;
        this.count = 0;
        this.maxSize = 1024;
      }
      var _proto = Pool.prototype;
      _proto.get = function get() {};
      _proto.put = function put() {};
      _proto.clear = function clear() {};
      return Pool;
    })();
    exports["default"] = Pool;
    cc.pool = {};
    Pool.register = function(name, pool) {
      cc.pool[name] = pool;
    };
    module.exports = exports["default"];
  }), {} ],
  389: [ (function(require, module, exports) {
    "use strict";
    cc._PrefabInfo = cc.Class({
      name: "cc.PrefabInfo",
      properties: {
        root: null,
        asset: null,
        fileId: "",
        sync: false
      }
    });
    module.exports = {
      syncWithPrefab: function syncWithPrefab(node) {
        var _prefab = node._prefab;
        if (!_prefab.asset) {
          var NodeUtils;
          var PrefabUtils;
          false;
          cc.errorID(3701, node.name);
          node._prefab = null;
          return;
        }
        var _objFlags = node._objFlags;
        var _parent = node._parent;
        var _id = node._id;
        var _name = node._name;
        var _active = node._active;
        var eulerAnglesX = node._eulerAngles.x;
        var eulerAnglesY = node._eulerAngles.y;
        var eulerAnglesZ = node._eulerAngles.z;
        var _localZOrder = node._localZOrder;
        var trs = node._trs;
        var x = trs[0];
        var y = trs[1];
        var z = trs[2];
        cc.game._isCloning = true;
        var prefabRoot;
        true;
        _prefab.asset._doInstantiate(node);
        cc.game._isCloning = false;
        node._objFlags = _objFlags;
        node._parent = _parent;
        node._id = _id;
        node._prefab = _prefab;
        node._name = _name;
        node._active = _active;
        node._localZOrder = _localZOrder;
        trs = node._trs;
        trs[0] = x;
        trs[1] = y;
        trs[2] = z;
        node._eulerAngles.x = eulerAnglesX;
        node._eulerAngles.y = eulerAnglesY;
        node._eulerAngles.z = eulerAnglesZ;
      }
    };
  }), {} ],
  390: [ (function(require, module, exports) {
    "use strict";
    var macro = require("../../platform/CCMacro");
    var PerfCounter = require("./perf-counter");
    var _showFPS = false;
    var _fontSize = 15;
    var _stats = null;
    var _rootNode = null;
    var _label = null;
    function generateStats() {
      if (_stats) return;
      _stats = {
        fps: {
          desc: "Framerate (FPS)",
          below: 30,
          average: 500
        },
        draws: {
          desc: "Draw Call"
        },
        frame: {
          desc: "Frame time (ms)",
          min: 0,
          max: 50,
          average: 500
        },
        logic: {
          desc: "Game Logic (ms)",
          min: 0,
          max: 50,
          average: 500,
          color: "#080"
        },
        render: {
          desc: "Renderer (ms)",
          min: 0,
          max: 50,
          average: 500,
          color: "#f90"
        },
        mode: {
          desc: cc.game.renderType === cc.game.RENDER_TYPE_WEBGL ? "WebGL" : "Canvas",
          min: 1
        }
      };
      var now = performance.now();
      for (var id in _stats) _stats[id]._counter = new PerfCounter(id, _stats[id], now);
    }
    function generateNode() {
      if (_rootNode && _rootNode.isValid) return;
      _rootNode = new cc.Node("PROFILER-NODE");
      _rootNode.x = _rootNode.y = 10;
      _rootNode.groupIndex = cc.Node.BuiltinGroupIndex.DEBUG;
      cc.Camera._setupDebugCamera();
      _rootNode.zIndex = macro.MAX_ZINDEX;
      cc.game.addPersistRootNode(_rootNode);
      var left = new cc.Node("LEFT-PANEL");
      left.anchorX = left.anchorY = 0;
      var leftLabel = left.addComponent(cc.Label);
      leftLabel.fontSize = _fontSize;
      leftLabel.lineHeight = _fontSize;
      left.parent = _rootNode;
      var right = new cc.Node("RIGHT-PANEL");
      right.anchorX = 1;
      right.anchorY = 0;
      right.x = 200;
      var rightLabel = right.addComponent(cc.Label);
      rightLabel.horizontalAlign = cc.Label.HorizontalAlign.RIGHT;
      rightLabel.fontSize = _fontSize;
      rightLabel.lineHeight = _fontSize;
      right.parent = _rootNode;
      if (cc.sys.platform !== cc.sys.BAIDU_GAME_SUB && cc.sys.platform !== cc.sys.WECHAT_GAME_SUB) {
        leftLabel.cacheMode = cc.Label.CacheMode.CHAR;
        rightLabel.cacheMode = cc.Label.CacheMode.CHAR;
      }
      _label = {
        left: leftLabel,
        right: rightLabel
      };
    }
    function beforeUpdate() {
      generateNode();
      var now = cc.director._lastUpdate;
      _stats["frame"]._counter.start(now);
      _stats["logic"]._counter.start(now);
    }
    function afterUpdate() {
      var now = performance.now();
      cc.director.isPaused() ? _stats["frame"]._counter.start(now) : _stats["logic"]._counter.end(now);
      _stats["render"]._counter.start(now);
    }
    function updateLabel(stat) {
      var length = 20;
      var desc = stat.desc;
      var value = stat._counter.human() + "";
      stat.label.string = stat.desc + "  " + stat._counter.human();
    }
    function afterDraw() {
      var now = performance.now();
      _stats["render"]._counter.end(now);
      _stats["draws"]._counter.value = cc.renderer.drawCalls;
      _stats["frame"]._counter.end(now);
      _stats["fps"]._counter.frame(now);
      var left = "";
      var right = "";
      for (var id in _stats) {
        var stat = _stats[id];
        stat._counter.sample(now);
        left += stat.desc + "\n";
        right += stat._counter.human() + "\n";
      }
      if (_label) {
        _label.left.string = left;
        _label.right.string = right;
      }
    }
    cc.profiler = module.exports = {
      isShowingStats: function isShowingStats() {
        return _showFPS;
      },
      hideStats: function hideStats() {
        if (_showFPS) {
          _rootNode && (_rootNode.active = false);
          cc.director.off(cc.Director.EVENT_BEFORE_UPDATE, beforeUpdate);
          cc.director.off(cc.Director.EVENT_AFTER_UPDATE, afterUpdate);
          cc.director.off(cc.Director.EVENT_AFTER_DRAW, afterDraw);
          _showFPS = false;
        }
      },
      showStats: function showStats() {
        if (!_showFPS) {
          generateStats();
          _rootNode && (_rootNode.active = true);
          cc.director.on(cc.Director.EVENT_BEFORE_UPDATE, beforeUpdate);
          cc.director.on(cc.Director.EVENT_AFTER_UPDATE, afterUpdate);
          cc.director.on(cc.Director.EVENT_AFTER_DRAW, afterDraw);
          _showFPS = true;
        }
      }
    };
  }), {
    "../../platform/CCMacro": 277,
    "./perf-counter": 392
  } ],
  391: [ (function(require, module, exports) {
    "use strict";
    var Counter = cc.Class({
      name: "cc.Counter",
      ctor: function ctor(id, opts, now) {
        this._id = id;
        this._opts = opts || {};
        this._value = 0;
        this._total = 0;
        this._averageValue = 0;
        this._accumValue = 0;
        this._accumSamples = 0;
        this._accumStart = now;
      },
      properties: {
        value: {
          get: function get() {
            return this._value;
          },
          set: function set(v) {
            this._value = v;
          }
        }
      },
      _average: function _average(v, now) {
        if (this._opts.average) {
          this._accumValue += v;
          ++this._accumSamples;
          var t = now;
          if (t - this._accumStart >= this._opts.average) {
            this._averageValue = this._accumValue / this._accumSamples;
            this._accumValue = 0;
            this._accumStart = t;
            this._accumSamples = 0;
          }
        }
      },
      sample: function sample(now) {
        this._average(this._value, now);
      },
      human: function human() {
        var v = this._opts.average ? this._averageValue : this._value;
        return Math.round(100 * v) / 100;
      },
      alarm: function alarm() {
        return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
      }
    });
    module.exports = Counter;
  }), {} ],
  392: [ (function(require, module, exports) {
    "use strict";
    var Counter = require("./counter");
    var PerfCounter = cc.Class({
      name: "cc.PerfCounter",
      extends: Counter,
      ctor: function ctor(id, opts, now) {
        this._time = now;
      },
      start: function start(now) {
        this._time = now;
      },
      end: function end(now) {
        this._value = now - this._time;
        this._average(this._value);
      },
      tick: function tick() {
        this.end();
        this.start();
      },
      frame: function frame(now) {
        var t = now;
        var e = t - this._time;
        this._total++;
        var avg = this._opts.average || 1e3;
        if (e > avg) {
          this._value = 1e3 * this._total / e;
          this._total = 0;
          this._time = t;
          this._average(this._value);
        }
      }
    });
    module.exports = PerfCounter;
  }), {
    "./counter": 391
  } ],
  393: [ (function(require, module, exports) {
    "use strict";
    var _js = _interopRequireDefault(require("../platform/js"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var _BASELINE_RATIO = .26;
    var _BASELINE_OFFSET = 0;
    false;
    var MAX_CACHE_SIZE = 100;
    var pool = new _js["default"].Pool(2);
    pool.get = function() {
      var node = this._get() || {
        key: null,
        value: null,
        prev: null,
        next: null
      };
      return node;
    };
    function LRUCache(size) {
      this.count = 0;
      this.limit = size;
      this.datas = {};
      this.head = null;
      this.tail = null;
    }
    LRUCache.prototype.moveToHead = function(node) {
      node.next = this.head;
      node.prev = null;
      null !== this.head && (this.head.prev = node);
      this.head = node;
      null === this.tail && (this.tail = node);
      this.count++;
      this.datas[node.key] = node;
    };
    LRUCache.prototype.put = function(key, value) {
      var node = pool.get();
      node.key = key;
      node.value = value;
      if (this.count >= this.limit) {
        var discard = this.tail;
        delete this.datas[discard.key];
        this.count--;
        this.tail = discard.prev;
        this.tail.next = null;
        discard.prev = null;
        discard.next = null;
        pool.put(discard);
      }
      this.moveToHead(node);
    };
    LRUCache.prototype.remove = function(node) {
      null !== node.prev ? node.prev.next = node.next : this.head = node.next;
      null !== node.next ? node.next.prev = node.prev : this.tail = node.prev;
      delete this.datas[node.key];
      this.count--;
    };
    LRUCache.prototype.get = function(key) {
      var node = this.datas[key];
      if (node) {
        this.remove(node);
        this.moveToHead(node);
        return node.value;
      }
      return null;
    };
    LRUCache.prototype.clear = function() {
      this.count = 0;
      this.datas = {};
      this.head = null;
      this.tail = null;
    };
    LRUCache.prototype.has = function(key) {
      return !!this.datas[key];
    };
    LRUCache.prototype["delete"] = function(key) {
      var node = this.datas[key];
      this.remove(node);
    };
    var measureCache = new LRUCache(MAX_CACHE_SIZE);
    var textUtils = {
      BASELINE_RATIO: _BASELINE_RATIO,
      MIDDLE_RATIO: (_BASELINE_RATIO + 1) / 2 - _BASELINE_RATIO,
      BASELINE_OFFSET: _BASELINE_OFFSET,
      label_wordRex: /([a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430-\u044f\u0410-\u042f\u0401\u0451]+|\S)/,
      label_symbolRex: /^[!,.:;'}\]%\?>\u3001\u2018\u201c\u300b\uff1f\u3002\uff0c\uff01]/,
      label_lastWordRex: /([a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430\xed\xec\xcd\xcc\xef\xc1\xc0\xe1\xe0\xc9\xc8\xd2\xd3\xf2\xf3\u0150\u0151\xd9\xda\u0170\xfa\u0171\xf1\xd1\xe6\xc6\u0153\u0152\xc3\xc2\xe3\xd4\xf5\u011b\u0161\u010d\u0159\u017e\xfd\xe1\xed\xe9\xf3\xfa\u016f\u0165\u010f\u0148\u011a\u0160\u010c\u0158\u017d\xc1\xcd\xc9\xd3\xda\u0164\u017c\u017a\u015b\xf3\u0144\u0142\u0119\u0107\u0105\u017b\u0179\u015a\xd3\u0143\u0141\u0118\u0106\u0104-\u044f\u0410-\u042f\u0401\u0451]+|\S)$/,
      label_lastEnglish: /[a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430\xed\xec\xcd\xcc\xef\xc1\xc0\xe1\xe0\xc9\xc8\xd2\xd3\xf2\xf3\u0150\u0151\xd9\xda\u0170\xfa\u0171\xf1\xd1\xe6\xc6\u0153\u0152\xc3\xc2\xe3\xd4\xf5\u011b\u0161\u010d\u0159\u017e\xfd\xe1\xed\xe9\xf3\xfa\u016f\u0165\u010f\u0148\u011a\u0160\u010c\u0158\u017d\xc1\xcd\xc9\xd3\xda\u0164\u017c\u017a\u015b\xf3\u0144\u0142\u0119\u0107\u0105\u017b\u0179\u015a\xd3\u0143\u0141\u0118\u0106\u0104-\u044f\u0410-\u042f\u0401\u0451]+$/,
      label_firstEnglish: /^[a-zA-Z0-9\xc4\xd6\xdc\xe4\xf6\xfc\xdf\xe9\xe8\xe7\xe0\xf9\xea\xe2\xee\xf4\xfb\u0430\xed\xec\xcd\xcc\xef\xc1\xc0\xe1\xe0\xc9\xc8\xd2\xd3\xf2\xf3\u0150\u0151\xd9\xda\u0170\xfa\u0171\xf1\xd1\xe6\xc6\u0153\u0152\xc3\xc2\xe3\xd4\xf5\u011b\u0161\u010d\u0159\u017e\xfd\xe1\xed\xe9\xf3\xfa\u016f\u0165\u010f\u0148\u011a\u0160\u010c\u0158\u017d\xc1\xcd\xc9\xd3\xda\u0164\u017c\u017a\u015b\xf3\u0144\u0142\u0119\u0107\u0105\u017b\u0179\u015a\xd3\u0143\u0141\u0118\u0106\u0104-\u044f\u0410-\u042f\u0401\u0451]/,
      highSurrogateRex: /[\uD800-\uDBFF]/,
      lowSurrogateRex: /[\uDC00-\uDFFF]/,
      label_wrapinspection: true,
      __CHINESE_REG: /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/,
      __JAPANESE_REG: /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g,
      __KOREAN_REG: /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/,
      isUnicodeCJK: function isUnicodeCJK(ch) {
        return this.__CHINESE_REG.test(ch) || this.__JAPANESE_REG.test(ch) || this.__KOREAN_REG.test(ch);
      },
      isUnicodeSpace: function isUnicodeSpace(ch) {
        ch = ch.charCodeAt(0);
        return ch >= 9 && ch <= 13 || 32 === ch || 133 === ch || 160 === ch || 5760 === ch || ch >= 8192 && ch <= 8202 || 8232 === ch || 8233 === ch || 8239 === ch || 8287 === ch || 12288 === ch;
      },
      safeMeasureText: function safeMeasureText(ctx, string, desc) {
        var font = desc || ctx.font;
        var key = font + "\ud83c\udfae" + string;
        var cache = measureCache.get(key);
        if (null !== cache) return cache;
        var metric = ctx.measureText(string);
        var width = metric && metric.width || 0;
        measureCache.put(key, width);
        return width;
      },
      _safeSubstring: function _safeSubstring(targetString, startIndex, endIndex) {
        var newStartIndex = startIndex, newEndIndex = endIndex;
        var startChar = targetString[startIndex];
        this.lowSurrogateRex.test(startChar) && newStartIndex--;
        if (void 0 !== endIndex) if (endIndex - 1 !== startIndex) {
          var endChar = targetString[endIndex - 1];
          this.highSurrogateRex.test(endChar) && newEndIndex--;
        } else this.highSurrogateRex.test(startChar) && newEndIndex++;
        return targetString.substring(newStartIndex, newEndIndex);
      },
      fragmentText: function fragmentText(stringToken, allWidth, maxWidth, measureText) {
        var wrappedWords = [];
        if (0 === stringToken.length || maxWidth < 0) {
          wrappedWords.push("");
          return wrappedWords;
        }
        var text = stringToken;
        while (allWidth > maxWidth && text.length > 1) {
          var fuzzyLen = text.length * (maxWidth / allWidth) | 0;
          var tmpText = this._safeSubstring(text, fuzzyLen);
          var width = allWidth - measureText(tmpText);
          var sLine = tmpText;
          var pushNum = 0;
          var checkWhile = 0;
          var checkCount = 10;
          while (width > maxWidth && checkWhile++ < checkCount) {
            fuzzyLen *= maxWidth / width;
            fuzzyLen |= 0;
            tmpText = this._safeSubstring(text, fuzzyLen);
            width = allWidth - measureText(tmpText);
          }
          checkWhile = 0;
          while (width <= maxWidth && checkWhile++ < checkCount) {
            if (tmpText) {
              var exec = this.label_wordRex.exec(tmpText);
              pushNum = exec ? exec[0].length : 1;
              sLine = tmpText;
            }
            fuzzyLen += pushNum;
            tmpText = this._safeSubstring(text, fuzzyLen);
            width = allWidth - measureText(tmpText);
          }
          fuzzyLen -= pushNum;
          if (0 === fuzzyLen) {
            fuzzyLen = 1;
            sLine = this._safeSubstring(text, 1);
          } else if (1 === fuzzyLen && this.highSurrogateRex.test(text[0])) {
            fuzzyLen = 2;
            sLine = this._safeSubstring(text, 2);
          }
          var sText = this._safeSubstring(text, 0, fuzzyLen), result;
          if (this.label_wrapinspection && this.label_symbolRex.test(sLine || tmpText)) {
            result = this.label_lastWordRex.exec(sText);
            fuzzyLen -= result ? result[0].length : 0;
            0 === fuzzyLen && (fuzzyLen = 1);
            sLine = this._safeSubstring(text, fuzzyLen);
            sText = this._safeSubstring(text, 0, fuzzyLen);
          }
          if (this.label_firstEnglish.test(sLine)) {
            result = this.label_lastEnglish.exec(sText);
            if (result && sText !== result[0]) {
              fuzzyLen -= result[0].length;
              sLine = this._safeSubstring(text, fuzzyLen);
              sText = this._safeSubstring(text, 0, fuzzyLen);
            }
          }
          if (0 === wrappedWords.length) wrappedWords.push(sText); else {
            sText = sText.trimLeft();
            sText.length > 0 && wrappedWords.push(sText);
          }
          text = sLine || tmpText;
          allWidth = measureText(text);
        }
        if (0 === wrappedWords.length) wrappedWords.push(text); else {
          text = text.trimLeft();
          text.length > 0 && wrappedWords.push(text);
        }
        return wrappedWords;
      }
    };
    cc.textUtils = module.exports = textUtils;
  }), {
    "../platform/js": 294
  } ],
  394: [ (function(require, module, exports) {
    "use strict";
    var Texture2D = require("../assets/CCTexture2D");
    var textureUtil = {
      loadImage: function loadImage(url, cb, target) {
        cc.assertID(url, 3103);
        var tex = cc.assetManager.assets.get(url);
        if (tex) {
          if (tex.loaded) {
            cb && cb.call(target, null, tex);
            return tex;
          }
          tex.once("load", (function() {
            cb && cb.call(target, null, tex);
          }), target);
          return tex;
        }
        cc.assetManager.loadRemote(url, (function(err, texture) {
          cb && cb.call(target, err, texture);
        }));
      },
      cacheImage: function cacheImage(url, image) {
        if (url && image) {
          var tex = new Texture2D();
          tex.initWithElement(image);
          cc.assetManager.assets.add(url, tex);
          return tex;
        }
      },
      postLoadTexture: function postLoadTexture(texture, callback) {
        if (texture.loaded) {
          callback && callback();
          return;
        }
        if (!texture.nativeUrl) {
          callback && callback();
          return;
        }
        cc.assetManager.postLoadNative(texture, callback);
      }
    };
    module.exports = textureUtil;
  }), {
    "../assets/CCTexture2D": 152
  } ],
  395: [ (function(require, module, exports) {
    "use strict";
    var NodeUnit = require("./node-unit");
    var NodeMemPool = require("./node-mem-pool");
    module.exports = {
      NodeMemPool: new NodeMemPool(NodeUnit)
    };
  }), {
    "./node-mem-pool": 397,
    "./node-unit": 398
  } ],
  396: [ (function(require, module, exports) {
    "use strict";
    var MemPool = function MemPool(unitClass) {
      this._unitClass = unitClass;
      this._pool = [];
      this._findOrder = [];
      true, true;
      this._initNative();
    };
    var proto = MemPool.prototype;
    proto._initNative = function() {
      this._nativeMemPool = new renderer.MemPool();
    };
    proto._buildUnit = function(unitID) {
      var unit = new this._unitClass(unitID, this);
      true, true;
      this._nativeMemPool.updateCommonData(unitID, unit._data, unit._signData);
      return unit;
    };
    proto._destroyUnit = function(unitID) {
      this._pool[unitID] = null;
      for (var idx = 0, n = this._findOrder.length; idx < n; idx++) {
        var unit = this._findOrder[idx];
        if (unit && unit.unitID == unitID) {
          this._findOrder.splice(idx, 1);
          break;
        }
      }
      true, true;
      this._nativeMemPool.removeCommonData(unitID);
    };
    proto._findUnitID = function() {
      var unitID = 0;
      var pool = this._pool;
      while (pool[unitID]) unitID++;
      return unitID;
    };
    proto.pop = function() {
      var findUnit = null;
      var idx = 0;
      var findOrder = this._findOrder;
      var pool = this._pool;
      for (var n = findOrder.length; idx < n; idx++) {
        var unit = findOrder[idx];
        if (unit && unit.hasSpace()) {
          findUnit = unit;
          break;
        }
      }
      if (!findUnit) {
        var unitID = this._findUnitID();
        findUnit = this._buildUnit(unitID);
        pool[unitID] = findUnit;
        findOrder.push(findUnit);
        idx = findOrder.length - 1;
      }
      var firstUnit = findOrder[0];
      if (firstUnit !== findUnit) {
        findOrder[0] = findUnit;
        findOrder[idx] = firstUnit;
      }
      return findUnit.pop();
    };
    proto.push = function(info) {
      var unit = this._pool[info.unitID];
      unit.push(info.index);
      this._findOrder.length > 1 && unit.isAllFree() && this._destroyUnit(info.unitID);
      return unit;
    };
    module.exports = MemPool;
  }), {} ],
  397: [ (function(require, module, exports) {
    "use strict";
    var MemPool = require("./mem-pool");
    var NodeMemPool = function NodeMemPool(unitClass) {
      MemPool.call(this, unitClass);
    };
    (function() {
      var Super = function Super() {};
      Super.prototype = MemPool.prototype;
      NodeMemPool.prototype = new Super();
    })();
    var proto = NodeMemPool.prototype;
    proto._initNative = function() {
      this._nativeMemPool = new renderer.NodeMemPool();
    };
    proto._destroyUnit = function(unitID) {
      MemPool.prototype._destroyUnit.call(this, unitID);
      true, true;
      this._nativeMemPool.removeNodeData(unitID);
    };
    module.exports = NodeMemPool;
  }), {
    "./mem-pool": 396
  } ],
  398: [ (function(require, module, exports) {
    "use strict";
    var _utils = require("../../value-types/utils");
    var Uint32_Bytes = 4;
    var Uint8_Bytes = 1;
    var Dirty_Type = Uint32Array;
    var Dirty_Members = 1;
    var Dirty_Stride = Dirty_Members * Uint32_Bytes;
    var TRS_Members = 10;
    var TRS_Stride = TRS_Members * _utils.FLOAT_BYTES;
    var LocalMatrix_Members = 16;
    var LocalMatrix_Stride = LocalMatrix_Members * _utils.FLOAT_BYTES;
    var WorldMatrix_Members = 16;
    var WorldMatrix_Stride = WorldMatrix_Members * _utils.FLOAT_BYTES;
    var Parent_Type = Uint32Array;
    var Parent_Members = 2;
    var Parent_Stride = Parent_Members * Uint32_Bytes;
    var ZOrder_Type = Uint32Array;
    var ZOrder_Members = 1;
    var ZOrder_Stride = ZOrder_Members * Uint32_Bytes;
    var CullingMask_Type = Int32Array;
    var CullingMask_Members = 1;
    var CullingMask_Stride = CullingMask_Members * Uint32_Bytes;
    var Opacity_Type = Uint8Array;
    var Opacity_Members = 1;
    var Opacity_Stride = Opacity_Members * Uint8_Bytes;
    var Is3D_Type = Uint8Array;
    var Is3D_Members = 1;
    var Is3D_Stride = Is3D_Members * Uint8_Bytes;
    var Node_Type = Uint32Array;
    var Node_Members = 2;
    var Skew_Members = 2;
    var Skew_Stride = Skew_Members * _utils.FLOAT_BYTES;
    var UnitBase = require("./unit-base");
    var NodeUnit = function NodeUnit(unitID, memPool) {
      UnitBase.call(this, unitID, memPool);
      var contentNum = this._contentNum;
      this.trsList = new _utils.FLOAT_ARRAY_TYPE(contentNum * TRS_Members);
      this.localMatList = new _utils.FLOAT_ARRAY_TYPE(contentNum * LocalMatrix_Members);
      this.worldMatList = new _utils.FLOAT_ARRAY_TYPE(contentNum * WorldMatrix_Members);
      true, true;
      this.dirtyList = new Dirty_Type(contentNum * Dirty_Members);
      this.parentList = new Parent_Type(contentNum * Parent_Members);
      this.zOrderList = new ZOrder_Type(contentNum * ZOrder_Members);
      this.cullingMaskList = new CullingMask_Type(contentNum * CullingMask_Members);
      this.opacityList = new Opacity_Type(contentNum * Opacity_Members);
      this.is3DList = new Is3D_Type(contentNum * Is3D_Members);
      this.nodeList = new Node_Type(contentNum * Node_Members);
      this.skewList = new _utils.FLOAT_ARRAY_TYPE(contentNum * Skew_Members);
      this._memPool._nativeMemPool.updateNodeData(unitID, this.dirtyList, this.trsList, this.localMatList, this.worldMatList, this.parentList, this.zOrderList, this.cullingMaskList, this.opacityList, this.is3DList, this.nodeList, this.skewList);
      for (var i = 0; i < contentNum; i++) {
        var space = this._spacesData[i];
        space.trs = new _utils.FLOAT_ARRAY_TYPE(this.trsList.buffer, i * TRS_Stride, TRS_Members);
        space.localMat = new _utils.FLOAT_ARRAY_TYPE(this.localMatList.buffer, i * LocalMatrix_Stride, LocalMatrix_Members);
        space.worldMat = new _utils.FLOAT_ARRAY_TYPE(this.worldMatList.buffer, i * WorldMatrix_Stride, WorldMatrix_Members);
        true, true;
        space.dirty = new Dirty_Type(this.dirtyList.buffer, i * Dirty_Stride, Dirty_Members);
        space.parent = new Parent_Type(this.parentList.buffer, i * Parent_Stride, Parent_Members);
        space.zOrder = new ZOrder_Type(this.zOrderList.buffer, i * ZOrder_Stride, ZOrder_Members);
        space.cullingMask = new CullingMask_Type(this.cullingMaskList.buffer, i * CullingMask_Stride, CullingMask_Members);
        space.opacity = new Opacity_Type(this.opacityList.buffer, i * Opacity_Stride, Opacity_Members);
        space.is3D = new Is3D_Type(this.is3DList.buffer, i * Is3D_Stride, Is3D_Members);
        space.skew = new _utils.FLOAT_ARRAY_TYPE(this.skewList.buffer, i * Skew_Stride, Skew_Members);
      }
    };
    (function() {
      var Super = function Super() {};
      Super.prototype = UnitBase.prototype;
      NodeUnit.prototype = new Super();
    })();
    module.exports = NodeUnit;
  }), {
    "../../value-types/utils": 408,
    "./unit-base": 399
  } ],
  399: [ (function(require, module, exports) {
    "use strict";
    var POINTER_INVALID_FLAG = 65535;
    var SPACE_FREE_FLAG = 0;
    var SPACE_USE_FLAG = 1;
    var POS_NEXT_FREE = 0;
    var POS_FREE_FLAG = 1;
    var UnitBase = function UnitBase(unitID, memPool, contentNum) {
      contentNum = contentNum || 128;
      this.unitID = unitID;
      this._memPool = memPool;
      this._data = new Uint16Array(2);
      this._data[0] = 0;
      this._data[1] = 0;
      this._contentNum = contentNum;
      this._signData = new Uint16Array(2 * this._contentNum);
      this._spacesData = [];
      for (var i = 0; i < contentNum; i++) {
        var signIndex = 2 * i;
        this._signData[signIndex + POS_NEXT_FREE] = i + 1;
        this._signData[signIndex + POS_FREE_FLAG] = SPACE_FREE_FLAG;
        this._spacesData[i] = {
          index: i,
          unitID: unitID
        };
      }
      this._signData[2 * (contentNum - 1)] = POINTER_INVALID_FLAG;
    };
    var UnitBaseProto = UnitBase.prototype;
    UnitBaseProto.hasSpace = function() {
      return this._data[0] !== POINTER_INVALID_FLAG;
    };
    UnitBaseProto.isAllFree = function() {
      return 0 == this._data[1];
    };
    UnitBaseProto.pop = function() {
      var headFreeIndex = this._data[0];
      if (headFreeIndex === POINTER_INVALID_FLAG) return null;
      var index = headFreeIndex;
      var signIndex = 2 * index;
      var space = this._spacesData[index];
      this._signData[signIndex + POS_FREE_FLAG] = SPACE_USE_FLAG;
      this._data[0] = this._signData[signIndex + POS_NEXT_FREE];
      this._data[1]++;
      return space;
    };
    UnitBaseProto.push = function(index) {
      var signIndex = 2 * index;
      this._signData[signIndex + POS_FREE_FLAG] = SPACE_FREE_FLAG;
      this._signData[signIndex + POS_NEXT_FREE] = this._data[0];
      this._data[0] = index;
      this._data[1]--;
    };
    UnitBaseProto.dump = function() {
      var spaceNum = 0;
      var index = this._data[0];
      var freeStr = "";
      while (index != POINTER_INVALID_FLAG) {
        spaceNum++;
        freeStr += index + "->";
        index = this._signData[2 * index + POS_NEXT_FREE];
      }
      var usingNum = 0;
      var usingStr = "";
      var contentNum = this._contentNum;
      for (var i = 0; i < contentNum; i++) {
        var freeFlag = this._signData[2 * i + POS_FREE_FLAG];
        if (freeFlag == SPACE_USE_FLAG) {
          usingNum++;
          usingStr += i + "->";
        }
      }
      var totalNum = spaceNum + usingNum;
      console.log("unitID:", this.unitID, "spaceNum:", spaceNum, "calc using num:", usingNum, "store using num:", this._data[1], "calc total num:", totalNum, "actually total num:", this._contentNum);
      console.log("free info:", freeStr);
      console.log("using info:", usingStr);
      usingNum != this._data[1] && cc.error("using num error", "calc using num:", usingNum, "store using num:", this._data[1]);
      spaceNum + usingNum != this._contentNum && cc.error("total num error", "calc total num:", totalNum, "actually total num:", this._contentNum);
    };
    module.exports = UnitBase;
  }), {} ],
  400: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueType = _interopRequireDefault(require("./value-type"));
    var _CCClass = _interopRequireDefault(require("../platform/CCClass"));
    var _misc = _interopRequireDefault(require("../utils/misc"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Color = (function(_ValueType) {
      _inheritsLoose(Color, _ValueType);
      Color.copy = function copy(out, a) {
        out.r = a.r;
        out.g = a.g;
        out.b = a.b;
        out.a = a.a;
        return out;
      };
      Color.clone = function clone(a) {
        return new Color(a.r, a.g, a.b, a.a);
      };
      Color.set = function set(out, r, g, b, a) {
        void 0 === r && (r = 255);
        void 0 === g && (g = 255);
        void 0 === b && (b = 255);
        void 0 === a && (a = 255);
        out.r = r;
        out.g = g;
        out.b = b;
        out.a = a;
        return out;
      };
      Color.fromHex = function fromHex(out, hex) {
        var r = hex >> 24 & 255;
        var g = hex >> 16 & 255;
        var b = hex >> 8 & 255;
        var a = 255 & hex;
        out.r = r;
        out.g = g;
        out.b = b;
        out.a = a;
        return out;
      };
      Color.fromHEX = function fromHEX(out, hexString) {
        hexString = 0 === hexString.indexOf("#") ? hexString.substring(1) : hexString;
        out.r = parseInt(hexString.substr(0, 2), 16) || 0;
        out.g = parseInt(hexString.substr(2, 2), 16) || 0;
        out.b = parseInt(hexString.substr(4, 2), 16) || 0;
        out.a = parseInt(hexString.substr(6, 2), 16) || 255;
        out._val = (out.a << 24 >>> 0) + (out.b << 16) + (out.g << 8) + out.r;
        return out;
      };
      Color.add = function add(out, a, b) {
        out.r = a.r + b.r;
        out.g = a.g + b.g;
        out.b = a.b + b.b;
        out.a = a.a + b.a;
        return out;
      };
      Color.subtract = function subtract(out, a, b) {
        out.r = a.r - b.r;
        out.g = a.g - b.g;
        out.b = a.b - b.b;
        out.a = a.a - b.a;
        return out;
      };
      Color.multiply = function multiply(out, a, b) {
        out.r = a.r * b.r;
        out.g = a.g * b.g;
        out.b = a.b * b.b;
        out.a = a.a * b.a;
        return out;
      };
      Color.divide = function divide(out, a, b) {
        out.r = a.r / b.r;
        out.g = a.g / b.g;
        out.b = a.b / b.b;
        out.a = a.a / b.a;
        return out;
      };
      Color.scale = function scale(out, a, b) {
        out.r = a.r * b;
        out.g = a.g * b;
        out.b = a.b * b;
        out.a = a.a * b;
        return out;
      };
      Color.lerp = function lerp(out, a, b, t) {
        var ar = a.r, ag = a.g, ab = a.b, aa = a.a;
        out.r = ar + t * (b.r - ar);
        out.g = ag + t * (b.g - ag);
        out.b = ab + t * (b.b - ab);
        out.a = aa + t * (b.a - aa);
        return out;
      };
      Color.toArray = function toArray(out, a, ofs) {
        void 0 === ofs && (ofs = 0);
        var scale = a instanceof Color || a.a > 1 ? 1 / 255 : 1;
        out[ofs + 0] = a.r * scale;
        out[ofs + 1] = a.g * scale;
        out[ofs + 2] = a.b * scale;
        out[ofs + 3] = a.a * scale;
        return out;
      };
      Color.fromArray = function fromArray(arr, out, ofs) {
        void 0 === ofs && (ofs = 0);
        out.r = 255 * arr[ofs + 0];
        out.g = 255 * arr[ofs + 1];
        out.b = 255 * arr[ofs + 2];
        out.a = 255 * arr[ofs + 3];
        return out;
      };
      Color.premultiplyAlpha = function premultiplyAlpha(out, color) {
        var alpha = color.a / 255;
        out.r = color.r * alpha;
        out.g = color.g * alpha;
        out.b = color.b * alpha;
        out._fastSetA(color.a);
        return out;
      };
      function Color(r, g, b, a) {
        var _this;
        void 0 === r && (r = 0);
        void 0 === g && (g = 0);
        void 0 === b && (b = 0);
        void 0 === a && (a = 255);
        _this = _ValueType.call(this) || this;
        _this._val = 0;
        if ("object" === typeof r) {
          g = r.g;
          b = r.b;
          a = r.a;
          r = r.r;
        }
        _this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + (0 | r);
        return _this;
      }
      var _proto = Color.prototype;
      _proto.clone = function clone() {
        var ret = new Color();
        ret._val = this._val;
        return ret;
      };
      _proto.equals = function equals(other) {
        return other && this._val === other._val;
      };
      _proto.lerp = function lerp(to, ratio, out) {
        out = out || new Color();
        var r = this.r;
        var g = this.g;
        var b = this.b;
        var a = this.a;
        out.r = r + (to.r - r) * ratio;
        out.g = g + (to.g - g) * ratio;
        out.b = b + (to.b - b) * ratio;
        out.a = a + (to.a - a) * ratio;
        return out;
      };
      _proto.toString = function toString() {
        return "rgba(" + this.r.toFixed() + ", " + this.g.toFixed() + ", " + this.b.toFixed() + ", " + this.a.toFixed() + ")";
      };
      _proto.getR = function getR() {
        return 255 & this._val;
      };
      _proto.setR = function setR(red) {
        red = ~~_misc["default"].clampf(red, 0, 255);
        this._val = (4294967040 & this._val | red) >>> 0;
        return this;
      };
      _proto.getG = function getG() {
        return (65280 & this._val) >> 8;
      };
      _proto.setG = function setG(green) {
        green = ~~_misc["default"].clampf(green, 0, 255);
        this._val = (4294902015 & this._val | green << 8) >>> 0;
        return this;
      };
      _proto.getB = function getB() {
        return (16711680 & this._val) >> 16;
      };
      _proto.setB = function setB(blue) {
        blue = ~~_misc["default"].clampf(blue, 0, 255);
        this._val = (4278255615 & this._val | blue << 16) >>> 0;
        return this;
      };
      _proto.getA = function getA() {
        return (4278190080 & this._val) >>> 24;
      };
      _proto.setA = function setA(alpha) {
        alpha = ~~_misc["default"].clampf(alpha, 0, 255);
        this._val = (16777215 & this._val | alpha << 24) >>> 0;
        return this;
      };
      _proto.toCSS = function toCSS(opt) {
        return opt && "rgba" !== opt ? "rgb" === opt ? "rgb(" + this.r + "," + this.g + "," + this.b + ")" : "#" + this.toHEX(opt) : "rgba(" + this.r + "," + this.g + "," + this.b + "," + (this.a / 255).toFixed(2) + ")";
      };
      _proto.fromHEX = function fromHEX(hexString) {
        hexString = 0 === hexString.indexOf("#") ? hexString.substring(1) : hexString;
        var r = parseInt(hexString.substr(0, 2), 16) || 0;
        var g = parseInt(hexString.substr(2, 2), 16) || 0;
        var b = parseInt(hexString.substr(4, 2), 16) || 0;
        var a = parseInt(hexString.substr(6, 2), 16) || 255;
        this._val = (a << 24 >>> 0) + (b << 16) + (g << 8) + r;
        return this;
      };
      _proto.toHEX = function toHEX(fmt) {
        var prefix = "0";
        var hex = [ (this.r < 16 ? prefix : "") + this.r.toString(16), (this.g < 16 ? prefix : "") + this.g.toString(16), (this.b < 16 ? prefix : "") + this.b.toString(16) ];
        if ("#rgb" === fmt) {
          hex[0] = hex[0][0];
          hex[1] = hex[1][0];
          hex[2] = hex[2][0];
        } else "#rrggbbaa" === fmt && hex.push((this.a < 16 ? prefix : "") + this.a.toString(16));
        return hex.join("");
      };
      _proto.toRGBValue = function toRGBValue() {
        return 16777215 & this._val;
      };
      _proto.fromHSV = function fromHSV(h, s, v) {
        var r, g, b;
        if (0 === s) r = g = b = v; else if (0 === v) r = g = b = 0; else {
          1 === h && (h = 0);
          h *= 6;
          var i = Math.floor(h);
          var f = h - i;
          var p = v * (1 - s);
          var q = v * (1 - s * f);
          var t = v * (1 - s * (1 - f));
          switch (i) {
           case 0:
            r = v;
            g = t;
            b = p;
            break;

           case 1:
            r = q;
            g = v;
            b = p;
            break;

           case 2:
            r = p;
            g = v;
            b = t;
            break;

           case 3:
            r = p;
            g = q;
            b = v;
            break;

           case 4:
            r = t;
            g = p;
            b = v;
            break;

           case 5:
            r = v;
            g = p;
            b = q;
          }
        }
        r *= 255;
        g *= 255;
        b *= 255;
        this._val = (this.a << 24 >>> 0) + (b << 16) + (g << 8) + (0 | r);
        return this;
      };
      _proto.toHSV = function toHSV() {
        var r = this.r / 255;
        var g = this.g / 255;
        var b = this.b / 255;
        var hsv = {
          h: 0,
          s: 0,
          v: 0
        };
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var delta = 0;
        hsv.v = max;
        hsv.s = max ? (max - min) / max : 0;
        if (hsv.s) {
          delta = max - min;
          hsv.h = r === max ? (g - b) / delta : g === max ? 2 + (b - r) / delta : 4 + (r - g) / delta;
          hsv.h /= 6;
          hsv.h < 0 && (hsv.h += 1);
        } else hsv.h = 0;
        return hsv;
      };
      _proto.set = function set(color) {
        if (color._val) this._val = color._val; else {
          this.r = color.r;
          this.g = color.g;
          this.b = color.b;
          this.a = color.a;
        }
        return this;
      };
      _proto._fastSetA = function _fastSetA(alpha) {
        this._val = (16777215 & this._val | alpha << 24) >>> 0;
      };
      _proto.multiply = function multiply(other) {
        var r = (255 & this._val) * other.r >> 8;
        var g = (65280 & this._val) * other.g >> 8;
        var b = (16711680 & this._val) * other.b >> 8;
        var a = ((4278190080 & this._val) >>> 8) * other.a;
        this._val = 4278190080 & a | 16711680 & b | 65280 & g | 255 & r;
        return this;
      };
      _createClass(Color, [ {
        key: "r",
        get: function get() {
          return this.getR();
        },
        set: function set(v) {
          this.setR(v);
        }
      }, {
        key: "g",
        get: function get() {
          return this.getG();
        },
        set: function set(v) {
          this.setG(v);
        }
      }, {
        key: "b",
        get: function get() {
          return this.getB();
        },
        set: function set(v) {
          this.setB(v);
        }
      }, {
        key: "a",
        get: function get() {
          return this.getA();
        },
        set: function set(v) {
          this.setA(v);
        }
      } ], [ {
        key: "WHITE",
        get: function get() {
          return new Color(255, 255, 255, 255);
        }
      }, {
        key: "BLACK",
        get: function get() {
          return new Color(0, 0, 0, 255);
        }
      }, {
        key: "TRANSPARENT",
        get: function get() {
          return new Color(0, 0, 0, 0);
        }
      }, {
        key: "GRAY",
        get: function get() {
          return new Color(127.5, 127.5, 127.5);
        }
      }, {
        key: "RED",
        get: function get() {
          return new Color(255, 0, 0);
        }
      }, {
        key: "GREEN",
        get: function get() {
          return new Color(0, 255, 0);
        }
      }, {
        key: "BLUE",
        get: function get() {
          return new Color(0, 0, 255);
        }
      }, {
        key: "YELLOW",
        get: function get() {
          return new Color(255, 235, 4);
        }
      }, {
        key: "ORANGE",
        get: function get() {
          return new Color(255, 127, 0);
        }
      }, {
        key: "CYAN",
        get: function get() {
          return new Color(0, 255, 255);
        }
      }, {
        key: "MAGENTA",
        get: function get() {
          return new Color(255, 0, 255);
        }
      } ]);
      return Color;
    })(_valueType["default"]);
    exports["default"] = Color;
    Color.div = Color.divide;
    Color.sub = Color.subtract;
    Color.mul = Color.multiply;
    Color.WHITE_R = Color.WHITE;
    Color.BLACK_R = Color.BLACK;
    Color.TRANSPARENT_R = Color.TRANSPARENT;
    Color.GRAY_R = Color.GRAY;
    Color.RED_R = Color.RED;
    Color.GREEN_R = Color.GREEN;
    Color.BLUE_R = Color.BLUE;
    Color.YELLOW_R = Color.YELLOW;
    Color.ORANGE_R = Color.ORANGE;
    Color.CYAN_R = Color.CYAN;
    Color.MAGENTA_R = Color.MAGENTA;
    _CCClass["default"].fastDefine("cc.Color", Color, {
      r: 0,
      g: 0,
      b: 0,
      a: 255
    });
    cc.Color = Color;
    cc.color = function color(r, g, b, a) {
      if ("string" === typeof r) {
        var result = new Color();
        return result.fromHEX(r);
      }
      if ("object" === typeof r) return new Color(r.r, r.g, r.b, r.a);
      return new Color(r, g, b, a);
    };
    module.exports = exports["default"];
  }), {
    "../platform/CCClass": 272,
    "../utils/misc": 386,
    "./value-type": 409
  } ],
  401: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    var _exportNames = {
      Vec2: true,
      Vec3: true,
      Vec4: true,
      Mat4: true,
      Mat3: true,
      Rect: true,
      Size: true,
      Color: true,
      Quat: true,
      Trs: true
    };
    exports.Vec4 = exports.Vec3 = exports.Vec2 = exports.Trs = exports.Size = exports.Rect = exports.Quat = exports.Mat4 = exports.Mat3 = exports.Color = void 0;
    var _vec = _interopRequireDefault(require("./vec2"));
    exports.Vec2 = _vec["default"];
    var _vec2 = _interopRequireDefault(require("./vec3"));
    exports.Vec3 = _vec2["default"];
    var _vec3 = _interopRequireDefault(require("./vec4"));
    exports.Vec4 = _vec3["default"];
    var _mat = _interopRequireDefault(require("./mat4"));
    exports.Mat4 = _mat["default"];
    var _mat2 = _interopRequireDefault(require("./mat3"));
    exports.Mat3 = _mat2["default"];
    var _rect = _interopRequireDefault(require("./rect"));
    exports.Rect = _rect["default"];
    var _size = _interopRequireDefault(require("./size"));
    exports.Size = _size["default"];
    var _color = _interopRequireDefault(require("./color"));
    exports.Color = _color["default"];
    var _quat = _interopRequireDefault(require("./quat"));
    exports.Quat = _quat["default"];
    var _trs = _interopRequireDefault(require("./trs"));
    exports.Trs = _trs["default"];
    var _utils = require("./utils");
    Object.keys(_utils).forEach((function(key) {
      if ("default" === key || "__esModule" === key) return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _utils[key]) return;
      exports[key] = _utils[key];
    }));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    cc.math = module.exports;
  }), {
    "./color": 400,
    "./mat3": 402,
    "./mat4": 403,
    "./quat": 404,
    "./rect": 405,
    "./size": 406,
    "./trs": 407,
    "./utils": 408,
    "./vec2": 410,
    "./vec3": 411,
    "./vec4": 412
  } ],
  402: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _utils = require("../value-types/utils");
    var _vec = _interopRequireDefault(require("./vec3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Mat3 = (function() {
      Mat3.create = function create(m00, m01, m02, m03, m04, m05, m06, m07, m08) {
        void 0 === m00 && (m00 = 1);
        void 0 === m01 && (m01 = 0);
        void 0 === m02 && (m02 = 0);
        void 0 === m03 && (m03 = 0);
        void 0 === m04 && (m04 = 1);
        void 0 === m05 && (m05 = 0);
        void 0 === m06 && (m06 = 0);
        void 0 === m07 && (m07 = 0);
        void 0 === m08 && (m08 = 1);
        return new Mat3(m00, m01, m02, m03, m04, m05, m06, m07, m08);
      };
      Mat3.clone = function clone(a) {
        var am = a.m;
        return new Mat3(am[0], am[1], am[2], am[3], am[4], am[5], am[6], am[7], am[8]);
      };
      Mat3.copy = function copy(out, a) {
        out.m.set(a.m);
        return out;
      };
      Mat3.set = function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        var outm = out.m;
        outm[0] = m00;
        outm[1] = m01;
        outm[2] = m02;
        outm[3] = m10;
        outm[4] = m11;
        outm[5] = m12;
        outm[6] = m20;
        outm[7] = m21;
        outm[8] = m22;
        return out;
      };
      Mat3.identity = function identity(out) {
        var outm = out.m;
        outm[0] = 1;
        outm[1] = 0;
        outm[2] = 0;
        outm[3] = 0;
        outm[4] = 1;
        outm[5] = 0;
        outm[6] = 0;
        outm[7] = 0;
        outm[8] = 1;
        return out;
      };
      Mat3.transpose = function transpose(out, a) {
        var am = a.m, outm = out.m;
        if (out === a) {
          var a01 = am[1], a02 = am[2], a12 = am[5];
          outm[1] = am[3];
          outm[2] = am[6];
          outm[3] = a01;
          outm[5] = am[7];
          outm[6] = a02;
          outm[7] = a12;
        } else {
          outm[0] = am[0];
          outm[1] = am[3];
          outm[2] = am[6];
          outm[3] = am[1];
          outm[4] = am[4];
          outm[5] = am[7];
          outm[6] = am[2];
          outm[7] = am[5];
          outm[8] = am[8];
        }
        return out;
      };
      Mat3.invert = function invert(out, a) {
        var am = a.m, outm = out.m;
        var a00 = am[0], a01 = am[1], a02 = am[2], a10 = am[3], a11 = am[4], a12 = am[5], a20 = am[6], a21 = am[7], a22 = am[8];
        var b01 = a22 * a11 - a12 * a21;
        var b11 = -a22 * a10 + a12 * a20;
        var b21 = a21 * a10 - a11 * a20;
        var det = a00 * b01 + a01 * b11 + a02 * b21;
        if (!det) return out;
        det = 1 / det;
        outm[0] = b01 * det;
        outm[1] = (-a22 * a01 + a02 * a21) * det;
        outm[2] = (a12 * a01 - a02 * a11) * det;
        outm[3] = b11 * det;
        outm[4] = (a22 * a00 - a02 * a20) * det;
        outm[5] = (-a12 * a00 + a02 * a10) * det;
        outm[6] = b21 * det;
        outm[7] = (-a21 * a00 + a01 * a20) * det;
        outm[8] = (a11 * a00 - a01 * a10) * det;
        return out;
      };
      Mat3.adjoint = function adjoint(out, a) {
        var am = a.m, outm = out.m;
        var a00 = am[0], a01 = am[1], a02 = am[2], a10 = am[3], a11 = am[4], a12 = am[5], a20 = am[6], a21 = am[7], a22 = am[8];
        outm[0] = a11 * a22 - a12 * a21;
        outm[1] = a02 * a21 - a01 * a22;
        outm[2] = a01 * a12 - a02 * a11;
        outm[3] = a12 * a20 - a10 * a22;
        outm[4] = a00 * a22 - a02 * a20;
        outm[5] = a02 * a10 - a00 * a12;
        outm[6] = a10 * a21 - a11 * a20;
        outm[7] = a01 * a20 - a00 * a21;
        outm[8] = a00 * a11 - a01 * a10;
        return out;
      };
      Mat3.determinant = function determinant(a) {
        var am = a.m;
        var a00 = am[0], a01 = am[1], a02 = am[2], a10 = am[3], a11 = am[4], a12 = am[5], a20 = am[6], a21 = am[7], a22 = am[8];
        return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
      };
      Mat3.multiply = function multiply(out, a, b) {
        var am = a.m, bm = b.m, outm = out.m;
        var a00 = am[0], a01 = am[1], a02 = am[2], a10 = am[3], a11 = am[4], a12 = am[5], a20 = am[6], a21 = am[7], a22 = am[8];
        var b00 = bm[0], b01 = bm[1], b02 = bm[2];
        var b10 = bm[3], b11 = bm[4], b12 = bm[5];
        var b20 = bm[6], b21 = bm[7], b22 = bm[8];
        outm[0] = b00 * a00 + b01 * a10 + b02 * a20;
        outm[1] = b00 * a01 + b01 * a11 + b02 * a21;
        outm[2] = b00 * a02 + b01 * a12 + b02 * a22;
        outm[3] = b10 * a00 + b11 * a10 + b12 * a20;
        outm[4] = b10 * a01 + b11 * a11 + b12 * a21;
        outm[5] = b10 * a02 + b11 * a12 + b12 * a22;
        outm[6] = b20 * a00 + b21 * a10 + b22 * a20;
        outm[7] = b20 * a01 + b21 * a11 + b22 * a21;
        outm[8] = b20 * a02 + b21 * a12 + b22 * a22;
        return out;
      };
      Mat3.multiplyMat4 = function multiplyMat4(out, a, b) {
        var am = a.m, bm = b.m, outm = out.m;
        var a00 = am[0], a01 = am[1], a02 = am[2], a10 = am[3], a11 = am[4], a12 = am[5], a20 = am[6], a21 = am[7], a22 = am[8];
        var b00 = bm[0], b01 = bm[1], b02 = bm[2];
        var b10 = bm[4], b11 = bm[5], b12 = bm[6];
        var b20 = bm[8], b21 = bm[9], b22 = bm[10];
        outm[0] = b00 * a00 + b01 * a10 + b02 * a20;
        outm[1] = b00 * a01 + b01 * a11 + b02 * a21;
        outm[2] = b00 * a02 + b01 * a12 + b02 * a22;
        outm[3] = b10 * a00 + b11 * a10 + b12 * a20;
        outm[4] = b10 * a01 + b11 * a11 + b12 * a21;
        outm[5] = b10 * a02 + b11 * a12 + b12 * a22;
        outm[6] = b20 * a00 + b21 * a10 + b22 * a20;
        outm[7] = b20 * a01 + b21 * a11 + b22 * a21;
        outm[8] = b20 * a02 + b21 * a12 + b22 * a22;
        return out;
      };
      Mat3.translate = function translate(out, a, v) {
        var am = a.m, outm = out.m;
        var a00 = am[0], a01 = am[1], a02 = am[2], a10 = am[3], a11 = am[4], a12 = am[5], a20 = am[6], a21 = am[7], a22 = am[8];
        var x = v.x, y = v.y;
        outm[0] = a00;
        outm[1] = a01;
        outm[2] = a02;
        outm[3] = a10;
        outm[4] = a11;
        outm[5] = a12;
        outm[6] = x * a00 + y * a10 + a20;
        outm[7] = x * a01 + y * a11 + a21;
        outm[8] = x * a02 + y * a12 + a22;
        return out;
      };
      Mat3.rotate = function rotate(out, a, rad) {
        var am = a.m, outm = out.m;
        var a00 = am[0], a01 = am[1], a02 = am[2], a10 = am[3], a11 = am[4], a12 = am[5], a20 = am[6], a21 = am[7], a22 = am[8];
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        outm[0] = c * a00 + s * a10;
        outm[1] = c * a01 + s * a11;
        outm[2] = c * a02 + s * a12;
        outm[3] = c * a10 - s * a00;
        outm[4] = c * a11 - s * a01;
        outm[5] = c * a12 - s * a02;
        outm[6] = a20;
        outm[7] = a21;
        outm[8] = a22;
        return out;
      };
      Mat3.scale = function scale(out, a, v) {
        var x = v.x, y = v.y;
        var am = a.m, outm = out.m;
        outm[0] = x * am[0];
        outm[1] = x * am[1];
        outm[2] = x * am[2];
        outm[3] = y * am[3];
        outm[4] = y * am[4];
        outm[5] = y * am[5];
        outm[6] = am[6];
        outm[7] = am[7];
        outm[8] = am[8];
        return out;
      };
      Mat3.fromMat4 = function fromMat4(out, a) {
        var am = a.m, outm = out.m;
        outm[0] = am[0];
        outm[1] = am[1];
        outm[2] = am[2];
        outm[3] = am[4];
        outm[4] = am[5];
        outm[5] = am[6];
        outm[6] = am[8];
        outm[7] = am[9];
        outm[8] = am[10];
        return out;
      };
      Mat3.fromTranslation = function fromTranslation(out, v) {
        var outm = out.m;
        outm[0] = 1;
        outm[1] = 0;
        outm[2] = 0;
        outm[3] = 0;
        outm[4] = 1;
        outm[5] = 0;
        outm[6] = v.x;
        outm[7] = v.y;
        outm[8] = 1;
        return out;
      };
      Mat3.fromRotation = function fromRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        var outm = out.m;
        outm[0] = c;
        outm[1] = s;
        outm[2] = 0;
        outm[3] = -s;
        outm[4] = c;
        outm[5] = 0;
        outm[6] = 0;
        outm[7] = 0;
        outm[8] = 1;
        return out;
      };
      Mat3.fromScaling = function fromScaling(out, v) {
        var outm = out.m;
        outm[0] = v.x;
        outm[1] = 0;
        outm[2] = 0;
        outm[3] = 0;
        outm[4] = v.y;
        outm[5] = 0;
        outm[6] = 0;
        outm[7] = 0;
        outm[8] = 1;
        return out;
      };
      Mat3.fromQuat = function fromQuat(out, q) {
        var outm = out.m;
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        outm[0] = 1 - yy - zz;
        outm[3] = yx - wz;
        outm[6] = zx + wy;
        outm[1] = yx + wz;
        outm[4] = 1 - xx - zz;
        outm[7] = zy - wx;
        outm[2] = zx - wy;
        outm[5] = zy + wx;
        outm[8] = 1 - xx - yy;
        return out;
      };
      Mat3.fromViewUp = function fromViewUp(out, view, up) {
        var _fromViewUpIIFE = (function() {
          var default_up = new _vec["default"](0, 1, 0);
          var x = new _vec["default"]();
          var y = new _vec["default"]();
          return function(out, view, up) {
            if (_vec["default"].lengthSqr(view) < _utils.EPSILON * _utils.EPSILON) {
              Mat3.identity(out);
              return out;
            }
            up = up || default_up;
            _vec["default"].normalize(x, _vec["default"].cross(x, up, view));
            if (_vec["default"].lengthSqr(x) < _utils.EPSILON * _utils.EPSILON) {
              Mat3.identity(out);
              return out;
            }
            _vec["default"].cross(y, view, x);
            Mat3.set(out, x.x, x.y, x.z, y.x, y.y, y.z, view.x, view.y, view.z);
            return out;
          };
        })();
        return _fromViewUpIIFE(out, view, up);
      };
      Mat3.normalFromMat4 = function normalFromMat4(out, a) {
        var am = a.m, outm = out.m;
        var a00 = am[0], a01 = am[1], a02 = am[2], a03 = am[3], a10 = am[4], a11 = am[5], a12 = am[6], a13 = am[7], a20 = am[8], a21 = am[9], a22 = am[10], a23 = am[11], a30 = am[12], a31 = am[13], a32 = am[14], a33 = am[15];
        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;
        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;
        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) return out;
        det = 1 / det;
        outm[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        outm[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        outm[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        outm[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        outm[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        outm[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        outm[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        outm[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        outm[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        return out;
      };
      Mat3.frob = function frob(a) {
        var am = a.m;
        return Math.sqrt(Math.pow(am[0], 2) + Math.pow(am[1], 2) + Math.pow(am[2], 2) + Math.pow(am[3], 2) + Math.pow(am[4], 2) + Math.pow(am[5], 2) + Math.pow(am[6], 2) + Math.pow(am[7], 2) + Math.pow(am[8], 2));
      };
      Mat3.add = function add(out, a, b) {
        var am = a.m, bm = b.m, outm = out.m;
        outm[0] = am[0] + bm[0];
        outm[1] = am[1] + bm[1];
        outm[2] = am[2] + bm[2];
        outm[3] = am[3] + bm[3];
        outm[4] = am[4] + bm[4];
        outm[5] = am[5] + bm[5];
        outm[6] = am[6] + bm[6];
        outm[7] = am[7] + bm[7];
        outm[8] = am[8] + bm[8];
        return out;
      };
      Mat3.subtract = function subtract(out, a, b) {
        var am = a.m, bm = b.m, outm = out.m;
        outm[0] = am[0] - bm[0];
        outm[1] = am[1] - bm[1];
        outm[2] = am[2] - bm[2];
        outm[3] = am[3] - bm[3];
        outm[4] = am[4] - bm[4];
        outm[5] = am[5] - bm[5];
        outm[6] = am[6] - bm[6];
        outm[7] = am[7] - bm[7];
        outm[8] = am[8] - bm[8];
        return out;
      };
      Mat3.multiplyScalar = function multiplyScalar(out, a, b) {
        var am = a.m, outm = out.m;
        outm[0] = am[0] * b;
        outm[1] = am[1] * b;
        outm[2] = am[2] * b;
        outm[3] = am[3] * b;
        outm[4] = am[4] * b;
        outm[5] = am[5] * b;
        outm[6] = am[6] * b;
        outm[7] = am[7] * b;
        outm[8] = am[8] * b;
        return out;
      };
      Mat3.multiplyScalarAndAdd = function multiplyScalarAndAdd(out, a, b, scale) {
        var am = a.m, bm = b.m, outm = out.m;
        outm[0] = am[0] + bm[0] * scale;
        outm[1] = am[1] + bm[1] * scale;
        outm[2] = am[2] + bm[2] * scale;
        outm[3] = am[3] + bm[3] * scale;
        outm[4] = am[4] + bm[4] * scale;
        outm[5] = am[5] + bm[5] * scale;
        outm[6] = am[6] + bm[6] * scale;
        outm[7] = am[7] + bm[7] * scale;
        outm[8] = am[8] + bm[8] * scale;
        return out;
      };
      Mat3.exactEquals = function exactEquals(a, b) {
        var am = a.m, bm = b.m;
        return am[0] === bm[0] && am[1] === bm[1] && am[2] === bm[2] && am[3] === bm[3] && am[4] === bm[4] && am[5] === bm[5] && am[6] === bm[6] && am[7] === bm[7] && am[8] === bm[8];
      };
      Mat3.equals = function equals(a, b) {
        var am = a.m, bm = b.m;
        var a0 = am[0], a1 = am[1], a2 = am[2], a3 = am[3], a4 = am[4], a5 = am[5], a6 = am[6], a7 = am[7], a8 = am[8];
        var b0 = bm[0], b1 = bm[1], b2 = bm[2], b3 = bm[3], b4 = bm[4], b5 = bm[5], b6 = bm[6], b7 = bm[7], b8 = bm[8];
        return Math.abs(a0 - b0) <= _utils.EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _utils.EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _utils.EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _utils.EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _utils.EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _utils.EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _utils.EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _utils.EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _utils.EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
      };
      Mat3.toArray = function toArray(out, mat, ofs) {
        void 0 === ofs && (ofs = 0);
        var m = mat.m;
        for (var i = 0; i < 9; i++) out[ofs + i] = m[i];
        return out;
      };
      Mat3.fromArray = function fromArray(out, arr, ofs) {
        void 0 === ofs && (ofs = 0);
        var m = out.m;
        for (var i = 0; i < 9; i++) m[i] = arr[ofs + i];
        return out;
      };
      function Mat3(m00, m01, m02, m03, m04, m05, m06, m07, m08) {
        void 0 === m00 && (m00 = 1);
        void 0 === m01 && (m01 = 0);
        void 0 === m02 && (m02 = 0);
        void 0 === m03 && (m03 = 0);
        void 0 === m04 && (m04 = 1);
        void 0 === m05 && (m05 = 0);
        void 0 === m06 && (m06 = 0);
        void 0 === m07 && (m07 = 0);
        void 0 === m08 && (m08 = 1);
        this.m = void 0;
        if (m00 instanceof _utils.FLOAT_ARRAY_TYPE) this.m = m00; else {
          this.m = new _utils.FLOAT_ARRAY_TYPE(9);
          var m = this.m;
          m[0] = m00;
          m[1] = m01;
          m[2] = m02;
          m[3] = m03;
          m[4] = m04;
          m[5] = m05;
          m[6] = m06;
          m[7] = m07;
          m[8] = m08;
        }
      }
      var _proto = Mat3.prototype;
      _proto.toString = function toString() {
        var am = this.m;
        return "mat3(" + am[0] + ", " + am[1] + ", " + am[2] + ", " + am[3] + ", " + am[4] + ", " + am[5] + ", " + am[6] + ", " + am[7] + ", " + am[8] + ")";
      };
      return Mat3;
    })();
    exports["default"] = Mat3;
    Mat3.sub = Mat3.subtract;
    Mat3.mul = Mat3.multiply;
    Mat3.IDENTITY = Object.freeze(new Mat3());
    cc.Mat3 = Mat3;
    module.exports = exports["default"];
  }), {
    "../value-types/utils": 408,
    "./vec3": 411
  } ],
  403: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueType = _interopRequireDefault(require("./value-type"));
    var _CCClass = _interopRequireDefault(require("../platform/CCClass"));
    var _vec = _interopRequireDefault(require("./vec3"));
    var _quat = _interopRequireDefault(require("./quat"));
    var _utils = require("./utils");
    var _mat = _interopRequireDefault(require("./mat3"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var _a00 = 0;
    var _a01 = 0;
    var _a02 = 0;
    var _a03 = 0;
    var _a10 = 0;
    var _a11 = 0;
    var _a12 = 0;
    var _a13 = 0;
    var _a20 = 0;
    var _a21 = 0;
    var _a22 = 0;
    var _a23 = 0;
    var _a30 = 0;
    var _a31 = 0;
    var _a32 = 0;
    var _a33 = 0;
    var Mat4 = (function(_ValueType) {
      _inheritsLoose(Mat4, _ValueType);
      var _proto = Mat4.prototype;
      _proto.mul = function mul(m, out) {
        return Mat4.multiply(out || new Mat4(), this, m);
      };
      _proto.mulScalar = function mulScalar(num, out) {
        Mat4.multiplyScalar(out || new Mat4(), this, num);
      };
      _proto.sub = function sub(m, out) {
        Mat4.subtract(out || new Mat4(), this, m);
      };
      Mat4.clone = function clone(a) {
        var m = a.m;
        return new Mat4(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
      };
      Mat4.copy = function copy(out, a) {
        var m = out.m, am = a.m;
        m[0] = am[0];
        m[1] = am[1];
        m[2] = am[2];
        m[3] = am[3];
        m[4] = am[4];
        m[5] = am[5];
        m[6] = am[6];
        m[7] = am[7];
        m[8] = am[8];
        m[9] = am[9];
        m[10] = am[10];
        m[11] = am[11];
        m[12] = am[12];
        m[13] = am[13];
        m[14] = am[14];
        m[15] = am[15];
        return out;
      };
      Mat4.set = function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        var m = out.m;
        m[0] = m00;
        m[1] = m01;
        m[2] = m02;
        m[3] = m03;
        m[4] = m10;
        m[5] = m11;
        m[6] = m12;
        m[7] = m13;
        m[8] = m20;
        m[9] = m21;
        m[10] = m22;
        m[11] = m23;
        m[12] = m30;
        m[13] = m31;
        m[14] = m32;
        m[15] = m33;
        return out;
      };
      Mat4.identity = function identity(out) {
        var m = out.m;
        m[0] = 1;
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 0;
        m[5] = 1;
        m[6] = 0;
        m[7] = 0;
        m[8] = 0;
        m[9] = 0;
        m[10] = 1;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
        return out;
      };
      Mat4.transpose = function transpose(out, a) {
        var m = out.m, am = a.m;
        if (out === a) {
          var a01 = am[1], a02 = am[2], a03 = am[3], a12 = am[6], a13 = am[7], a23 = am[11];
          m[1] = am[4];
          m[2] = am[8];
          m[3] = am[12];
          m[4] = a01;
          m[6] = am[9];
          m[7] = am[13];
          m[8] = a02;
          m[9] = a12;
          m[11] = am[14];
          m[12] = a03;
          m[13] = a13;
          m[14] = a23;
        } else {
          m[0] = am[0];
          m[1] = am[4];
          m[2] = am[8];
          m[3] = am[12];
          m[4] = am[1];
          m[5] = am[5];
          m[6] = am[9];
          m[7] = am[13];
          m[8] = am[2];
          m[9] = am[6];
          m[10] = am[10];
          m[11] = am[14];
          m[12] = am[3];
          m[13] = am[7];
          m[14] = am[11];
          m[15] = am[15];
        }
        return out;
      };
      Mat4.invert = function invert(out, a) {
        var am = a.m;
        _a00 = am[0];
        _a01 = am[1];
        _a02 = am[2];
        _a03 = am[3];
        _a10 = am[4];
        _a11 = am[5];
        _a12 = am[6];
        _a13 = am[7];
        _a20 = am[8];
        _a21 = am[9];
        _a22 = am[10];
        _a23 = am[11];
        _a30 = am[12];
        _a31 = am[13];
        _a32 = am[14];
        _a33 = am[15];
        var b00 = _a00 * _a11 - _a01 * _a10;
        var b01 = _a00 * _a12 - _a02 * _a10;
        var b02 = _a00 * _a13 - _a03 * _a10;
        var b03 = _a01 * _a12 - _a02 * _a11;
        var b04 = _a01 * _a13 - _a03 * _a11;
        var b05 = _a02 * _a13 - _a03 * _a12;
        var b06 = _a20 * _a31 - _a21 * _a30;
        var b07 = _a20 * _a32 - _a22 * _a30;
        var b08 = _a20 * _a33 - _a23 * _a30;
        var b09 = _a21 * _a32 - _a22 * _a31;
        var b10 = _a21 * _a33 - _a23 * _a31;
        var b11 = _a22 * _a33 - _a23 * _a32;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (0 === det) return null;
        det = 1 / det;
        var m = out.m;
        m[0] = (_a11 * b11 - _a12 * b10 + _a13 * b09) * det;
        m[1] = (_a02 * b10 - _a01 * b11 - _a03 * b09) * det;
        m[2] = (_a31 * b05 - _a32 * b04 + _a33 * b03) * det;
        m[3] = (_a22 * b04 - _a21 * b05 - _a23 * b03) * det;
        m[4] = (_a12 * b08 - _a10 * b11 - _a13 * b07) * det;
        m[5] = (_a00 * b11 - _a02 * b08 + _a03 * b07) * det;
        m[6] = (_a32 * b02 - _a30 * b05 - _a33 * b01) * det;
        m[7] = (_a20 * b05 - _a22 * b02 + _a23 * b01) * det;
        m[8] = (_a10 * b10 - _a11 * b08 + _a13 * b06) * det;
        m[9] = (_a01 * b08 - _a00 * b10 - _a03 * b06) * det;
        m[10] = (_a30 * b04 - _a31 * b02 + _a33 * b00) * det;
        m[11] = (_a21 * b02 - _a20 * b04 - _a23 * b00) * det;
        m[12] = (_a11 * b07 - _a10 * b09 - _a12 * b06) * det;
        m[13] = (_a00 * b09 - _a01 * b07 + _a02 * b06) * det;
        m[14] = (_a31 * b01 - _a30 * b03 - _a32 * b00) * det;
        m[15] = (_a20 * b03 - _a21 * b01 + _a22 * b00) * det;
        return out;
      };
      Mat4.determinant = function determinant(a) {
        var m = a.m;
        _a00 = m[0];
        _a01 = m[1];
        _a02 = m[2];
        _a03 = m[3];
        _a10 = m[4];
        _a11 = m[5];
        _a12 = m[6];
        _a13 = m[7];
        _a20 = m[8];
        _a21 = m[9];
        _a22 = m[10];
        _a23 = m[11];
        _a30 = m[12];
        _a31 = m[13];
        _a32 = m[14];
        _a33 = m[15];
        var b00 = _a00 * _a11 - _a01 * _a10;
        var b01 = _a00 * _a12 - _a02 * _a10;
        var b02 = _a00 * _a13 - _a03 * _a10;
        var b03 = _a01 * _a12 - _a02 * _a11;
        var b04 = _a01 * _a13 - _a03 * _a11;
        var b05 = _a02 * _a13 - _a03 * _a12;
        var b06 = _a20 * _a31 - _a21 * _a30;
        var b07 = _a20 * _a32 - _a22 * _a30;
        var b08 = _a20 * _a33 - _a23 * _a30;
        var b09 = _a21 * _a32 - _a22 * _a31;
        var b10 = _a21 * _a33 - _a23 * _a31;
        var b11 = _a22 * _a33 - _a23 * _a32;
        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      };
      Mat4.multiply = function multiply(out, a, b) {
        var m = out.m, am = a.m, bm = b.m;
        _a00 = am[0];
        _a01 = am[1];
        _a02 = am[2];
        _a03 = am[3];
        _a10 = am[4];
        _a11 = am[5];
        _a12 = am[6];
        _a13 = am[7];
        _a20 = am[8];
        _a21 = am[9];
        _a22 = am[10];
        _a23 = am[11];
        _a30 = am[12];
        _a31 = am[13];
        _a32 = am[14];
        _a33 = am[15];
        var b0 = bm[0], b1 = bm[1], b2 = bm[2], b3 = bm[3];
        m[0] = b0 * _a00 + b1 * _a10 + b2 * _a20 + b3 * _a30;
        m[1] = b0 * _a01 + b1 * _a11 + b2 * _a21 + b3 * _a31;
        m[2] = b0 * _a02 + b1 * _a12 + b2 * _a22 + b3 * _a32;
        m[3] = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33;
        b0 = bm[4];
        b1 = bm[5];
        b2 = bm[6];
        b3 = bm[7];
        m[4] = b0 * _a00 + b1 * _a10 + b2 * _a20 + b3 * _a30;
        m[5] = b0 * _a01 + b1 * _a11 + b2 * _a21 + b3 * _a31;
        m[6] = b0 * _a02 + b1 * _a12 + b2 * _a22 + b3 * _a32;
        m[7] = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33;
        b0 = bm[8];
        b1 = bm[9];
        b2 = bm[10];
        b3 = bm[11];
        m[8] = b0 * _a00 + b1 * _a10 + b2 * _a20 + b3 * _a30;
        m[9] = b0 * _a01 + b1 * _a11 + b2 * _a21 + b3 * _a31;
        m[10] = b0 * _a02 + b1 * _a12 + b2 * _a22 + b3 * _a32;
        m[11] = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33;
        b0 = bm[12];
        b1 = bm[13];
        b2 = bm[14];
        b3 = bm[15];
        m[12] = b0 * _a00 + b1 * _a10 + b2 * _a20 + b3 * _a30;
        m[13] = b0 * _a01 + b1 * _a11 + b2 * _a21 + b3 * _a31;
        m[14] = b0 * _a02 + b1 * _a12 + b2 * _a22 + b3 * _a32;
        m[15] = b0 * _a03 + b1 * _a13 + b2 * _a23 + b3 * _a33;
        return out;
      };
      Mat4.transform = function transform(out, a, v) {
        var x = v.x, y = v.y, z = v.z;
        var m = out.m, am = a.m;
        if (a === out) {
          m[12] = am[0] * x + am[4] * y + am[8] * z + am[12];
          m[13] = am[1] * x + am[5] * y + am[9] * z + am[13];
          m[14] = am[2] * x + am[6] * y + am[10] * z + am[14];
          m[15] = am[3] * x + am[7] * y + am[11] * z + am[15];
        } else {
          _a00 = am[0];
          _a01 = am[1];
          _a02 = am[2];
          _a03 = am[3];
          _a10 = am[4];
          _a11 = am[5];
          _a12 = am[6];
          _a13 = am[7];
          _a20 = am[8];
          _a21 = am[9];
          _a22 = am[10];
          _a23 = am[11];
          _a30 = am[12];
          _a31 = am[13];
          _a32 = am[14];
          _a33 = am[15];
          m[0] = _a00;
          m[1] = _a01;
          m[2] = _a02;
          m[3] = _a03;
          m[4] = _a10;
          m[5] = _a11;
          m[6] = _a12;
          m[7] = _a13;
          m[8] = _a20;
          m[9] = _a21;
          m[10] = _a22;
          m[11] = _a23;
          m[12] = _a00 * x + _a10 * y + _a20 * z + am[12];
          m[13] = _a01 * x + _a11 * y + _a21 * z + am[13];
          m[14] = _a02 * x + _a12 * y + _a22 * z + am[14];
          m[15] = _a03 * x + _a13 * y + _a23 * z + am[15];
        }
        return out;
      };
      Mat4.translate = function translate(out, a, v) {
        var m = out.m, am = a.m;
        if (a === out) {
          m[12] += v.x;
          m[13] += v.y;
          m[14] += v.z;
        } else {
          m[0] = am[0];
          m[1] = am[1];
          m[2] = am[2];
          m[3] = am[3];
          m[4] = am[4];
          m[5] = am[5];
          m[6] = am[6];
          m[7] = am[7];
          m[8] = am[8];
          m[9] = am[9];
          m[10] = am[10];
          m[11] = am[11];
          m[12] += v.x;
          m[13] += v.y;
          m[14] += v.z;
          m[15] = am[15];
        }
        return out;
      };
      Mat4.scale = function scale(out, a, v) {
        var x = v.x, y = v.y, z = v.z;
        var m = out.m, am = a.m;
        m[0] = am[0] * x;
        m[1] = am[1] * x;
        m[2] = am[2] * x;
        m[3] = am[3] * x;
        m[4] = am[4] * y;
        m[5] = am[5] * y;
        m[6] = am[6] * y;
        m[7] = am[7] * y;
        m[8] = am[8] * z;
        m[9] = am[9] * z;
        m[10] = am[10] * z;
        m[11] = am[11] * z;
        m[12] = am[12];
        m[13] = am[13];
        m[14] = am[14];
        m[15] = am[15];
        return out;
      };
      Mat4.rotate = function rotate(out, a, rad, axis) {
        var x = axis.x, y = axis.y, z = axis.z;
        var len = Math.sqrt(x * x + y * y + z * z);
        if (Math.abs(len) < _utils.EPSILON) return null;
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        var t = 1 - c;
        var am = a.m;
        _a00 = am[0];
        _a01 = am[1];
        _a02 = am[2];
        _a03 = am[3];
        _a10 = am[4];
        _a11 = am[5];
        _a12 = am[6];
        _a13 = am[7];
        _a20 = am[8];
        _a21 = am[9];
        _a22 = am[10];
        _a23 = am[11];
        var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s;
        var b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s;
        var b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
        var m = out.m;
        m[0] = _a00 * b00 + _a10 * b01 + _a20 * b02;
        m[1] = _a01 * b00 + _a11 * b01 + _a21 * b02;
        m[2] = _a02 * b00 + _a12 * b01 + _a22 * b02;
        m[3] = _a03 * b00 + _a13 * b01 + _a23 * b02;
        m[4] = _a00 * b10 + _a10 * b11 + _a20 * b12;
        m[5] = _a01 * b10 + _a11 * b11 + _a21 * b12;
        m[6] = _a02 * b10 + _a12 * b11 + _a22 * b12;
        m[7] = _a03 * b10 + _a13 * b11 + _a23 * b12;
        m[8] = _a00 * b20 + _a10 * b21 + _a20 * b22;
        m[9] = _a01 * b20 + _a11 * b21 + _a21 * b22;
        m[10] = _a02 * b20 + _a12 * b21 + _a22 * b22;
        m[11] = _a03 * b20 + _a13 * b21 + _a23 * b22;
        if (a !== out) {
          m[12] = am[12];
          m[13] = am[13];
          m[14] = am[14];
          m[15] = am[15];
        }
        return out;
      };
      Mat4.rotateX = function rotateX(out, a, rad) {
        var m = out.m, am = a.m;
        var s = Math.sin(rad), c = Math.cos(rad), a10 = am[4], a11 = am[5], a12 = am[6], a13 = am[7], a20 = am[8], a21 = am[9], a22 = am[10], a23 = am[11];
        if (a !== out) {
          m[0] = am[0];
          m[1] = am[1];
          m[2] = am[2];
          m[3] = am[3];
          m[12] = am[12];
          m[13] = am[13];
          m[14] = am[14];
          m[15] = am[15];
        }
        m[4] = a10 * c + a20 * s;
        m[5] = a11 * c + a21 * s;
        m[6] = a12 * c + a22 * s;
        m[7] = a13 * c + a23 * s;
        m[8] = a20 * c - a10 * s;
        m[9] = a21 * c - a11 * s;
        m[10] = a22 * c - a12 * s;
        m[11] = a23 * c - a13 * s;
        return out;
      };
      Mat4.rotateY = function rotateY(out, a, rad) {
        var m = out.m, am = a.m;
        var s = Math.sin(rad), c = Math.cos(rad), a00 = am[0], a01 = am[1], a02 = am[2], a03 = am[3], a20 = am[8], a21 = am[9], a22 = am[10], a23 = am[11];
        if (a !== out) {
          m[4] = am[4];
          m[5] = am[5];
          m[6] = am[6];
          m[7] = am[7];
          m[12] = am[12];
          m[13] = am[13];
          m[14] = am[14];
          m[15] = am[15];
        }
        m[0] = a00 * c - a20 * s;
        m[1] = a01 * c - a21 * s;
        m[2] = a02 * c - a22 * s;
        m[3] = a03 * c - a23 * s;
        m[8] = a00 * s + a20 * c;
        m[9] = a01 * s + a21 * c;
        m[10] = a02 * s + a22 * c;
        m[11] = a03 * s + a23 * c;
        return out;
      };
      Mat4.rotateZ = function rotateZ(out, a, rad) {
        var am = a.m;
        var m = out.m;
        var s = Math.sin(rad), c = Math.cos(rad), a00 = a.m[0], a01 = a.m[1], a02 = a.m[2], a03 = a.m[3], a10 = a.m[4], a11 = a.m[5], a12 = a.m[6], a13 = a.m[7];
        if (a !== out) {
          m[8] = am[8];
          m[9] = am[9];
          m[10] = am[10];
          m[11] = am[11];
          m[12] = am[12];
          m[13] = am[13];
          m[14] = am[14];
          m[15] = am[15];
        }
        m[0] = a00 * c + a10 * s;
        m[1] = a01 * c + a11 * s;
        m[2] = a02 * c + a12 * s;
        m[3] = a03 * c + a13 * s;
        m[4] = a10 * c - a00 * s;
        m[5] = a11 * c - a01 * s;
        m[6] = a12 * c - a02 * s;
        m[7] = a13 * c - a03 * s;
        return out;
      };
      Mat4.fromTranslation = function fromTranslation(out, v) {
        var m = out.m;
        m[0] = 1;
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 0;
        m[5] = 1;
        m[6] = 0;
        m[7] = 0;
        m[8] = 0;
        m[9] = 0;
        m[10] = 1;
        m[11] = 0;
        m[12] = v.x;
        m[13] = v.y;
        m[14] = v.z;
        m[15] = 1;
        return out;
      };
      Mat4.fromScaling = function fromScaling(out, v) {
        var m = out.m;
        m[0] = v.x;
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 0;
        m[5] = v.y;
        m[6] = 0;
        m[7] = 0;
        m[8] = 0;
        m[9] = 0;
        m[10] = v.z;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
        return out;
      };
      Mat4.fromRotation = function fromRotation(out, rad, axis) {
        var x = axis.x, y = axis.y, z = axis.z;
        var len = Math.sqrt(x * x + y * y + z * z);
        if (Math.abs(len) < _utils.EPSILON) return null;
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        var t = 1 - c;
        var m = out.m;
        m[0] = x * x * t + c;
        m[1] = y * x * t + z * s;
        m[2] = z * x * t - y * s;
        m[3] = 0;
        m[4] = x * y * t - z * s;
        m[5] = y * y * t + c;
        m[6] = z * y * t + x * s;
        m[7] = 0;
        m[8] = x * z * t + y * s;
        m[9] = y * z * t - x * s;
        m[10] = z * z * t + c;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
        return out;
      };
      Mat4.fromXRotation = function fromXRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        var m = out.m;
        m[0] = 1;
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 0;
        m[5] = c;
        m[6] = s;
        m[7] = 0;
        m[8] = 0;
        m[9] = -s;
        m[10] = c;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
        return out;
      };
      Mat4.fromYRotation = function fromYRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        var m = out.m;
        m[0] = c;
        m[1] = 0;
        m[2] = -s;
        m[3] = 0;
        m[4] = 0;
        m[5] = 1;
        m[6] = 0;
        m[7] = 0;
        m[8] = s;
        m[9] = 0;
        m[10] = c;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
        return out;
      };
      Mat4.fromZRotation = function fromZRotation(out, rad) {
        var s = Math.sin(rad), c = Math.cos(rad);
        var m = out.m;
        m[0] = c;
        m[1] = s;
        m[2] = 0;
        m[3] = 0;
        m[4] = -s;
        m[5] = c;
        m[6] = 0;
        m[7] = 0;
        m[8] = 0;
        m[9] = 0;
        m[10] = 1;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
        return out;
      };
      Mat4.fromRT = function fromRT(out, q, v) {
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var m = out.m;
        m[0] = 1 - (yy + zz);
        m[1] = xy + wz;
        m[2] = xz - wy;
        m[3] = 0;
        m[4] = xy - wz;
        m[5] = 1 - (xx + zz);
        m[6] = yz + wx;
        m[7] = 0;
        m[8] = xz + wy;
        m[9] = yz - wx;
        m[10] = 1 - (xx + yy);
        m[11] = 0;
        m[12] = v.x;
        m[13] = v.y;
        m[14] = v.z;
        m[15] = 1;
        return out;
      };
      Mat4.getTranslation = function getTranslation(out, mat) {
        var m = mat.m;
        out.x = m[12];
        out.y = m[13];
        out.z = m[14];
        return out;
      };
      Mat4.getScaling = function getScaling(out, mat) {
        var m = mat.m;
        var m3 = m3_1.m;
        var m00 = m3[0] = m[0];
        var m01 = m3[1] = m[1];
        var m02 = m3[2] = m[2];
        var m04 = m3[3] = m[4];
        var m05 = m3[4] = m[5];
        var m06 = m3[5] = m[6];
        var m08 = m3[6] = m[8];
        var m09 = m3[7] = m[9];
        var m10 = m3[8] = m[10];
        out.x = Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
        out.y = Math.sqrt(m04 * m04 + m05 * m05 + m06 * m06);
        out.z = Math.sqrt(m08 * m08 + m09 * m09 + m10 * m10);
        _mat["default"].determinant(m3_1) < 0 && (out.x *= -1);
        return out;
      };
      Mat4.getRotation = function getRotation(out, mat) {
        var m = mat.m;
        var trace = m[0] + m[5] + m[10];
        var S = 0;
        if (trace > 0) {
          S = 2 * Math.sqrt(trace + 1);
          out.w = .25 * S;
          out.x = (m[6] - m[9]) / S;
          out.y = (m[8] - m[2]) / S;
          out.z = (m[1] - m[4]) / S;
        } else if (m[0] > m[5] && m[0] > m[10]) {
          S = 2 * Math.sqrt(1 + m[0] - m[5] - m[10]);
          out.w = (m[6] - m[9]) / S;
          out.x = .25 * S;
          out.y = (m[1] + m[4]) / S;
          out.z = (m[8] + m[2]) / S;
        } else if (m[5] > m[10]) {
          S = 2 * Math.sqrt(1 + m[5] - m[0] - m[10]);
          out.w = (m[8] - m[2]) / S;
          out.x = (m[1] + m[4]) / S;
          out.y = .25 * S;
          out.z = (m[6] + m[9]) / S;
        } else {
          S = 2 * Math.sqrt(1 + m[10] - m[0] - m[5]);
          out.w = (m[1] - m[4]) / S;
          out.x = (m[8] + m[2]) / S;
          out.y = (m[6] + m[9]) / S;
          out.z = .25 * S;
        }
        return out;
      };
      Mat4.toRTS = function toRTS(mat, q, v, s) {
        var m = mat.m;
        var m3 = m3_1.m;
        s.x = _vec["default"].set(v3_1, m[0], m[1], m[2]).mag();
        m3[0] = m[0] / s.x;
        m3[1] = m[1] / s.x;
        m3[2] = m[2] / s.x;
        s.y = _vec["default"].set(v3_1, m[4], m[5], m[6]).mag();
        m3[3] = m[4] / s.y;
        m3[4] = m[5] / s.y;
        m3[5] = m[6] / s.y;
        s.z = _vec["default"].set(v3_1, m[8], m[9], m[10]).mag();
        m3[6] = m[8] / s.z;
        m3[7] = m[9] / s.z;
        m3[8] = m[10] / s.z;
        var det = _mat["default"].determinant(m3_1);
        if (det < 0) {
          s.x *= -1;
          m3[0] *= -1;
          m3[1] *= -1;
          m3[2] *= -1;
        }
        _quat["default"].fromMat3(q, m3_1);
        _vec["default"].set(v, m[12], m[13], m[14]);
      };
      Mat4.fromRTS = function fromRTS(out, q, v, s) {
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var sx = s.x;
        var sy = s.y;
        var sz = s.z;
        var m = out.m;
        m[0] = (1 - (yy + zz)) * sx;
        m[1] = (xy + wz) * sx;
        m[2] = (xz - wy) * sx;
        m[3] = 0;
        m[4] = (xy - wz) * sy;
        m[5] = (1 - (xx + zz)) * sy;
        m[6] = (yz + wx) * sy;
        m[7] = 0;
        m[8] = (xz + wy) * sz;
        m[9] = (yz - wx) * sz;
        m[10] = (1 - (xx + yy)) * sz;
        m[11] = 0;
        m[12] = v.x;
        m[13] = v.y;
        m[14] = v.z;
        m[15] = 1;
        return out;
      };
      Mat4.fromRTSOrigin = function fromRTSOrigin(out, q, v, s, o) {
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var sx = s.x;
        var sy = s.y;
        var sz = s.z;
        var ox = o.x;
        var oy = o.y;
        var oz = o.z;
        var m = out.m;
        m[0] = (1 - (yy + zz)) * sx;
        m[1] = (xy + wz) * sx;
        m[2] = (xz - wy) * sx;
        m[3] = 0;
        m[4] = (xy - wz) * sy;
        m[5] = (1 - (xx + zz)) * sy;
        m[6] = (yz + wx) * sy;
        m[7] = 0;
        m[8] = (xz + wy) * sz;
        m[9] = (yz - wx) * sz;
        m[10] = (1 - (xx + yy)) * sz;
        m[11] = 0;
        m[12] = v.x + ox - (m[0] * ox + m[4] * oy + m[8] * oz);
        m[13] = v.y + oy - (m[1] * ox + m[5] * oy + m[9] * oz);
        m[14] = v.z + oz - (m[2] * ox + m[6] * oy + m[10] * oz);
        m[15] = 1;
        return out;
      };
      Mat4.fromQuat = function fromQuat(out, q) {
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var m = out.m;
        m[0] = 1 - yy - zz;
        m[1] = yx + wz;
        m[2] = zx - wy;
        m[3] = 0;
        m[4] = yx - wz;
        m[5] = 1 - xx - zz;
        m[6] = zy + wx;
        m[7] = 0;
        m[8] = zx + wy;
        m[9] = zy - wx;
        m[10] = 1 - xx - yy;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
        return out;
      };
      Mat4.frustum = function frustum(out, left, right, bottom, top, near, far) {
        var rl = 1 / (right - left);
        var tb = 1 / (top - bottom);
        var nf = 1 / (near - far);
        var m = out.m;
        m[0] = 2 * near * rl;
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 0;
        m[5] = 2 * near * tb;
        m[6] = 0;
        m[7] = 0;
        m[8] = (right + left) * rl;
        m[9] = (top + bottom) * tb;
        m[10] = (far + near) * nf;
        m[11] = -1;
        m[12] = 0;
        m[13] = 0;
        m[14] = far * near * 2 * nf;
        m[15] = 0;
        return out;
      };
      Mat4.perspective = function perspective(out, fovy, aspect, near, far) {
        var f = 1 / Math.tan(fovy / 2);
        var nf = 1 / (near - far);
        var m = out.m;
        m[0] = f / aspect;
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 0;
        m[5] = f;
        m[6] = 0;
        m[7] = 0;
        m[8] = 0;
        m[9] = 0;
        m[10] = (far + near) * nf;
        m[11] = -1;
        m[12] = 0;
        m[13] = 0;
        m[14] = 2 * far * near * nf;
        m[15] = 0;
        return out;
      };
      Mat4.ortho = function ortho(out, left, right, bottom, top, near, far) {
        var lr = 1 / (left - right);
        var bt = 1 / (bottom - top);
        var nf = 1 / (near - far);
        var m = out.m;
        m[0] = -2 * lr;
        m[1] = 0;
        m[2] = 0;
        m[3] = 0;
        m[4] = 0;
        m[5] = -2 * bt;
        m[6] = 0;
        m[7] = 0;
        m[8] = 0;
        m[9] = 0;
        m[10] = 2 * nf;
        m[11] = 0;
        m[12] = (left + right) * lr;
        m[13] = (top + bottom) * bt;
        m[14] = (far + near) * nf;
        m[15] = 1;
        return out;
      };
      Mat4.lookAt = function lookAt(out, eye, center, up) {
        var eyex = eye.x;
        var eyey = eye.y;
        var eyez = eye.z;
        var upx = up.x;
        var upy = up.y;
        var upz = up.z;
        var centerx = center.x;
        var centery = center.y;
        var centerz = center.z;
        var z0 = eyex - centerx;
        var z1 = eyey - centery;
        var z2 = eyez - centerz;
        var len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;
        var x0 = upy * z2 - upz * z1;
        var x1 = upz * z0 - upx * z2;
        var x2 = upx * z1 - upy * z0;
        len = 1 / Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        x0 *= len;
        x1 *= len;
        x2 *= len;
        var y0 = z1 * x2 - z2 * x1;
        var y1 = z2 * x0 - z0 * x2;
        var y2 = z0 * x1 - z1 * x0;
        var m = out.m;
        m[0] = x0;
        m[1] = y0;
        m[2] = z0;
        m[3] = 0;
        m[4] = x1;
        m[5] = y1;
        m[6] = z1;
        m[7] = 0;
        m[8] = x2;
        m[9] = y2;
        m[10] = z2;
        m[11] = 0;
        m[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        m[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        m[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        m[15] = 1;
        return out;
      };
      Mat4.inverseTranspose = function inverseTranspose(out, a) {
        var m = a.m;
        _a00 = m[0];
        _a01 = m[1];
        _a02 = m[2];
        _a03 = m[3];
        _a10 = m[4];
        _a11 = m[5];
        _a12 = m[6];
        _a13 = m[7];
        _a20 = m[8];
        _a21 = m[9];
        _a22 = m[10];
        _a23 = m[11];
        _a30 = m[12];
        _a31 = m[13];
        _a32 = m[14];
        _a33 = m[15];
        var b00 = _a00 * _a11 - _a01 * _a10;
        var b01 = _a00 * _a12 - _a02 * _a10;
        var b02 = _a00 * _a13 - _a03 * _a10;
        var b03 = _a01 * _a12 - _a02 * _a11;
        var b04 = _a01 * _a13 - _a03 * _a11;
        var b05 = _a02 * _a13 - _a03 * _a12;
        var b06 = _a20 * _a31 - _a21 * _a30;
        var b07 = _a20 * _a32 - _a22 * _a30;
        var b08 = _a20 * _a33 - _a23 * _a30;
        var b09 = _a21 * _a32 - _a22 * _a31;
        var b10 = _a21 * _a33 - _a23 * _a31;
        var b11 = _a22 * _a33 - _a23 * _a32;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) return null;
        det = 1 / det;
        m = out.m;
        m[0] = (_a11 * b11 - _a12 * b10 + _a13 * b09) * det;
        m[1] = (_a12 * b08 - _a10 * b11 - _a13 * b07) * det;
        m[2] = (_a10 * b10 - _a11 * b08 + _a13 * b06) * det;
        m[3] = 0;
        m[4] = (_a02 * b10 - _a01 * b11 - _a03 * b09) * det;
        m[5] = (_a00 * b11 - _a02 * b08 + _a03 * b07) * det;
        m[6] = (_a01 * b08 - _a00 * b10 - _a03 * b06) * det;
        m[7] = 0;
        m[8] = (_a31 * b05 - _a32 * b04 + _a33 * b03) * det;
        m[9] = (_a32 * b02 - _a30 * b05 - _a33 * b01) * det;
        m[10] = (_a30 * b04 - _a31 * b02 + _a33 * b00) * det;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
        return out;
      };
      Mat4.add = function add(out, a, b) {
        var m = out.m, am = a.m, bm = b.m;
        m[0] = am[0] + bm[0];
        m[1] = am[1] + bm[1];
        m[2] = am[2] + bm[2];
        m[3] = am[3] + bm[3];
        m[4] = am[4] + bm[4];
        m[5] = am[5] + bm[5];
        m[6] = am[6] + bm[6];
        m[7] = am[7] + bm[7];
        m[8] = am[8] + bm[8];
        m[9] = am[9] + bm[9];
        m[10] = am[10] + bm[10];
        m[11] = am[11] + bm[11];
        m[12] = am[12] + bm[12];
        m[13] = am[13] + bm[13];
        m[14] = am[14] + bm[14];
        m[15] = am[15] + bm[15];
        return out;
      };
      Mat4.subtract = function subtract(out, a, b) {
        var m = out.m, am = a.m, bm = b.m;
        m[0] = am[0] - bm[0];
        m[1] = am[1] - bm[1];
        m[2] = am[2] - bm[2];
        m[3] = am[3] - bm[3];
        m[4] = am[4] - bm[4];
        m[5] = am[5] - bm[5];
        m[6] = am[6] - bm[6];
        m[7] = am[7] - bm[7];
        m[8] = am[8] - bm[8];
        m[9] = am[9] - bm[9];
        m[10] = am[10] - bm[10];
        m[11] = am[11] - bm[11];
        m[12] = am[12] - bm[12];
        m[13] = am[13] - bm[13];
        m[14] = am[14] - bm[14];
        m[15] = am[15] - bm[15];
        return out;
      };
      Mat4.multiplyScalar = function multiplyScalar(out, a, b) {
        var m = out.m, am = a.m;
        m[0] = am[0] * b;
        m[1] = am[1] * b;
        m[2] = am[2] * b;
        m[3] = am[3] * b;
        m[4] = am[4] * b;
        m[5] = am[5] * b;
        m[6] = am[6] * b;
        m[7] = am[7] * b;
        m[8] = am[8] * b;
        m[9] = am[9] * b;
        m[10] = am[10] * b;
        m[11] = am[11] * b;
        m[12] = am[12] * b;
        m[13] = am[13] * b;
        m[14] = am[14] * b;
        m[15] = am[15] * b;
        return out;
      };
      Mat4.multiplyScalarAndAdd = function multiplyScalarAndAdd(out, a, b, scale) {
        var m = out.m, am = a.m, bm = b.m;
        m[0] = am[0] + bm[0] * scale;
        m[1] = am[1] + bm[1] * scale;
        m[2] = am[2] + bm[2] * scale;
        m[3] = am[3] + bm[3] * scale;
        m[4] = am[4] + bm[4] * scale;
        m[5] = am[5] + bm[5] * scale;
        m[6] = am[6] + bm[6] * scale;
        m[7] = am[7] + bm[7] * scale;
        m[8] = am[8] + bm[8] * scale;
        m[9] = am[9] + bm[9] * scale;
        m[10] = am[10] + bm[10] * scale;
        m[11] = am[11] + bm[11] * scale;
        m[12] = am[12] + bm[12] * scale;
        m[13] = am[13] + bm[13] * scale;
        m[14] = am[14] + bm[14] * scale;
        m[15] = am[15] + bm[15] * scale;
        return out;
      };
      Mat4.strictEquals = function strictEquals(a, b) {
        var am = a.m, bm = b.m;
        return am[0] === bm[0] && am[1] === bm[1] && am[2] === bm[2] && am[3] === bm[3] && am[4] === bm[4] && am[5] === bm[5] && am[6] === bm[6] && am[7] === bm[7] && am[8] === bm[8] && am[9] === bm[9] && am[10] === bm[10] && am[11] === bm[11] && am[12] === bm[12] && am[13] === bm[13] && am[14] === bm[14] && am[15] === bm[15];
      };
      Mat4.equals = function equals(a, b, epsilon) {
        void 0 === epsilon && (epsilon = _utils.EPSILON);
        var am = a.m, bm = b.m;
        return Math.abs(am[0] - bm[0]) <= epsilon * Math.max(1, Math.abs(am[0]), Math.abs(bm[0])) && Math.abs(am[1] - bm[1]) <= epsilon * Math.max(1, Math.abs(am[1]), Math.abs(bm[1])) && Math.abs(am[2] - bm[2]) <= epsilon * Math.max(1, Math.abs(am[2]), Math.abs(bm[2])) && Math.abs(am[3] - bm[3]) <= epsilon * Math.max(1, Math.abs(am[3]), Math.abs(bm[3])) && Math.abs(am[4] - bm[4]) <= epsilon * Math.max(1, Math.abs(am[4]), Math.abs(bm[4])) && Math.abs(am[5] - bm[5]) <= epsilon * Math.max(1, Math.abs(am[5]), Math.abs(bm[5])) && Math.abs(am[6] - bm[6]) <= epsilon * Math.max(1, Math.abs(am[6]), Math.abs(bm[6])) && Math.abs(am[7] - bm[7]) <= epsilon * Math.max(1, Math.abs(am[7]), Math.abs(bm[7])) && Math.abs(am[8] - bm[8]) <= epsilon * Math.max(1, Math.abs(am[8]), Math.abs(bm[8])) && Math.abs(am[9] - bm[9]) <= epsilon * Math.max(1, Math.abs(am[9]), Math.abs(bm[9])) && Math.abs(am[10] - bm[10]) <= epsilon * Math.max(1, Math.abs(am[10]), Math.abs(bm[10])) && Math.abs(am[11] - bm[11]) <= epsilon * Math.max(1, Math.abs(am[11]), Math.abs(bm[11])) && Math.abs(am[12] - bm[12]) <= epsilon * Math.max(1, Math.abs(am[12]), Math.abs(bm[12])) && Math.abs(am[13] - bm[13]) <= epsilon * Math.max(1, Math.abs(am[13]), Math.abs(bm[13])) && Math.abs(am[14] - bm[14]) <= epsilon * Math.max(1, Math.abs(am[14]), Math.abs(bm[14])) && Math.abs(am[15] - bm[15]) <= epsilon * Math.max(1, Math.abs(am[15]), Math.abs(bm[15]));
      };
      Mat4.adjoint = function adjoint(out, a) {
        var am = a.m, outm = out.m;
        var a00 = am[0], a01 = am[1], a02 = am[2], a03 = am[3], a10 = am[4], a11 = am[5], a12 = am[6], a13 = am[7], a20 = am[8], a21 = am[9], a22 = am[10], a23 = am[11], a30 = am[12], a31 = am[13], a32 = am[14], a33 = am[15];
        outm[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
        outm[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
        outm[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
        outm[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
        outm[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
        outm[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
        outm[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
        outm[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
        outm[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
        outm[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
        outm[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
        outm[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
        outm[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
        outm[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
        outm[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
        outm[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
        return out;
      };
      Mat4.toArray = function toArray(out, mat, ofs) {
        void 0 === ofs && (ofs = 0);
        var m = mat.m;
        for (var i = 0; i < 16; i++) out[ofs + i] = m[i];
        return out;
      };
      Mat4.fromArray = function fromArray(out, arr, ofs) {
        void 0 === ofs && (ofs = 0);
        var m = out.m;
        for (var i = 0; i < 16; i++) m[i] = arr[ofs + i];
        return out;
      };
      function Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        var _this;
        void 0 === m00 && (m00 = 1);
        void 0 === m01 && (m01 = 0);
        void 0 === m02 && (m02 = 0);
        void 0 === m03 && (m03 = 0);
        void 0 === m10 && (m10 = 0);
        void 0 === m11 && (m11 = 1);
        void 0 === m12 && (m12 = 0);
        void 0 === m13 && (m13 = 0);
        void 0 === m20 && (m20 = 0);
        void 0 === m21 && (m21 = 0);
        void 0 === m22 && (m22 = 1);
        void 0 === m23 && (m23 = 0);
        void 0 === m30 && (m30 = 0);
        void 0 === m31 && (m31 = 0);
        void 0 === m32 && (m32 = 0);
        void 0 === m33 && (m33 = 1);
        _this = _ValueType.call(this) || this;
        _this.m = void 0;
        if (m00 instanceof _utils.FLOAT_ARRAY_TYPE) _this.m = m00; else {
          _this.m = new _utils.FLOAT_ARRAY_TYPE(16);
          var tm = _this.m;
          tm[0] = m00;
          tm[1] = m01;
          tm[2] = m02;
          tm[3] = m03;
          tm[4] = m10;
          tm[5] = m11;
          tm[6] = m12;
          tm[7] = m13;
          tm[8] = m20;
          tm[9] = m21;
          tm[10] = m22;
          tm[11] = m23;
          tm[12] = m30;
          tm[13] = m31;
          tm[14] = m32;
          tm[15] = m33;
        }
        return _this;
      }
      _proto.clone = function clone() {
        var t = this;
        var tm = t.m;
        return new Mat4(tm[0], tm[1], tm[2], tm[3], tm[4], tm[5], tm[6], tm[7], tm[8], tm[9], tm[10], tm[11], tm[12], tm[13], tm[14], tm[15]);
      };
      _proto.set = function set(s) {
        var t = this;
        var tm = t.m, sm = s.m;
        tm[0] = sm[0];
        tm[1] = sm[1];
        tm[2] = sm[2];
        tm[3] = sm[3];
        tm[4] = sm[4];
        tm[5] = sm[5];
        tm[6] = sm[6];
        tm[7] = sm[7];
        tm[8] = sm[8];
        tm[9] = sm[9];
        tm[10] = sm[10];
        tm[11] = sm[11];
        tm[12] = sm[12];
        tm[13] = sm[13];
        tm[14] = sm[14];
        tm[15] = sm[15];
        return this;
      };
      _proto.equals = function equals(other) {
        return Mat4.strictEquals(this, other);
      };
      _proto.fuzzyEquals = function fuzzyEquals(other) {
        return Mat4.equals(this, other);
      };
      _proto.toString = function toString() {
        var tm = this.m;
        return tm ? "[\n" + tm[0] + ", " + tm[1] + ", " + tm[2] + ", " + tm[3] + ",\n" + tm[4] + ", " + tm[5] + ", " + tm[6] + ", " + tm[7] + ",\n" + tm[8] + ", " + tm[9] + ", " + tm[10] + ", " + tm[11] + ",\n" + tm[12] + ", " + tm[13] + ", " + tm[14] + ", " + tm[15] + "\n]" : "[\n1, 0, 0, 0\n0, 1, 0, 0\n0, 0, 1, 0\n0, 0, 0, 1\n]";
      };
      _proto.identity = function identity() {
        return Mat4.identity(this);
      };
      _proto.transpose = function transpose(out) {
        out = out || new Mat4();
        return Mat4.transpose(out, this);
      };
      _proto.invert = function invert(out) {
        out = out || new Mat4();
        return Mat4.invert(out, this);
      };
      _proto.adjoint = function adjoint(out) {
        out = out || new Mat4();
        return Mat4.adjoint(out, this);
      };
      _proto.determinant = function determinant() {
        return Mat4.determinant(this);
      };
      _proto.add = function add(other, out) {
        out = out || new Mat4();
        return Mat4.add(out, this, other);
      };
      _proto.subtract = function subtract(other) {
        return Mat4.subtract(this, this, other);
      };
      _proto.multiply = function multiply(other) {
        return Mat4.multiply(this, this, other);
      };
      _proto.multiplyScalar = function multiplyScalar(number) {
        return Mat4.multiplyScalar(this, this, number);
      };
      _proto.translate = function translate(v, out) {
        out = out || new Mat4();
        return Mat4.translate(out, this, v);
      };
      _proto.scale = function scale(v, out) {
        out = out || new Mat4();
        return Mat4.scale(out, this, v);
      };
      _proto.rotate = function rotate(rad, axis, out) {
        out = out || new Mat4();
        return Mat4.rotate(out, this, rad, axis);
      };
      _proto.getTranslation = function getTranslation(out) {
        out = out || new _vec["default"]();
        return Mat4.getTranslation(out, this);
      };
      _proto.getScale = function getScale(out) {
        out = out || new _vec["default"]();
        return Mat4.getScaling(out, this);
      };
      _proto.getRotation = function getRotation(out) {
        out = out || new _quat["default"]();
        return Mat4.getRotation(out, this);
      };
      _proto.fromRTS = function fromRTS(q, v, s) {
        return Mat4.fromRTS(this, q, v, s);
      };
      _proto.fromQuat = function fromQuat(quat) {
        return Mat4.fromQuat(this, quat);
      };
      return Mat4;
    })(_valueType["default"]);
    exports["default"] = Mat4;
    Mat4.mul = Mat4.multiply;
    Mat4.sub = Mat4.subtract;
    Mat4.IDENTITY = Object.freeze(new Mat4());
    var v3_1 = new _vec["default"]();
    var m3_1 = new _mat["default"]();
    _CCClass["default"].fastDefine("cc.Mat4", Mat4, {
      m00: 1,
      m01: 0,
      m02: 0,
      m03: 0,
      m04: 0,
      m05: 1,
      m06: 0,
      m07: 0,
      m08: 0,
      m09: 0,
      m10: 1,
      m11: 0,
      m12: 0,
      m13: 0,
      m14: 0,
      m15: 1
    });
    var _loop = function _loop(i) {
      Object.defineProperty(Mat4.prototype, "m" + i, {
        get: function get() {
          return this.m[i];
        },
        set: function set(value) {
          this.m[i] = value;
        }
      });
    };
    for (var i = 0; i < 16; i++) _loop(i);
    cc.mat4 = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      var mat = new Mat4(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
      void 0 === m00 && Mat4.identity(mat);
      return mat;
    };
    cc.Mat4 = Mat4;
    module.exports = exports["default"];
  }), {
    "../platform/CCClass": 272,
    "./mat3": 402,
    "./quat": 404,
    "./utils": 408,
    "./value-type": 409,
    "./vec3": 411
  } ],
  404: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueType = _interopRequireDefault(require("./value-type"));
    var _CCClass = _interopRequireDefault(require("../platform/CCClass"));
    var _vec = _interopRequireDefault(require("./vec3"));
    var _mat = _interopRequireDefault(require("./mat3"));
    var _utils = require("./utils");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var _x = 0;
    var _y = 0;
    var _z = 0;
    var _w = 0;
    var Quat = (function(_ValueType) {
      _inheritsLoose(Quat, _ValueType);
      var _proto = Quat.prototype;
      _proto.mul = function mul(other, out) {
        return Quat.multiply(out || new Quat(), this, other);
      };
      Quat.clone = function clone(a) {
        return new Quat(a.x, a.y, a.z, a.w);
      };
      Quat.copy = function copy(out, a) {
        out.x = a.x;
        out.y = a.y;
        out.z = a.z;
        out.w = a.w;
        return out;
      };
      Quat.set = function set(out, x, y, z, w) {
        out.x = x;
        out.y = y;
        out.z = z;
        out.w = w;
        return out;
      };
      Quat.identity = function identity(out) {
        out.x = 0;
        out.y = 0;
        out.z = 0;
        out.w = 1;
        return out;
      };
      Quat.rotationTo = function rotationTo(out, a, b) {
        var dot = _vec["default"].dot(a, b);
        if (dot < -.999999) {
          _vec["default"].cross(v3_1, _vec["default"].RIGHT, a);
          v3_1.mag() < 1e-6 && _vec["default"].cross(v3_1, _vec["default"].UP, a);
          _vec["default"].normalize(v3_1, v3_1);
          Quat.fromAxisAngle(out, v3_1, Math.PI);
          return out;
        }
        if (dot > .999999) {
          out.x = 0;
          out.y = 0;
          out.z = 0;
          out.w = 1;
          return out;
        }
        _vec["default"].cross(v3_1, a, b);
        out.x = v3_1.x;
        out.y = v3_1.y;
        out.z = v3_1.z;
        out.w = 1 + dot;
        return Quat.normalize(out, out);
      };
      Quat.getAxisAngle = function getAxisAngle(outAxis, q) {
        var rad = 2 * Math.acos(q.w);
        var s = Math.sin(rad / 2);
        if (0 !== s) {
          outAxis.x = q.x / s;
          outAxis.y = q.y / s;
          outAxis.z = q.z / s;
        } else {
          outAxis.x = 1;
          outAxis.y = 0;
          outAxis.z = 0;
        }
        return rad;
      };
      Quat.multiply = function multiply(out, a, b) {
        _x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;
        _y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;
        _z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;
        _w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;
        out.x = _x;
        out.y = _y;
        out.z = _z;
        out.w = _w;
        return out;
      };
      Quat.multiplyScalar = function multiplyScalar(out, a, b) {
        out.x = a.x * b;
        out.y = a.y * b;
        out.z = a.z * b;
        out.w = a.w * b;
        return out;
      };
      Quat.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
        out.x = a.x + b.x * scale;
        out.y = a.y + b.y * scale;
        out.z = a.z + b.z * scale;
        out.w = a.w + b.w * scale;
        return out;
      };
      Quat.rotateX = function rotateX(out, a, rad) {
        rad *= .5;
        var bx = Math.sin(rad);
        var bw = Math.cos(rad);
        _x = a.x * bw + a.w * bx;
        _y = a.y * bw + a.z * bx;
        _z = a.z * bw - a.y * bx;
        _w = a.w * bw - a.x * bx;
        out.x = _x;
        out.y = _y;
        out.z = _z;
        out.w = _w;
        return out;
      };
      Quat.rotateY = function rotateY(out, a, rad) {
        rad *= .5;
        var by = Math.sin(rad);
        var bw = Math.cos(rad);
        _x = a.x * bw - a.z * by;
        _y = a.y * bw + a.w * by;
        _z = a.z * bw + a.x * by;
        _w = a.w * bw - a.y * by;
        out.x = _x;
        out.y = _y;
        out.z = _z;
        out.w = _w;
        return out;
      };
      Quat.rotateZ = function rotateZ(out, a, rad) {
        rad *= .5;
        var bz = Math.sin(rad);
        var bw = Math.cos(rad);
        _x = a.x * bw + a.y * bz;
        _y = a.y * bw - a.x * bz;
        _z = a.z * bw + a.w * bz;
        _w = a.w * bw - a.z * bz;
        out.x = _x;
        out.y = _y;
        out.z = _z;
        out.w = _w;
        return out;
      };
      Quat.rotateAround = function rotateAround(out, rot, axis, rad) {
        Quat.invert(qt_1, rot);
        _vec["default"].transformQuat(v3_1, axis, qt_1);
        Quat.fromAxisAngle(qt_1, v3_1, rad);
        Quat.multiply(out, rot, qt_1);
        return out;
      };
      Quat.rotateAroundLocal = function rotateAroundLocal(out, rot, axis, rad) {
        Quat.fromAxisAngle(qt_1, axis, rad);
        Quat.multiply(out, rot, qt_1);
        return out;
      };
      Quat.calculateW = function calculateW(out, a) {
        out.x = a.x;
        out.y = a.y;
        out.z = a.z;
        out.w = Math.sqrt(Math.abs(1 - a.x * a.x - a.y * a.y - a.z * a.z));
        return out;
      };
      Quat.dot = function dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
      };
      Quat.lerp = function lerp(out, a, b, t) {
        out.x = a.x + t * (b.x - a.x);
        out.y = a.y + t * (b.y - a.y);
        out.z = a.z + t * (b.z - a.z);
        out.w = a.w + t * (b.w - a.w);
        return out;
      };
      Quat.slerp = function slerp(out, a, b, t) {
        var scale0 = 0;
        var scale1 = 0;
        var cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
        if (cosom < 0) {
          cosom = -cosom;
          b.x = -b.x;
          b.y = -b.y;
          b.z = -b.z;
          b.w = -b.w;
        }
        if (1 - cosom > 1e-6) {
          var omega = Math.acos(cosom);
          var sinom = Math.sin(omega);
          scale0 = Math.sin((1 - t) * omega) / sinom;
          scale1 = Math.sin(t * omega) / sinom;
        } else {
          scale0 = 1 - t;
          scale1 = t;
        }
        out.x = scale0 * a.x + scale1 * b.x;
        out.y = scale0 * a.y + scale1 * b.y;
        out.z = scale0 * a.z + scale1 * b.z;
        out.w = scale0 * a.w + scale1 * b.w;
        return out;
      };
      Quat.sqlerp = function sqlerp(out, a, b, c, d, t) {
        Quat.slerp(qt_1, a, d, t);
        Quat.slerp(qt_2, b, c, t);
        Quat.slerp(out, qt_1, qt_2, 2 * t * (1 - t));
        return out;
      };
      Quat.invert = function invert(out, a) {
        var dot = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
        var invDot = dot ? 1 / dot : 0;
        out.x = -a.x * invDot;
        out.y = -a.y * invDot;
        out.z = -a.z * invDot;
        out.w = a.w * invDot;
        return out;
      };
      Quat.conjugate = function conjugate(out, a) {
        out.x = -a.x;
        out.y = -a.y;
        out.z = -a.z;
        out.w = a.w;
        return out;
      };
      Quat.len = function len(a) {
        return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w);
      };
      Quat.lengthSqr = function lengthSqr(a) {
        return a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
      };
      Quat.normalize = function normalize(out, a) {
        var len = a.x * a.x + a.y * a.y + a.z * a.z + a.w * a.w;
        if (len > 0) {
          len = 1 / Math.sqrt(len);
          out.x = a.x * len;
          out.y = a.y * len;
          out.z = a.z * len;
          out.w = a.w * len;
        }
        return out;
      };
      Quat.fromAxes = function fromAxes(out, xAxis, yAxis, zAxis) {
        _mat["default"].set(m3_1, xAxis.x, xAxis.y, xAxis.z, yAxis.x, yAxis.y, yAxis.z, zAxis.x, zAxis.y, zAxis.z);
        return Quat.normalize(out, Quat.fromMat3(out, m3_1));
      };
      Quat.fromViewUp = function fromViewUp(out, view, up) {
        _mat["default"].fromViewUp(m3_1, view, up);
        return Quat.normalize(out, Quat.fromMat3(out, m3_1));
      };
      Quat.fromAxisAngle = function fromAxisAngle(out, axis, rad) {
        rad *= .5;
        var s = Math.sin(rad);
        out.x = s * axis.x;
        out.y = s * axis.y;
        out.z = s * axis.z;
        out.w = Math.cos(rad);
        return out;
      };
      Quat.fromAngleZ = function fromAngleZ(out, z) {
        z *= halfToRad;
        out.x = out.y = 0;
        out.z = Math.sin(z);
        out.w = Math.cos(z);
        return out;
      };
      Quat.fromMat3 = function fromMat3(out, mat) {
        var m = mat.m;
        var m00 = m[0], m10 = m[1], m20 = m[2], m01 = m[3], m11 = m[4], m21 = m[5], m02 = m[6], m12 = m[7], m22 = m[8];
        var trace = m00 + m11 + m22;
        if (trace > 0) {
          var s = .5 / Math.sqrt(trace + 1);
          out.w = .25 / s;
          out.x = (m21 - m12) * s;
          out.y = (m02 - m20) * s;
          out.z = (m10 - m01) * s;
        } else if (m00 > m11 && m00 > m22) {
          var _s = 2 * Math.sqrt(1 + m00 - m11 - m22);
          out.w = (m21 - m12) / _s;
          out.x = .25 * _s;
          out.y = (m01 + m10) / _s;
          out.z = (m02 + m20) / _s;
        } else if (m11 > m22) {
          var _s2 = 2 * Math.sqrt(1 + m11 - m00 - m22);
          out.w = (m02 - m20) / _s2;
          out.x = (m01 + m10) / _s2;
          out.y = .25 * _s2;
          out.z = (m12 + m21) / _s2;
        } else {
          var _s3 = 2 * Math.sqrt(1 + m22 - m00 - m11);
          out.w = (m10 - m01) / _s3;
          out.x = (m02 + m20) / _s3;
          out.y = (m12 + m21) / _s3;
          out.z = .25 * _s3;
        }
        return out;
      };
      Quat.fromEuler = function fromEuler(out, x, y, z) {
        x *= halfToRad;
        y *= halfToRad;
        z *= halfToRad;
        var sx = Math.sin(x);
        var cx = Math.cos(x);
        var sy = Math.sin(y);
        var cy = Math.cos(y);
        var sz = Math.sin(z);
        var cz = Math.cos(z);
        out.x = sx * cy * cz + cx * sy * sz;
        out.y = cx * sy * cz + sx * cy * sz;
        out.z = cx * cy * sz - sx * sy * cz;
        out.w = cx * cy * cz - sx * sy * sz;
        return out;
      };
      Quat.toAxisX = function toAxisX(out, q) {
        var fy = 2 * q.y;
        var fz = 2 * q.z;
        out.x = 1 - fy * q.y - fz * q.z;
        out.y = fy * q.x + fz * q.w;
        out.z = fz * q.x + fy * q.w;
        return out;
      };
      Quat.toAxisY = function toAxisY(out, q) {
        var fx = 2 * q.x;
        var fy = 2 * q.y;
        var fz = 2 * q.z;
        out.x = fy * q.x - fz * q.w;
        out.y = 1 - fx * q.x - fz * q.z;
        out.z = fz * q.y + fx * q.w;
        return out;
      };
      Quat.toAxisZ = function toAxisZ(out, q) {
        var fx = 2 * q.x;
        var fy = 2 * q.y;
        var fz = 2 * q.z;
        out.x = fz * q.x - fy * q.w;
        out.y = fz * q.y - fx * q.w;
        out.z = 1 - fx * q.x - fy * q.y;
        return out;
      };
      Quat.toEuler = function toEuler(out, q, outerZ) {
        var x = q.x, y = q.y, z = q.z, w = q.w;
        var bank = 0;
        var heading = 0;
        var attitude = 0;
        var test = x * y + z * w;
        if (test > .499999) {
          bank = 0;
          heading = (0, _utils.toDegree)(2 * Math.atan2(x, w));
          attitude = 90;
        } else if (test < -.499999) {
          bank = 0;
          heading = -(0, _utils.toDegree)(2 * Math.atan2(x, w));
          attitude = -90;
        } else {
          var sqx = x * x;
          var sqy = y * y;
          var sqz = z * z;
          bank = (0, _utils.toDegree)(Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz));
          heading = (0, _utils.toDegree)(Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz));
          attitude = (0, _utils.toDegree)(Math.asin(2 * test));
          if (outerZ) {
            bank = -180 * Math.sign(bank + 1e-6) + bank;
            heading = -180 * Math.sign(heading + 1e-6) + heading;
            attitude = 180 * Math.sign(attitude + 1e-6) - attitude;
          }
        }
        out.x = bank;
        out.y = heading;
        out.z = attitude;
        return out;
      };
      Quat.strictEquals = function strictEquals(a, b) {
        return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
      };
      Quat.equals = function equals(a, b, epsilon) {
        void 0 === epsilon && (epsilon = _utils.EPSILON);
        return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1, Math.abs(a.w), Math.abs(b.w));
      };
      Quat.toArray = function toArray(out, q, ofs) {
        void 0 === ofs && (ofs = 0);
        out[ofs + 0] = q.x;
        out[ofs + 1] = q.y;
        out[ofs + 2] = q.z;
        out[ofs + 3] = q.w;
        return out;
      };
      Quat.fromArray = function fromArray(out, arr, ofs) {
        void 0 === ofs && (ofs = 0);
        out.x = arr[ofs + 0];
        out.y = arr[ofs + 1];
        out.z = arr[ofs + 2];
        out.w = arr[ofs + 3];
        return out;
      };
      function Quat(x, y, z, w) {
        var _this;
        void 0 === x && (x = 0);
        void 0 === y && (y = 0);
        void 0 === z && (z = 0);
        void 0 === w && (w = 1);
        _this = _ValueType.call(this) || this;
        _this.x = void 0;
        _this.y = void 0;
        _this.z = void 0;
        _this.w = void 0;
        if (x && "object" === typeof x) {
          _this.x = x.x;
          _this.y = x.y;
          _this.z = x.z;
          _this.w = x.w;
        } else {
          _this.x = x;
          _this.y = y;
          _this.z = z;
          _this.w = w;
        }
        return _this;
      }
      _proto.clone = function clone() {
        return new Quat(this.x, this.y, this.z, this.w);
      };
      _proto.set = function set(newValue) {
        this.x = newValue.x;
        this.y = newValue.y;
        this.z = newValue.z;
        this.w = newValue.w;
        return this;
      };
      _proto.equals = function equals(other) {
        return other && this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
      };
      _proto.toEuler = function toEuler(out) {
        return Quat.toEuler(out, this);
      };
      _proto.fromEuler = function fromEuler(euler) {
        return Quat.fromEuler(this, euler.x, euler.y, euler.z);
      };
      _proto.lerp = function lerp(to, ratio, out) {
        out = out || new Quat();
        Quat.slerp(out, this, to, ratio);
        return out;
      };
      _proto.multiply = function multiply(other) {
        return Quat.multiply(this, this, other);
      };
      _proto.rotateAround = function rotateAround(rot, axis, rad, out) {
        out = out || new Quat();
        return Quat.rotateAround(out, rot, axis, rad);
      };
      return Quat;
    })(_valueType["default"]);
    exports["default"] = Quat;
    Quat.mul = Quat.multiply;
    Quat.scale = Quat.multiplyScalar;
    Quat.mag = Quat.len;
    Quat.IDENTITY = Object.freeze(new Quat());
    var qt_1 = new Quat();
    var qt_2 = new Quat();
    var v3_1 = new _vec["default"]();
    var m3_1 = new _mat["default"]();
    var halfToRad = .5 * Math.PI / 180;
    _CCClass["default"].fastDefine("cc.Quat", Quat, {
      x: 0,
      y: 0,
      z: 0,
      w: 1
    });
    cc.quat = function quat(x, y, z, w) {
      return new Quat(x, y, z, w);
    };
    cc.Quat = Quat;
    module.exports = exports["default"];
  }), {
    "../platform/CCClass": 272,
    "./mat3": 402,
    "./utils": 408,
    "./value-type": 409,
    "./vec3": 411
  } ],
  405: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueType = _interopRequireDefault(require("./value-type"));
    var _CCClass = _interopRequireDefault(require("../platform/CCClass"));
    var _vec = _interopRequireDefault(require("./vec2"));
    var _size = _interopRequireDefault(require("./size"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Rect = (function(_ValueType) {
      _inheritsLoose(Rect, _ValueType);
      Rect.fromMinMax = function fromMinMax(v1, v2) {
        var min_x = Math.min(v1.x, v2.x);
        var min_y = Math.min(v1.y, v2.y);
        var max_x = Math.max(v1.x, v2.x);
        var max_y = Math.max(v1.y, v2.y);
        return new Rect(min_x, min_y, max_x - min_x, max_y - min_y);
      };
      function Rect(x, y, w, h) {
        var _this;
        void 0 === x && (x = 0);
        void 0 === y && (y = 0);
        void 0 === w && (w = 0);
        void 0 === h && (h = 0);
        _this = _ValueType.call(this) || this;
        _this.x = void 0;
        _this.y = void 0;
        _this.width = void 0;
        _this.height = void 0;
        if (x && "object" === typeof x) {
          y = x.y;
          w = x.width;
          h = x.height;
          x = x.x;
        }
        _this.x = x || 0;
        _this.y = y || 0;
        _this.width = w || 0;
        _this.height = h || 0;
        return _this;
      }
      var _proto = Rect.prototype;
      _proto.clone = function clone() {
        return new Rect(this.x, this.y, this.width, this.height);
      };
      _proto.equals = function equals(other) {
        return other && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
      };
      _proto.lerp = function lerp(to, ratio, out) {
        out = out || new Rect();
        var x = this.x;
        var y = this.y;
        var width = this.width;
        var height = this.height;
        out.x = x + (to.x - x) * ratio;
        out.y = y + (to.y - y) * ratio;
        out.width = width + (to.width - width) * ratio;
        out.height = height + (to.height - height) * ratio;
        return out;
      };
      _proto.set = function set(source) {
        this.x = source.x;
        this.y = source.y;
        this.width = source.width;
        this.height = source.height;
        return this;
      };
      _proto.intersects = function intersects(rect) {
        var maxax = this.x + this.width, maxay = this.y + this.height, maxbx = rect.x + rect.width, maxby = rect.y + rect.height;
        return !(maxax < rect.x || maxbx < this.x || maxay < rect.y || maxby < this.y);
      };
      _proto.intersection = function intersection(out, rectB) {
        var axMin = this.x, ayMin = this.y, axMax = this.x + this.width, ayMax = this.y + this.height;
        var bxMin = rectB.x, byMin = rectB.y, bxMax = rectB.x + rectB.width, byMax = rectB.y + rectB.height;
        out.x = Math.max(axMin, bxMin);
        out.y = Math.max(ayMin, byMin);
        out.width = Math.min(axMax, bxMax) - out.x;
        out.height = Math.min(ayMax, byMax) - out.y;
        return out;
      };
      _proto.contains = function contains(point) {
        return this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y;
      };
      _proto.containsRect = function containsRect(rect) {
        return this.x <= rect.x && this.x + this.width >= rect.x + rect.width && this.y <= rect.y && this.y + this.height >= rect.y + rect.height;
      };
      _proto.union = function union(out, rectB) {
        var ax = this.x, ay = this.y, aw = this.width, ah = this.height;
        var bx = rectB.x, by = rectB.y, bw = rectB.width, bh = rectB.height;
        out.x = Math.min(ax, bx);
        out.y = Math.min(ay, by);
        out.width = Math.max(ax + aw, bx + bw) - out.x;
        out.height = Math.max(ay + ah, by + bh) - out.y;
        return out;
      };
      _proto.transformMat4 = function transformMat4(out, mat) {
        var ol = this.x;
        var ob = this.y;
        var or = ol + this.width;
        var ot = ob + this.height;
        var matm = mat.m;
        var lbx = matm[0] * ol + matm[4] * ob + matm[12];
        var lby = matm[1] * ol + matm[5] * ob + matm[13];
        var rbx = matm[0] * or + matm[4] * ob + matm[12];
        var rby = matm[1] * or + matm[5] * ob + matm[13];
        var ltx = matm[0] * ol + matm[4] * ot + matm[12];
        var lty = matm[1] * ol + matm[5] * ot + matm[13];
        var rtx = matm[0] * or + matm[4] * ot + matm[12];
        var rty = matm[1] * or + matm[5] * ot + matm[13];
        var minX = Math.min(lbx, rbx, ltx, rtx);
        var maxX = Math.max(lbx, rbx, ltx, rtx);
        var minY = Math.min(lby, rby, lty, rty);
        var maxY = Math.max(lby, rby, lty, rty);
        out.x = minX;
        out.y = minY;
        out.width = maxX - minX;
        out.height = maxY - minY;
        return out;
      };
      _proto.toString = function toString() {
        return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
      };
      _createClass(Rect, [ {
        key: "xMin",
        get: function get() {
          return this.x;
        },
        set: function set(v) {
          this.width += this.x - v;
          this.x = v;
        }
      }, {
        key: "yMin",
        get: function get() {
          return this.y;
        },
        set: function set(v) {
          this.height += this.y - v;
          this.y = v;
        }
      }, {
        key: "xMax",
        get: function get() {
          return this.x + this.width;
        },
        set: function set(value) {
          this.width = value - this.x;
        }
      }, {
        key: "yMax",
        get: function get() {
          return this.y + this.height;
        },
        set: function set(value) {
          this.height = value - this.y;
        }
      }, {
        key: "center",
        get: function get() {
          return new _vec["default"](this.x + .5 * this.width, this.y + .5 * this.height);
        },
        set: function set(value) {
          this.x = value.x - .5 * this.width;
          this.y = value.y - .5 * this.height;
        }
      }, {
        key: "origin",
        get: function get() {
          return new _vec["default"](this.x, this.y);
        },
        set: function set(value) {
          this.x = value.x;
          this.y = value.y;
        }
      }, {
        key: "size",
        get: function get() {
          return new _size["default"](this.width, this.height);
        },
        set: function set(value) {
          this.width = value.width;
          this.height = value.height;
        }
      } ]);
      return Rect;
    })(_valueType["default"]);
    exports["default"] = Rect;
    _CCClass["default"].fastDefine("cc.Rect", Rect, {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
    cc.Rect = Rect;
    cc.rect = function rect(x, y, w, h) {
      return new Rect(x, y, w, h);
    };
    module.exports = exports["default"];
  }), {
    "../platform/CCClass": 272,
    "./size": 406,
    "./value-type": 409,
    "./vec2": 410
  } ],
  406: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueType = _interopRequireDefault(require("./value-type"));
    var _CCClass = _interopRequireDefault(require("../platform/CCClass"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Size = (function(_ValueType) {
      _inheritsLoose(Size, _ValueType);
      function Size(width, height) {
        var _this;
        void 0 === width && (width = 0);
        void 0 === height && (height = 0);
        _this = _ValueType.call(this) || this;
        _this.width = void 0;
        _this.height = void 0;
        if (width && "object" === typeof width) {
          _this.width = width.width;
          _this.height = width.height;
        } else {
          _this.width = width || 0;
          _this.height = height || 0;
        }
        return _this;
      }
      var _proto = Size.prototype;
      _proto.clone = function clone() {
        return new Size(this.width, this.height);
      };
      _proto.equals = function equals(other) {
        return other && this.width === other.width && this.height === other.height;
      };
      _proto.lerp = function lerp(to, ratio, out) {
        out = out || new Size();
        var width = this.width;
        var height = this.height;
        out.width = width + (to.width - width) * ratio;
        out.height = height + (to.height - height) * ratio;
        return out;
      };
      _proto.set = function set(source) {
        this.width = source.width;
        this.height = source.height;
        return this;
      };
      _proto.toString = function toString() {
        return "(" + this.width.toFixed(2) + ", " + this.height.toFixed(2) + ")";
      };
      _createClass(Size, null, [ {
        key: "ZERO",
        get: function get() {
          return new Size();
        }
      } ]);
      return Size;
    })(_valueType["default"]);
    exports["default"] = Size;
    Size.ZERO_R = Size.ZERO;
    _CCClass["default"].fastDefine("cc.Size", Size, {
      width: 0,
      height: 0
    });
    cc.size = function(w, h) {
      return new Size(w, h);
    };
    cc.Size = Size;
    module.exports = exports["default"];
  }), {
    "../platform/CCClass": 272,
    "./value-type": 409
  } ],
  407: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _quat = _interopRequireDefault(require("./quat"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var tmp_quat = new _quat["default"]();
    var Trs = (function() {
      function Trs() {}
      Trs.toRotation = function toRotation(out, a) {
        out.x = a[3];
        out.y = a[4];
        out.z = a[5];
        out.w = a[6];
        return out;
      };
      Trs.fromRotation = function fromRotation(out, a) {
        out[3] = a.x;
        out[4] = a.y;
        out[5] = a.z;
        out[6] = a.w;
        return out;
      };
      Trs.toEuler = function toEuler(out, a) {
        Trs.toRotation(tmp_quat, a);
        _quat["default"].toEuler(out, tmp_quat);
        return out;
      };
      Trs.fromEuler = function fromEuler(out, a) {
        _quat["default"].fromEuler(tmp_quat, a.x, a.y, a.z);
        Trs.fromRotation(out, tmp_quat);
        return out;
      };
      Trs.fromEulerNumber = function fromEulerNumber(out, x, y, z) {
        _quat["default"].fromEuler(tmp_quat, x, y, z);
        Trs.fromRotation(out, tmp_quat);
        return out;
      };
      Trs.toScale = function toScale(out, a) {
        out.x = a[7];
        out.y = a[8];
        out.z = a[9];
        return out;
      };
      Trs.fromScale = function fromScale(out, a) {
        out[7] = a.x;
        out[8] = a.y;
        out[9] = a.z;
        return out;
      };
      Trs.toPosition = function toPosition(out, a) {
        out.x = a[0];
        out.y = a[1];
        out.z = a[2];
        return out;
      };
      Trs.fromPosition = function fromPosition(out, a) {
        out[0] = a.x;
        out[1] = a.y;
        out[2] = a.z;
        return out;
      };
      Trs.fromAngleZ = function fromAngleZ(out, a) {
        _quat["default"].fromAngleZ(tmp_quat, a);
        Trs.fromRotation(out, tmp_quat);
        return out;
      };
      Trs.toMat4 = function toMat4(out, trs) {
        var x = trs[3], y = trs[4], z = trs[5], w = trs[6];
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var sx = trs[7];
        var sy = trs[8];
        var sz = trs[9];
        var m = out.m;
        m[0] = (1 - (yy + zz)) * sx;
        m[1] = (xy + wz) * sx;
        m[2] = (xz - wy) * sx;
        m[3] = 0;
        m[4] = (xy - wz) * sy;
        m[5] = (1 - (xx + zz)) * sy;
        m[6] = (yz + wx) * sy;
        m[7] = 0;
        m[8] = (xz + wy) * sz;
        m[9] = (yz - wx) * sz;
        m[10] = (1 - (xx + yy)) * sz;
        m[11] = 0;
        m[12] = trs[0];
        m[13] = trs[1];
        m[14] = trs[2];
        m[15] = 1;
        return out;
      };
      return Trs;
    })();
    exports["default"] = Trs;
    cc.Trs = Trs;
    module.exports = exports["default"];
  }), {
    "./quat": 404
  } ],
  408: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.INT_MIN = exports.INT_MAX = exports.INT_BITS = exports.FLOAT_BYTES = exports.FLOAT_ARRAY_TYPE = exports.EPSILON = void 0;
    exports.approx = approx;
    exports.clamp = clamp;
    exports.clamp01 = clamp01;
    exports.equals = equals;
    exports.inverseLerp = inverseLerp;
    exports.lerp = lerp;
    exports.nextPow2 = nextPow2;
    exports.pingPong = pingPong;
    exports.pseudoRandom = pseudoRandom;
    exports.pseudoRandomRange = pseudoRandomRange;
    exports.pseudoRandomRangeInt = pseudoRandomRangeInt;
    exports.random = void 0;
    exports.randomRange = randomRange;
    exports.randomRangeInt = randomRangeInt;
    exports.repeat = repeat;
    exports.sign = sign;
    exports.toDegree = toDegree;
    exports.toRadian = toRadian;
    var _d2r = Math.PI / 180;
    var _r2d = 180 / Math.PI;
    var EPSILON = 1e-6;
    exports.EPSILON = EPSILON;
    var INT_BITS = 32;
    exports.INT_BITS = INT_BITS;
    var INT_MAX = 2147483647;
    exports.INT_MAX = INT_MAX;
    var INT_MIN = -1 << INT_BITS - 1;
    exports.INT_MIN = INT_MIN;
    var FLOAT_ARRAY_TYPE = (true, Float32Array);
    exports.FLOAT_ARRAY_TYPE = FLOAT_ARRAY_TYPE;
    var FLOAT_BYTES = (true, 4);
    exports.FLOAT_BYTES = FLOAT_BYTES;
    function equals(a, b) {
      return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
    }
    function approx(a, b, maxDiff) {
      maxDiff = maxDiff || EPSILON;
      return Math.abs(a - b) <= maxDiff;
    }
    function clamp(val, min, max) {
      return val < min ? min : val > max ? max : val;
    }
    function clamp01(val) {
      return val < 0 ? 0 : val > 1 ? 1 : val;
    }
    function lerp(from, to, ratio) {
      return from + (to - from) * ratio;
    }
    function toRadian(a) {
      return a * _d2r;
    }
    function toDegree(a) {
      return a * _r2d;
    }
    var random = Math.random;
    exports.random = random;
    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }
    function randomRangeInt(min, max) {
      return Math.floor(randomRange(min, max));
    }
    function pseudoRandom(seed) {
      seed = (9301 * seed + 49297) % 233280;
      return seed / 233280;
    }
    function pseudoRandomRange(seed, min, max) {
      return pseudoRandom(seed) * (max - min) + min;
    }
    function pseudoRandomRangeInt(seed, min, max) {
      return Math.floor(pseudoRandomRange(seed, min, max));
    }
    function nextPow2(val) {
      --val;
      val |= val >> 1;
      val |= val >> 2;
      val |= val >> 4;
      val |= val >> 8;
      val |= val >> 16;
      ++val;
      return val;
    }
    function repeat(t, length) {
      return t - Math.floor(t / length) * length;
    }
    function pingPong(t, length) {
      t = repeat(t, 2 * length);
      t = length - Math.abs(t - length);
      return t;
    }
    function inverseLerp(from, to, value) {
      return (value - from) / (to - from);
    }
    function sign(v) {
      return (v > 0) - (v < 0);
    }
  }), {} ],
  409: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _js = _interopRequireDefault(require("../platform/js"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var ValueType = (function() {
      function ValueType() {}
      var _proto = ValueType.prototype;
      _proto.clone = function clone() {
        cc.errorID("0100", _js["default"].getClassName(this) + ".clone");
        return null;
      };
      _proto.equals = function equals(other) {
        cc.errorID("0100", _js["default"].getClassName(this) + ".equals");
        return false;
      };
      _proto.lerp = function lerp(to, ratio) {
        cc.errorID("0100", _js["default"].getClassName(this) + ".lerp");
        return this.clone();
      };
      _proto.set = function set(source) {
        cc.errorID("0100", _js["default"].getClassName(this) + ".set");
      };
      _proto.toString = function toString() {
        return "" + {};
      };
      return ValueType;
    })();
    exports["default"] = ValueType;
    _js["default"].setClassName("cc.ValueType", ValueType);
    cc.ValueType = ValueType;
    module.exports = exports["default"];
  }), {
    "../platform/js": 294
  } ],
  410: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueType = _interopRequireDefault(require("./value-type"));
    var _CCClass = _interopRequireDefault(require("../platform/CCClass"));
    var _misc = _interopRequireDefault(require("../utils/misc"));
    var _utils = require("./utils");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var _x = 0;
    var _y = 0;
    var Vec2 = (function(_ValueType) {
      _inheritsLoose(Vec2, _ValueType);
      var _proto = Vec2.prototype;
      _proto.sub = function sub(vector, out) {
        return Vec2.subtract(out || new Vec2(), this, vector);
      };
      _proto.mul = function mul(num, out) {
        return Vec2.multiplyScalar(out || new Vec2(), this, num);
      };
      _proto.div = function div(num, out) {
        return Vec2.multiplyScalar(out || new Vec2(), this, 1 / num);
      };
      _proto.scale = function scale(vector, out) {
        return Vec2.multiply(out || new Vec2(), this, vector);
      };
      _proto.neg = function neg(out) {
        return Vec2.negate(out || new Vec2(), this);
      };
      Vec2.clone = function clone(a) {
        return new Vec2(a.x, a.y);
      };
      Vec2.copy = function copy(out, a) {
        out.x = a.x;
        out.y = a.y;
        return out;
      };
      Vec2.set = function set(out, x, y) {
        out.x = x;
        out.y = y;
        return out;
      };
      Vec2.add = function add(out, a, b) {
        out.x = a.x + b.x;
        out.y = a.y + b.y;
        return out;
      };
      Vec2.subtract = function subtract(out, a, b) {
        out.x = a.x - b.x;
        out.y = a.y - b.y;
        return out;
      };
      Vec2.multiply = function multiply(out, a, b) {
        out.x = a.x * b.x;
        out.y = a.y * b.y;
        return out;
      };
      Vec2.divide = function divide(out, a, b) {
        out.x = a.x / b.x;
        out.y = a.y / b.y;
        return out;
      };
      Vec2.ceil = function ceil(out, a) {
        out.x = Math.ceil(a.x);
        out.y = Math.ceil(a.y);
        return out;
      };
      Vec2.floor = function floor(out, a) {
        out.x = Math.floor(a.x);
        out.y = Math.floor(a.y);
        return out;
      };
      Vec2.min = function min(out, a, b) {
        out.x = Math.min(a.x, b.x);
        out.y = Math.min(a.y, b.y);
        return out;
      };
      Vec2.max = function max(out, a, b) {
        out.x = Math.max(a.x, b.x);
        out.y = Math.max(a.y, b.y);
        return out;
      };
      Vec2.round = function round(out, a) {
        out.x = Math.round(a.x);
        out.y = Math.round(a.y);
        return out;
      };
      Vec2.multiplyScalar = function multiplyScalar(out, a, b) {
        out.x = a.x * b;
        out.y = a.y * b;
        return out;
      };
      Vec2.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
        out.x = a.x + b.x * scale;
        out.y = a.y + b.y * scale;
        return out;
      };
      Vec2.distance = function distance(a, b) {
        _x = b.x - a.x;
        _y = b.y - a.y;
        return Math.sqrt(_x * _x + _y * _y);
      };
      Vec2.squaredDistance = function squaredDistance(a, b) {
        _x = b.x - a.x;
        _y = b.y - a.y;
        return _x * _x + _y * _y;
      };
      Vec2.len = function len(a) {
        _x = a.x;
        _y = a.y;
        return Math.sqrt(_x * _x + _y * _y);
      };
      Vec2.lengthSqr = function lengthSqr(a) {
        _x = a.x;
        _y = a.y;
        return _x * _x + _y * _y;
      };
      Vec2.negate = function negate(out, a) {
        out.x = -a.x;
        out.y = -a.y;
        return out;
      };
      Vec2.inverse = function inverse(out, a) {
        out.x = 1 / a.x;
        out.y = 1 / a.y;
        return out;
      };
      Vec2.inverseSafe = function inverseSafe(out, a) {
        _x = a.x;
        _y = a.y;
        Math.abs(_x) < _utils.EPSILON ? out.x = 0 : out.x = 1 / _x;
        Math.abs(_y) < _utils.EPSILON ? out.y = 0 : out.y = 1 / _y;
        return out;
      };
      Vec2.normalize = function normalize(out, a) {
        _x = a.x;
        _y = a.y;
        var len = _x * _x + _y * _y;
        if (len > 0) {
          len = 1 / Math.sqrt(len);
          out.x = _x * len;
          out.y = _y * len;
        }
        return out;
      };
      Vec2.dot = function dot(a, b) {
        return a.x * b.x + a.y * b.y;
      };
      Vec2.cross = function cross(out, a, b) {
        out.x = out.y = 0;
        out.z = a.x * b.y - a.y * b.x;
        return out;
      };
      Vec2.lerp = function lerp(out, a, b, t) {
        _x = a.x;
        _y = a.y;
        out.x = _x + t * (b.x - _x);
        out.y = _y + t * (b.y - _y);
        return out;
      };
      Vec2.random = function random(out, scale) {
        scale = scale || 1;
        var r = 2 * (0, _utils.random)() * Math.PI;
        out.x = Math.cos(r) * scale;
        out.y = Math.sin(r) * scale;
        return out;
      };
      Vec2.transformMat3 = function transformMat3(out, a, mat) {
        _x = a.x;
        _y = a.y;
        var m = mat.m;
        out.x = m[0] * _x + m[3] * _y + m[6];
        out.y = m[1] * _x + m[4] * _y + m[7];
        return out;
      };
      Vec2.transformMat4 = function transformMat4(out, a, mat) {
        _x = a.x;
        _y = a.y;
        var m = mat.m;
        out.x = m[0] * _x + m[4] * _y + m[12];
        out.y = m[1] * _x + m[5] * _y + m[13];
        return out;
      };
      Vec2.strictEquals = function strictEquals(a, b) {
        return a.x === b.x && a.y === b.y;
      };
      Vec2.equals = function equals(a, b, epsilon) {
        void 0 === epsilon && (epsilon = _utils.EPSILON);
        return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y));
      };
      Vec2.angle = function angle(a, b) {
        Vec2.normalize(v2_1, a);
        Vec2.normalize(v2_2, b);
        var cosine = Vec2.dot(v2_1, v2_2);
        if (cosine > 1) return 0;
        if (cosine < -1) return Math.PI;
        return Math.acos(cosine);
      };
      Vec2.toArray = function toArray(out, v, ofs) {
        void 0 === ofs && (ofs = 0);
        out[ofs + 0] = v.x;
        out[ofs + 1] = v.y;
        return out;
      };
      Vec2.fromArray = function fromArray(out, arr, ofs) {
        void 0 === ofs && (ofs = 0);
        out.x = arr[ofs + 0];
        out.y = arr[ofs + 1];
        return out;
      };
      function Vec2(x, y) {
        var _this;
        void 0 === x && (x = 0);
        void 0 === y && (y = 0);
        _this = _ValueType.call(this) || this;
        _this.mag = Vec2.prototype.len;
        _this.magSqr = Vec2.prototype.lengthSqr;
        _this.subSelf = Vec2.prototype.subtract;
        _this.mulSelf = Vec2.prototype.multiplyScalar;
        _this.divSelf = Vec2.prototype.divide;
        _this.scaleSelf = Vec2.prototype.multiply;
        _this.negSelf = Vec2.prototype.negate;
        _this.x = void 0;
        _this.y = void 0;
        _this.z = 0;
        if (x && "object" === typeof x) {
          _this.x = x.x || 0;
          _this.y = x.y || 0;
        } else {
          _this.x = x || 0;
          _this.y = y || 0;
        }
        return _this;
      }
      _proto.clone = function clone() {
        return new Vec2(this.x, this.y);
      };
      _proto.set = function set(newValue) {
        this.x = newValue.x;
        this.y = newValue.y;
        return this;
      };
      _proto.equals = function equals(other) {
        return other && this.x === other.x && this.y === other.y;
      };
      _proto.fuzzyEquals = function fuzzyEquals(other, variance) {
        if (this.x - variance <= other.x && other.x <= this.x + variance && this.y - variance <= other.y && other.y <= this.y + variance) return true;
        return false;
      };
      _proto.toString = function toString() {
        return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ")";
      };
      _proto.lerp = function lerp(to, ratio, out) {
        out = out || new Vec2();
        var x = this.x;
        var y = this.y;
        out.x = x + (to.x - x) * ratio;
        out.y = y + (to.y - y) * ratio;
        return out;
      };
      _proto.clampf = function clampf(min_inclusive, max_inclusive) {
        this.x = _misc["default"].clampf(this.x, min_inclusive.x, max_inclusive.x);
        this.y = _misc["default"].clampf(this.y, min_inclusive.y, max_inclusive.y);
        return this;
      };
      _proto.add = function add(vector, out) {
        out = out || new Vec2();
        out.x = this.x + vector.x;
        out.y = this.y + vector.y;
        return out;
      };
      _proto.addSelf = function addSelf(vector) {
        this.x += vector.x;
        this.y += vector.y;
        return this;
      };
      _proto.subtract = function subtract(vector) {
        this.x -= vector.x;
        this.y -= vector.y;
        return this;
      };
      _proto.multiplyScalar = function multiplyScalar(num) {
        this.x *= num;
        this.y *= num;
        return this;
      };
      _proto.multiply = function multiply(vector) {
        this.x *= vector.x;
        this.y *= vector.y;
        return this;
      };
      _proto.divide = function divide(num) {
        this.x /= num;
        this.y /= num;
        return this;
      };
      _proto.negate = function negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      };
      _proto.dot = function dot(vector) {
        return this.x * vector.x + this.y * vector.y;
      };
      _proto.cross = function cross(vector) {
        return this.x * vector.y - this.y * vector.x;
      };
      _proto.len = function len() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      };
      _proto.lengthSqr = function lengthSqr() {
        return this.x * this.x + this.y * this.y;
      };
      _proto.normalizeSelf = function normalizeSelf() {
        var magSqr = this.x * this.x + this.y * this.y;
        if (1 === magSqr) return this;
        if (0 === magSqr) return this;
        var invsqrt = 1 / Math.sqrt(magSqr);
        this.x *= invsqrt;
        this.y *= invsqrt;
        return this;
      };
      _proto.normalize = function normalize(out) {
        out = out || new Vec2();
        out.x = this.x;
        out.y = this.y;
        out.normalizeSelf();
        return out;
      };
      _proto.angle = function angle(vector) {
        var magSqr1 = this.magSqr();
        var magSqr2 = vector.magSqr();
        if (0 === magSqr1 || 0 === magSqr2) {
          console.warn("Can't get angle between zero vector");
          return 0;
        }
        var dot = this.dot(vector);
        var theta = dot / Math.sqrt(magSqr1 * magSqr2);
        theta = _misc["default"].clampf(theta, -1, 1);
        return Math.acos(theta);
      };
      _proto.signAngle = function signAngle(vector) {
        var angle = this.angle(vector);
        return this.cross(vector) < 0 ? -angle : angle;
      };
      _proto.rotate = function rotate(radians, out) {
        out = out || new Vec2();
        out.x = this.x;
        out.y = this.y;
        return out.rotateSelf(radians);
      };
      _proto.rotateSelf = function rotateSelf(radians) {
        var sin = Math.sin(radians);
        var cos = Math.cos(radians);
        var x = this.x;
        this.x = cos * x - sin * this.y;
        this.y = sin * x + cos * this.y;
        return this;
      };
      _proto.project = function project(vector) {
        return vector.multiplyScalar(this.dot(vector) / vector.dot(vector));
      };
      _proto.transformMat4 = function transformMat4(m, out) {
        out = out || new Vec2();
        Vec2.transformMat4(out, this, m);
        return out;
      };
      _proto.maxAxis = function maxAxis() {
        return Math.max(this.x, this.y);
      };
      _createClass(Vec2, null, [ {
        key: "ONE",
        get: function get() {
          return new Vec2(1, 1);
        }
      }, {
        key: "ZERO",
        get: function get() {
          return new Vec2(0, 0);
        }
      }, {
        key: "UP",
        get: function get() {
          return new Vec2(0, 1);
        }
      }, {
        key: "RIGHT",
        get: function get() {
          return new Vec2(1, 0);
        }
      } ]);
      return Vec2;
    })(_valueType["default"]);
    exports["default"] = Vec2;
    Vec2.sub = Vec2.subtract;
    Vec2.mul = Vec2.multiply;
    Vec2.scale = Vec2.multiplyScalar;
    Vec2.mag = Vec2.len;
    Vec2.squaredMagnitude = Vec2.lengthSqr;
    Vec2.div = Vec2.divide;
    Vec2.ONE_R = Vec2.ONE;
    Vec2.ZERO_R = Vec2.ZERO;
    Vec2.UP_R = Vec2.UP;
    Vec2.RIGHT_R = Vec2.RIGHT;
    var v2_1 = new Vec2();
    var v2_2 = new Vec2();
    _CCClass["default"].fastDefine("cc.Vec2", Vec2, {
      x: 0,
      y: 0
    });
    cc.v2 = function v2(x, y) {
      return new Vec2(x, y);
    };
    cc.Vec2 = Vec2;
    module.exports = exports["default"];
  }), {
    "../platform/CCClass": 272,
    "../utils/misc": 386,
    "./utils": 408,
    "./value-type": 409
  } ],
  411: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _valueType = _interopRequireDefault(require("./value-type"));
    var _CCClass = _interopRequireDefault(require("../platform/CCClass"));
    var _misc = _interopRequireDefault(require("../utils/misc"));
    var _vec = _interopRequireDefault(require("./vec2"));
    var _utils = require("./utils");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var _x = 0;
    var _y = 0;
    var _z = 0;
    var Vec3 = (function(_ValueType) {
      _inheritsLoose(Vec3, _ValueType);
      var _proto = Vec3.prototype;
      _proto.sub = function sub(vector, out) {
        return Vec3.subtract(out || new Vec3(), this, vector);
      };
      _proto.mul = function mul(num, out) {
        return Vec3.multiplyScalar(out || new Vec3(), this, num);
      };
      _proto.div = function div(num, out) {
        return Vec3.multiplyScalar(out || new Vec3(), this, 1 / num);
      };
      _proto.scale = function scale(vector, out) {
        return Vec3.multiply(out || new Vec3(), this, vector);
      };
      _proto.neg = function neg(out) {
        return Vec3.negate(out || new Vec3(), this);
      };
      Vec3.zero = function zero(out) {
        out.x = 0;
        out.y = 0;
        out.z = 0;
        return out;
      };
      Vec3.clone = function clone(a) {
        return new Vec3(a.x, a.y, a.z);
      };
      Vec3.copy = function copy(out, a) {
        out.x = a.x;
        out.y = a.y;
        out.z = a.z;
        return out;
      };
      Vec3.set = function set(out, x, y, z) {
        out.x = x;
        out.y = y;
        out.z = z;
        return out;
      };
      Vec3.add = function add(out, a, b) {
        out.x = a.x + b.x;
        out.y = a.y + b.y;
        out.z = a.z + b.z;
        return out;
      };
      Vec3.subtract = function subtract(out, a, b) {
        out.x = a.x - b.x;
        out.y = a.y - b.y;
        out.z = a.z - b.z;
        return out;
      };
      Vec3.multiply = function multiply(out, a, b) {
        out.x = a.x * b.x;
        out.y = a.y * b.y;
        out.z = a.z * b.z;
        return out;
      };
      Vec3.divide = function divide(out, a, b) {
        out.x = a.x / b.x;
        out.y = a.y / b.y;
        out.z = a.z / b.z;
        return out;
      };
      Vec3.ceil = function ceil(out, a) {
        out.x = Math.ceil(a.x);
        out.y = Math.ceil(a.y);
        out.z = Math.ceil(a.z);
        return out;
      };
      Vec3.floor = function floor(out, a) {
        out.x = Math.floor(a.x);
        out.y = Math.floor(a.y);
        out.z = Math.floor(a.z);
        return out;
      };
      Vec3.min = function min(out, a, b) {
        out.x = Math.min(a.x, b.x);
        out.y = Math.min(a.y, b.y);
        out.z = Math.min(a.z, b.z);
        return out;
      };
      Vec3.max = function max(out, a, b) {
        out.x = Math.max(a.x, b.x);
        out.y = Math.max(a.y, b.y);
        out.z = Math.max(a.z, b.z);
        return out;
      };
      Vec3.round = function round(out, a) {
        out.x = Math.round(a.x);
        out.y = Math.round(a.y);
        out.z = Math.round(a.z);
        return out;
      };
      Vec3.multiplyScalar = function multiplyScalar(out, a, b) {
        out.x = a.x * b;
        out.y = a.y * b;
        out.z = a.z * b;
        return out;
      };
      Vec3.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
        out.x = a.x + b.x * scale;
        out.y = a.y + b.y * scale;
        out.z = a.z + b.z * scale;
        return out;
      };
      Vec3.distance = function distance(a, b) {
        _x = b.x - a.x;
        _y = b.y - a.y;
        _z = b.z - a.z;
        return Math.sqrt(_x * _x + _y * _y + _z * _z);
      };
      Vec3.squaredDistance = function squaredDistance(a, b) {
        _x = b.x - a.x;
        _y = b.y - a.y;
        _z = b.z - a.z;
        return _x * _x + _y * _y + _z * _z;
      };
      Vec3.len = function len(a) {
        _x = a.x;
        _y = a.y;
        _z = a.z;
        return Math.sqrt(_x * _x + _y * _y + _z * _z);
      };
      Vec3.lengthSqr = function lengthSqr(a) {
        _x = a.x;
        _y = a.y;
        _z = a.z;
        return _x * _x + _y * _y + _z * _z;
      };
      Vec3.negate = function negate(out, a) {
        out.x = -a.x;
        out.y = -a.y;
        out.z = -a.z;
        return out;
      };
      Vec3.inverse = function inverse(out, a) {
        out.x = 1 / a.x;
        out.y = 1 / a.y;
        out.z = 1 / a.z;
        return out;
      };
      Vec3.inverseSafe = function inverseSafe(out, a) {
        _x = a.x;
        _y = a.y;
        _z = a.z;
        Math.abs(_x) < _utils.EPSILON ? out.x = 0 : out.x = 1 / _x;
        Math.abs(_y) < _utils.EPSILON ? out.y = 0 : out.y = 1 / _y;
        Math.abs(_z) < _utils.EPSILON ? out.z = 0 : out.z = 1 / _z;
        return out;
      };
      Vec3.normalize = function normalize(out, a) {
        _x = a.x;
        _y = a.y;
        _z = a.z;
        var len = _x * _x + _y * _y + _z * _z;
        if (len > 0) {
          len = 1 / Math.sqrt(len);
          out.x = _x * len;
          out.y = _y * len;
          out.z = _z * len;
        }
        return out;
      };
      Vec3.dot = function dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
      };
      Vec3.cross = function cross(out, a, b) {
        var ax = a.x, ay = a.y, az = a.z;
        var bx = b.x, by = b.y, bz = b.z;
        out.x = ay * bz - az * by;
        out.y = az * bx - ax * bz;
        out.z = ax * by - ay * bx;
        return out;
      };
      Vec3.lerp = function lerp(out, a, b, t) {
        out.x = a.x + t * (b.x - a.x);
        out.y = a.y + t * (b.y - a.y);
        out.z = a.z + t * (b.z - a.z);
        return out;
      };
      Vec3.random = function random(out, scale) {
        scale = scale || 1;
        var phi = 2 * (0, _utils.random)() * Math.PI;
        var cosTheta = 2 * (0, _utils.random)() - 1;
        var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
        out.x = sinTheta * Math.cos(phi) * scale;
        out.y = sinTheta * Math.sin(phi) * scale;
        out.z = cosTheta * scale;
        return out;
      };
      Vec3.transformMat4 = function transformMat4(out, a, mat) {
        _x = a.x;
        _y = a.y;
        _z = a.z;
        var m = mat.m;
        var rhw = m[3] * _x + m[7] * _y + m[11] * _z + m[15];
        rhw = rhw ? 1 / rhw : 1;
        out.x = (m[0] * _x + m[4] * _y + m[8] * _z + m[12]) * rhw;
        out.y = (m[1] * _x + m[5] * _y + m[9] * _z + m[13]) * rhw;
        out.z = (m[2] * _x + m[6] * _y + m[10] * _z + m[14]) * rhw;
        return out;
      };
      Vec3.transformMat4Normal = function transformMat4Normal(out, a, mat) {
        _x = a.x;
        _y = a.y;
        _z = a.z;
        var m = mat.m;
        var rhw = m[3] * _x + m[7] * _y + m[11] * _z;
        rhw = rhw ? 1 / rhw : 1;
        out.x = (m[0] * _x + m[4] * _y + m[8] * _z) * rhw;
        out.y = (m[1] * _x + m[5] * _y + m[9] * _z) * rhw;
        out.z = (m[2] * _x + m[6] * _y + m[10] * _z) * rhw;
        return out;
      };
      Vec3.transformMat3 = function transformMat3(out, a, mat) {
        _x = a.x;
        _y = a.y;
        _z = a.z;
        var m = mat.m;
        out.x = _x * m[0] + _y * m[3] + _z * m[6];
        out.y = _x * m[1] + _y * m[4] + _z * m[7];
        out.z = _x * m[2] + _y * m[5] + _z * m[8];
        return out;
      };
      Vec3.transformAffine = function transformAffine(out, v, mat) {
        _x = v.x;
        _y = v.y;
        _z = v.z;
        var m = mat.m;
        out.x = m[0] * _x + m[1] * _y + m[2] * _z + m[3];
        out.y = m[4] * _x + m[5] * _y + m[6] * _z + m[7];
        out.x = m[8] * _x + m[9] * _y + m[10] * _z + m[11];
        return out;
      };
      Vec3.transformQuat = function transformQuat(out, a, q) {
        var ix = q.w * a.x + q.y * a.z - q.z * a.y;
        var iy = q.w * a.y + q.z * a.x - q.x * a.z;
        var iz = q.w * a.z + q.x * a.y - q.y * a.x;
        var iw = -q.x * a.x - q.y * a.y - q.z * a.z;
        out.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;
        out.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;
        out.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;
        return out;
      };
      Vec3.transformRTS = function transformRTS(out, a, r, t, s) {
        var x = a.x * s.x;
        var y = a.y * s.y;
        var z = a.z * s.z;
        var ix = r.w * x + r.y * z - r.z * y;
        var iy = r.w * y + r.z * x - r.x * z;
        var iz = r.w * z + r.x * y - r.y * x;
        var iw = -r.x * x - r.y * y - r.z * z;
        out.x = ix * r.w + iw * -r.x + iy * -r.z - iz * -r.y + t.x;
        out.y = iy * r.w + iw * -r.y + iz * -r.x - ix * -r.z + t.y;
        out.z = iz * r.w + iw * -r.z + ix * -r.y - iy * -r.x + t.z;
        return out;
      };
      Vec3.transformInverseRTS = function transformInverseRTS(out, a, r, t, s) {
        var x = a.x - t.x;
        var y = a.y - t.y;
        var z = a.z - t.z;
        var ix = r.w * x - r.y * z + r.z * y;
        var iy = r.w * y - r.z * x + r.x * z;
        var iz = r.w * z - r.x * y + r.y * x;
        var iw = r.x * x + r.y * y + r.z * z;
        out.x = (ix * r.w + iw * r.x + iy * r.z - iz * r.y) / s.x;
        out.y = (iy * r.w + iw * r.y + iz * r.x - ix * r.z) / s.y;
        out.z = (iz * r.w + iw * r.z + ix * r.y - iy * r.x) / s.z;
        return out;
      };
      Vec3.rotateX = function rotateX(out, v, o, a) {
        _x = v.x - o.x;
        _y = v.y - o.y;
        _z = v.z - o.z;
        var cos = Math.cos(a);
        var sin = Math.sin(a);
        var rx = _x;
        var ry = _y * cos - _z * sin;
        var rz = _y * sin + _z * cos;
        out.x = rx + o.x;
        out.y = ry + o.y;
        out.z = rz + o.z;
        return out;
      };
      Vec3.rotateY = function rotateY(out, v, o, a) {
        _x = v.x - o.x;
        _y = v.y - o.y;
        _z = v.z - o.z;
        var cos = Math.cos(a);
        var sin = Math.sin(a);
        var rx = _z * sin + _x * cos;
        var ry = _y;
        var rz = _z * cos - _x * sin;
        out.x = rx + o.x;
        out.y = ry + o.y;
        out.z = rz + o.z;
        return out;
      };
      Vec3.rotateZ = function rotateZ(out, v, o, a) {
        _x = v.x - o.x;
        _y = v.y - o.y;
        _z = v.z - o.z;
        var cos = Math.cos(a);
        var sin = Math.sin(a);
        var rx = _x * cos - _y * sin;
        var ry = _x * sin + _y * cos;
        var rz = _z;
        out.x = rx + o.x;
        out.y = ry + o.y;
        out.z = rz + o.z;
        return out;
      };
      Vec3.strictEquals = function strictEquals(a, b) {
        return a.x === b.x && a.y === b.y && a.z === b.z;
      };
      Vec3.equals = function equals(a, b, epsilon) {
        void 0 === epsilon && (epsilon = _utils.EPSILON);
        var a0 = a.x, a1 = a.y, a2 = a.z;
        var b0 = b.x, b1 = b.y, b2 = b.z;
        return Math.abs(a0 - b0) <= epsilon * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= epsilon * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= epsilon * Math.max(1, Math.abs(a2), Math.abs(b2));
      };
      Vec3.angle = function angle(a, b) {
        Vec3.normalize(v3_1, a);
        Vec3.normalize(v3_2, b);
        var cosine = Vec3.dot(v3_1, v3_2);
        if (cosine > 1) return 0;
        if (cosine < -1) return Math.PI;
        return Math.acos(cosine);
      };
      Vec3.projectOnPlane = function projectOnPlane(out, a, n) {
        return Vec3.subtract(out, a, Vec3.project(out, a, n));
      };
      Vec3.project = function project(out, a, b) {
        var sqrLen = Vec3.lengthSqr(b);
        return sqrLen < 1e-6 ? Vec3.set(out, 0, 0, 0) : Vec3.multiplyScalar(out, b, Vec3.dot(a, b) / sqrLen);
      };
      Vec3.toArray = function toArray(out, v, ofs) {
        void 0 === ofs && (ofs = 0);
        out[ofs + 0] = v.x;
        out[ofs + 1] = v.y;
        out[ofs + 2] = v.z;
        return out;
      };
      Vec3.fromArray = function fromArray(out, arr, ofs) {
        void 0 === ofs && (ofs = 0);
        out.x = arr[ofs + 0];
        out.y = arr[ofs + 1];
        out.z = arr[ofs + 2];
        return out;
      };
      function Vec3(x, y, z) {
        var _this;
        void 0 === x && (x = 0);
        void 0 === y && (y = 0);
        void 0 === z && (z = 0);
        _this = _ValueType.call(this) || this;
        _this.mag = Vec3.prototype.len;
        _this.magSqr = Vec3.prototype.lengthSqr;
        _this.subSelf = Vec3.prototype.subtract;
        _this.mulSelf = Vec3.prototype.multiplyScalar;
        _this.divSelf = Vec3.prototype.divide;
        _this.scaleSelf = Vec3.prototype.multiply;
        _this.negSelf = Vec3.prototype.negate;
        _this.x = void 0;
        _this.y = void 0;
        _this.z = void 0;
        _this.angle = _vec["default"].prototype.angle;
        _this.project = _vec["default"].prototype.project;
        if (x && "object" === typeof x) {
          _this.x = x.x;
          _this.y = x.y;
          _this.z = x.z;
        } else {
          _this.x = x;
          _this.y = y;
          _this.z = z;
        }
        return _this;
      }
      _proto.clone = function clone() {
        return new Vec3(this.x, this.y, this.z);
      };
      _proto.set = function set(newValue) {
        this.x = newValue.x;
        this.y = newValue.y;
        this.z = newValue.z;
        return this;
      };
      _proto.equals = function equals(other) {
        return other && this.x === other.x && this.y === other.y && this.z === other.z;
      };
      _proto.fuzzyEquals = function fuzzyEquals(other, variance) {
        if (this.x - variance <= other.x && other.x <= this.x + variance && this.y - variance <= other.y && other.y <= this.y + variance && this.z - variance <= other.z && other.z <= this.z + variance) return true;
        return false;
      };
      _proto.toString = function toString() {
        return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.z.toFixed(2) + ")";
      };
      _proto.lerp = function lerp(to, ratio, out) {
        out = out || new Vec3();
        Vec3.lerp(out, this, to, ratio);
        return out;
      };
      _proto.clampf = function clampf(min_inclusive, max_inclusive) {
        this.x = _misc["default"].clampf(this.x, min_inclusive.x, max_inclusive.x);
        this.y = _misc["default"].clampf(this.y, min_inclusive.y, max_inclusive.y);
        this.z = _misc["default"].clampf(this.z, min_inclusive.z, max_inclusive.z);
        return this;
      };
      _proto.addSelf = function addSelf(vector) {
        this.x += vector.x;
        this.y += vector.y;
        this.z += vector.z;
        return this;
      };
      _proto.add = function add(vector, out) {
        out = out || new Vec3();
        out.x = this.x + vector.x;
        out.y = this.y + vector.y;
        out.z = this.z + vector.z;
        return out;
      };
      _proto.subtract = function subtract(vector) {
        this.x -= vector.x;
        this.y -= vector.y;
        this.z -= vector.z;
        return this;
      };
      _proto.multiplyScalar = function multiplyScalar(num) {
        this.x *= num;
        this.y *= num;
        this.z *= num;
        return this;
      };
      _proto.multiply = function multiply(vector) {
        this.x *= vector.x;
        this.y *= vector.y;
        this.z *= vector.z;
        return this;
      };
      _proto.divide = function divide(num) {
        this.x /= num;
        this.y /= num;
        this.z /= num;
        return this;
      };
      _proto.negate = function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      };
      _proto.dot = function dot(vector) {
        return this.x * vector.x + this.y * vector.y + this.z * vector.z;
      };
      _proto.cross = function cross(vector, out) {
        out = out || new Vec3();
        Vec3.cross(out, this, vector);
        return out;
      };
      _proto.len = function len() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      };
      _proto.lengthSqr = function lengthSqr() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      };
      _proto.normalizeSelf = function normalizeSelf() {
        Vec3.normalize(this, this);
        return this;
      };
      _proto.normalize = function normalize(out) {
        out = out || new Vec3();
        Vec3.normalize(out, this);
        return out;
      };
      _proto.transformMat4 = function transformMat4(m, out) {
        out = out || new Vec3();
        Vec3.transformMat4(out, this, m);
        return out;
      };
      _proto.maxAxis = function maxAxis() {
        return Math.max(this.x, this.y, this.z);
      };
      _proto.signAngle = function signAngle(vector) {
        cc.warnID(1408, "vec3.signAngle", "v2.1", "cc.v2(selfVector).signAngle(vector)");
        var vec1 = new _vec["default"](this.x, this.y);
        var vec2 = new _vec["default"](vector.x, vector.y);
        return vec1.signAngle(vec2);
      };
      _proto.rotate = function rotate(radians, out) {
        cc.warnID(1408, "vec3.rotate", "v2.1", "cc.v2(selfVector).rotate(radians, out)");
        return _vec["default"].prototype.rotate.call(this, radians, out);
      };
      _proto.rotateSelf = function rotateSelf(radians) {
        cc.warnID(1408, "vec3.rotateSelf", "v2.1", "cc.v2(selfVector).rotateSelf(radians)");
        return _vec["default"].prototype.rotateSelf.call(this, radians);
      };
      _createClass(Vec3, null, [ {
        key: "ONE",
        get: function get() {
          return new Vec3(1, 1, 1);
        }
      }, {
        key: "ZERO",
        get: function get() {
          return new Vec3();
        }
      }, {
        key: "UP",
        get: function get() {
          return new Vec3(0, 1, 0);
        }
      }, {
        key: "RIGHT",
        get: function get() {
          return new Vec3(1, 0, 0);
        }
      }, {
        key: "FORWARD",
        get: function get() {
          return new Vec3(0, 0, 1);
        }
      } ]);
      return Vec3;
    })(_valueType["default"]);
    exports["default"] = Vec3;
    Vec3.sub = Vec3.subtract;
    Vec3.mul = Vec3.multiply;
    Vec3.scale = Vec3.multiplyScalar;
    Vec3.mag = Vec3.len;
    Vec3.squaredMagnitude = Vec3.lengthSqr;
    Vec3.div = Vec3.divide;
    Vec3.ONE_R = Vec3.ONE;
    Vec3.ZERO_R = Vec3.ZERO;
    Vec3.UP_R = Vec3.UP;
    Vec3.RIGHT_R = Vec3.RIGHT;
    Vec3.FRONT_R = Vec3.FORWARD;
    var v3_1 = new Vec3();
    var v3_2 = new Vec3();
    _CCClass["default"].fastDefine("cc.Vec3", Vec3, {
      x: 0,
      y: 0,
      z: 0
    });
    cc.v3 = function v3(x, y, z) {
      return new Vec3(x, y, z);
    };
    cc.Vec3 = Vec3;
    module.exports = exports["default"];
  }), {
    "../platform/CCClass": 272,
    "../utils/misc": 386,
    "./utils": 408,
    "./value-type": 409,
    "./vec2": 410
  } ],
  412: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    exports.v4 = v4;
    var _CCClass = _interopRequireDefault(require("../platform/CCClass"));
    var _valueType = _interopRequireDefault(require("./value-type"));
    var _utils = require("./utils");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var _x = 0;
    var _y = 0;
    var _z = 0;
    var _w = 0;
    var Vec4 = (function(_ValueType) {
      _inheritsLoose(Vec4, _ValueType);
      var _proto = Vec4.prototype;
      _proto.sub = function sub(vector, out) {
        return Vec4.subtract(out || new Vec4(), this, vector);
      };
      _proto.mul = function mul(num, out) {
        return Vec4.multiplyScalar(out || new Vec4(), this, num);
      };
      _proto.div = function div(num, out) {
        return Vec4.multiplyScalar(out || new Vec4(), this, 1 / num);
      };
      _proto.scale = function scale(vector, out) {
        return Vec4.multiply(out || new Vec4(), this, vector);
      };
      _proto.neg = function neg(out) {
        return Vec4.negate(out || new Vec4(), this);
      };
      Vec4.clone = function clone(a) {
        return new Vec4(a.x, a.y, a.z, a.w);
      };
      Vec4.copy = function copy(out, a) {
        out.x = a.x;
        out.y = a.y;
        out.z = a.z;
        out.w = a.w;
        return out;
      };
      Vec4.set = function set(out, x, y, z, w) {
        out.x = x;
        out.y = y;
        out.z = z;
        out.w = w;
        return out;
      };
      Vec4.add = function add(out, a, b) {
        out.x = a.x + b.x;
        out.y = a.y + b.y;
        out.z = a.z + b.z;
        out.w = a.w + b.w;
        return out;
      };
      Vec4.subtract = function subtract(out, a, b) {
        out.x = a.x - b.x;
        out.y = a.y - b.y;
        out.z = a.z - b.z;
        out.w = a.w - b.w;
        return out;
      };
      Vec4.multiply = function multiply(out, a, b) {
        out.x = a.x * b.x;
        out.y = a.y * b.y;
        out.z = a.z * b.z;
        out.w = a.w * b.w;
        return out;
      };
      Vec4.divide = function divide(out, a, b) {
        out.x = a.x / b.x;
        out.y = a.y / b.y;
        out.z = a.z / b.z;
        out.w = a.w / b.w;
        return out;
      };
      Vec4.ceil = function ceil(out, a) {
        out.x = Math.ceil(a.x);
        out.y = Math.ceil(a.y);
        out.z = Math.ceil(a.z);
        out.w = Math.ceil(a.w);
        return out;
      };
      Vec4.floor = function floor(out, a) {
        out.x = Math.floor(a.x);
        out.y = Math.floor(a.y);
        out.z = Math.floor(a.z);
        out.w = Math.floor(a.w);
        return out;
      };
      Vec4.min = function min(out, a, b) {
        out.x = Math.min(a.x, b.x);
        out.y = Math.min(a.y, b.y);
        out.z = Math.min(a.z, b.z);
        out.w = Math.min(a.w, b.w);
        return out;
      };
      Vec4.max = function max(out, a, b) {
        out.x = Math.max(a.x, b.x);
        out.y = Math.max(a.y, b.y);
        out.z = Math.max(a.z, b.z);
        out.w = Math.max(a.w, b.w);
        return out;
      };
      Vec4.round = function round(out, a) {
        out.x = Math.round(a.x);
        out.y = Math.round(a.y);
        out.z = Math.round(a.z);
        out.w = Math.round(a.w);
        return out;
      };
      Vec4.multiplyScalar = function multiplyScalar(out, a, b) {
        out.x = a.x * b;
        out.y = a.y * b;
        out.z = a.z * b;
        out.w = a.w * b;
        return out;
      };
      Vec4.scaleAndAdd = function scaleAndAdd(out, a, b, scale) {
        out.x = a.x + b.x * scale;
        out.y = a.y + b.y * scale;
        out.z = a.z + b.z * scale;
        out.w = a.w + b.w * scale;
        return out;
      };
      Vec4.distance = function distance(a, b) {
        var x = b.x - a.x;
        var y = b.y - a.y;
        var z = b.z - a.z;
        var w = b.w - a.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      };
      Vec4.squaredDistance = function squaredDistance(a, b) {
        var x = b.x - a.x;
        var y = b.y - a.y;
        var z = b.z - a.z;
        var w = b.w - a.w;
        return x * x + y * y + z * z + w * w;
      };
      Vec4.len = function len(a) {
        _x = a.x;
        _y = a.y;
        _z = a.z;
        _w = a.w;
        return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
      };
      Vec4.lengthSqr = function lengthSqr(a) {
        _x = a.x;
        _y = a.y;
        _z = a.z;
        _w = a.w;
        return _x * _x + _y * _y + _z * _z + _w * _w;
      };
      Vec4.negate = function negate(out, a) {
        out.x = -a.x;
        out.y = -a.y;
        out.z = -a.z;
        out.w = -a.w;
        return out;
      };
      Vec4.inverse = function inverse(out, a) {
        out.x = 1 / a.x;
        out.y = 1 / a.y;
        out.z = 1 / a.z;
        out.w = 1 / a.w;
        return out;
      };
      Vec4.inverseSafe = function inverseSafe(out, a) {
        _x = a.x;
        _y = a.y;
        _z = a.z;
        _w = a.w;
        Math.abs(_x) < _utils.EPSILON ? out.x = 0 : out.x = 1 / _x;
        Math.abs(_y) < _utils.EPSILON ? out.y = 0 : out.y = 1 / _y;
        Math.abs(_z) < _utils.EPSILON ? out.z = 0 : out.z = 1 / _z;
        Math.abs(_w) < _utils.EPSILON ? out.w = 0 : out.w = 1 / _w;
        return out;
      };
      Vec4.normalize = function normalize(out, a) {
        _x = a.x;
        _y = a.y;
        _z = a.z;
        _w = a.w;
        var len = _x * _x + _y * _y + _z * _z + _w * _w;
        if (len > 0) {
          len = 1 / Math.sqrt(len);
          out.x = _x * len;
          out.y = _y * len;
          out.z = _z * len;
          out.w = _w * len;
        }
        return out;
      };
      Vec4.dot = function dot(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
      };
      Vec4.lerp = function lerp(out, a, b, t) {
        out.x = a.x + t * (b.x - a.x);
        out.y = a.y + t * (b.y - a.y);
        out.z = a.z + t * (b.z - a.z);
        out.w = a.w + t * (b.w - a.w);
        return out;
      };
      Vec4.random = function random(out, scale) {
        scale = scale || 1;
        var phi = 2 * (0, _utils.random)() * Math.PI;
        var cosTheta = 2 * (0, _utils.random)() - 1;
        var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
        out.x = sinTheta * Math.cos(phi) * scale;
        out.y = sinTheta * Math.sin(phi) * scale;
        out.z = cosTheta * scale;
        out.w = 0;
        return out;
      };
      Vec4.transformMat4 = function transformMat4(out, a, mat) {
        _x = a.x;
        _y = a.y;
        _z = a.z;
        _w = a.w;
        var m = mat.m;
        out.x = m[0] * _x + m[4] * _y + m[8] * _z + m[12] * _w;
        out.y = m[1] * _x + m[5] * _y + m[9] * _z + m[13] * _w;
        out.z = m[2] * _x + m[6] * _y + m[10] * _z + m[14] * _w;
        out.w = m[3] * _x + m[7] * _y + m[11] * _z + m[15] * _w;
        return out;
      };
      Vec4.transformAffine = function transformAffine(out, v, mat) {
        _x = v.x;
        _y = v.y;
        _z = v.z;
        _w = v.w;
        var m = mat.m;
        out.x = m[0] * _x + m[1] * _y + m[2] * _z + m[3] * _w;
        out.y = m[4] * _x + m[5] * _y + m[6] * _z + m[7] * _w;
        out.x = m[8] * _x + m[9] * _y + m[10] * _z + m[11] * _w;
        out.w = v.w;
        return out;
      };
      Vec4.transformQuat = function transformQuat(out, a, q) {
        var x = a.x, y = a.y, z = a.z;
        _x = q.x;
        _y = q.y;
        _z = q.z;
        _w = q.w;
        var ix = _w * x + _y * z - _z * y;
        var iy = _w * y + _z * x - _x * z;
        var iz = _w * z + _x * y - _y * x;
        var iw = -_x * x - _y * y - _z * z;
        out.x = ix * _w + iw * -_x + iy * -_z - iz * -_y;
        out.y = iy * _w + iw * -_y + iz * -_x - ix * -_z;
        out.z = iz * _w + iw * -_z + ix * -_y - iy * -_x;
        out.w = a.w;
        return out;
      };
      Vec4.strictEquals = function strictEquals(a, b) {
        return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
      };
      Vec4.equals = function equals(a, b, epsilon) {
        void 0 === epsilon && (epsilon = _utils.EPSILON);
        return Math.abs(a.x - b.x) <= epsilon * Math.max(1, Math.abs(a.x), Math.abs(b.x)) && Math.abs(a.y - b.y) <= epsilon * Math.max(1, Math.abs(a.y), Math.abs(b.y)) && Math.abs(a.z - b.z) <= epsilon * Math.max(1, Math.abs(a.z), Math.abs(b.z)) && Math.abs(a.w - b.w) <= epsilon * Math.max(1, Math.abs(a.w), Math.abs(b.w));
      };
      Vec4.toArray = function toArray(out, v, ofs) {
        void 0 === ofs && (ofs = 0);
        out[ofs + 0] = v.x;
        out[ofs + 1] = v.y;
        out[ofs + 2] = v.z;
        out[ofs + 3] = v.w;
        return out;
      };
      Vec4.fromArray = function fromArray(out, arr, ofs) {
        void 0 === ofs && (ofs = 0);
        out.x = arr[ofs + 0];
        out.y = arr[ofs + 1];
        out.z = arr[ofs + 2];
        out.w = arr[ofs + 3];
        return out;
      };
      function Vec4(x, y, z, w) {
        var _this;
        void 0 === x && (x = 0);
        void 0 === y && (y = 0);
        void 0 === z && (z = 0);
        void 0 === w && (w = 0);
        _this = _ValueType.call(this) || this;
        _this.mag = Vec4.prototype.len;
        _this.magSqr = Vec4.prototype.lengthSqr;
        _this.subSelf = Vec4.prototype.subtract;
        _this.mulSelf = Vec4.prototype.multiplyScalar;
        _this.divSelf = Vec4.prototype.divide;
        _this.scaleSelf = Vec4.prototype.multiply;
        _this.negSelf = Vec4.prototype.negate;
        _this.x = void 0;
        _this.y = void 0;
        _this.z = void 0;
        _this.w = void 0;
        if (x && "object" === typeof x) {
          _this.x = x.x;
          _this.y = x.y;
          _this.z = x.z;
          _this.w = x.w;
        } else {
          _this.x = x;
          _this.y = y;
          _this.z = z;
          _this.w = w;
        }
        return _this;
      }
      _proto.clone = function clone() {
        return new Vec4(this.x, this.y, this.z, this.w);
      };
      _proto.set = function set(x, y, z, w) {
        if (x && "object" === typeof x) {
          this.x = x.x;
          this.y = x.y;
          this.z = x.z;
          this.w = x.w;
        } else {
          this.x = x || 0;
          this.y = y || 0;
          this.z = z || 0;
          this.w = w || 0;
        }
        return this;
      };
      _proto.equals = function equals(other, epsilon) {
        void 0 === epsilon && (epsilon = _utils.EPSILON);
        return Math.abs(this.x - other.x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(other.x)) && Math.abs(this.y - other.y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(other.y)) && Math.abs(this.z - other.z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(other.z)) && Math.abs(this.w - other.w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(other.w));
      };
      _proto.equals4f = function equals4f(x, y, z, w, epsilon) {
        void 0 === epsilon && (epsilon = _utils.EPSILON);
        return Math.abs(this.x - x) <= epsilon * Math.max(1, Math.abs(this.x), Math.abs(x)) && Math.abs(this.y - y) <= epsilon * Math.max(1, Math.abs(this.y), Math.abs(y)) && Math.abs(this.z - z) <= epsilon * Math.max(1, Math.abs(this.z), Math.abs(z)) && Math.abs(this.w - w) <= epsilon * Math.max(1, Math.abs(this.w), Math.abs(w));
      };
      _proto.strictEquals = function strictEquals(other) {
        return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;
      };
      _proto.strictEquals4f = function strictEquals4f(x, y, z, w) {
        return this.x === x && this.y === y && this.z === z && this.w === w;
      };
      _proto.lerp = function lerp(to, ratio) {
        _x = this.x;
        _y = this.y;
        _z = this.z;
        _w = this.w;
        this.x = _x + ratio * (to.x - _x);
        this.y = _y + ratio * (to.y - _y);
        this.z = _z + ratio * (to.z - _z);
        this.w = _w + ratio * (to.w - _w);
        return this;
      };
      _proto.toString = function toString() {
        return "(" + this.x.toFixed(2) + ", " + this.y.toFixed(2) + ", " + this.z.toFixed(2) + ", " + this.w.toFixed(2) + ")";
      };
      _proto.clampf = function clampf(minInclusive, maxInclusive) {
        this.x = (0, _utils.clamp)(this.x, minInclusive.x, maxInclusive.x);
        this.y = (0, _utils.clamp)(this.y, minInclusive.y, maxInclusive.y);
        this.z = (0, _utils.clamp)(this.z, minInclusive.z, maxInclusive.z);
        this.w = (0, _utils.clamp)(this.w, minInclusive.w, maxInclusive.w);
        return this;
      };
      _proto.addSelf = function addSelf(vector) {
        this.x += vector.x;
        this.y += vector.y;
        this.z += vector.z;
        this.w += vector.w;
        return this;
      };
      _proto.add = function add(vector, out) {
        out = out || new Vec4();
        out.x = this.x + vector.x;
        out.y = this.y + vector.y;
        out.z = this.z + vector.z;
        out.w = this.w + vector.w;
        return out;
      };
      _proto.subtract = function subtract(vector, out) {
        out = out || new Vec4();
        out.x = this.x - vector.x;
        out.y = this.y - vector.y;
        out.z = this.z - vector.z;
        out.w = this.w - vector.w;
        return out;
      };
      _proto.multiplyScalar = function multiplyScalar(num) {
        this.x *= num;
        this.y *= num;
        this.z *= num;
        this.w *= num;
        return this;
      };
      _proto.multiply = function multiply(vector) {
        this.x *= vector.x;
        this.y *= vector.y;
        this.z *= vector.z;
        this.w *= vector.w;
        return this;
      };
      _proto.divide = function divide(num) {
        this.x /= num;
        this.y /= num;
        this.z /= num;
        this.w /= num;
        return this;
      };
      _proto.negate = function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      };
      _proto.dot = function dot(vector) {
        return this.x * vector.x + this.y * vector.y + this.z * vector.z + this.w * vector.w;
      };
      _proto.cross = function cross(vector, out) {
        out = out || new Vec4();
        var ax = this.x, ay = this.y, az = this.z;
        var bx = vector.x, by = vector.y, bz = vector.z;
        out.x = ay * bz - az * by;
        out.y = az * bx - ax * bz;
        out.z = ax * by - ay * bx;
        return out;
      };
      _proto.len = function len() {
        var x = this.x, y = this.y, z = this.z, w = this.w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
      };
      _proto.lengthSqr = function lengthSqr() {
        var x = this.x, y = this.y, z = this.z, w = this.w;
        return x * x + y * y + z * z + w * w;
      };
      _proto.normalizeSelf = function normalizeSelf() {
        this.normalize(this);
        return this;
      };
      _proto.normalize = function normalize(out) {
        out = out || new Vec4();
        _x = this.x;
        _y = this.y;
        _z = this.z;
        _w = this.w;
        var len = _x * _x + _y * _y + _z * _z + _w * _w;
        if (len > 0) {
          len = 1 / Math.sqrt(len);
          out.x = _x * len;
          out.y = _y * len;
          out.z = _z * len;
          out.w = _w * len;
        }
        return out;
      };
      _proto.transformMat4 = function transformMat4(matrix, out) {
        out = out || new Vec4();
        _x = this.x;
        _y = this.y;
        _z = this.z;
        _w = this.w;
        var m = matrix.m;
        out.x = m[0] * _x + m[4] * _y + m[8] * _z + m[12] * _w;
        out.y = m[1] * _x + m[5] * _y + m[9] * _z + m[13] * _w;
        out.z = m[2] * _x + m[6] * _y + m[10] * _z + m[14] * _w;
        out.w = m[3] * _x + m[7] * _y + m[11] * _z + m[15] * _w;
        return out;
      };
      _proto.maxAxis = function maxAxis() {
        return Math.max(this.x, this.y, this.z, this.w);
      };
      _createClass(Vec4, null, [ {
        key: "ZERO",
        get: function get() {
          return new Vec4(0, 0, 0, 0);
        }
      }, {
        key: "ONE",
        get: function get() {
          return new Vec4(1, 1, 1, 1);
        }
      }, {
        key: "NEG_ONE",
        get: function get() {
          return new Vec4(-1, -1, -1, -1);
        }
      } ]);
      return Vec4;
    })(_valueType["default"]);
    exports["default"] = Vec4;
    Vec4.sub = Vec4.subtract;
    Vec4.mul = Vec4.multiply;
    Vec4.div = Vec4.divide;
    Vec4.scale = Vec4.multiplyScalar;
    Vec4.mag = Vec4.len;
    Vec4.squaredMagnitude = Vec4.lengthSqr;
    Vec4.ZERO_R = Vec4.ZERO;
    Vec4.ONE_R = Vec4.ONE;
    Vec4.NEG_ONE_R = Vec4.NEG_ONE;
    _CCClass["default"].fastDefine("cc.Vec4", Vec4, {
      x: 0,
      y: 0,
      z: 0,
      w: 0
    });
    function v4(x, y, z, w) {
      return new Vec4(x, y, z, w);
    }
    cc.v4 = v4;
    cc.Vec4 = Vec4;
  }), {
    "../platform/CCClass": 272,
    "./utils": 408,
    "./value-type": 409
  } ],
  413: [ (function(require, module, exports) {
    "use strict";
    var js = cc.js;
    true;
    var deprecateEnum = function deprecateEnum(obj, oldPath, newPath, hasTypePrefixBefore) {
      false;
      hasTypePrefixBefore = false !== hasTypePrefixBefore;
      var enumDef = Function("return " + newPath)();
      var entries = cc.Enum.getList(enumDef);
      var delimiter = hasTypePrefixBefore ? "_" : ".";
      for (var i = 0; i < entries.length; i++) {
        var entry = entries[i].name;
        var oldPropName;
        if (hasTypePrefixBefore) {
          var oldTypeName = oldPath.split(".").slice(-1)[0];
          oldPropName = oldTypeName + "_" + entry;
        } else oldPropName = entry;
        js.get(obj, oldPropName, function(entry) {
          cc.errorID(1400, oldPath + delimiter + entry, newPath + "." + entry);
          return enumDef[entry];
        }.bind(null, entry));
      }
    };
    var markAsRemoved = function markAsRemoved(ownerCtor, removedProps, ownerName) {
      if (!ownerCtor) return;
      ownerName = ownerName || js.getClassName(ownerCtor);
      removedProps.forEach((function(prop) {
        function error() {
          cc.errorID(1406, ownerName, prop);
        }
        js.getset(ownerCtor.prototype, prop, error, error);
      }));
    };
    var markAsDeprecated = function markAsDeprecated(ownerCtor, deprecatedProps, ownerName) {
      if (!ownerCtor) return;
      ownerName = ownerName || js.getClassName(ownerCtor);
      var descriptors = Object.getOwnPropertyDescriptors(ownerCtor.prototype);
      deprecatedProps.forEach((function(prop) {
        var deprecatedProp = prop[0];
        var newProp = prop[1];
        var descriptor = descriptors[deprecatedProp];
        js.getset(ownerCtor.prototype, deprecatedProp, (function() {
          cc.warnID(1400, ownerName + "." + deprecatedProp, ownerName + "." + newProp);
          return descriptor.get.call(this);
        }), (function(v) {
          cc.warnID(1400, ownerName + "." + deprecatedProp, ownerName + "." + newProp);
          descriptor.set.call(this, v);
        }));
      }));
    };
    var markAsRemovedInObject = function markAsRemovedInObject(ownerObj, removedProps, ownerName) {
      if (!ownerObj) return;
      removedProps.forEach((function(prop) {
        function error() {
          cc.errorID(1406, ownerName, prop);
        }
        js.getset(ownerObj, prop, error);
      }));
    };
    var provideClearError = function provideClearError(owner, obj, ownerName) {
      if (!owner) return;
      var className = ownerName || cc.js.getClassName(owner);
      var Info = "Sorry, " + className + ".%s is removed, please use %s instead.";
      var _loop = function _loop() {
        function define(prop, getset) {
          function accessor(newProp) {
            cc.error(Info, prop, newProp);
          }
          Array.isArray(getset) || (getset = getset.split(",").map((function(x) {
            return x.trim();
          })));
          try {
            js.getset(owner, prop, accessor.bind(null, getset[0]), getset[1] && accessor.bind(null, getset[1]));
          } catch (e) {}
        }
        getset = obj[prop];
        if ("*" === prop[0]) {
          etProp = prop.slice(1);
          define("g" + etProp, getset);
          define("s" + etProp, getset);
        } else prop.split(",").map((function(x) {
          return x.trim();
        })).forEach((function(x) {
          define(x, getset);
        }));
      };
      for (var prop in obj) {
        var getset;
        var etProp;
        _loop();
      }
    };
    var markFunctionWarning = function markFunctionWarning(ownerCtor, obj, ownerName) {
      if (!ownerCtor) return;
      ownerName = ownerName || js.getClassName(ownerCtor);
      for (var prop in obj) (function() {
        var propName = prop;
        var originFunc = ownerCtor[propName];
        if (!originFunc) return;
        function warn() {
          cc.warn("Sorry, %s.%s is deprecated. Please use %s instead", ownerName, propName, obj[propName]);
          return originFunc.apply(this, arguments);
        }
        ownerCtor[propName] = warn;
      })();
    };
    js.get(cc, "info", (function() {
      cc.errorID(1400, "cc.info", "cc.log");
      return cc.log;
    }));
    js.get(cc, "spriteFrameCache", (function() {
      cc.errorID(1404);
    }));
    js.get(cc, "vmath", (function() {
      cc.warnID(1400, "cc.vmath", "cc.math");
      return cc.math;
    }));
    js.get(cc.math, "vec2", (function() {
      cc.warnID(1400, "cc.vmath.vec2", "cc.Vec2");
      return cc.Vec2;
    }));
    js.get(cc.math, "vec3", (function() {
      cc.warnID(1400, "cc.vmath.vec3", "cc.Vec3");
      return cc.Vec3;
    }));
    js.get(cc.math, "vec4", (function() {
      cc.warnID(1400, "cc.vmath.vec4", "cc.Vec4");
      return cc.Vec4;
    }));
    js.get(cc.math, "mat4", (function() {
      cc.warnID(1400, "cc.vmath.mat4", "cc.Mat4");
      return cc.Mat4;
    }));
    js.get(cc.math, "mat3", (function() {
      cc.warnID(1400, "cc.vmath.mat3", "cc.Mat3");
      return cc.Mat3;
    }));
    js.get(cc.math, "quat", (function() {
      cc.warnID(1400, "cc.vmath.quat", "cc.Quat");
      return cc.Quat;
    }));
    js.get(cc.SpriteFrame.prototype, "_textureLoaded", (function() {
      cc.errorID(1400, "spriteFrame._textureLoaded", "spriteFrame.textureLoaded()");
      return this.textureLoaded();
    }));
    markAsRemoved(cc.SpriteFrame, [ "addLoadedEventListener" ]);
    markFunctionWarning(cc.Sprite.prototype, {
      setState: "cc.Sprite.setMaterial",
      getState: "cc.Sprite.getMaterial"
    }, "cc.Sprite");
    js.get(cc.SpriteFrame.prototype, "clearTexture", (function() {
      cc.errorID(1406, "cc.SpriteFrame", "clearTexture");
      return function() {};
    }));
    js.get(cc, "textureCache", (function() {
      cc.errorID(1406, "cc", "textureCache");
    }));
    var Texture2D = cc.Texture2D;
    js.get(Texture2D.prototype, "releaseTexture", (function() {
      cc.errorID(1400, "texture.releaseTexture()", "texture.destroy()");
      return this.destroy;
    }));
    js.get(Texture2D.prototype, "getName", (function() {
      cc.errorID(1400, "texture.getName()", "texture._glID");
      return function() {
        return this._glID || null;
      };
    }));
    js.get(Texture2D.prototype, "isLoaded", (function() {
      cc.errorID(1400, "texture.isLoaded function", "texture.loaded property");
      return function() {
        return this.loaded;
      };
    }));
    js.get(Texture2D.prototype, "setAntiAliasTexParameters", (function() {
      cc.errorID(1400, "texture.setAntiAliasTexParameters()", "texture.setFilters(cc.Texture2D.Filter.LINEAR, cc.Texture2D.Filter.LINEAR)");
      return function() {
        this.setFilters(Texture2D.Filter.LINEAR, Texture2D.Filter.LINEAR);
      };
    }));
    js.get(Texture2D.prototype, "setAliasTexParameters", (function() {
      cc.errorID(1400, "texture.setAntiAliasTexParameters()", "texture.setFilters(cc.Texture2D.Filter.NEAREST, cc.Texture2D.Filter.NEAREST)");
      return function() {
        this.setFilters(Texture2D.Filter.NEAREST, Texture2D.Filter.NEAREST);
      };
    }));
    markAsRemovedInObject(cc.macro, [ "ENABLE_GL_STATE_CACHE", "FIX_ARTIFACTS_BY_STRECHING_TEXEL" ], "cc.macro");
    provideClearError(cc.macro, {
      PI: "Math.PI",
      PI2: "Math.PI * 2",
      FLT_MAX: "Number.MAX_VALUE",
      FLT_MIN: "Number.MIN_VALUE",
      UINT_MAX: "Number.MAX_SAFE_INTEGER"
    }, "cc.macro");
    markAsRemovedInObject(cc.game, [ "CONFIG_KEY" ], "cc.game");
    markAsRemovedInObject(cc.sys, [ "dumpRoot", "cleanScript", "BROWSER_TYPE_WECHAT_GAME", "BROWSER_TYPE_WECHAT_GAME_SUB", "BROWSER_TYPE_BAIDU_GAME", "BROWSER_TYPE_BAIDU_GAME_SUB", "BROWSER_TYPE_XIAOMI_GAME", "BROWSER_TYPE_ALIPAY_GAME" ], "cc.sys");
    provideClearError(cc.Director, {
      EVENT_PROJECTION_CHANGED: "",
      EVENT_BEFORE_VISIT: "EVENT_AFTER_UPDATE",
      EVENT_AFTER_VISIT: "EVENT_BEFORE_DRAW"
    }, "cc.Director");
    markFunctionWarning(cc.Director.prototype, {
      convertToGL: "cc.view.convertToLocationInView",
      convertToUI: "",
      getWinSize: "cc.winSize",
      getWinSizeInPixels: "cc.winSize",
      getVisibleSize: "cc.view.getVisibleSize",
      getVisibleOrigin: "cc.view.getVisibleOrigin",
      purgeCachedData: "cc.assetManager.releaseAll",
      setDepthTest: "cc.Camera.main.depth",
      setClearColor: "cc.Camera.main.backgroundColor",
      getRunningScene: "cc.director.getScene",
      getAnimationInterval: "cc.game.getFrameRate",
      setAnimationInterval: "cc.game.setFrameRate",
      isDisplayStats: "cc.debug.isDisplayStats",
      setDisplayStats: "cc.debug.setDisplayStats",
      stopAnimation: "cc.game.pause",
      startAnimation: "cc.game.resume"
    }, "cc.Director");
    markAsRemoved(cc.Director, [ "pushScene", "popScene", "popToRootScene", "popToSceneStackLevel", "setProjection", "getProjection" ], "cc.Director");
    provideClearError(cc.Scheduler, {
      scheduleCallbackForTarget: "schedule",
      scheduleUpdateForTarget: "scheduleUpdate",
      unscheduleCallbackForTarget: "unschedule",
      unscheduleUpdateForTarget: "unscheduleUpdate",
      unscheduleAllCallbacksForTarget: "unscheduleAllForTarget",
      unscheduleAllCallbacks: "unscheduleAll",
      unscheduleAllCallbacksWithMinPriority: "unscheduleAllWithMinPriority"
    }, "cc.Scheduler");
    provideClearError(cc.view, {
      adjustViewPort: "adjustViewportMeta",
      setViewPortInPoints: "setViewportInPoints",
      getViewPortRect: "getViewportRect"
    }, "cc.view");
    markAsRemovedInObject(cc.view, [ "isViewReady", "setTargetDensityDPI", "getTargetDensityDPI", "setFrameZoomFactor", "canSetContentScaleFactor", "setContentTranslateLeftTop", "getContentTranslateLeftTop", "setViewName", "getViewName" ], "cc.view");
    markAsRemoved(cc.PhysicsManager, [ "attachDebugDrawToCamera", "detachDebugDrawFromCamera" ]);
    markAsRemoved(cc.CollisionManager, [ "attachDebugDrawToCamera", "detachDebugDrawFromCamera" ]);
    provideClearError(cc._BaseNode.prototype, {
      tag: "name",
      getTag: "name",
      setTag: "name",
      getChildByTag: "getChildByName",
      removeChildByTag: "getChildByName(name).destroy()"
    });
    markAsRemoved(cc.Node, [ "_cascadeColorEnabled", "cascadeColor", "isCascadeColorEnabled", "setCascadeColorEnabled", "_cascadeOpacityEnabled", "cascadeOpacity", "isCascadeOpacityEnabled", "setCascadeOpacityEnabled", "opacityModifyRGB", "isOpacityModifyRGB", "setOpacityModifyRGB", "ignoreAnchor", "isIgnoreAnchorPointForPosition", "ignoreAnchorPointForPosition", "isRunning", "_sgNode" ]);
    markFunctionWarning(cc.Node.prototype, {
      getNodeToParentTransform: "getLocalMatrix",
      getNodeToParentTransformAR: "getLocalMatrix",
      getNodeToWorldTransform: "getWorldMatrix",
      getNodeToWorldTransformAR: "getWorldMatrix",
      getParentToNodeTransform: "getLocalMatrix",
      getWorldToNodeTransform: "getWorldMatrix",
      convertTouchToNodeSpace: "convertToNodeSpaceAR",
      convertTouchToNodeSpaceAR: "convertToNodeSpaceAR",
      convertToWorldSpace: "convertToWorldSpaceAR",
      convertToNodeSpace: "convertToNodeSpaceAR"
    });
    provideClearError(cc.Node.prototype, {
      getRotationX: "rotationX",
      setRotationX: "rotationX",
      getRotationY: "rotationY",
      setRotationY: "rotationY",
      getPositionX: "x",
      setPositionX: "x",
      getPositionY: "y",
      setPositionY: "y",
      getSkewX: "skewX",
      setSkewX: "skewX",
      getSkewY: "skewY",
      setSkewY: "skewY",
      getScaleX: "scaleX",
      setScaleX: "scaleX",
      getScaleY: "scaleY",
      setScaleY: "scaleY",
      getOpacity: "opacity",
      setOpacity: "opacity",
      getColor: "color",
      setColor: "color",
      getLocalZOrder: "zIndex",
      setLocalZOrder: "zIndex"
    });
    provideClearError(cc.Sprite.prototype, {
      setInsetLeft: "cc.SpriteFrame insetLeft",
      setInsetRight: "cc.SpriteFrame insetRight",
      setInsetTop: "cc.SpriteFrame insetTop",
      setInsetBottom: "cc.SpriteFrame insetBottom"
    });
    cc.Material.getInstantiatedBuiltinMaterial = cc.MaterialVariant.createWithBuiltin;
    cc.Material.getInstantiatedMaterial = cc.MaterialVariant.create;
    markFunctionWarning(cc.Material, {
      getInstantiatedBuiltinMaterial: "cc.MaterialVariant.createWithBuiltin",
      getInstantiatedMaterial: "cc.MaterialVariant.create"
    });
    cc.js.getset(cc.RenderComponent.prototype, "sharedMaterials", (function() {
      cc.warnID(1400, "sharedMaterials", "getMaterials");
      return this.materials;
    }), (function(v) {
      cc.warnID(1400, "sharedMaterials", "setMaterial");
      this.materials = v;
    }));
    markFunctionWarning(cc.Follow.prototype, {
      setBoudarySet: "cc.Follow.setBoundarySet"
    });
    markFunctionWarning(cc.Camera.prototype, {
      getNodeToCameraTransform: "getWorldToScreenMatrix2D",
      getCameraToWorldPoint: "getScreenToWorldPoint",
      getWorldToCameraPoint: "getWorldToScreenPoint",
      getCameraToWorldMatrix: "getScreenToWorldMatrix2D",
      getWorldToCameraMatrix: "getWorldToScreenMatrix2D"
    });
    markAsRemoved(cc.Camera, [ "addTarget", "removeTarget", "getTargets" ]);
    var ERR = '"%s" is not defined in the Scene, it is only defined in normal nodes.';
    false, Object.defineProperties(cc.Scene.prototype, {
      active: {
        get: function get() {
          cc.error(ERR, "active");
          return true;
        },
        set: function set() {
          cc.error(ERR, "active");
        }
      },
      activeInHierarchy: {
        get: function get() {
          cc.error(ERR, "activeInHierarchy");
          return true;
        }
      },
      getComponent: {
        get: function get() {
          cc.error(ERR, "getComponent");
          return function() {
            return null;
          };
        }
      },
      addComponent: {
        get: function get() {
          cc.error(ERR, "addComponent");
          return function() {
            return null;
          };
        }
      }
    });
    markAsRemovedInObject(cc.dynamicAtlasManager, [ "minFrameSize" ], "cc.dynamicAtlasManager");
    cc.Light && markAsRemovedInObject(cc.Light.prototype, [ "shadowDepthScale" ], "cc.Light.prototype");
    provideClearError(cc, {
      affineTransformMake: "cc.AffineTransform.create",
      affineTransformMakeIdentity: "cc.AffineTransform.identity",
      affineTransformClone: "cc.AffineTransform.clone",
      affineTransformConcat: "cc.AffineTransform.concat",
      affineTransformConcatIn: "cc.AffineTransform.concat",
      affineTransformInvert: "cc.AffineTransform.invert",
      affineTransformInvertIn: "cc.AffineTransform.invert",
      affineTransformInvertOut: "cc.AffineTransform.invert",
      affineTransformEqualToTransform: "cc.AffineTransform.equal",
      pointApplyAffineTransform: "cc.AffineTransform.transformVec2",
      sizeApplyAffineTransform: "cc.AffineTransform.transformSize",
      rectApplyAffineTransform: "cc.AffineTransform.transformRect",
      obbApplyAffineTransform: "cc.AffineTransform.transformObb",
      pointEqualToPoint: "cc.Vec2 equals",
      sizeEqualToSize: "cc.Size equals",
      rectEqualToRect: "rectA.equals(rectB)",
      rectContainsRect: "rectA.containsRect(rectB)",
      rectContainsPoint: "rect.contains(vec2)",
      rectOverlapsRect: "rectA.intersects(rectB)",
      rectIntersectsRect: "rectA.intersects(rectB)",
      rectIntersection: "rectA.intersection(intersection, rectB)",
      rectUnion: "rectA.union(union, rectB)",
      rectGetMaxX: "rect.xMax",
      rectGetMidX: "rect.center.x",
      rectGetMinX: "rect.xMin",
      rectGetMaxY: "rect.yMax",
      rectGetMidY: "rect.center.y",
      rectGetMinY: "rect.yMin",
      colorEqual: "colorA.equals(colorB)",
      hexToColor: "color.fromHEX(hexColor)",
      colorToHex: "color.toHEX()",
      TextAlignment: "cc.macro.TextAlignment",
      VerticalTextAlignment: "cc.macro.VerticalTextAlignment",
      pNeg: "p.neg()",
      pAdd: "p1.add(p2)",
      pSub: "p1.sub(p2)",
      pMult: "p.mul(factor)",
      pMidpoint: "p1.add(p2).mul(0.5)",
      pDot: "p1.dot(p2)",
      pCross: "p1.cross(p2)",
      pPerp: "p.rotate(-90 * Math.PI / 180)",
      pRPerp: "p.rotate(90 * Math.PI / 180)",
      pProject: "p1.project(p2)",
      pLengthSQ: "p.magSqr()",
      pDistanceSQ: "p1.sub(p2).magSqr()",
      pLength: "p.mag()",
      pDistance: "p1.sub(p2).mag()",
      pNormalize: "p.normalize()",
      pForAngle: "cc.v2(Math.cos(a), Math.sin(a))",
      pToAngle: "Math.atan2(v.y, v.x)",
      pZeroIn: "p.x = p.y = 0",
      pIn: "p1.set(p2)",
      pMultIn: "p.mulSelf(factor)",
      pSubIn: "p1.subSelf(p2)",
      pAddIn: "p1.addSelf(p2)",
      pNormalizeIn: "p.normalizeSelf()",
      pSameAs: "p1.equals(p2)",
      pAngle: "v1.angle(v2)",
      pAngleSigned: "v1.signAngle(v2)",
      pRotateByAngle: "p.rotate(radians)",
      pCompMult: "v1.multiply(v2)",
      pFuzzyEqual: "v1.fuzzyEquals(v2, tolerance)",
      pLerp: "p.lerp(endPoint, ratio)",
      pClamp: "p.clampf(min_inclusive, max_inclusive)",
      rand: "Math.random() * 0xffffff",
      randomMinus1To1: "(Math.random() - 0.5) * 2",
      container: "cc.game.container",
      _canvas: "cc.game.canvas",
      _renderType: "cc.game.renderType",
      _getError: "cc.debug.getError",
      _initDebugSetting: "cc.debug._resetDebugSetting",
      DebugMode: "cc.debug.DebugMode"
    }, "cc");
    markAsRemovedInObject(cc, [ "blendFuncDisable", "pFromSize", "pCompOp", "pIntersectPoint", "pSegmentIntersect", "pLineIntersect", "obbApplyMatrix", "getImageFormatByData", "initEngine" ], "cc");
    markFunctionWarning(cc, {
      p: "cc.v2"
    }, "cc");
    provideClearError(cc.Rect, {
      contain: "rectA.contains(rectB)",
      transformMat4: "rect.transformMat4(out, mat4)"
    });
    provideClearError(cc.Color, {
      rgb2hsv: "color.toHSV()",
      hsv2rgb: "color.fromHSV(h, s, v)"
    });
    markFunctionWarning(cc.Color, {
      fromHex: "cc.Color.fromHEX"
    });
    js.get(cc, "lerp", (function() {
      cc.errorID(1400, "cc.lerp", "cc.misc.lerp");
      return cc.misc.lerp;
    }));
    js.get(cc, "random0To1", (function() {
      cc.errorID(1400, "cc.random0To1", "Math.random");
      return Math.random;
    }));
    js.get(cc, "degreesToRadians", (function() {
      cc.errorID(1400, "cc.degreesToRadians", "cc.misc.degreesToRadians");
      return cc.misc.degreesToRadians;
    }));
    js.get(cc, "radiansToDegrees", (function() {
      cc.errorID(1400, "cc.radiansToDegrees", "cc.misc.radiansToDegrees");
      return cc.misc.radiansToDegrees;
    }));
    js.get(cc, "clampf", (function() {
      cc.errorID(1400, "cc.clampf", "cc.misc.clampf");
      return cc.misc.clampf;
    }));
    js.get(cc, "clamp01", (function() {
      cc.errorID(1400, "cc.clamp01", "cc.misc.clamp01");
      return cc.misc.clamp01;
    }));
    js.get(cc, "ImageFormat", (function() {
      cc.errorID(1400, "cc.ImageFormat", "cc.macro.ImageFormat");
      return cc.macro.ImageFormat;
    }));
    js.get(cc, "KEY", (function() {
      cc.errorID(1400, "cc.KEY", "cc.macro.KEY");
      return cc.macro.KEY;
    }));
    js.get(cc, "Easing", (function() {
      cc.errorID(1400, "cc.Easing", "cc.easing");
      return cc.easing;
    }));
    js.get(cc, "isChildClassOf", (function() {
      cc.errorID(1400, "cc.isChildClassOf", "cc.js.isChildClassOf");
      return cc.js.isChildClassOf;
    }));
    "object" === typeof dragonBones && "undefined" !== typeof dragonBones.CCFactory && js.get(dragonBones.CCFactory, "getFactory", (function() {
      cc.errorID(1400, "dragonBones.CCFactory.getFactory", "dragonBones.CCFactory.getInstance");
      return dragonBones.CCFactory.getInstance;
    }));
    cc.renderer.renderEngine = {
      get gfx() {
        cc.warnID(1400, "cc.renderer.renderEngine.gfx", "cc.gfx");
        return cc.gfx;
      },
      get math() {
        cc.warnID(1400, "cc.renderer.renderEngine.math", "cc.math");
        return cc.vmath;
      },
      get InputAssembler() {
        cc.warnID(1400, "cc.renderer.renderEngine.InputAssembler", "cc.renderer.InputAssembler");
        return cc.renderer.InputAssembler;
      }
    };
    markAsRemovedInObject(cc.audioEngine, [ "getProfile", "preload", "setMaxWebAudioSize" ], "cc.audioEngine");
  }), {} ],
  414: [ (function(require, module, exports) {
    "use strict";
    require("./core/CCGame");
    require("./actions");
  }), {
    "./actions": 8,
    "./core/CCGame": 103
  } ],
  415: [ (function(require, module, exports) {
    "use strict";
    var zlib = require("../compression/zlib.min");
    var debug = require("../core/CCDebug");
    var PNGReader = function PNGReader(data) {
      var chunkSize, colors, delayDen, delayNum, frame, i, index, key, section, ccshort, text, _i, _j, _ref;
      this.data = data;
      this.pos = 8;
      this.palette = [];
      this.imgData = [];
      this.transparency = {};
      this.animation = null;
      this.text = {};
      frame = null;
      while (true) {
        chunkSize = this.readUInt32();
        section = function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; _i < 4; i = ++_i) _results.push(String.fromCharCode(this.data[this.pos++]));
          return _results;
        }.call(this).join("");
        switch (section) {
         case "IHDR":
          this.width = this.readUInt32();
          this.height = this.readUInt32();
          this.bits = this.data[this.pos++];
          this.colorType = this.data[this.pos++];
          this.compressionMethod = this.data[this.pos++];
          this.filterMethod = this.data[this.pos++];
          this.interlaceMethod = this.data[this.pos++];
          break;

         case "acTL":
          this.animation = {
            numFrames: this.readUInt32(),
            numPlays: this.readUInt32() || Infinity,
            frames: []
          };
          break;

         case "PLTE":
          this.palette = this.read(chunkSize);
          break;

         case "fcTL":
          frame && this.animation.frames.push(frame);
          this.pos += 4;
          frame = {
            width: this.readUInt32(),
            height: this.readUInt32(),
            xOffset: this.readUInt32(),
            yOffset: this.readUInt32()
          };
          delayNum = this.readUInt16();
          delayDen = this.readUInt16() || 100;
          frame.delay = 1e3 * delayNum / delayDen;
          frame.disposeOp = this.data[this.pos++];
          frame.blendOp = this.data[this.pos++];
          frame.data = [];
          break;

         case "IDAT":
         case "fdAT":
          if ("fdAT" === section) {
            this.pos += 4;
            chunkSize -= 4;
          }
          data = (null != frame ? frame.data : void 0) || this.imgData;
          for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i) data.push(this.data[this.pos++]);
          break;

         case "tRNS":
          this.transparency = {};
          switch (this.colorType) {
           case 3:
            this.transparency.indexed = this.read(chunkSize);
            ccshort = 255 - this.transparency.indexed.length;
            if (ccshort > 0) for (i = _j = 0; 0 <= ccshort ? _j < ccshort : _j > ccshort; i = 0 <= ccshort ? ++_j : --_j) this.transparency.indexed.push(255);
            break;

           case 0:
            this.transparency.grayscale = this.read(chunkSize)[0];
            break;

           case 2:
            this.transparency.rgb = this.read(chunkSize);
          }
          break;

         case "tEXt":
          text = this.read(chunkSize);
          index = text.indexOf(0);
          key = String.fromCharCode.apply(String, text.slice(0, index));
          this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
          break;

         case "IEND":
          frame && this.animation.frames.push(frame);
          this.colors = function() {
            switch (this.colorType) {
             case 0:
             case 3:
             case 4:
              return 1;

             case 2:
             case 6:
              return 3;
            }
          }.call(this);
          this.hasAlphaChannel = 4 === (_ref = this.colorType) || 6 === _ref;
          colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
          this.pixelBitlength = this.bits * colors;
          this.colorSpace = function() {
            switch (this.colors) {
             case 1:
              return "DeviceGray";

             case 3:
              return "DeviceRGB";
            }
          }.call(this);
          Uint8Array != Array && (this.imgData = new Uint8Array(this.imgData));
          return;

         default:
          this.pos += chunkSize;
        }
        this.pos += 4;
        if (this.pos > this.data.length) throw new Error(debug.getError(6017));
      }
    };
    PNGReader.prototype = {
      constructor: PNGReader,
      read: function read(bytes) {
        var i, _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) _results.push(this.data[this.pos++]);
        return _results;
      },
      readUInt32: function readUInt32() {
        var b1, b2, b3, b4;
        b1 = this.data[this.pos++] << 24;
        b2 = this.data[this.pos++] << 16;
        b3 = this.data[this.pos++] << 8;
        b4 = this.data[this.pos++];
        return b1 | b2 | b3 | b4;
      },
      readUInt16: function readUInt16() {
        var b1, b2;
        b1 = this.data[this.pos++] << 8;
        b2 = this.data[this.pos++];
        return b1 | b2;
      },
      decodePixels: function decodePixels(data) {
        var ccbyte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
        null == data && (data = this.imgData);
        if (0 === data.length) return new Uint8Array(0);
        var inflate = new zlib.Inflate(data, {
          index: 0,
          verify: false
        });
        data = inflate.decompress();
        pixelBytes = this.pixelBitlength / 8;
        scanlineLength = pixelBytes * this.width;
        pixels = new Uint8Array(scanlineLength * this.height);
        length = data.length;
        row = 0;
        pos = 0;
        c = 0;
        while (pos < length) {
          switch (data[pos++]) {
           case 0:
            for (i = _i = 0; _i < scanlineLength; i = _i += 1) pixels[c++] = data[pos++];
            break;

           case 1:
            for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
              ccbyte = data[pos++];
              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
              pixels[c++] = (ccbyte + left) % 256;
            }
            break;

           case 2:
            for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
              ccbyte = data[pos++];
              col = (i - i % pixelBytes) / pixelBytes;
              upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
              pixels[c++] = (upper + ccbyte) % 256;
            }
            break;

           case 3:
            for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
              ccbyte = data[pos++];
              col = (i - i % pixelBytes) / pixelBytes;
              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
              upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
              pixels[c++] = (ccbyte + Math.floor((left + upper) / 2)) % 256;
            }
            break;

           case 4:
            for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
              ccbyte = data[pos++];
              col = (i - i % pixelBytes) / pixelBytes;
              left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
              if (0 === row) upper = upperLeft = 0; else {
                upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];
                upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];
              }
              p = left + upper - upperLeft;
              pa = Math.abs(p - left);
              pb = Math.abs(p - upper);
              pc = Math.abs(p - upperLeft);
              paeth = pa <= pb && pa <= pc ? left : pb <= pc ? upper : upperLeft;
              pixels[c++] = (ccbyte + paeth) % 256;
            }
            break;

           default:
            throw new Error(debug.getError(6018, data[pos - 1]));
          }
          row++;
        }
        return pixels;
      },
      copyToImageData: function copyToImageData(imageData, pixels) {
        var alpha, colors, data, i, input, j, k, length, palette, v, _ref;
        colors = this.colors;
        palette = null;
        alpha = this.hasAlphaChannel;
        if (this.palette.length) {
          palette = null != (_ref = this._decodedPalette) ? _ref : this._decodedPalette = this.decodePalette();
          colors = 4;
          alpha = true;
        }
        data = imageData.data || imageData;
        length = data.length;
        input = palette || pixels;
        i = j = 0;
        if (1 === colors) while (i < length) {
          k = palette ? 4 * pixels[i / 4] : j;
          v = input[k++];
          data[i++] = v;
          data[i++] = v;
          data[i++] = v;
          data[i++] = alpha ? input[k++] : 255;
          j = k;
        } else while (i < length) {
          k = palette ? 4 * pixels[i / 4] : j;
          data[i++] = input[k++];
          data[i++] = input[k++];
          data[i++] = input[k++];
          data[i++] = alpha ? input[k++] : 255;
          j = k;
        }
      },
      decodePalette: function decodePalette() {
        var c, i, palette, pos, ret, transparency, _i, _ref, _ref1;
        palette = this.palette;
        transparency = this.transparency.indexed || [];
        ret = new Uint8Array((transparency.length || 0) + palette.length);
        pos = 0;
        c = 0;
        for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
          ret[pos++] = palette[i];
          ret[pos++] = palette[i + 1];
          ret[pos++] = palette[i + 2];
          ret[pos++] = null != (_ref1 = transparency[c++]) ? _ref1 : 255;
        }
        return ret;
      },
      render: function render(canvas) {
        var ctx, data;
        canvas.width = this.width;
        canvas.height = this.height;
        ctx = canvas.getContext("2d");
        data = ctx.createImageData(this.width, this.height);
        this.copyToImageData(data, this.decodePixels());
        return ctx.putImageData(data, 0, 0);
      }
    };
    module.exports = PNGReader;
  }), {
    "../compression/zlib.min": 26,
    "../core/CCDebug": 101
  } ],
  416: [ (function(require, module, exports) {
    "use strict";
    var Asset = require("../core/assets/CCAsset");
    var CCSpriteFrame = require("../core/assets/CCSpriteFrame");
    var ParticleAsset = cc.Class({
      name: "cc.ParticleAsset",
      extends: Asset,
      properties: {
        spriteFrame: {
          default: null,
          type: CCSpriteFrame
        }
      }
    });
    cc.ParticleAsset = module.exports = ParticleAsset;
  }), {
    "../core/assets/CCAsset": 137,
    "../core/assets/CCSpriteFrame": 149
  } ],
  417: [ (function(require, module, exports) {
    "use strict";
    var macro = require("../core/platform/CCMacro");
    var ParticleAsset = require("./CCParticleAsset");
    var RenderComponent = require("../core/components/CCRenderComponent");
    var codec = require("../compression/ZipUtils");
    var PNGReader = require("./CCPNGReader");
    var tiffReader = require("./CCTIFFReader");
    var textureUtil = require("../core/utils/texture-util");
    var RenderFlow = require("../core/renderer/render-flow");
    var ParticleSimulator = require("./particle-simulator");
    var Material = require("../core/assets/material/CCMaterial");
    var BlendFunc = require("../core/utils/blend-func");
    function getImageFormatByData(imgData) {
      if (imgData.length > 8 && 137 === imgData[0] && 80 === imgData[1] && 78 === imgData[2] && 71 === imgData[3] && 13 === imgData[4] && 10 === imgData[5] && 26 === imgData[6] && 10 === imgData[7]) return macro.ImageFormat.PNG;
      if (imgData.length > 2 && (73 === imgData[0] && 73 === imgData[1] || 77 === imgData[0] && 77 === imgData[1] || 255 === imgData[0] && 216 === imgData[1])) return macro.ImageFormat.TIFF;
      return macro.ImageFormat.UNKNOWN;
    }
    function getParticleComponents(node) {
      var parent = node.parent, comp = node.getComponent(cc.ParticleSystem);
      if (!parent || !comp) return node.getComponentsInChildren(cc.ParticleSystem);
      return getParticleComponents(parent);
    }
    var EmitterMode = cc.Enum({
      GRAVITY: 0,
      RADIUS: 1
    });
    var PositionType = cc.Enum({
      FREE: 0,
      RELATIVE: 1,
      GROUPED: 2
    });
    var properties = {
      preview: {
        default: true,
        editorOnly: true,
        notify: false,
        animatable: false,
        tooltip: (true, "i18n:COMPONENT.particle_system.preview")
      },
      _custom: false,
      custom: {
        get: function get() {
          return this._custom;
        },
        set: function set(value) {
          false;
          if (this._custom !== value) {
            this._custom = value;
            this._applyFile();
            false;
          }
        },
        animatable: false,
        tooltip: (true, "i18n:COMPONENT.particle_system.custom")
      },
      _file: {
        default: null,
        type: ParticleAsset
      },
      file: {
        get: function get() {
          return this._file;
        },
        set: function set(value, force) {
          if (this._file !== value || false) {
            this._file = value;
            if (value) {
              this._applyFile();
              false;
            } else this.custom = true;
          }
        },
        animatable: false,
        type: ParticleAsset,
        tooltip: (true, "i18n:COMPONENT.particle_system.file")
      },
      _spriteFrame: {
        default: null,
        type: cc.SpriteFrame
      },
      spriteFrame: {
        get: function get() {
          return this._spriteFrame;
        },
        set: function set(value, force) {
          var lastSprite = this._renderSpriteFrame;
          false;
          if (lastSprite === value) return;
          this._renderSpriteFrame = value;
          value && !value._uuid || (this._spriteFrame = value);
          this._applySpriteFrame(lastSprite);
          false;
        },
        type: cc.SpriteFrame,
        tooltip: (true, "i18n:COMPONENT.particle_system.spriteFrame")
      },
      _texture: {
        default: null,
        type: cc.Texture2D,
        editorOnly: true
      },
      texture: {
        get: function get() {
          return this._getTexture();
        },
        set: function set(value) {
          value && cc.warnID(6017);
        },
        type: cc.Texture2D,
        tooltip: (true, "i18n:COMPONENT.particle_system.texture"),
        readonly: true,
        visible: false,
        animatable: false
      },
      particleCount: {
        visible: false,
        get: function get() {
          return this._simulator.particles.length;
        },
        readonly: true
      },
      _stopped: true,
      stopped: {
        get: function get() {
          return this._stopped;
        },
        animatable: false,
        visible: false
      },
      playOnLoad: true,
      autoRemoveOnFinish: {
        default: false,
        animatable: false,
        tooltip: (true, "i18n:COMPONENT.particle_system.autoRemoveOnFinish")
      },
      active: {
        get: function get() {
          return this._simulator.active;
        },
        visible: false
      },
      totalParticles: 150,
      duration: -1,
      emissionRate: 10,
      life: 1,
      lifeVar: 0,
      _startColor: null,
      startColor: {
        type: cc.Color,
        get: function get() {
          return this._startColor;
        },
        set: function set(val) {
          this._startColor.r = val.r;
          this._startColor.g = val.g;
          this._startColor.b = val.b;
          this._startColor.a = val.a;
        }
      },
      _startColorVar: null,
      startColorVar: {
        type: cc.Color,
        get: function get() {
          return this._startColorVar;
        },
        set: function set(val) {
          this._startColorVar.r = val.r;
          this._startColorVar.g = val.g;
          this._startColorVar.b = val.b;
          this._startColorVar.a = val.a;
        }
      },
      _endColor: null,
      endColor: {
        type: cc.Color,
        get: function get() {
          return this._endColor;
        },
        set: function set(val) {
          this._endColor.r = val.r;
          this._endColor.g = val.g;
          this._endColor.b = val.b;
          this._endColor.a = val.a;
        }
      },
      _endColorVar: null,
      endColorVar: {
        type: cc.Color,
        get: function get() {
          return this._endColorVar;
        },
        set: function set(val) {
          this._endColorVar.r = val.r;
          this._endColorVar.g = val.g;
          this._endColorVar.b = val.b;
          this._endColorVar.a = val.a;
        }
      },
      angle: 90,
      angleVar: 20,
      startSize: 50,
      startSizeVar: 0,
      endSize: 0,
      endSizeVar: 0,
      startSpin: 0,
      startSpinVar: 0,
      endSpin: 0,
      endSpinVar: 0,
      sourcePos: cc.Vec2.ZERO,
      posVar: cc.Vec2.ZERO,
      _positionType: {
        default: PositionType.FREE,
        formerlySerializedAs: "positionType"
      },
      positionType: {
        type: PositionType,
        get: function get() {
          return this._positionType;
        },
        set: function set(val) {
          this._positionType = val;
          this._updateMaterial();
        }
      },
      emitterMode: {
        default: EmitterMode.GRAVITY,
        type: EmitterMode
      },
      gravity: cc.Vec2.ZERO,
      speed: 180,
      speedVar: 50,
      tangentialAccel: 80,
      tangentialAccelVar: 0,
      radialAccel: 0,
      radialAccelVar: 0,
      rotationIsDir: false,
      startRadius: 0,
      startRadiusVar: 0,
      endRadius: 0,
      endRadiusVar: 0,
      rotatePerS: 0,
      rotatePerSVar: 0
    };
    var ParticleSystem = cc.Class({
      name: "cc.ParticleSystem",
      extends: RenderComponent,
      mixins: [ BlendFunc ],
      editor: false,
      ctor: function ctor() {
        this.initProperties();
      },
      initProperties: function initProperties() {
        this._previewTimer = null;
        this._focused = false;
        this._aspectRatio = 1;
        this._simulator = new ParticleSimulator(this);
        this._startColor = cc.color(255, 255, 255, 255);
        this._startColorVar = cc.color(0, 0, 0, 0);
        this._endColor = cc.color(255, 255, 255, 0);
        this._endColorVar = cc.color(0, 0, 0, 0);
        this._renderSpriteFrame = null;
      },
      properties: properties,
      statics: {
        DURATION_INFINITY: -1,
        START_SIZE_EQUAL_TO_END_SIZE: -1,
        START_RADIUS_EQUAL_TO_END_RADIUS: -1,
        EmitterMode: EmitterMode,
        PositionType: PositionType,
        _PNGReader: PNGReader,
        _TIFFReader: tiffReader
      },
      onFocusInEditor: false,
      onLostFocusInEditor: false,
      _startPreview: false,
      _stopPreview: false,
      _convertTextureToSpriteFrame: false,
      __preload: function __preload() {
        this._super();
        false;
        if (this._custom && this.spriteFrame && !this._renderSpriteFrame) this._applySpriteFrame(this.spriteFrame); else if (this._file) if (this._custom) {
          var missCustomTexture = !this._getTexture();
          missCustomTexture && this._applyFile();
        } else this._applyFile();
        true;
        this.playOnLoad && this.resetSystem();
        false;
      },
      onDestroy: function onDestroy() {
        this.autoRemoveOnFinish && (this.autoRemoveOnFinish = false);
        if (this._buffer) {
          this._buffer.destroy();
          this._buffer = null;
        }
        this._simulator._uvFilled = 0;
        this._super();
      },
      lateUpdate: function lateUpdate(dt) {
        this._simulator.finished || this._simulator.step(dt);
      },
      addParticle: function addParticle() {},
      stopSystem: function stopSystem() {
        this._stopped = true;
        this._simulator.stop();
      },
      resetSystem: function resetSystem() {
        this._stopped = false;
        this._simulator.reset();
        this.markForRender(true);
      },
      isFull: function isFull() {
        return this.particleCount >= this.totalParticles;
      },
      setTextureWithRect: function setTextureWithRect(texture, rect) {
        texture instanceof cc.Texture2D && (this.spriteFrame = new cc.SpriteFrame(texture, rect));
      },
      _applyFile: function _applyFile() {
        var file = this._file;
        if (file) {
          var self = this;
          cc.assetManager.postLoadNative(file, (function(err) {
            if (err || !file._nativeAsset) {
              cc.errorID(6029);
              return;
            }
            if (!self.isValid) return;
            self._plistFile = file.nativeUrl;
            if (!self._custom) {
              var isDiffFrame = self._spriteFrame !== file.spriteFrame;
              isDiffFrame && (self.spriteFrame = file.spriteFrame);
              self._initWithDictionary(file._nativeAsset);
            }
            self._spriteFrame ? !self._renderSpriteFrame && self._spriteFrame && self._applySpriteFrame(self.spriteFrame) : file.spriteFrame ? self.spriteFrame = file.spriteFrame : self._custom && self._initTextureWithDictionary(file._nativeAsset);
          }));
        }
      },
      _initTextureWithDictionary: function _initTextureWithDictionary(dict) {
        var imgPath = cc.path.changeBasename(this._plistFile, dict["textureFileName"] || "");
        if (dict["textureFileName"]) textureUtil.loadImage(imgPath, (function(error, texture) {
          if (error) {
            dict["textureFileName"] = void 0;
            this._initTextureWithDictionary(dict);
          } else {
            cc.assetManager.assets.add(imgPath, texture);
            this.spriteFrame = new cc.SpriteFrame(texture);
          }
        }), this); else if (dict["textureImageData"]) {
          var textureData = dict["textureImageData"];
          if (!(textureData && textureData.length > 0)) return false;
          var tex = cc.assetManager.assets.get(imgPath);
          if (!tex) {
            var buffer = codec.unzipBase64AsArray(textureData, 1);
            if (!buffer) {
              cc.warnID(6030, this._file.name);
              return false;
            }
            var imageFormat = getImageFormatByData(buffer);
            if (imageFormat !== macro.ImageFormat.TIFF && imageFormat !== macro.ImageFormat.PNG) {
              cc.warnID(6031, this._file.name);
              return false;
            }
            var canvasObj = document.createElement("canvas");
            if (imageFormat === macro.ImageFormat.PNG) {
              var myPngObj = new PNGReader(buffer);
              myPngObj.render(canvasObj);
            } else tiffReader.parseTIFF(buffer, canvasObj);
            tex = textureUtil.cacheImage(imgPath, canvasObj);
          }
          tex || cc.warnID(6032, this._file.name);
          this.spriteFrame = new cc.SpriteFrame(tex);
        }
        return true;
      },
      _initWithDictionary: function _initWithDictionary(dict) {
        this.totalParticles = parseInt(dict["maxParticles"] || 0);
        this.life = parseFloat(dict["particleLifespan"] || 0);
        this.lifeVar = parseFloat(dict["particleLifespanVariance"] || 0);
        var _tempEmissionRate = dict["emissionRate"];
        this.emissionRate = _tempEmissionRate || Math.min(this.totalParticles / this.life, Number.MAX_VALUE);
        this.duration = parseFloat(dict["duration"] || 0);
        this.srcBlendFactor = parseInt(dict["blendFuncSource"] || macro.SRC_ALPHA);
        this.dstBlendFactor = parseInt(dict["blendFuncDestination"] || macro.ONE_MINUS_SRC_ALPHA);
        var locStartColor = this._startColor;
        locStartColor.r = 255 * parseFloat(dict["startColorRed"] || 0);
        locStartColor.g = 255 * parseFloat(dict["startColorGreen"] || 0);
        locStartColor.b = 255 * parseFloat(dict["startColorBlue"] || 0);
        locStartColor.a = 255 * parseFloat(dict["startColorAlpha"] || 0);
        var locStartColorVar = this._startColorVar;
        locStartColorVar.r = 255 * parseFloat(dict["startColorVarianceRed"] || 0);
        locStartColorVar.g = 255 * parseFloat(dict["startColorVarianceGreen"] || 0);
        locStartColorVar.b = 255 * parseFloat(dict["startColorVarianceBlue"] || 0);
        locStartColorVar.a = 255 * parseFloat(dict["startColorVarianceAlpha"] || 0);
        var locEndColor = this._endColor;
        locEndColor.r = 255 * parseFloat(dict["finishColorRed"] || 0);
        locEndColor.g = 255 * parseFloat(dict["finishColorGreen"] || 0);
        locEndColor.b = 255 * parseFloat(dict["finishColorBlue"] || 0);
        locEndColor.a = 255 * parseFloat(dict["finishColorAlpha"] || 0);
        var locEndColorVar = this._endColorVar;
        locEndColorVar.r = 255 * parseFloat(dict["finishColorVarianceRed"] || 0);
        locEndColorVar.g = 255 * parseFloat(dict["finishColorVarianceGreen"] || 0);
        locEndColorVar.b = 255 * parseFloat(dict["finishColorVarianceBlue"] || 0);
        locEndColorVar.a = 255 * parseFloat(dict["finishColorVarianceAlpha"] || 0);
        this.startSize = parseFloat(dict["startParticleSize"] || 0);
        this.startSizeVar = parseFloat(dict["startParticleSizeVariance"] || 0);
        this.endSize = parseFloat(dict["finishParticleSize"] || 0);
        this.endSizeVar = parseFloat(dict["finishParticleSizeVariance"] || 0);
        this.positionType = parseFloat(void 0 !== dict["positionType"] ? dict["positionType"] : PositionType.RELATIVE);
        this.sourcePos.x = 0;
        this.sourcePos.y = 0;
        this.posVar.x = parseFloat(dict["sourcePositionVariancex"] || 0);
        this.posVar.y = parseFloat(dict["sourcePositionVariancey"] || 0);
        this.angle = parseFloat(dict["angle"] || 0);
        this.angleVar = parseFloat(dict["angleVariance"] || 0);
        this.startSpin = parseFloat(dict["rotationStart"] || 0);
        this.startSpinVar = parseFloat(dict["rotationStartVariance"] || 0);
        this.endSpin = parseFloat(dict["rotationEnd"] || 0);
        this.endSpinVar = parseFloat(dict["rotationEndVariance"] || 0);
        this.emitterMode = parseInt(dict["emitterType"] || EmitterMode.GRAVITY);
        if (this.emitterMode === EmitterMode.GRAVITY) {
          this.gravity.x = parseFloat(dict["gravityx"] || 0);
          this.gravity.y = parseFloat(dict["gravityy"] || 0);
          this.speed = parseFloat(dict["speed"] || 0);
          this.speedVar = parseFloat(dict["speedVariance"] || 0);
          this.radialAccel = parseFloat(dict["radialAcceleration"] || 0);
          this.radialAccelVar = parseFloat(dict["radialAccelVariance"] || 0);
          this.tangentialAccel = parseFloat(dict["tangentialAcceleration"] || 0);
          this.tangentialAccelVar = parseFloat(dict["tangentialAccelVariance"] || 0);
          var locRotationIsDir = dict["rotationIsDir"] || "";
          if (null !== locRotationIsDir) {
            locRotationIsDir = locRotationIsDir.toString().toLowerCase();
            this.rotationIsDir = "true" === locRotationIsDir || "1" === locRotationIsDir;
          } else this.rotationIsDir = false;
        } else {
          if (this.emitterMode !== EmitterMode.RADIUS) {
            cc.warnID(6009);
            return false;
          }
          this.startRadius = parseFloat(dict["maxRadius"] || 0);
          this.startRadiusVar = parseFloat(dict["maxRadiusVariance"] || 0);
          this.endRadius = parseFloat(dict["minRadius"] || 0);
          this.endRadiusVar = parseFloat(dict["minRadiusVariance"] || 0);
          this.rotatePerS = parseFloat(dict["rotatePerSecond"] || 0);
          this.rotatePerSVar = parseFloat(dict["rotatePerSecondVariance"] || 0);
        }
        this._initTextureWithDictionary(dict);
        return true;
      },
      _validateRender: function _validateRender() {
        var texture = this._getTexture();
        if (!texture || !texture.loaded) {
          this.disableRender();
          return;
        }
        this._super();
      },
      _onTextureLoaded: function _onTextureLoaded() {
        this._simulator.updateUVs(true);
        this._syncAspect();
        this._updateMaterial();
        this.markForRender(true);
      },
      _syncAspect: function _syncAspect() {
        var frameRect = this._renderSpriteFrame._rect;
        this._aspectRatio = frameRect.width / frameRect.height;
      },
      _applySpriteFrame: function _applySpriteFrame() {
        this._renderSpriteFrame = this._renderSpriteFrame || this._spriteFrame;
        this._renderSpriteFrame && (this._renderSpriteFrame.textureLoaded() ? this._onTextureLoaded() : this._renderSpriteFrame.onTextureLoaded(this._onTextureLoaded, this));
      },
      _getTexture: function _getTexture() {
        return this._renderSpriteFrame && this._renderSpriteFrame.getTexture() || this._texture;
      },
      _updateMaterial: function _updateMaterial() {
        var material = this.getMaterial(0);
        if (!material) return;
        material.define("CC_USE_MODEL", this._positionType !== PositionType.FREE);
        material.setProperty("texture", this._getTexture());
        BlendFunc.prototype._updateMaterial.call(this);
      },
      _finishedSimulation: function _finishedSimulation() {
        false;
        this.resetSystem();
        this.stopSystem();
        this.disableRender();
        this.autoRemoveOnFinish && this._stopped && this.node.destroy();
      }
    });
    cc.ParticleSystem = module.exports = ParticleSystem;
  }), {
    "../compression/ZipUtils": 23,
    "../core/assets/material/CCMaterial": 156,
    "../core/components/CCRenderComponent": 192,
    "../core/platform/CCMacro": 277,
    "../core/renderer/render-flow": 323,
    "../core/utils/blend-func": 380,
    "../core/utils/texture-util": 394,
    "./CCPNGReader": 415,
    "./CCParticleAsset": 416,
    "./CCTIFFReader": 418,
    "./particle-simulator": 420,
    "fire-url": void 0
  } ],
  418: [ (function(require, module, exports) {
    "use strict";
    var debug = require("../core/CCDebug");
    var tiffReader = {
      _littleEndian: false,
      _tiffData: null,
      _fileDirectories: [],
      getUint8: function getUint8(offset) {
        return this._tiffData[offset];
      },
      getUint16: function getUint16(offset) {
        return this._littleEndian ? this._tiffData[offset + 1] << 8 | this._tiffData[offset] : this._tiffData[offset] << 8 | this._tiffData[offset + 1];
      },
      getUint32: function getUint32(offset) {
        var a = this._tiffData;
        return this._littleEndian ? a[offset + 3] << 24 | a[offset + 2] << 16 | a[offset + 1] << 8 | a[offset] : a[offset] << 24 | a[offset + 1] << 16 | a[offset + 2] << 8 | a[offset + 3];
      },
      checkLittleEndian: function checkLittleEndian() {
        var BOM = this.getUint16(0);
        if (18761 === BOM) this.littleEndian = true; else {
          if (19789 !== BOM) {
            console.log(BOM);
            throw TypeError(debug.getError(6019));
          }
          this.littleEndian = false;
        }
        return this.littleEndian;
      },
      hasTowel: function hasTowel() {
        if (42 !== this.getUint16(2)) throw RangeError(debug.getError(6020));
        return true;
      },
      getFieldTypeName: function getFieldTypeName(fieldType) {
        var typeNames = this.fieldTypeNames;
        if (fieldType in typeNames) return typeNames[fieldType];
        return null;
      },
      getFieldTagName: function getFieldTagName(fieldTag) {
        var tagNames = this.fieldTagNames;
        if (fieldTag in tagNames) return tagNames[fieldTag];
        cc.logID(6021, fieldTag);
        return "Tag" + fieldTag;
      },
      getFieldTypeLength: function getFieldTypeLength(fieldTypeName) {
        if (-1 !== [ "BYTE", "ASCII", "SBYTE", "UNDEFINED" ].indexOf(fieldTypeName)) return 1;
        if (-1 !== [ "SHORT", "SSHORT" ].indexOf(fieldTypeName)) return 2;
        if (-1 !== [ "LONG", "SLONG", "FLOAT" ].indexOf(fieldTypeName)) return 4;
        if (-1 !== [ "RATIONAL", "SRATIONAL", "DOUBLE" ].indexOf(fieldTypeName)) return 8;
        return null;
      },
      getFieldValues: function getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset) {
        var fieldValues = [];
        var fieldTypeLength = this.getFieldTypeLength(fieldTypeName);
        var fieldValueSize = fieldTypeLength * typeCount;
        if (fieldValueSize <= 4) false === this.littleEndian ? fieldValues.push(valueOffset >>> 8 * (4 - fieldTypeLength)) : fieldValues.push(valueOffset); else for (var i = 0; i < typeCount; i++) {
          var indexOffset = fieldTypeLength * i;
          if (fieldTypeLength >= 8) if (-1 !== [ "RATIONAL", "SRATIONAL" ].indexOf(fieldTypeName)) {
            fieldValues.push(this.getUint32(valueOffset + indexOffset));
            fieldValues.push(this.getUint32(valueOffset + indexOffset + 4));
          } else cc.logID(8e3); else fieldValues.push(this.getBytes(fieldTypeLength, valueOffset + indexOffset));
        }
        "ASCII" === fieldTypeName && fieldValues.forEach((function(e, i, a) {
          a[i] = String.fromCharCode(e);
        }));
        return fieldValues;
      },
      getBytes: function getBytes(numBytes, offset) {
        if (numBytes <= 0) cc.logID(8001); else {
          if (numBytes <= 1) return this.getUint8(offset);
          if (numBytes <= 2) return this.getUint16(offset);
          if (numBytes <= 3) return this.getUint32(offset) >>> 8;
          if (numBytes <= 4) return this.getUint32(offset);
          cc.logID(8002);
        }
      },
      getBits: function getBits(numBits, byteOffset, bitOffset) {
        bitOffset = bitOffset || 0;
        var extraBytes = Math.floor(bitOffset / 8);
        var newByteOffset = byteOffset + extraBytes;
        var totalBits = bitOffset + numBits;
        var shiftRight = 32 - numBits;
        var shiftLeft, rawBits;
        if (totalBits <= 0) cc.logID(6023); else if (totalBits <= 8) {
          shiftLeft = 24 + bitOffset;
          rawBits = this.getUint8(newByteOffset);
        } else if (totalBits <= 16) {
          shiftLeft = 16 + bitOffset;
          rawBits = this.getUint16(newByteOffset);
        } else if (totalBits <= 32) {
          shiftLeft = bitOffset;
          rawBits = this.getUint32(newByteOffset);
        } else cc.logID(6022);
        return {
          bits: rawBits << shiftLeft >>> shiftRight,
          byteOffset: newByteOffset + Math.floor(totalBits / 8),
          bitOffset: totalBits % 8
        };
      },
      parseFileDirectory: function parseFileDirectory(byteOffset) {
        var numDirEntries = this.getUint16(byteOffset);
        var tiffFields = [];
        for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, 
        entryCount++) {
          var fieldTag = this.getUint16(i);
          var fieldType = this.getUint16(i + 2);
          var typeCount = this.getUint32(i + 4);
          var valueOffset = this.getUint32(i + 8);
          var fieldTagName = this.getFieldTagName(fieldTag);
          var fieldTypeName = this.getFieldTypeName(fieldType);
          var fieldValues = this.getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);
          tiffFields[fieldTagName] = {
            type: fieldTypeName,
            values: fieldValues
          };
        }
        this._fileDirectories.push(tiffFields);
        var nextIFDByteOffset = this.getUint32(i);
        0 !== nextIFDByteOffset && this.parseFileDirectory(nextIFDByteOffset);
      },
      clampColorSample: function clampColorSample(colorSample, bitsPerSample) {
        var multiplier = Math.pow(2, 8 - bitsPerSample);
        return Math.floor(colorSample * multiplier + (multiplier - 1));
      },
      parseTIFF: function parseTIFF(tiffData, canvas) {
        canvas = canvas || document.createElement("canvas");
        this._tiffData = tiffData;
        this.canvas = canvas;
        this.checkLittleEndian();
        if (!this.hasTowel()) return;
        var firstIFDByteOffset = this.getUint32(4);
        this._fileDirectories.length = 0;
        this.parseFileDirectory(firstIFDByteOffset);
        var fileDirectory = this._fileDirectories[0];
        var imageWidth = fileDirectory["ImageWidth"].values[0];
        var imageLength = fileDirectory["ImageLength"].values[0];
        this.canvas.width = imageWidth;
        this.canvas.height = imageLength;
        var strips = [];
        var compression = fileDirectory["Compression"] ? fileDirectory["Compression"].values[0] : 1;
        var samplesPerPixel = fileDirectory["SamplesPerPixel"].values[0];
        var sampleProperties = [];
        var bitsPerPixel = 0;
        var hasBytesPerPixel = false;
        fileDirectory["BitsPerSample"].values.forEach((function(bitsPerSample, i, bitsPerSampleValues) {
          sampleProperties[i] = {
            bitsPerSample: bitsPerSample,
            hasBytesPerSample: false,
            bytesPerSample: void 0
          };
          if (bitsPerSample % 8 === 0) {
            sampleProperties[i].hasBytesPerSample = true;
            sampleProperties[i].bytesPerSample = bitsPerSample / 8;
          }
          bitsPerPixel += bitsPerSample;
        }), this);
        if (bitsPerPixel % 8 === 0) {
          hasBytesPerPixel = true;
          var bytesPerPixel = bitsPerPixel / 8;
        }
        var stripOffsetValues = fileDirectory["StripOffsets"].values;
        var numStripOffsetValues = stripOffsetValues.length;
        if (fileDirectory["StripByteCounts"]) var stripByteCountValues = fileDirectory["StripByteCounts"].values; else {
          cc.logID(8003);
          if (1 !== numStripOffsetValues) throw Error(debug.getError(6024));
          var stripByteCountValues = [ Math.ceil(imageWidth * imageLength * bitsPerPixel / 8) ];
        }
        for (var i = 0; i < numStripOffsetValues; i++) {
          var stripOffset = stripOffsetValues[i];
          strips[i] = [];
          var stripByteCount = stripByteCountValues[i];
          for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) switch (compression) {
           case 1:
            for (var m = 0, pixel = []; m < samplesPerPixel; m++) {
              if (!sampleProperties[m].hasBytesPerSample) {
                var sampleInfo = this.getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);
                pixel.push(sampleInfo.bits);
                byteOffset = sampleInfo.byteOffset - stripOffset;
                bitOffset = sampleInfo.bitOffset;
                throw RangeError(debug.getError(6025));
              }
              var sampleOffset = sampleProperties[m].bytesPerSample * m;
              pixel.push(this.getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));
            }
            strips[i].push(pixel);
            if (!hasBytesPerPixel) {
              jIncrement = 0;
              throw RangeError(debug.getError(6026));
            }
            jIncrement = bytesPerPixel;
            break;

           case 2:
           case 3:
           case 4:
           case 5:
           case 6:
           case 7:
            break;

           case 32773:
            if (getHeader) {
              getHeader = false;
              var blockLength = 1;
              var iterations = 1;
              var header = this.getInt8(stripOffset + byteOffset);
              header >= 0 && header <= 127 ? blockLength = header + 1 : header >= -127 && header <= -1 ? iterations = 1 - header : getHeader = true;
            } else {
              var currentByte = this.getUint8(stripOffset + byteOffset);
              for (var m = 0; m < iterations; m++) {
                if (!sampleProperties[sample].hasBytesPerSample) throw RangeError(debug.getError(6025));
                currentSample = currentSample << 8 * numBytes | currentByte;
                numBytes++;
                if (numBytes === sampleProperties[sample].bytesPerSample) {
                  pixel.push(currentSample);
                  currentSample = numBytes = 0;
                  sample++;
                }
                if (sample === samplesPerPixel) {
                  strips[i].push(pixel);
                  pixel = [];
                  sample = 0;
                }
              }
              blockLength--;
              0 === blockLength && (getHeader = true);
            }
            jIncrement = 1;
          }
        }
        if (canvas.getContext) {
          var ctx = this.canvas.getContext("2d");
          ctx.fillStyle = "rgba(255, 255, 255, 0)";
          var rowsPerStrip = fileDirectory["RowsPerStrip"] ? fileDirectory["RowsPerStrip"].values[0] : imageLength;
          var numStrips = strips.length;
          var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;
          var rowsInLastStrip = 0 === imageLengthModRowsPerStrip ? rowsPerStrip : imageLengthModRowsPerStrip;
          var numRowsInStrip = rowsPerStrip;
          var numRowsInPreviousStrip = 0;
          var photometricInterpretation = fileDirectory["PhotometricInterpretation"].values[0];
          var extraSamplesValues = [];
          var numExtraSamples = 0;
          if (fileDirectory["ExtraSamples"]) {
            extraSamplesValues = fileDirectory["ExtraSamples"].values;
            numExtraSamples = extraSamplesValues.length;
          }
          if (fileDirectory["ColorMap"]) {
            var colorMapValues = fileDirectory["ColorMap"].values;
            var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);
          }
          for (var i = 0; i < numStrips; i++) {
            i + 1 === numStrips && (numRowsInStrip = rowsInLastStrip);
            var numPixels = strips[i].length;
            var yPadding = numRowsInPreviousStrip * i;
            for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++) for (var x = 0; x < imageWidth; x++, 
            j++) {
              var pixelSamples = strips[i][j];
              var red = 0;
              var green = 0;
              var blue = 0;
              var opacity = 1;
              if (numExtraSamples > 0) for (var k = 0; k < numExtraSamples; k++) if (1 === extraSamplesValues[k] || 2 === extraSamplesValues[k]) {
                opacity = pixelSamples[3 + k] / 256;
                break;
              }
              switch (photometricInterpretation) {
               case 0:
                if (sampleProperties[0].hasBytesPerSample) var invertValue = Math.pow(16, 2 * sampleProperties[0].bytesPerSample);
                pixelSamples.forEach((function(sample, index, samples) {
                  samples[index] = invertValue - sample;
                }));

               case 1:
                red = green = blue = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                break;

               case 2:
                red = this.clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);
                green = this.clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);
                blue = this.clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);
                break;

               case 3:
                if (void 0 === colorMapValues) throw Error(debug.getError(6027));
                var colorMapIndex = pixelSamples[0];
                red = this.clampColorSample(colorMapValues[colorMapIndex], 16);
                green = this.clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);
                blue = this.clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);
                break;

               default:
                throw RangeError(debug.getError(6028, photometricInterpretation));
              }
              ctx.fillStyle = "rgba(" + red + ", " + green + ", " + blue + ", " + opacity + ")";
              ctx.fillRect(x, yPadding + y, 1, 1);
            }
            numRowsInPreviousStrip = numRowsInStrip;
          }
        }
        return this.canvas;
      },
      fieldTagNames: {
        315: "Artist",
        258: "BitsPerSample",
        265: "CellLength",
        264: "CellWidth",
        320: "ColorMap",
        259: "Compression",
        33432: "Copyright",
        306: "DateTime",
        338: "ExtraSamples",
        266: "FillOrder",
        289: "FreeByteCounts",
        288: "FreeOffsets",
        291: "GrayResponseCurve",
        290: "GrayResponseUnit",
        316: "HostComputer",
        270: "ImageDescription",
        257: "ImageLength",
        256: "ImageWidth",
        271: "Make",
        281: "MaxSampleValue",
        280: "MinSampleValue",
        272: "Model",
        254: "NewSubfileType",
        274: "Orientation",
        262: "PhotometricInterpretation",
        284: "PlanarConfiguration",
        296: "ResolutionUnit",
        278: "RowsPerStrip",
        277: "SamplesPerPixel",
        305: "Software",
        279: "StripByteCounts",
        273: "StripOffsets",
        255: "SubfileType",
        263: "Threshholding",
        282: "XResolution",
        283: "YResolution",
        326: "BadFaxLines",
        327: "CleanFaxData",
        343: "ClipPath",
        328: "ConsecutiveBadFaxLines",
        433: "Decode",
        434: "DefaultImageColor",
        269: "DocumentName",
        336: "DotRange",
        321: "HalftoneHints",
        346: "Indexed",
        347: "JPEGTables",
        285: "PageName",
        297: "PageNumber",
        317: "Predictor",
        319: "PrimaryChromaticities",
        532: "ReferenceBlackWhite",
        339: "SampleFormat",
        559: "StripRowCounts",
        330: "SubIFDs",
        292: "T4Options",
        293: "T6Options",
        325: "TileByteCounts",
        323: "TileLength",
        324: "TileOffsets",
        322: "TileWidth",
        301: "TransferFunction",
        318: "WhitePoint",
        344: "XClipPathUnits",
        286: "XPosition",
        529: "YCbCrCoefficients",
        531: "YCbCrPositioning",
        530: "YCbCrSubSampling",
        345: "YClipPathUnits",
        287: "YPosition",
        37378: "ApertureValue",
        40961: "ColorSpace",
        36868: "DateTimeDigitized",
        36867: "DateTimeOriginal",
        34665: "Exif IFD",
        36864: "ExifVersion",
        33434: "ExposureTime",
        41728: "FileSource",
        37385: "Flash",
        40960: "FlashpixVersion",
        33437: "FNumber",
        42016: "ImageUniqueID",
        37384: "LightSource",
        37500: "MakerNote",
        37377: "ShutterSpeedValue",
        37510: "UserComment",
        33723: "IPTC",
        34675: "ICC Profile",
        700: "XMP",
        42112: "GDAL_METADATA",
        42113: "GDAL_NODATA",
        34377: "Photoshop"
      },
      fieldTypeNames: {
        1: "BYTE",
        2: "ASCII",
        3: "SHORT",
        4: "LONG",
        5: "RATIONAL",
        6: "SBYTE",
        7: "UNDEFINED",
        8: "SSHORT",
        9: "SLONG",
        10: "SRATIONAL",
        11: "FLOAT",
        12: "DOUBLE"
      }
    };
    module.exports = tiffReader;
  }), {
    "../core/CCDebug": 101
  } ],
  419: [ (function(require, module, exports) {
    "use strict";
    require("./CCParticleAsset");
    require("./CCParticleSystem");
    require("./particle-simulator");
    require("./particle-system-assembler");
  }), {
    "./CCParticleAsset": 416,
    "./CCParticleSystem": 417,
    "./particle-simulator": 420,
    "./particle-system-assembler": 421
  } ],
  420: [ (function(require, module, exports) {
    "use strict";
    var js = require("../core/platform/js");
    var misc = require("../core/utils/misc");
    var ZERO_VEC2 = cc.v2(0, 0);
    var _pos = cc.v2();
    var _tpa = cc.v2();
    var _tpb = cc.v2();
    var _tpc = cc.v2();
    var Particle = function Particle() {
      this.pos = cc.v2(0, 0);
      this.startPos = cc.v2(0, 0);
      this.color = cc.color(0, 0, 0, 255);
      this.deltaColor = {
        r: 0,
        g: 0,
        b: 0,
        a: 255
      };
      this.preciseColor = {
        r: 0,
        g: 0,
        b: 0,
        a: 255
      };
      this.size = 0;
      this.deltaSize = 0;
      this.rotation = 0;
      this.deltaRotation = 0;
      this.timeToLive = 0;
      this.drawPos = cc.v2(0, 0);
      this.aspectRatio = 1;
      this.dir = cc.v2(0, 0);
      this.radialAccel = 0;
      this.tangentialAccel = 0;
      this.angle = 0;
      this.degreesPerSecond = 0;
      this.radius = 0;
      this.deltaRadius = 0;
    };
    var pool = new js.Pool(function(par) {
      par.pos.set(ZERO_VEC2);
      par.startPos.set(ZERO_VEC2);
      par.color._val = 4278190080;
      par.deltaColor.r = par.deltaColor.g = par.deltaColor.b = 0;
      par.deltaColor.a = 255;
      par.size = 0;
      par.deltaSize = 0;
      par.rotation = 0;
      par.deltaRotation = 0;
      par.timeToLive = 0;
      par.drawPos.set(ZERO_VEC2);
      par.aspectRatio = 1;
      par.dir.set(ZERO_VEC2);
      par.radialAccel = 0;
      par.tangentialAccel = 0;
      par.angle = 0;
      par.degreesPerSecond = 0;
      par.radius = 0;
      par.deltaRadius = 0;
    }, 1024);
    pool.get = function() {
      return this._get() || new Particle();
    };
    var Simulator = function Simulator(system) {
      this.sys = system;
      this.particles = [];
      this.active = false;
      this.readyToPlay = true;
      this.finished = false;
      this.elapsed = 0;
      this.emitCounter = 0;
      this._uvFilled = 0;
      this._worldRotation = 0;
    };
    Simulator.prototype.stop = function() {
      this.active = false;
      this.readyToPlay = false;
      this.elapsed = this.sys.duration;
      this.emitCounter = 0;
    };
    Simulator.prototype.reset = function() {
      this.active = true;
      this.readyToPlay = true;
      this.elapsed = 0;
      this.emitCounter = 0;
      this.finished = false;
      var particles = this.particles;
      for (var id = 0; id < particles.length; ++id) pool.put(particles[id]);
      particles.length = 0;
      var assembler = this.sys._assembler;
      assembler && assembler._ia && (assembler._ia._count = 0);
    };
    Simulator.prototype.emitParticle = function(pos) {
      var psys = this.sys;
      var clampf = misc.clampf;
      var particle = pool.get();
      this.particles.push(particle);
      particle.timeToLive = psys.life + psys.lifeVar * (Math.random() - .5) * 2;
      var timeToLive = particle.timeToLive = Math.max(0, particle.timeToLive);
      particle.pos.x = psys.sourcePos.x + psys.posVar.x * (Math.random() - .5) * 2;
      particle.pos.y = psys.sourcePos.y + psys.posVar.y * (Math.random() - .5) * 2;
      var sr, sg, sb, sa;
      var startColor = psys._startColor, startColorVar = psys._startColorVar;
      var endColor = psys._endColor, endColorVar = psys._endColorVar;
      particle.color.r = sr = clampf(startColor.r + startColorVar.r * (Math.random() - .5) * 2, 0, 255);
      particle.color.g = sg = clampf(startColor.g + startColorVar.g * (Math.random() - .5) * 2, 0, 255);
      particle.color.b = sb = clampf(startColor.b + startColorVar.b * (Math.random() - .5) * 2, 0, 255);
      particle.color.a = sa = clampf(startColor.a + startColorVar.a * (Math.random() - .5) * 2, 0, 255);
      var color = particle.color;
      var preciseColor = particle.preciseColor;
      preciseColor.r = color.r;
      preciseColor.g = color.g;
      preciseColor.b = color.b;
      preciseColor.a = color.a;
      particle.deltaColor.r = (clampf(endColor.r + endColorVar.r * (Math.random() - .5) * 2, 0, 255) - sr) / timeToLive;
      particle.deltaColor.g = (clampf(endColor.g + endColorVar.g * (Math.random() - .5) * 2, 0, 255) - sg) / timeToLive;
      particle.deltaColor.b = (clampf(endColor.b + endColorVar.b * (Math.random() - .5) * 2, 0, 255) - sb) / timeToLive;
      particle.deltaColor.a = (clampf(endColor.a + endColorVar.a * (Math.random() - .5) * 2, 0, 255) - sa) / timeToLive;
      var startS = psys.startSize + psys.startSizeVar * (Math.random() - .5) * 2;
      startS = Math.max(0, startS);
      particle.size = startS;
      if (psys.endSize === cc.ParticleSystem.START_SIZE_EQUAL_TO_END_SIZE) particle.deltaSize = 0; else {
        var endS = psys.endSize + psys.endSizeVar * (Math.random() - .5) * 2;
        endS = Math.max(0, endS);
        particle.deltaSize = (endS - startS) / timeToLive;
      }
      var startA = psys.startSpin + psys.startSpinVar * (Math.random() - .5) * 2;
      var endA = psys.endSpin + psys.endSpinVar * (Math.random() - .5) * 2;
      particle.rotation = startA;
      particle.deltaRotation = (endA - startA) / timeToLive;
      particle.startPos.x = pos.x;
      particle.startPos.y = pos.y;
      particle.aspectRatio = psys._aspectRatio || 1;
      var a = misc.degreesToRadians(psys.angle + this._worldRotation + psys.angleVar * (Math.random() - .5) * 2);
      if (psys.emitterMode === cc.ParticleSystem.EmitterMode.GRAVITY) {
        var s = psys.speed + psys.speedVar * (Math.random() - .5) * 2;
        particle.dir.x = Math.cos(a);
        particle.dir.y = Math.sin(a);
        particle.dir.mulSelf(s);
        particle.radialAccel = psys.radialAccel + psys.radialAccelVar * (Math.random() - .5) * 2;
        particle.tangentialAccel = psys.tangentialAccel + psys.tangentialAccelVar * (Math.random() - .5) * 2;
        psys.rotationIsDir && (particle.rotation = -misc.radiansToDegrees(Math.atan2(particle.dir.y, particle.dir.x)));
      } else {
        var startRadius = psys.startRadius + psys.startRadiusVar * (Math.random() - .5) * 2;
        var endRadius = psys.endRadius + psys.endRadiusVar * (Math.random() - .5) * 2;
        particle.radius = startRadius;
        particle.deltaRadius = psys.endRadius === cc.ParticleSystem.START_RADIUS_EQUAL_TO_END_RADIUS ? 0 : (endRadius - startRadius) / timeToLive;
        particle.angle = a;
        particle.degreesPerSecond = misc.degreesToRadians(psys.rotatePerS + psys.rotatePerSVar * (Math.random() - .5) * 2);
      }
    };
    function getWorldRotation(node) {
      var rotation = 0;
      var tempNode = node;
      while (tempNode) {
        rotation += tempNode.angle;
        tempNode = tempNode.parent;
      }
      return rotation;
    }
    Simulator.prototype.updateUVs = function(force) {
      var assembler = this.sys._assembler;
      if (!assembler) return;
      var buffer = assembler.getBuffer();
      if (buffer && this.sys._renderSpriteFrame) {
        var FLOAT_PER_PARTICLE = 4 * assembler._vfmt._bytes / 4;
        var vbuf = buffer._vData;
        var uv = this.sys._renderSpriteFrame.uv;
        var start = force ? 0 : this._uvFilled;
        var particleCount = this.particles.length;
        for (var i = start; i < particleCount; i++) {
          var offset = i * FLOAT_PER_PARTICLE;
          vbuf[offset + 2] = uv[0];
          vbuf[offset + 3] = uv[1];
          vbuf[offset + 7] = uv[2];
          vbuf[offset + 8] = uv[3];
          vbuf[offset + 12] = uv[4];
          vbuf[offset + 13] = uv[5];
          vbuf[offset + 17] = uv[6];
          vbuf[offset + 18] = uv[7];
        }
        this._uvFilled = particleCount;
      }
    };
    Simulator.prototype.updateParticleBuffer = function(particle, pos, buffer, offset) {
      var vbuf = buffer._vData;
      var uintbuf = buffer._uintVData;
      var x = pos.x, y = pos.y;
      var width = particle.size;
      var height = width;
      var aspectRatio = particle.aspectRatio;
      aspectRatio > 1 ? height = width / aspectRatio : width = height * aspectRatio;
      var halfWidth = width / 2;
      var halfHeight = height / 2;
      if (particle.rotation) {
        var x1 = -halfWidth, y1 = -halfHeight;
        var x2 = halfWidth, y2 = halfHeight;
        var rad = -misc.degreesToRadians(particle.rotation);
        var cr = Math.cos(rad), sr = Math.sin(rad);
        vbuf[offset] = x1 * cr - y1 * sr + x;
        vbuf[offset + 1] = x1 * sr + y1 * cr + y;
        vbuf[offset + 5] = x2 * cr - y1 * sr + x;
        vbuf[offset + 6] = x2 * sr + y1 * cr + y;
        vbuf[offset + 10] = x1 * cr - y2 * sr + x;
        vbuf[offset + 11] = x1 * sr + y2 * cr + y;
        vbuf[offset + 15] = x2 * cr - y2 * sr + x;
        vbuf[offset + 16] = x2 * sr + y2 * cr + y;
      } else {
        vbuf[offset] = x - halfWidth;
        vbuf[offset + 1] = y - halfHeight;
        vbuf[offset + 5] = x + halfWidth;
        vbuf[offset + 6] = y - halfHeight;
        vbuf[offset + 10] = x - halfWidth;
        vbuf[offset + 11] = y + halfHeight;
        vbuf[offset + 15] = x + halfWidth;
        vbuf[offset + 16] = y + halfHeight;
      }
      uintbuf[offset + 4] = particle.color._val;
      uintbuf[offset + 9] = particle.color._val;
      uintbuf[offset + 14] = particle.color._val;
      uintbuf[offset + 19] = particle.color._val;
    };
    Simulator.prototype.step = function(dt) {
      dt = dt > cc.director._maxParticleDeltaTime ? cc.director._maxParticleDeltaTime : dt;
      var psys = this.sys;
      var node = psys.node;
      var particles = this.particles;
      var FLOAT_PER_PARTICLE = 4 * this.sys._assembler._vfmt._bytes / 4;
      var PositionType = cc.ParticleSystem.PositionType;
      node._updateWorldMatrix();
      if (psys.positionType === PositionType.FREE) {
        this._worldRotation = getWorldRotation(node);
        var m = node._worldMatrix.m;
        _pos.x = m[12];
        _pos.y = m[13];
      } else if (psys.positionType === PositionType.RELATIVE) {
        this._worldRotation = node.angle;
        _pos.x = node.x;
        _pos.y = node.y;
      } else this._worldRotation = 0;
      if (this.active && psys.emissionRate) {
        var rate = 1 / psys.emissionRate;
        particles.length < psys.totalParticles && (this.emitCounter += dt);
        while (particles.length < psys.totalParticles && this.emitCounter > rate) {
          this.emitParticle(_pos);
          this.emitCounter -= rate;
        }
        this.elapsed += dt;
        -1 !== psys.duration && psys.duration < this.elapsed && psys.stopSystem();
      }
      var buffer = psys._assembler.getBuffer();
      var particleCount = particles.length;
      buffer.reset();
      buffer.request(4 * particleCount, 6 * particleCount);
      particleCount > this._uvFilled && this.updateUVs();
      var particleIdx = 0;
      while (particleIdx < particles.length) {
        _tpa.x = _tpa.y = _tpb.x = _tpb.y = _tpc.x = _tpc.y = 0;
        var particle = particles[particleIdx];
        particle.timeToLive -= dt;
        if (particle.timeToLive > 0) {
          if (psys.emitterMode === cc.ParticleSystem.EmitterMode.GRAVITY) {
            var tmp = _tpc, radial = _tpa, tangential = _tpb;
            if (particle.pos.x || particle.pos.y) {
              radial.set(particle.pos);
              radial.normalizeSelf();
            }
            tangential.set(radial);
            radial.mulSelf(particle.radialAccel);
            var newy = tangential.x;
            tangential.x = -tangential.y;
            tangential.y = newy;
            tangential.mulSelf(particle.tangentialAccel);
            tmp.set(radial);
            tmp.addSelf(tangential);
            tmp.addSelf(psys.gravity);
            tmp.mulSelf(dt);
            particle.dir.addSelf(tmp);
            tmp.set(particle.dir);
            tmp.mulSelf(dt);
            particle.pos.addSelf(tmp);
          } else {
            particle.angle += particle.degreesPerSecond * dt;
            particle.radius += particle.deltaRadius * dt;
            particle.pos.x = -Math.cos(particle.angle) * particle.radius;
            particle.pos.y = -Math.sin(particle.angle) * particle.radius;
          }
          var preciseColor = particle.preciseColor;
          var deltaColor = particle.deltaColor;
          preciseColor.r += deltaColor.r * dt;
          preciseColor.g += deltaColor.g * dt;
          preciseColor.b += deltaColor.b * dt;
          preciseColor.a += deltaColor.a * dt;
          var color = particle.color;
          color.r = preciseColor.r;
          color.g = preciseColor.g;
          color.b = preciseColor.b;
          color.a = preciseColor.a;
          particle.size += particle.deltaSize * dt;
          particle.size < 0 && (particle.size = 0);
          particle.rotation += particle.deltaRotation * dt;
          var newPos = _tpa;
          newPos.set(particle.pos);
          psys.positionType !== PositionType.GROUPED && newPos.addSelf(particle.startPos);
          var offset = FLOAT_PER_PARTICLE * particleIdx;
          this.updateParticleBuffer(particle, newPos, buffer, offset);
          ++particleIdx;
        } else {
          var deadParticle = particles[particleIdx];
          particleIdx !== particles.length - 1 && (particles[particleIdx] = particles[particles.length - 1]);
          pool.put(deadParticle);
          particles.length--;
        }
      }
      psys._assembler._ia._count = 6 * particles.length;
      if (particles.length > 0) buffer.uploadData(); else if (!this.active && !this.readyToPlay) {
        this.finished = true;
        psys._finishedSimulation();
      }
    };
    module.exports = Simulator;
  }), {
    "../core/platform/js": 294,
    "../core/utils/misc": 386
  } ],
  421: [ (function(require, module, exports) {
    "use strict";
    var _assembler = _interopRequireDefault(require("../core/renderer/assembler"));
    var _inputAssembler = _interopRequireDefault(require("../renderer/core/input-assembler"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var ParticleSystem = require("./CCParticleSystem");
    var renderer = require("../core/renderer/");
    var QuadBuffer = require("../core/renderer/webgl/quad-buffer");
    var vfmtPosUvColor = require("../core/renderer/webgl/vertex-format").vfmtPosUvColor;
    var ParticleAssembler = (function(_Assembler) {
      _inheritsLoose(ParticleAssembler, _Assembler);
      function ParticleAssembler(comp) {
        var _this;
        _this = _Assembler.call(this, comp) || this;
        _this._buffer = null;
        _this._ia = null;
        _this._vfmt = vfmtPosUvColor;
        return _this;
      }
      var _proto = ParticleAssembler.prototype;
      _proto.getBuffer = function getBuffer() {
        if (!this._buffer) {
          this._buffer = new QuadBuffer(renderer._handle, vfmtPosUvColor);
          this._ia = new _inputAssembler["default"]();
          this._ia._vertexBuffer = this._buffer._vb;
          this._ia._indexBuffer = this._buffer._ib;
          this._ia._start = 0;
          this._ia._count = 0;
        }
        return this._buffer;
      };
      _proto.fillBuffers = function fillBuffers(comp, renderer) {
        if (!this._ia) return;
        var PositionType = cc.ParticleSystem.PositionType;
        comp.positionType === PositionType.RELATIVE ? renderer.node = comp.node.parent : renderer.node = comp.node;
        renderer.material = comp._materials[0];
        renderer._flushIA(this._ia);
      };
      return ParticleAssembler;
    })(_assembler["default"]);
    _assembler["default"].register(ParticleSystem, ParticleAssembler);
    module.exports = ParticleAssembler;
  }), {
    "../core/renderer/": 322,
    "../core/renderer/assembler": 302,
    "../core/renderer/webgl/quad-buffer": 369,
    "../core/renderer/webgl/vertex-format": 371,
    "../renderer/core/input-assembler": 423,
    "./CCParticleSystem": 417
  } ],
  422: [ (function(require, module, exports) {
    "use strict";
    var enums = {
      USAGE_STATIC: 35044,
      USAGE_DYNAMIC: 35048,
      USAGE_STREAM: 35040,
      INDEX_FMT_UINT8: 5121,
      INDEX_FMT_UINT16: 5123,
      INDEX_FMT_UINT32: 5125,
      ATTR_POSITION: "a_position",
      ATTR_NORMAL: "a_normal",
      ATTR_TANGENT: "a_tangent",
      ATTR_BITANGENT: "a_bitangent",
      ATTR_WEIGHTS: "a_weights",
      ATTR_JOINTS: "a_joints",
      ATTR_COLOR: "a_color",
      ATTR_COLOR0: "a_color0",
      ATTR_COLOR1: "a_color1",
      ATTR_UV: "a_uv",
      ATTR_UV0: "a_uv0",
      ATTR_UV1: "a_uv1",
      ATTR_UV2: "a_uv2",
      ATTR_UV3: "a_uv3",
      ATTR_UV4: "a_uv4",
      ATTR_UV5: "a_uv5",
      ATTR_UV6: "a_uv6",
      ATTR_UV7: "a_uv7",
      ATTR_TYPE_INT8: 5120,
      ATTR_TYPE_UINT8: 5121,
      ATTR_TYPE_INT16: 5122,
      ATTR_TYPE_UINT16: 5123,
      ATTR_TYPE_INT32: 5124,
      ATTR_TYPE_UINT32: 5125,
      ATTR_TYPE_FLOAT32: 5126,
      FILTER_NEAREST: 0,
      FILTER_LINEAR: 1,
      WRAP_REPEAT: 10497,
      WRAP_CLAMP: 33071,
      WRAP_MIRROR: 33648,
      TEXTURE_FMT_RGB_DXT1: 0,
      TEXTURE_FMT_RGBA_DXT1: 1,
      TEXTURE_FMT_RGBA_DXT3: 2,
      TEXTURE_FMT_RGBA_DXT5: 3,
      TEXTURE_FMT_RGB_ETC1: 4,
      TEXTURE_FMT_RGB_PVRTC_2BPPV1: 5,
      TEXTURE_FMT_RGBA_PVRTC_2BPPV1: 6,
      TEXTURE_FMT_RGB_PVRTC_4BPPV1: 7,
      TEXTURE_FMT_RGBA_PVRTC_4BPPV1: 8,
      TEXTURE_FMT_A8: 9,
      TEXTURE_FMT_L8: 10,
      TEXTURE_FMT_L8_A8: 11,
      TEXTURE_FMT_R5_G6_B5: 12,
      TEXTURE_FMT_R5_G5_B5_A1: 13,
      TEXTURE_FMT_R4_G4_B4_A4: 14,
      TEXTURE_FMT_RGB8: 15,
      TEXTURE_FMT_RGBA8: 16,
      TEXTURE_FMT_RGB16F: 17,
      TEXTURE_FMT_RGBA16F: 18,
      TEXTURE_FMT_RGB32F: 19,
      TEXTURE_FMT_RGBA32F: 20,
      TEXTURE_FMT_R32F: 21,
      TEXTURE_FMT_111110F: 22,
      TEXTURE_FMT_SRGB: 23,
      TEXTURE_FMT_SRGBA: 24,
      TEXTURE_FMT_D16: 25,
      TEXTURE_FMT_D32: 26,
      TEXTURE_FMT_D24S8: 27,
      TEXTURE_FMT_RGB_ETC2: 28,
      TEXTURE_FMT_RGBA_ETC2: 29,
      DS_FUNC_NEVER: 512,
      DS_FUNC_LESS: 513,
      DS_FUNC_EQUAL: 514,
      DS_FUNC_LEQUAL: 515,
      DS_FUNC_GREATER: 516,
      DS_FUNC_NOTEQUAL: 517,
      DS_FUNC_GEQUAL: 518,
      DS_FUNC_ALWAYS: 519,
      RB_FMT_RGBA4: 32854,
      RB_FMT_RGB5_A1: 32855,
      RB_FMT_RGB565: 36194,
      RB_FMT_D16: 33189,
      RB_FMT_S8: 36168,
      RB_FMT_D24S8: 34041,
      BLEND_FUNC_ADD: 32774,
      BLEND_FUNC_SUBTRACT: 32778,
      BLEND_FUNC_REVERSE_SUBTRACT: 32779,
      BLEND_ZERO: 0,
      BLEND_ONE: 1,
      BLEND_SRC_COLOR: 768,
      BLEND_ONE_MINUS_SRC_COLOR: 769,
      BLEND_DST_COLOR: 774,
      BLEND_ONE_MINUS_DST_COLOR: 775,
      BLEND_SRC_ALPHA: 770,
      BLEND_ONE_MINUS_SRC_ALPHA: 771,
      BLEND_DST_ALPHA: 772,
      BLEND_ONE_MINUS_DST_ALPHA: 773,
      BLEND_CONSTANT_COLOR: 32769,
      BLEND_ONE_MINUS_CONSTANT_COLOR: 32770,
      BLEND_CONSTANT_ALPHA: 32771,
      BLEND_ONE_MINUS_CONSTANT_ALPHA: 32772,
      BLEND_SRC_ALPHA_SATURATE: 776,
      STENCIL_DISABLE: 0,
      STENCIL_ENABLE: 1,
      STENCIL_INHERIT: 2,
      STENCIL_OP_KEEP: 7680,
      STENCIL_OP_ZERO: 0,
      STENCIL_OP_REPLACE: 7681,
      STENCIL_OP_INCR: 7682,
      STENCIL_OP_INCR_WRAP: 34055,
      STENCIL_OP_DECR: 7683,
      STENCIL_OP_DECR_WRAP: 34056,
      STENCIL_OP_INVERT: 5386,
      CULL_NONE: 0,
      CULL_FRONT: 1028,
      CULL_BACK: 1029,
      CULL_FRONT_AND_BACK: 1032,
      PT_POINTS: 0,
      PT_LINES: 1,
      PT_LINE_LOOP: 2,
      PT_LINE_STRIP: 3,
      PT_TRIANGLES: 4,
      PT_TRIANGLE_STRIP: 5,
      PT_TRIANGLE_FAN: 6
    };
    var RenderQueue = {
      OPAQUE: 0,
      TRANSPARENT: 1,
      OVERLAY: 2
    };
    function murmurhash2_32_gc(str, seed) {
      var l = str.length, h = seed ^ l, i = 0, k;
      while (l >= 4) {
        k = 255 & str.charCodeAt(i) | (255 & str.charCodeAt(++i)) << 8 | (255 & str.charCodeAt(++i)) << 16 | (255 & str.charCodeAt(++i)) << 24;
        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16);
        k ^= k >>> 24;
        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16);
        h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16) ^ k;
        l -= 4;
        ++i;
      }
      switch (l) {
       case 3:
        h ^= (255 & str.charCodeAt(i + 2)) << 16;

       case 2:
        h ^= (255 & str.charCodeAt(i + 1)) << 8;

       case 1:
        h ^= 255 & str.charCodeAt(i);
        h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16);
      }
      h ^= h >>> 13;
      h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16);
      h ^= h >>> 15;
      return h >>> 0;
    }
    var WebGLEXT;
    (function(WebGLEXT) {
      WebGLEXT[WebGLEXT["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
      WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
      WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
      WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
      WebGLEXT[WebGLEXT["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
      WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
      WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
      WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
      WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
      WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
      WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
      WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
      WebGLEXT[WebGLEXT["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
    })(WebGLEXT || (WebGLEXT = {}));
    var GFXObjectType;
    (function(GFXObjectType) {
      GFXObjectType[GFXObjectType["UNKNOWN"] = 0] = "UNKNOWN";
      GFXObjectType[GFXObjectType["BUFFER"] = 1] = "BUFFER";
      GFXObjectType[GFXObjectType["TEXTURE"] = 2] = "TEXTURE";
      GFXObjectType[GFXObjectType["TEXTURE_VIEW"] = 3] = "TEXTURE_VIEW";
      GFXObjectType[GFXObjectType["RENDER_PASS"] = 4] = "RENDER_PASS";
      GFXObjectType[GFXObjectType["FRAMEBUFFER"] = 5] = "FRAMEBUFFER";
      GFXObjectType[GFXObjectType["SAMPLER"] = 6] = "SAMPLER";
      GFXObjectType[GFXObjectType["SHADER"] = 7] = "SHADER";
      GFXObjectType[GFXObjectType["PIPELINE_LAYOUT"] = 8] = "PIPELINE_LAYOUT";
      GFXObjectType[GFXObjectType["PIPELINE_STATE"] = 9] = "PIPELINE_STATE";
      GFXObjectType[GFXObjectType["BINDING_LAYOUT"] = 10] = "BINDING_LAYOUT";
      GFXObjectType[GFXObjectType["INPUT_ASSEMBLER"] = 11] = "INPUT_ASSEMBLER";
      GFXObjectType[GFXObjectType["COMMAND_ALLOCATOR"] = 12] = "COMMAND_ALLOCATOR";
      GFXObjectType[GFXObjectType["COMMAND_BUFFER"] = 13] = "COMMAND_BUFFER";
      GFXObjectType[GFXObjectType["QUEUE"] = 14] = "QUEUE";
      GFXObjectType[GFXObjectType["WINDOW"] = 15] = "WINDOW";
    })(GFXObjectType || (GFXObjectType = {}));
    var GFXStatus;
    (function(GFXStatus) {
      GFXStatus[GFXStatus["UNREADY"] = 0] = "UNREADY";
      GFXStatus[GFXStatus["FAILED"] = 1] = "FAILED";
      GFXStatus[GFXStatus["SUCCESS"] = 2] = "SUCCESS";
    })(GFXStatus || (GFXStatus = {}));
    var GFXObject = (function() {
      function GFXObject(gfxType) {
        this._gfxType = GFXObjectType.UNKNOWN;
        this._status = GFXStatus.UNREADY;
        this._gfxType = gfxType;
      }
      Object.defineProperty(GFXObject.prototype, "gfxType", {
        get: function get() {
          return this._gfxType;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(GFXObject.prototype, "status", {
        get: function get() {
          return this._status;
        },
        enumerable: true,
        configurable: true
      });
      return GFXObject;
    })();
    var GFXAttributeName;
    (function(GFXAttributeName) {
      GFXAttributeName["ATTR_POSITION"] = "a_position";
      GFXAttributeName["ATTR_NORMAL"] = "a_normal";
      GFXAttributeName["ATTR_TANGENT"] = "a_tangent";
      GFXAttributeName["ATTR_BITANGENT"] = "a_bitangent";
      GFXAttributeName["ATTR_WEIGHTS"] = "a_weights";
      GFXAttributeName["ATTR_JOINTS"] = "a_joints";
      GFXAttributeName["ATTR_COLOR"] = "a_color";
      GFXAttributeName["ATTR_COLOR1"] = "a_color1";
      GFXAttributeName["ATTR_COLOR2"] = "a_color2";
      GFXAttributeName["ATTR_TEX_COORD"] = "a_texCoord";
      GFXAttributeName["ATTR_TEX_COORD1"] = "a_texCoord1";
      GFXAttributeName["ATTR_TEX_COORD2"] = "a_texCoord2";
      GFXAttributeName["ATTR_TEX_COORD3"] = "a_texCoord3";
      GFXAttributeName["ATTR_TEX_COORD4"] = "a_texCoord4";
      GFXAttributeName["ATTR_TEX_COORD5"] = "a_texCoord5";
      GFXAttributeName["ATTR_TEX_COORD6"] = "a_texCoord6";
      GFXAttributeName["ATTR_TEX_COORD7"] = "a_texCoord7";
      GFXAttributeName["ATTR_TEX_COORD8"] = "a_texCoord8";
    })(GFXAttributeName || (GFXAttributeName = {}));
    var GFXType;
    (function(GFXType) {
      GFXType[GFXType["UNKNOWN"] = 0] = "UNKNOWN";
      GFXType[GFXType["BOOL"] = 1] = "BOOL";
      GFXType[GFXType["BOOL2"] = 2] = "BOOL2";
      GFXType[GFXType["BOOL3"] = 3] = "BOOL3";
      GFXType[GFXType["BOOL4"] = 4] = "BOOL4";
      GFXType[GFXType["INT"] = 5] = "INT";
      GFXType[GFXType["INT2"] = 6] = "INT2";
      GFXType[GFXType["INT3"] = 7] = "INT3";
      GFXType[GFXType["INT4"] = 8] = "INT4";
      GFXType[GFXType["UINT"] = 9] = "UINT";
      GFXType[GFXType["UINT2"] = 10] = "UINT2";
      GFXType[GFXType["UINT3"] = 11] = "UINT3";
      GFXType[GFXType["UINT4"] = 12] = "UINT4";
      GFXType[GFXType["FLOAT"] = 13] = "FLOAT";
      GFXType[GFXType["FLOAT2"] = 14] = "FLOAT2";
      GFXType[GFXType["FLOAT3"] = 15] = "FLOAT3";
      GFXType[GFXType["FLOAT4"] = 16] = "FLOAT4";
      GFXType[GFXType["COLOR4"] = 17] = "COLOR4";
      GFXType[GFXType["MAT2"] = 18] = "MAT2";
      GFXType[GFXType["MAT2X3"] = 19] = "MAT2X3";
      GFXType[GFXType["MAT2X4"] = 20] = "MAT2X4";
      GFXType[GFXType["MAT3X2"] = 21] = "MAT3X2";
      GFXType[GFXType["MAT3"] = 22] = "MAT3";
      GFXType[GFXType["MAT3X4"] = 23] = "MAT3X4";
      GFXType[GFXType["MAT4X2"] = 24] = "MAT4X2";
      GFXType[GFXType["MAT4X3"] = 25] = "MAT4X3";
      GFXType[GFXType["MAT4"] = 26] = "MAT4";
      GFXType[GFXType["SAMPLER1D"] = 27] = "SAMPLER1D";
      GFXType[GFXType["SAMPLER1D_ARRAY"] = 28] = "SAMPLER1D_ARRAY";
      GFXType[GFXType["SAMPLER2D"] = 29] = "SAMPLER2D";
      GFXType[GFXType["SAMPLER2D_ARRAY"] = 30] = "SAMPLER2D_ARRAY";
      GFXType[GFXType["SAMPLER3D"] = 31] = "SAMPLER3D";
      GFXType[GFXType["SAMPLER_CUBE"] = 32] = "SAMPLER_CUBE";
      GFXType[GFXType["COUNT"] = 33] = "COUNT";
    })(GFXType || (GFXType = {}));
    var GFXFormat;
    (function(GFXFormat) {
      GFXFormat[GFXFormat["UNKNOWN"] = 0] = "UNKNOWN";
      GFXFormat[GFXFormat["A8"] = 1] = "A8";
      GFXFormat[GFXFormat["L8"] = 2] = "L8";
      GFXFormat[GFXFormat["LA8"] = 3] = "LA8";
      GFXFormat[GFXFormat["R8"] = 4] = "R8";
      GFXFormat[GFXFormat["R8SN"] = 5] = "R8SN";
      GFXFormat[GFXFormat["R8UI"] = 6] = "R8UI";
      GFXFormat[GFXFormat["R8I"] = 7] = "R8I";
      GFXFormat[GFXFormat["R16F"] = 8] = "R16F";
      GFXFormat[GFXFormat["R16UI"] = 9] = "R16UI";
      GFXFormat[GFXFormat["R16I"] = 10] = "R16I";
      GFXFormat[GFXFormat["R32F"] = 11] = "R32F";
      GFXFormat[GFXFormat["R32UI"] = 12] = "R32UI";
      GFXFormat[GFXFormat["R32I"] = 13] = "R32I";
      GFXFormat[GFXFormat["RG8"] = 14] = "RG8";
      GFXFormat[GFXFormat["RG8SN"] = 15] = "RG8SN";
      GFXFormat[GFXFormat["RG8UI"] = 16] = "RG8UI";
      GFXFormat[GFXFormat["RG8I"] = 17] = "RG8I";
      GFXFormat[GFXFormat["RG16F"] = 18] = "RG16F";
      GFXFormat[GFXFormat["RG16UI"] = 19] = "RG16UI";
      GFXFormat[GFXFormat["RG16I"] = 20] = "RG16I";
      GFXFormat[GFXFormat["RG32F"] = 21] = "RG32F";
      GFXFormat[GFXFormat["RG32UI"] = 22] = "RG32UI";
      GFXFormat[GFXFormat["RG32I"] = 23] = "RG32I";
      GFXFormat[GFXFormat["RGB8"] = 24] = "RGB8";
      GFXFormat[GFXFormat["SRGB8"] = 25] = "SRGB8";
      GFXFormat[GFXFormat["RGB8SN"] = 26] = "RGB8SN";
      GFXFormat[GFXFormat["RGB8UI"] = 27] = "RGB8UI";
      GFXFormat[GFXFormat["RGB8I"] = 28] = "RGB8I";
      GFXFormat[GFXFormat["RGB16F"] = 29] = "RGB16F";
      GFXFormat[GFXFormat["RGB16UI"] = 30] = "RGB16UI";
      GFXFormat[GFXFormat["RGB16I"] = 31] = "RGB16I";
      GFXFormat[GFXFormat["RGB32F"] = 32] = "RGB32F";
      GFXFormat[GFXFormat["RGB32UI"] = 33] = "RGB32UI";
      GFXFormat[GFXFormat["RGB32I"] = 34] = "RGB32I";
      GFXFormat[GFXFormat["RGBA8"] = 35] = "RGBA8";
      GFXFormat[GFXFormat["SRGB8_A8"] = 36] = "SRGB8_A8";
      GFXFormat[GFXFormat["RGBA8SN"] = 37] = "RGBA8SN";
      GFXFormat[GFXFormat["RGBA8UI"] = 38] = "RGBA8UI";
      GFXFormat[GFXFormat["RGBA8I"] = 39] = "RGBA8I";
      GFXFormat[GFXFormat["RGBA16F"] = 40] = "RGBA16F";
      GFXFormat[GFXFormat["RGBA16UI"] = 41] = "RGBA16UI";
      GFXFormat[GFXFormat["RGBA16I"] = 42] = "RGBA16I";
      GFXFormat[GFXFormat["RGBA32F"] = 43] = "RGBA32F";
      GFXFormat[GFXFormat["RGBA32UI"] = 44] = "RGBA32UI";
      GFXFormat[GFXFormat["RGBA32I"] = 45] = "RGBA32I";
      GFXFormat[GFXFormat["R5G6B5"] = 46] = "R5G6B5";
      GFXFormat[GFXFormat["R11G11B10F"] = 47] = "R11G11B10F";
      GFXFormat[GFXFormat["RGB5A1"] = 48] = "RGB5A1";
      GFXFormat[GFXFormat["RGBA4"] = 49] = "RGBA4";
      GFXFormat[GFXFormat["RGB10A2"] = 50] = "RGB10A2";
      GFXFormat[GFXFormat["RGB10A2UI"] = 51] = "RGB10A2UI";
      GFXFormat[GFXFormat["RGB9E5"] = 52] = "RGB9E5";
      GFXFormat[GFXFormat["D16"] = 53] = "D16";
      GFXFormat[GFXFormat["D16S8"] = 54] = "D16S8";
      GFXFormat[GFXFormat["D24"] = 55] = "D24";
      GFXFormat[GFXFormat["D24S8"] = 56] = "D24S8";
      GFXFormat[GFXFormat["D32F"] = 57] = "D32F";
      GFXFormat[GFXFormat["D32F_S8"] = 58] = "D32F_S8";
      GFXFormat[GFXFormat["BC1"] = 59] = "BC1";
      GFXFormat[GFXFormat["BC1_ALPHA"] = 60] = "BC1_ALPHA";
      GFXFormat[GFXFormat["BC1_SRGB"] = 61] = "BC1_SRGB";
      GFXFormat[GFXFormat["BC1_SRGB_ALPHA"] = 62] = "BC1_SRGB_ALPHA";
      GFXFormat[GFXFormat["BC2"] = 63] = "BC2";
      GFXFormat[GFXFormat["BC2_SRGB"] = 64] = "BC2_SRGB";
      GFXFormat[GFXFormat["BC3"] = 65] = "BC3";
      GFXFormat[GFXFormat["BC3_SRGB"] = 66] = "BC3_SRGB";
      GFXFormat[GFXFormat["BC4"] = 67] = "BC4";
      GFXFormat[GFXFormat["BC4_SNORM"] = 68] = "BC4_SNORM";
      GFXFormat[GFXFormat["BC5"] = 69] = "BC5";
      GFXFormat[GFXFormat["BC5_SNORM"] = 70] = "BC5_SNORM";
      GFXFormat[GFXFormat["BC6H_UF16"] = 71] = "BC6H_UF16";
      GFXFormat[GFXFormat["BC6H_SF16"] = 72] = "BC6H_SF16";
      GFXFormat[GFXFormat["BC7"] = 73] = "BC7";
      GFXFormat[GFXFormat["BC7_SRGB"] = 74] = "BC7_SRGB";
      GFXFormat[GFXFormat["ETC_RGB8"] = 75] = "ETC_RGB8";
      GFXFormat[GFXFormat["ETC2_RGB8"] = 76] = "ETC2_RGB8";
      GFXFormat[GFXFormat["ETC2_SRGB8"] = 77] = "ETC2_SRGB8";
      GFXFormat[GFXFormat["ETC2_RGB8_A1"] = 78] = "ETC2_RGB8_A1";
      GFXFormat[GFXFormat["ETC2_SRGB8_A1"] = 79] = "ETC2_SRGB8_A1";
      GFXFormat[GFXFormat["ETC2_RGBA8"] = 80] = "ETC2_RGBA8";
      GFXFormat[GFXFormat["ETC2_SRGB8_A8"] = 81] = "ETC2_SRGB8_A8";
      GFXFormat[GFXFormat["EAC_R11"] = 82] = "EAC_R11";
      GFXFormat[GFXFormat["EAC_R11SN"] = 83] = "EAC_R11SN";
      GFXFormat[GFXFormat["EAC_RG11"] = 84] = "EAC_RG11";
      GFXFormat[GFXFormat["EAC_RG11SN"] = 85] = "EAC_RG11SN";
      GFXFormat[GFXFormat["PVRTC_RGB2"] = 86] = "PVRTC_RGB2";
      GFXFormat[GFXFormat["PVRTC_RGBA2"] = 87] = "PVRTC_RGBA2";
      GFXFormat[GFXFormat["PVRTC_RGB4"] = 88] = "PVRTC_RGB4";
      GFXFormat[GFXFormat["PVRTC_RGBA4"] = 89] = "PVRTC_RGBA4";
      GFXFormat[GFXFormat["PVRTC2_2BPP"] = 90] = "PVRTC2_2BPP";
      GFXFormat[GFXFormat["PVRTC2_4BPP"] = 91] = "PVRTC2_4BPP";
    })(GFXFormat || (GFXFormat = {}));
    var GFXBufferUsageBit;
    (function(GFXBufferUsageBit) {
      GFXBufferUsageBit[GFXBufferUsageBit["NONE"] = 0] = "NONE";
      GFXBufferUsageBit[GFXBufferUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
      GFXBufferUsageBit[GFXBufferUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
      GFXBufferUsageBit[GFXBufferUsageBit["INDEX"] = 4] = "INDEX";
      GFXBufferUsageBit[GFXBufferUsageBit["VERTEX"] = 8] = "VERTEX";
      GFXBufferUsageBit[GFXBufferUsageBit["UNIFORM"] = 16] = "UNIFORM";
      GFXBufferUsageBit[GFXBufferUsageBit["STORAGE"] = 32] = "STORAGE";
      GFXBufferUsageBit[GFXBufferUsageBit["INDIRECT"] = 64] = "INDIRECT";
    })(GFXBufferUsageBit || (GFXBufferUsageBit = {}));
    var GFXMemoryUsageBit;
    (function(GFXMemoryUsageBit) {
      GFXMemoryUsageBit[GFXMemoryUsageBit["NONE"] = 0] = "NONE";
      GFXMemoryUsageBit[GFXMemoryUsageBit["DEVICE"] = 1] = "DEVICE";
      GFXMemoryUsageBit[GFXMemoryUsageBit["HOST"] = 2] = "HOST";
    })(GFXMemoryUsageBit || (GFXMemoryUsageBit = {}));
    var GFXBufferAccessBit;
    (function(GFXBufferAccessBit) {
      GFXBufferAccessBit[GFXBufferAccessBit["NONE"] = 0] = "NONE";
      GFXBufferAccessBit[GFXBufferAccessBit["READ"] = 1] = "READ";
      GFXBufferAccessBit[GFXBufferAccessBit["WRITE"] = 2] = "WRITE";
    })(GFXBufferAccessBit || (GFXBufferAccessBit = {}));
    var GFXPrimitiveMode;
    (function(GFXPrimitiveMode) {
      GFXPrimitiveMode[GFXPrimitiveMode["POINT_LIST"] = 0] = "POINT_LIST";
      GFXPrimitiveMode[GFXPrimitiveMode["LINE_LIST"] = 1] = "LINE_LIST";
      GFXPrimitiveMode[GFXPrimitiveMode["LINE_STRIP"] = 2] = "LINE_STRIP";
      GFXPrimitiveMode[GFXPrimitiveMode["LINE_LOOP"] = 3] = "LINE_LOOP";
      GFXPrimitiveMode[GFXPrimitiveMode["LINE_LIST_ADJACENCY"] = 4] = "LINE_LIST_ADJACENCY";
      GFXPrimitiveMode[GFXPrimitiveMode["LINE_STRIP_ADJACENCY"] = 5] = "LINE_STRIP_ADJACENCY";
      GFXPrimitiveMode[GFXPrimitiveMode["ISO_LINE_LIST"] = 6] = "ISO_LINE_LIST";
      GFXPrimitiveMode[GFXPrimitiveMode["TRIANGLE_LIST"] = 7] = "TRIANGLE_LIST";
      GFXPrimitiveMode[GFXPrimitiveMode["TRIANGLE_STRIP"] = 8] = "TRIANGLE_STRIP";
      GFXPrimitiveMode[GFXPrimitiveMode["TRIANGLE_FAN"] = 9] = "TRIANGLE_FAN";
      GFXPrimitiveMode[GFXPrimitiveMode["TRIANGLE_LIST_ADJACENCY"] = 10] = "TRIANGLE_LIST_ADJACENCY";
      GFXPrimitiveMode[GFXPrimitiveMode["TRIANGLE_STRIP_ADJACENCY"] = 11] = "TRIANGLE_STRIP_ADJACENCY";
      GFXPrimitiveMode[GFXPrimitiveMode["TRIANGLE_PATCH_ADJACENCY"] = 12] = "TRIANGLE_PATCH_ADJACENCY";
      GFXPrimitiveMode[GFXPrimitiveMode["QUAD_PATCH_LIST"] = 13] = "QUAD_PATCH_LIST";
    })(GFXPrimitiveMode || (GFXPrimitiveMode = {}));
    var GFXPolygonMode;
    (function(GFXPolygonMode) {
      GFXPolygonMode[GFXPolygonMode["FILL"] = 0] = "FILL";
      GFXPolygonMode[GFXPolygonMode["POINT"] = 1] = "POINT";
      GFXPolygonMode[GFXPolygonMode["LINE"] = 2] = "LINE";
    })(GFXPolygonMode || (GFXPolygonMode = {}));
    var GFXShadeModel;
    (function(GFXShadeModel) {
      GFXShadeModel[GFXShadeModel["GOURAND"] = 0] = "GOURAND";
      GFXShadeModel[GFXShadeModel["FLAT"] = 1] = "FLAT";
    })(GFXShadeModel || (GFXShadeModel = {}));
    var GFXCullMode;
    (function(GFXCullMode) {
      GFXCullMode[GFXCullMode["NONE"] = 0] = "NONE";
      GFXCullMode[GFXCullMode["FRONT"] = 1] = "FRONT";
      GFXCullMode[GFXCullMode["BACK"] = 2] = "BACK";
    })(GFXCullMode || (GFXCullMode = {}));
    var GFXComparisonFunc;
    (function(GFXComparisonFunc) {
      GFXComparisonFunc[GFXComparisonFunc["NEVER"] = 0] = "NEVER";
      GFXComparisonFunc[GFXComparisonFunc["LESS"] = 1] = "LESS";
      GFXComparisonFunc[GFXComparisonFunc["EQUAL"] = 2] = "EQUAL";
      GFXComparisonFunc[GFXComparisonFunc["LESS_EQUAL"] = 3] = "LESS_EQUAL";
      GFXComparisonFunc[GFXComparisonFunc["GREATER"] = 4] = "GREATER";
      GFXComparisonFunc[GFXComparisonFunc["NOT_EQUAL"] = 5] = "NOT_EQUAL";
      GFXComparisonFunc[GFXComparisonFunc["GREATER_EQUAL"] = 6] = "GREATER_EQUAL";
      GFXComparisonFunc[GFXComparisonFunc["ALWAYS"] = 7] = "ALWAYS";
    })(GFXComparisonFunc || (GFXComparisonFunc = {}));
    var GFXStencilOp;
    (function(GFXStencilOp) {
      GFXStencilOp[GFXStencilOp["ZERO"] = 0] = "ZERO";
      GFXStencilOp[GFXStencilOp["KEEP"] = 1] = "KEEP";
      GFXStencilOp[GFXStencilOp["REPLACE"] = 2] = "REPLACE";
      GFXStencilOp[GFXStencilOp["INCR"] = 3] = "INCR";
      GFXStencilOp[GFXStencilOp["DECR"] = 4] = "DECR";
      GFXStencilOp[GFXStencilOp["INVERT"] = 5] = "INVERT";
      GFXStencilOp[GFXStencilOp["INCR_WRAP"] = 6] = "INCR_WRAP";
      GFXStencilOp[GFXStencilOp["DECR_WRAP"] = 7] = "DECR_WRAP";
    })(GFXStencilOp || (GFXStencilOp = {}));
    var GFXBlendOp;
    (function(GFXBlendOp) {
      GFXBlendOp[GFXBlendOp["ADD"] = 0] = "ADD";
      GFXBlendOp[GFXBlendOp["SUB"] = 1] = "SUB";
      GFXBlendOp[GFXBlendOp["REV_SUB"] = 2] = "REV_SUB";
      GFXBlendOp[GFXBlendOp["MIN"] = 3] = "MIN";
      GFXBlendOp[GFXBlendOp["MAX"] = 4] = "MAX";
    })(GFXBlendOp || (GFXBlendOp = {}));
    var GFXBlendFactor;
    (function(GFXBlendFactor) {
      GFXBlendFactor[GFXBlendFactor["ZERO"] = 0] = "ZERO";
      GFXBlendFactor[GFXBlendFactor["ONE"] = 1] = "ONE";
      GFXBlendFactor[GFXBlendFactor["SRC_ALPHA"] = 2] = "SRC_ALPHA";
      GFXBlendFactor[GFXBlendFactor["DST_ALPHA"] = 3] = "DST_ALPHA";
      GFXBlendFactor[GFXBlendFactor["ONE_MINUS_SRC_ALPHA"] = 4] = "ONE_MINUS_SRC_ALPHA";
      GFXBlendFactor[GFXBlendFactor["ONE_MINUS_DST_ALPHA"] = 5] = "ONE_MINUS_DST_ALPHA";
      GFXBlendFactor[GFXBlendFactor["SRC_COLOR"] = 6] = "SRC_COLOR";
      GFXBlendFactor[GFXBlendFactor["DST_COLOR"] = 7] = "DST_COLOR";
      GFXBlendFactor[GFXBlendFactor["ONE_MINUS_SRC_COLOR"] = 8] = "ONE_MINUS_SRC_COLOR";
      GFXBlendFactor[GFXBlendFactor["ONE_MINUS_DST_COLOR"] = 9] = "ONE_MINUS_DST_COLOR";
      GFXBlendFactor[GFXBlendFactor["SRC_ALPHA_SATURATE"] = 10] = "SRC_ALPHA_SATURATE";
      GFXBlendFactor[GFXBlendFactor["CONSTANT_COLOR"] = 11] = "CONSTANT_COLOR";
      GFXBlendFactor[GFXBlendFactor["ONE_MINUS_CONSTANT_COLOR"] = 12] = "ONE_MINUS_CONSTANT_COLOR";
      GFXBlendFactor[GFXBlendFactor["CONSTANT_ALPHA"] = 13] = "CONSTANT_ALPHA";
      GFXBlendFactor[GFXBlendFactor["ONE_MINUS_CONSTANT_ALPHA"] = 14] = "ONE_MINUS_CONSTANT_ALPHA";
    })(GFXBlendFactor || (GFXBlendFactor = {}));
    var GFXColorMask;
    (function(GFXColorMask) {
      GFXColorMask[GFXColorMask["NONE"] = 0] = "NONE";
      GFXColorMask[GFXColorMask["R"] = 1] = "R";
      GFXColorMask[GFXColorMask["G"] = 2] = "G";
      GFXColorMask[GFXColorMask["B"] = 4] = "B";
      GFXColorMask[GFXColorMask["A"] = 8] = "A";
      GFXColorMask[GFXColorMask["ALL"] = 15] = "ALL";
    })(GFXColorMask || (GFXColorMask = {}));
    var GFXFilter;
    (function(GFXFilter) {
      GFXFilter[GFXFilter["NONE"] = 0] = "NONE";
      GFXFilter[GFXFilter["POINT"] = 1] = "POINT";
      GFXFilter[GFXFilter["LINEAR"] = 2] = "LINEAR";
      GFXFilter[GFXFilter["ANISOTROPIC"] = 3] = "ANISOTROPIC";
    })(GFXFilter || (GFXFilter = {}));
    var GFXAddress;
    (function(GFXAddress) {
      GFXAddress[GFXAddress["WRAP"] = 0] = "WRAP";
      GFXAddress[GFXAddress["MIRROR"] = 1] = "MIRROR";
      GFXAddress[GFXAddress["CLAMP"] = 2] = "CLAMP";
      GFXAddress[GFXAddress["BORDER"] = 3] = "BORDER";
    })(GFXAddress || (GFXAddress = {}));
    var GFXTextureType;
    (function(GFXTextureType) {
      GFXTextureType[GFXTextureType["TEX1D"] = 0] = "TEX1D";
      GFXTextureType[GFXTextureType["TEX2D"] = 1] = "TEX2D";
      GFXTextureType[GFXTextureType["TEX3D"] = 2] = "TEX3D";
    })(GFXTextureType || (GFXTextureType = {}));
    var GFXTextureUsageBit;
    (function(GFXTextureUsageBit) {
      GFXTextureUsageBit[GFXTextureUsageBit["NONE"] = 0] = "NONE";
      GFXTextureUsageBit[GFXTextureUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
      GFXTextureUsageBit[GFXTextureUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
      GFXTextureUsageBit[GFXTextureUsageBit["SAMPLED"] = 4] = "SAMPLED";
      GFXTextureUsageBit[GFXTextureUsageBit["STORAGE"] = 8] = "STORAGE";
      GFXTextureUsageBit[GFXTextureUsageBit["COLOR_ATTACHMENT"] = 16] = "COLOR_ATTACHMENT";
      GFXTextureUsageBit[GFXTextureUsageBit["DEPTH_STENCIL_ATTACHMENT"] = 32] = "DEPTH_STENCIL_ATTACHMENT";
      GFXTextureUsageBit[GFXTextureUsageBit["TRANSIENT_ATTACHMENT"] = 64] = "TRANSIENT_ATTACHMENT";
      GFXTextureUsageBit[GFXTextureUsageBit["INPUT_ATTACHMENT"] = 128] = "INPUT_ATTACHMENT";
    })(GFXTextureUsageBit || (GFXTextureUsageBit = {}));
    var GFXSampleCount;
    (function(GFXSampleCount) {
      GFXSampleCount[GFXSampleCount["X1"] = 0] = "X1";
      GFXSampleCount[GFXSampleCount["X2"] = 1] = "X2";
      GFXSampleCount[GFXSampleCount["X4"] = 2] = "X4";
      GFXSampleCount[GFXSampleCount["X8"] = 3] = "X8";
      GFXSampleCount[GFXSampleCount["X16"] = 4] = "X16";
      GFXSampleCount[GFXSampleCount["X32"] = 5] = "X32";
      GFXSampleCount[GFXSampleCount["X64"] = 6] = "X64";
    })(GFXSampleCount || (GFXSampleCount = {}));
    var GFXTextureFlagBit;
    (function(GFXTextureFlagBit) {
      GFXTextureFlagBit[GFXTextureFlagBit["NONE"] = 0] = "NONE";
      GFXTextureFlagBit[GFXTextureFlagBit["GEN_MIPMAP"] = 1] = "GEN_MIPMAP";
      GFXTextureFlagBit[GFXTextureFlagBit["CUBEMAP"] = 2] = "CUBEMAP";
      GFXTextureFlagBit[GFXTextureFlagBit["BAKUP_BUFFER"] = 4] = "BAKUP_BUFFER";
    })(GFXTextureFlagBit || (GFXTextureFlagBit = {}));
    var GFXTextureViewType;
    (function(GFXTextureViewType) {
      GFXTextureViewType[GFXTextureViewType["TV1D"] = 0] = "TV1D";
      GFXTextureViewType[GFXTextureViewType["TV2D"] = 1] = "TV2D";
      GFXTextureViewType[GFXTextureViewType["TV3D"] = 2] = "TV3D";
      GFXTextureViewType[GFXTextureViewType["CUBE"] = 3] = "CUBE";
      GFXTextureViewType[GFXTextureViewType["TV1D_ARRAY"] = 4] = "TV1D_ARRAY";
      GFXTextureViewType[GFXTextureViewType["TV2D_ARRAY"] = 5] = "TV2D_ARRAY";
    })(GFXTextureViewType || (GFXTextureViewType = {}));
    var GFXShaderType;
    (function(GFXShaderType) {
      GFXShaderType[GFXShaderType["VERTEX"] = 0] = "VERTEX";
      GFXShaderType[GFXShaderType["HULL"] = 1] = "HULL";
      GFXShaderType[GFXShaderType["DOMAIN"] = 2] = "DOMAIN";
      GFXShaderType[GFXShaderType["GEOMETRY"] = 3] = "GEOMETRY";
      GFXShaderType[GFXShaderType["FRAGMENT"] = 4] = "FRAGMENT";
      GFXShaderType[GFXShaderType["COMPUTE"] = 5] = "COMPUTE";
      GFXShaderType[GFXShaderType["COUNT"] = 6] = "COUNT";
    })(GFXShaderType || (GFXShaderType = {}));
    var GFXBindingType;
    (function(GFXBindingType) {
      GFXBindingType[GFXBindingType["UNKNOWN"] = 0] = "UNKNOWN";
      GFXBindingType[GFXBindingType["UNIFORM_BUFFER"] = 1] = "UNIFORM_BUFFER";
      GFXBindingType[GFXBindingType["SAMPLER"] = 2] = "SAMPLER";
      GFXBindingType[GFXBindingType["STORAGE_BUFFER"] = 3] = "STORAGE_BUFFER";
    })(GFXBindingType || (GFXBindingType = {}));
    var GFXCommandBufferType;
    (function(GFXCommandBufferType) {
      GFXCommandBufferType[GFXCommandBufferType["PRIMARY"] = 0] = "PRIMARY";
      GFXCommandBufferType[GFXCommandBufferType["SECONDARY"] = 1] = "SECONDARY";
    })(GFXCommandBufferType || (GFXCommandBufferType = {}));
    var GFXLoadOp;
    (function(GFXLoadOp) {
      GFXLoadOp[GFXLoadOp["LOAD"] = 0] = "LOAD";
      GFXLoadOp[GFXLoadOp["CLEAR"] = 1] = "CLEAR";
      GFXLoadOp[GFXLoadOp["DISCARD"] = 2] = "DISCARD";
    })(GFXLoadOp || (GFXLoadOp = {}));
    var GFXStoreOp;
    (function(GFXStoreOp) {
      GFXStoreOp[GFXStoreOp["STORE"] = 0] = "STORE";
      GFXStoreOp[GFXStoreOp["DISCARD"] = 1] = "DISCARD";
    })(GFXStoreOp || (GFXStoreOp = {}));
    var GFXTextureLayout;
    (function(GFXTextureLayout) {
      GFXTextureLayout[GFXTextureLayout["UNDEFINED"] = 0] = "UNDEFINED";
      GFXTextureLayout[GFXTextureLayout["GENERAL"] = 1] = "GENERAL";
      GFXTextureLayout[GFXTextureLayout["COLOR_ATTACHMENT_OPTIMAL"] = 2] = "COLOR_ATTACHMENT_OPTIMAL";
      GFXTextureLayout[GFXTextureLayout["DEPTH_STENCIL_ATTACHMENT_OPTIMAL"] = 3] = "DEPTH_STENCIL_ATTACHMENT_OPTIMAL";
      GFXTextureLayout[GFXTextureLayout["DEPTH_STENCIL_READONLY_OPTIMAL"] = 4] = "DEPTH_STENCIL_READONLY_OPTIMAL";
      GFXTextureLayout[GFXTextureLayout["SHADER_READONLY_OPTIMAL"] = 5] = "SHADER_READONLY_OPTIMAL";
      GFXTextureLayout[GFXTextureLayout["TRANSFER_SRC_OPTIMAL"] = 6] = "TRANSFER_SRC_OPTIMAL";
      GFXTextureLayout[GFXTextureLayout["TRANSFER_DST_OPTIMAL"] = 7] = "TRANSFER_DST_OPTIMAL";
      GFXTextureLayout[GFXTextureLayout["PREINITIALIZED"] = 8] = "PREINITIALIZED";
      GFXTextureLayout[GFXTextureLayout["PRESENT_SRC"] = 9] = "PRESENT_SRC";
    })(GFXTextureLayout || (GFXTextureLayout = {}));
    var GFXPipelineBindPoint;
    (function(GFXPipelineBindPoint) {
      GFXPipelineBindPoint[GFXPipelineBindPoint["GRAPHICS"] = 0] = "GRAPHICS";
      GFXPipelineBindPoint[GFXPipelineBindPoint["COMPUTE"] = 1] = "COMPUTE";
      GFXPipelineBindPoint[GFXPipelineBindPoint["RAY_TRACING"] = 2] = "RAY_TRACING";
    })(GFXPipelineBindPoint || (GFXPipelineBindPoint = {}));
    var GFXDynamicState;
    (function(GFXDynamicState) {
      GFXDynamicState[GFXDynamicState["VIEWPORT"] = 0] = "VIEWPORT";
      GFXDynamicState[GFXDynamicState["SCISSOR"] = 1] = "SCISSOR";
      GFXDynamicState[GFXDynamicState["LINE_WIDTH"] = 2] = "LINE_WIDTH";
      GFXDynamicState[GFXDynamicState["DEPTH_BIAS"] = 3] = "DEPTH_BIAS";
      GFXDynamicState[GFXDynamicState["BLEND_CONSTANTS"] = 4] = "BLEND_CONSTANTS";
      GFXDynamicState[GFXDynamicState["DEPTH_BOUNDS"] = 5] = "DEPTH_BOUNDS";
      GFXDynamicState[GFXDynamicState["STENCIL_WRITE_MASK"] = 6] = "STENCIL_WRITE_MASK";
      GFXDynamicState[GFXDynamicState["STENCIL_COMPARE_MASK"] = 7] = "STENCIL_COMPARE_MASK";
    })(GFXDynamicState || (GFXDynamicState = {}));
    var GFXStencilFace;
    (function(GFXStencilFace) {
      GFXStencilFace[GFXStencilFace["FRONT"] = 0] = "FRONT";
      GFXStencilFace[GFXStencilFace["BACK"] = 1] = "BACK";
      GFXStencilFace[GFXStencilFace["ALL"] = 2] = "ALL";
    })(GFXStencilFace || (GFXStencilFace = {}));
    var GFXQueueType;
    (function(GFXQueueType) {
      GFXQueueType[GFXQueueType["GRAPHICS"] = 0] = "GRAPHICS";
      GFXQueueType[GFXQueueType["COMPUTE"] = 1] = "COMPUTE";
      GFXQueueType[GFXQueueType["TRANSFER"] = 2] = "TRANSFER";
    })(GFXQueueType || (GFXQueueType = {}));
    var GFXClearFlag;
    (function(GFXClearFlag) {
      GFXClearFlag[GFXClearFlag["NONE"] = 0] = "NONE";
      GFXClearFlag[GFXClearFlag["COLOR"] = 1] = "COLOR";
      GFXClearFlag[GFXClearFlag["DEPTH"] = 2] = "DEPTH";
      GFXClearFlag[GFXClearFlag["STENCIL"] = 4] = "STENCIL";
      GFXClearFlag[GFXClearFlag["DEPTH_STENCIL"] = 6] = "DEPTH_STENCIL";
      GFXClearFlag[GFXClearFlag["ALL"] = 7] = "ALL";
    })(GFXClearFlag || (GFXClearFlag = {}));
    function GFXGetTypeSize(type) {
      switch (type) {
       case GFXType.BOOL:
       case GFXType.INT:
       case GFXType.UINT:
       case GFXType.FLOAT:
        return 4;

       case GFXType.BOOL2:
       case GFXType.INT2:
       case GFXType.UINT2:
       case GFXType.FLOAT2:
        return 8;

       case GFXType.BOOL3:
       case GFXType.INT3:
       case GFXType.UINT3:
       case GFXType.FLOAT3:
        return 12;

       case GFXType.BOOL4:
       case GFXType.INT4:
       case GFXType.UINT4:
       case GFXType.FLOAT4:
       case GFXType.MAT2:
        return 16;

       case GFXType.MAT2X3:
        return 24;

       case GFXType.MAT2X4:
        return 32;

       case GFXType.MAT3X2:
        return 24;

       case GFXType.MAT3:
        return 36;

       case GFXType.MAT3X4:
        return 48;

       case GFXType.MAT4X2:
       case GFXType.MAT4X2:
        return 32;

       case GFXType.MAT4:
        return 64;

       case GFXType.SAMPLER1D:
       case GFXType.SAMPLER1D_ARRAY:
       case GFXType.SAMPLER2D:
       case GFXType.SAMPLER2D_ARRAY:
       case GFXType.SAMPLER3D:
       case GFXType.SAMPLER_CUBE:
        return 4;

       default:
        return 0;
      }
    }
    var RenderPassStage;
    (function(RenderPassStage) {
      RenderPassStage[RenderPassStage["DEFAULT"] = 100] = "DEFAULT";
    })(RenderPassStage || (RenderPassStage = {}));
    var RenderPriority;
    (function(RenderPriority) {
      RenderPriority[RenderPriority["MIN"] = 0] = "MIN";
      RenderPriority[RenderPriority["MAX"] = 255] = "MAX";
      RenderPriority[RenderPriority["DEFAULT"] = 128] = "DEFAULT";
    })(RenderPriority || (RenderPriority = {}));
    var MAX_BINDING_SUPPORTED = 24;
    var UniformBinding;
    (function(UniformBinding) {
      UniformBinding[UniformBinding["UBO_GLOBAL"] = MAX_BINDING_SUPPORTED - 1] = "UBO_GLOBAL";
      UniformBinding[UniformBinding["UBO_SHADOW"] = MAX_BINDING_SUPPORTED - 2] = "UBO_SHADOW";
      UniformBinding[UniformBinding["UBO_LOCAL"] = MAX_BINDING_SUPPORTED - 3] = "UBO_LOCAL";
      UniformBinding[UniformBinding["UBO_FORWARD_LIGHTS"] = MAX_BINDING_SUPPORTED - 4] = "UBO_FORWARD_LIGHTS";
      UniformBinding[UniformBinding["UBO_SKINNING"] = MAX_BINDING_SUPPORTED - 5] = "UBO_SKINNING";
      UniformBinding[UniformBinding["UBO_SKINNING_TEXTURE"] = MAX_BINDING_SUPPORTED - 6] = "UBO_SKINNING_TEXTURE";
      UniformBinding[UniformBinding["UBO_UI"] = MAX_BINDING_SUPPORTED - 7] = "UBO_UI";
      UniformBinding[UniformBinding["SAMPLER_JOINTS"] = MAX_BINDING_SUPPORTED + 1] = "SAMPLER_JOINTS";
      UniformBinding[UniformBinding["SAMPLER_ENVIRONMENT"] = MAX_BINDING_SUPPORTED + 2] = "SAMPLER_ENVIRONMENT";
      UniformBinding[UniformBinding["CUSTUM_UBO_BINDING_END_POINT"] = MAX_BINDING_SUPPORTED - 7] = "CUSTUM_UBO_BINDING_END_POINT";
      UniformBinding[UniformBinding["CUSTOM_SAMPLER_BINDING_START_POINT"] = MAX_BINDING_SUPPORTED + 6] = "CUSTOM_SAMPLER_BINDING_START_POINT";
    })(UniformBinding || (UniformBinding = {}));
    var _a, _b;
    var SamplerInfoIndex;
    (function(SamplerInfoIndex) {
      SamplerInfoIndex[SamplerInfoIndex["minFilter"] = 0] = "minFilter";
      SamplerInfoIndex[SamplerInfoIndex["magFilter"] = 1] = "magFilter";
      SamplerInfoIndex[SamplerInfoIndex["mipFilter"] = 2] = "mipFilter";
      SamplerInfoIndex[SamplerInfoIndex["addressU"] = 3] = "addressU";
      SamplerInfoIndex[SamplerInfoIndex["addressV"] = 4] = "addressV";
      SamplerInfoIndex[SamplerInfoIndex["addressW"] = 5] = "addressW";
      SamplerInfoIndex[SamplerInfoIndex["maxAnisotropy"] = 6] = "maxAnisotropy";
      SamplerInfoIndex[SamplerInfoIndex["cmpFunc"] = 7] = "cmpFunc";
      SamplerInfoIndex[SamplerInfoIndex["minLOD"] = 8] = "minLOD";
      SamplerInfoIndex[SamplerInfoIndex["maxLOD"] = 9] = "maxLOD";
      SamplerInfoIndex[SamplerInfoIndex["mipLODBias"] = 10] = "mipLODBias";
      SamplerInfoIndex[SamplerInfoIndex["borderColor"] = 11] = "borderColor";
      SamplerInfoIndex[SamplerInfoIndex["total"] = 15] = "total";
    })(SamplerInfoIndex || (SamplerInfoIndex = {}));
    var typeMap = {};
    typeMap[typeMap["bool"] = GFXType.BOOL] = "bool";
    typeMap[typeMap["int"] = GFXType.INT] = "int";
    typeMap[typeMap["ivec2"] = GFXType.INT2] = "ivec2invTypeParams";
    typeMap[typeMap["ivec3"] = GFXType.INT3] = "ivec3";
    typeMap[typeMap["ivec4"] = GFXType.INT4] = "ivec4";
    typeMap[typeMap["float"] = GFXType.FLOAT] = "float";
    typeMap[typeMap["vec2"] = GFXType.FLOAT2] = "vec2";
    typeMap[typeMap["vec3"] = GFXType.FLOAT3] = "vec3";
    typeMap[typeMap["vec4"] = GFXType.FLOAT4] = "vec4";
    typeMap[typeMap["mat2"] = GFXType.MAT2] = "mat2";
    typeMap[typeMap["mat3"] = GFXType.MAT3] = "mat3";
    typeMap[typeMap["mat4"] = GFXType.MAT4] = "mat4";
    typeMap[typeMap["sampler2D"] = GFXType.SAMPLER2D] = "sampler2D";
    typeMap[typeMap["samplerCube"] = GFXType.SAMPLER_CUBE] = "samplerCube";
    var sizeMap = (_a = {}, _a[GFXType.BOOL] = 4, _a[GFXType.INT] = 4, _a[GFXType.INT2] = 8, 
    _a[GFXType.INT3] = 12, _a[GFXType.INT4] = 16, _a[GFXType.FLOAT] = 4, _a[GFXType.FLOAT2] = 8, 
    _a[GFXType.FLOAT3] = 12, _a[GFXType.FLOAT4] = 16, _a[GFXType.MAT2] = 16, _a[GFXType.MAT3] = 36, 
    _a[GFXType.MAT4] = 64, _a[GFXType.SAMPLER2D] = 4, _a[GFXType.SAMPLER_CUBE] = 4, 
    _a);
    var formatMap = (_b = {}, _b[GFXType.BOOL] = GFXFormat.R32I, _b[GFXType.INT] = GFXFormat.R32I, 
    _b[GFXType.INT2] = GFXFormat.RG32I, _b[GFXType.INT3] = GFXFormat.RGB32I, _b[GFXType.INT4] = GFXFormat.RGBA32I, 
    _b[GFXType.FLOAT] = GFXFormat.R32F, _b[GFXType.FLOAT2] = GFXFormat.RG32F, _b[GFXType.FLOAT3] = GFXFormat.RGB32F, 
    _b[GFXType.FLOAT4] = GFXFormat.RGBA32F, _b);
    var passParams = {
      BACK: enums.CULL_BACK,
      FRONT: enums.CULL_FRONT,
      NONE: enums.CULL_NONE,
      ADD: enums.BLEND_FUNC_ADD,
      SUB: enums.BLEND_FUNC_SUBTRACT,
      REV_SUB: enums.BLEND_FUNC_REVERSE_SUBTRACT,
      ZERO: enums.BLEND_ZERO,
      ONE: enums.BLEND_ONE,
      SRC_COLOR: enums.BLEND_SRC_COLOR,
      ONE_MINUS_SRC_COLOR: enums.BLEND_ONE_MINUS_SRC_COLOR,
      DST_COLOR: enums.BLEND_DST_COLOR,
      ONE_MINUS_DST_COLOR: enums.BLEND_ONE_MINUS_DST_COLOR,
      SRC_ALPHA: enums.BLEND_SRC_ALPHA,
      ONE_MINUS_SRC_ALPHA: enums.BLEND_ONE_MINUS_SRC_ALPHA,
      DST_ALPHA: enums.BLEND_DST_ALPHA,
      ONE_MINUS_DST_ALPHA: enums.BLEND_ONE_MINUS_DST_ALPHA,
      CONSTANT_COLOR: enums.BLEND_CONSTANT_COLOR,
      ONE_MINUS_CONSTANT_COLOR: enums.BLEND_ONE_MINUS_CONSTANT_COLOR,
      CONSTANT_ALPHA: enums.BLEND_CONSTANT_ALPHA,
      ONE_MINUS_CONSTANT_ALPHA: enums.BLEND_ONE_MINUS_CONSTANT_ALPHA,
      SRC_ALPHA_SATURATE: enums.BLEND_SRC_ALPHA_SATURATE,
      NEVER: enums.DS_FUNC_NEVER,
      LESS: enums.DS_FUNC_LESS,
      EQUAL: enums.DS_FUNC_EQUAL,
      LEQUAL: enums.DS_FUNC_LEQUAL,
      GREATER: enums.DS_FUNC_GREATER,
      NOTEQUAL: enums.DS_FUNC_NOTEQUAL,
      GEQUAL: enums.DS_FUNC_GEQUAL,
      ALWAYS: enums.DS_FUNC_ALWAYS,
      KEEP: enums.STENCIL_OP_KEEP,
      REPLACE: enums.STENCIL_OP_REPLACE,
      INCR: enums.STENCIL_OP_INCR,
      INCR_WRAP: enums.STENCIL_OP_INCR_WRAP,
      DECR: enums.STENCIL_OP_DECR,
      DECR_WRAP: enums.STENCIL_OP_DECR_WRAP,
      INVERT: enums.STENCIL_OP_INVERT
    };
    Object.assign(passParams, RenderPassStage);
    var effectStructure = {
      $techniques: [ {
        $passes: [ {
          depthStencilState: {},
          rasterizerState: {},
          blendState: {
            targets: [ {} ]
          },
          properties: {
            any: {
              sampler: {},
              inspector: {}
            }
          }
        } ]
      } ]
    };
    var mappings = {
      murmurhash2_32_gc: murmurhash2_32_gc,
      SamplerInfoIndex: SamplerInfoIndex,
      effectStructure: effectStructure,
      typeMap: typeMap,
      sizeMap: sizeMap,
      formatMap: formatMap,
      passParams: passParams,
      RenderQueue: RenderQueue,
      RenderPriority: RenderPriority,
      GFXGetTypeSize: GFXGetTypeSize,
      UniformBinding: UniformBinding
    };
    module.exports = mappings;
  }), {} ],
  423: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _gfx = _interopRequireDefault(require("../gfx"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var InputAssembler = (function() {
      function InputAssembler(vb, ib, pt) {
        void 0 === pt && (pt = _gfx["default"].PT_TRIANGLES);
        this._vertexBuffer = vb;
        this._indexBuffer = ib;
        this._primitiveType = pt;
        this._start = 0;
        this._count = -1;
      }
      _createClass(InputAssembler, [ {
        key: "count",
        get: function get() {
          if (-1 !== this._count) return this._count;
          if (this._indexBuffer) return this._indexBuffer.count;
          if (this._vertexBuffer) return this._vertexBuffer.count;
          return 0;
        }
      } ]);
      return InputAssembler;
    })();
    exports["default"] = InputAssembler;
    module.exports = exports["default"];
  }), {
    "../gfx": 427
  } ],
  424: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _gfx = _interopRequireDefault(require("../gfx"));
    var _enums = _interopRequireDefault(require("../enums"));
    var _valueType = _interopRequireDefault(require("../../core/value-types/value-type"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var Pass = (function() {
      function Pass(name, detailName, programName, stage, properties, defines) {
        void 0 === properties && (properties = {});
        void 0 === defines && (defines = {});
        this._name = name;
        this._detailName = detailName;
        this._programName = programName;
        this._programKey = null;
        this._stage = stage;
        this._properties = properties;
        this._defines = defines;
        this._propertyNames = Object.keys(properties);
        this._defineNames = Object.keys(defines);
        this._cullMode = _gfx["default"].CULL_BACK;
        this._blend = false;
        this._blendEq = _gfx["default"].BLEND_FUNC_ADD;
        this._blendAlphaEq = _gfx["default"].BLEND_FUNC_ADD;
        this._blendSrc = _gfx["default"].BLEND_SRC_ALPHA;
        this._blendDst = _gfx["default"].BLEND_ONE_MINUS_SRC_ALPHA;
        this._blendSrcAlpha = _gfx["default"].BLEND_SRC_ALPHA;
        this._blendDstAlpha = _gfx["default"].BLEND_ONE_MINUS_SRC_ALPHA;
        this._blendColor = 4294967295;
        this._depthTest = false;
        this._depthWrite = false;
        this._depthFunc = _gfx["default"].DS_FUNC_LESS, this._stencilTest = _gfx["default"].STENCIL_INHERIT;
        this._stencilFuncFront = _gfx["default"].DS_FUNC_ALWAYS;
        this._stencilRefFront = 0;
        this._stencilMaskFront = 255;
        this._stencilFailOpFront = _gfx["default"].STENCIL_OP_KEEP;
        this._stencilZFailOpFront = _gfx["default"].STENCIL_OP_KEEP;
        this._stencilZPassOpFront = _gfx["default"].STENCIL_OP_KEEP;
        this._stencilWriteMaskFront = 255;
        this._stencilFuncBack = _gfx["default"].DS_FUNC_ALWAYS;
        this._stencilRefBack = 0;
        this._stencilMaskBack = 255;
        this._stencilFailOpBack = _gfx["default"].STENCIL_OP_KEEP;
        this._stencilZFailOpBack = _gfx["default"].STENCIL_OP_KEEP;
        this._stencilZPassOpBack = _gfx["default"].STENCIL_OP_KEEP;
        this._stencilWriteMaskBack = 255;
      }
      var _proto = Pass.prototype;
      _proto.setCullMode = function setCullMode(cullMode) {
        void 0 === cullMode && (cullMode = _gfx["default"].CULL_BACK);
        this._cullMode = cullMode;
      };
      _proto.setBlend = function setBlend(enabled, blendEq, blendSrc, blendDst, blendAlphaEq, blendSrcAlpha, blendDstAlpha, blendColor) {
        void 0 === enabled && (enabled = false);
        void 0 === blendEq && (blendEq = _gfx["default"].BLEND_FUNC_ADD);
        void 0 === blendSrc && (blendSrc = _gfx["default"].BLEND_SRC_ALPHA);
        void 0 === blendDst && (blendDst = _gfx["default"].BLEND_ONE_MINUS_SRC_ALPHA);
        void 0 === blendAlphaEq && (blendAlphaEq = _gfx["default"].BLEND_FUNC_ADD);
        void 0 === blendSrcAlpha && (blendSrcAlpha = _gfx["default"].BLEND_SRC_ALPHA);
        void 0 === blendDstAlpha && (blendDstAlpha = _gfx["default"].BLEND_ONE_MINUS_SRC_ALPHA);
        void 0 === blendColor && (blendColor = 4294967295);
        this._blend = enabled;
        this._blendEq = blendEq;
        this._blendSrc = blendSrc;
        this._blendDst = blendDst;
        this._blendAlphaEq = blendAlphaEq;
        this._blendSrcAlpha = blendSrcAlpha;
        this._blendDstAlpha = blendDstAlpha;
        this._blendColor = blendColor;
      };
      _proto.setDepth = function setDepth(depthTest, depthWrite, depthFunc) {
        void 0 === depthTest && (depthTest = false);
        void 0 === depthWrite && (depthWrite = false);
        void 0 === depthFunc && (depthFunc = _gfx["default"].DS_FUNC_LESS);
        this._depthTest = depthTest;
        this._depthWrite = depthWrite;
        this._depthFunc = depthFunc;
      };
      _proto.setStencilFront = function setStencilFront(enabled, stencilFunc, stencilRef, stencilMask, stencilFailOp, stencilZFailOp, stencilZPassOp, stencilWriteMask) {
        void 0 === enabled && (enabled = _gfx["default"].STENCIL_INHERIT);
        void 0 === stencilFunc && (stencilFunc = _gfx["default"].DS_FUNC_ALWAYS);
        void 0 === stencilRef && (stencilRef = 0);
        void 0 === stencilMask && (stencilMask = 255);
        void 0 === stencilFailOp && (stencilFailOp = _gfx["default"].STENCIL_OP_KEEP);
        void 0 === stencilZFailOp && (stencilZFailOp = _gfx["default"].STENCIL_OP_KEEP);
        void 0 === stencilZPassOp && (stencilZPassOp = _gfx["default"].STENCIL_OP_KEEP);
        void 0 === stencilWriteMask && (stencilWriteMask = 255);
        this._stencilTest = enabled;
        this._stencilFuncFront = stencilFunc;
        this._stencilRefFront = stencilRef;
        this._stencilMaskFront = stencilMask;
        this._stencilFailOpFront = stencilFailOp;
        this._stencilZFailOpFront = stencilZFailOp;
        this._stencilZPassOpFront = stencilZPassOp;
        this._stencilWriteMaskFront = stencilWriteMask;
      };
      _proto.setStencilEnabled = function setStencilEnabled(stencilTest) {
        void 0 === stencilTest && (stencilTest = _gfx["default"].STENCIL_INHERIT);
        this._stencilTest = stencilTest;
      };
      _proto.setStencilBack = function setStencilBack(stencilTest, stencilFunc, stencilRef, stencilMask, stencilFailOp, stencilZFailOp, stencilZPassOp, stencilWriteMask) {
        void 0 === stencilTest && (stencilTest = _gfx["default"].STENCIL_INHERIT);
        void 0 === stencilFunc && (stencilFunc = _gfx["default"].DS_FUNC_ALWAYS);
        void 0 === stencilRef && (stencilRef = 0);
        void 0 === stencilMask && (stencilMask = 255);
        void 0 === stencilFailOp && (stencilFailOp = _gfx["default"].STENCIL_OP_KEEP);
        void 0 === stencilZFailOp && (stencilZFailOp = _gfx["default"].STENCIL_OP_KEEP);
        void 0 === stencilZPassOp && (stencilZPassOp = _gfx["default"].STENCIL_OP_KEEP);
        void 0 === stencilWriteMask && (stencilWriteMask = 255);
        this._stencilTest = stencilTest;
        this._stencilFuncBack = stencilFunc;
        this._stencilRefBack = stencilRef;
        this._stencilMaskBack = stencilMask;
        this._stencilFailOpBack = stencilFailOp;
        this._stencilZFailOpBack = stencilZFailOp;
        this._stencilZPassOpBack = stencilZPassOp;
        this._stencilWriteMaskBack = stencilWriteMask;
      };
      _proto.setStage = function setStage(stage) {
        this._stage = stage;
      };
      _proto.setProperties = function setProperties(properties) {
        this._properties = properties;
      };
      _proto.getProperty = function getProperty(name) {
        if (!this._properties[name]) return;
        return this._properties[name].value;
      };
      _proto.setProperty = function setProperty(name, value, directly) {
        var prop = this._properties[name];
        if (!prop) return false;
        prop.directly = directly;
        if (Array.isArray(value)) {
          var array = prop.value;
          if (array.length !== value.length) {
            cc.warnID(9105, this._name, name);
            return;
          }
          for (var i = 0; i < value.length; i++) array[i] = value[i];
        } else if (value && !ArrayBuffer.isView(value)) if (prop.type === _enums["default"].PARAM_TEXTURE_2D) prop.value = value.getImpl(); else if (value instanceof _valueType["default"]) value.constructor.toArray(prop.value, value); else {
          "object" === typeof value && cc.warnID(9106, this._name, name);
          prop.value = value;
        } else prop.value = value;
        return true;
      };
      _proto.getDefine = function getDefine(name) {
        return this._defines[name];
      };
      _proto.define = function define(name, value, force) {
        var oldValue = this._defines[name];
        if (!force && void 0 === oldValue) return false;
        if (oldValue !== value) {
          this._defines[name] = value;
          this._programKey = null;
        }
        return true;
      };
      _proto.clone = function clone() {
        var pass = new Pass(this._programName);
        Object.assign(pass, this);
        var newProperties = {};
        var properties = this._properties;
        for (var name in properties) {
          var prop = properties[name];
          var newProp = newProperties[name] = {};
          var value = prop.value;
          Array.isArray(value) ? newProp.value = value.concat() : ArrayBuffer.isView(value) ? newProp.value = new value.__proto__.constructor(value) : newProp.value = value;
          for (var _name in prop) {
            if ("value" === _name) continue;
            newProp[_name] = prop[_name];
          }
        }
        pass._properties = newProperties;
        pass._defines = Object.assign({}, this._defines);
        pass._propertyNames = this._propertyNames;
        pass._defineNames = this._defineNames;
        return pass;
      };
      return Pass;
    })();
    exports["default"] = Pass;
    module.exports = exports["default"];
  }), {
    "../../core/value-types/value-type": 409,
    "../enums": 426,
    "../gfx": 427
  } ],
  425: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var Technique = (function() {
      function Technique(name, passes) {
        this._name = name;
        this._passes = passes;
      }
      var _proto = Technique.prototype;
      _proto.clone = function clone() {
        var passes = [];
        for (var i = 0; i < this._passes.length; i++) passes.push(this._passes[i].clone());
        return new Technique(this._name, passes);
      };
      _createClass(Technique, [ {
        key: "name",
        get: function get() {
          return this._name;
        }
      }, {
        key: "passes",
        get: function get() {
          return this._passes;
        }
      } ]);
      return Technique;
    })();
    exports["default"] = Technique;
    module.exports = exports["default"];
  }), {} ],
  426: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _mappings = require("./build/mappings");
    var _default = {
      PROJ_PERSPECTIVE: 0,
      PROJ_ORTHO: 1,
      LIGHT_DIRECTIONAL: 0,
      LIGHT_POINT: 1,
      LIGHT_SPOT: 2,
      LIGHT_AMBIENT: 3,
      SHADOW_NONE: 0,
      SHADOW_HARD: 1,
      SHADOW_SOFT: 2,
      PARAM_INT: _mappings.typeMap["int"],
      PARAM_INT2: _mappings.typeMap.ivec2,
      PARAM_INT3: _mappings.typeMap.ivec3,
      PARAM_INT4: _mappings.typeMap.ivec4,
      PARAM_FLOAT: _mappings.typeMap["float"],
      PARAM_FLOAT2: _mappings.typeMap.vec2,
      PARAM_FLOAT3: _mappings.typeMap.vec3,
      PARAM_FLOAT4: _mappings.typeMap.vec4,
      PARAM_MAT2: _mappings.typeMap.mat2,
      PARAM_MAT3: _mappings.typeMap.mat3,
      PARAM_MAT4: _mappings.typeMap.mat4,
      PARAM_TEXTURE_2D: _mappings.typeMap.sampler2D,
      PARAM_TEXTURE_CUBE: _mappings.typeMap.samplerCube,
      CLEAR_COLOR: 1,
      CLEAR_DEPTH: 2,
      CLEAR_STENCIL: 4,
      CLEAR_SKYBOX: 8,
      BUFFER_VIEW_INT8: 0,
      BUFFER_VIEW_UINT8: 1,
      BUFFER_VIEW_INT16: 2,
      BUFFER_VIEW_UINT16: 3,
      BUFFER_VIEW_INT32: 4,
      BUFFER_VIEW_UINT32: 5,
      BUFFER_VIEW_FLOAT32: 6
    };
    exports["default"] = _default;
    module.exports = exports["default"];
  }), {
    "./build/mappings": 422
  } ],
  427: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _enums = require("./enums");
    var gfx = null;
    var VertexFormat;
    var IndexBuffer;
    var VertexBuffer;
    var Program;
    var Texture;
    var Texture2D;
    var TextureCube;
    var RenderBuffer;
    var FrameBuffer;
    var Device;
    true, true;
    gfx = window.gfx;
    var _default = gfx;
    exports["default"] = _default;
    cc.gfx = gfx;
    module.exports = exports["default"];
  }), {
    "./device": void 0,
    "./enums": void 0,
    "./frame-buffer": void 0,
    "./index-buffer": void 0,
    "./program": void 0,
    "./render-buffer": void 0,
    "./texture": void 0,
    "./texture-2d": void 0,
    "./texture-cube": void 0,
    "./vertex-buffer": void 0,
    "./vertex-format": void 0
  } ],
  428: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var Pool = (function() {
      function Pool(fn, size) {
        this._fn = fn;
        this._idx = size - 1;
        this._frees = new Array(size);
        for (var i = 0; i < size; ++i) this._frees[i] = fn();
      }
      var _proto = Pool.prototype;
      _proto._expand = function _expand(size) {
        var old = this._frees;
        this._frees = new Array(size);
        var len = size - old.length;
        for (var i = 0; i < len; ++i) this._frees[i] = this._fn();
        for (var _i = len, j = 0; _i < size; ++_i, ++j) this._frees[_i] = old[j];
        this._idx += len;
      };
      _proto.alloc = function alloc() {
        this._idx < 0 && this._expand(Math.round(1.2 * this._frees.length) + 1);
        var ret = this._frees[this._idx];
        this._frees[this._idx] = null;
        --this._idx;
        return ret;
      };
      _proto.free = function free(obj) {
        ++this._idx;
        this._frees[this._idx] = obj;
      };
      _proto.clear = function clear(fn) {
        for (var i = 0; i <= this._idx; i++) fn && fn(this._frees[i]);
        this._frees.length = 0;
        this._idx = -1;
      };
      return Pool;
    })();
    exports["default"] = Pool;
    module.exports = exports["default"];
  }), {} ],
  429: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _timsort = _interopRequireDefault(require("./timsort"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        "value" in descriptor && (descriptor.writable = true);
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      protoProps && _defineProperties(Constructor.prototype, protoProps);
      staticProps && _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    var RecyclePool = (function() {
      function RecyclePool(fn, size) {
        this._fn = fn;
        this._count = 0;
        this._data = new Array(size);
        for (var i = 0; i < size; ++i) this._data[i] = fn();
      }
      var _proto = RecyclePool.prototype;
      _proto.reset = function reset() {
        this._count = 0;
      };
      _proto.resize = function resize(size) {
        if (size > this._data.length) for (var i = this._data.length; i < size; ++i) this._data[i] = this._fn();
      };
      _proto.add = function add() {
        this._count >= this._data.length && this.resize(2 * this._data.length);
        return this._data[this._count++];
      };
      _proto.remove = function remove(idx) {
        if (idx >= this._count) return;
        var last = this._count - 1;
        var tmp = this._data[idx];
        this._data[idx] = this._data[last];
        this._data[last] = tmp;
        this._count -= 1;
      };
      _proto.sort = function sort(cmp) {
        return (0, _timsort["default"])(this._data, 0, this._count, cmp);
      };
      _createClass(RecyclePool, [ {
        key: "length",
        get: function get() {
          return this._count;
        }
      }, {
        key: "data",
        get: function get() {
          return this._data;
        }
      } ]);
      return RecyclePool;
    })();
    exports["default"] = RecyclePool;
    cc.RecyclePool = RecyclePool;
    module.exports = exports["default"];
  }), {
    "./timsort": 430
  } ],
  430: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = _default;
    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;
    var DEFAULT_TMP_STORAGE_LENGTH = 256;
    var POWERS_OF_TEN = [ 1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9 ];
    function log10(x) {
      if (x < 1e5) {
        if (x < 100) return x < 10 ? 0 : 1;
        if (x < 1e4) return x < 1e3 ? 2 : 3;
        return 4;
      }
      if (x < 1e7) return x < 1e6 ? 5 : 6;
      if (x < 1e9) return x < 1e8 ? 7 : 8;
      return 9;
    }
    function alphabeticalCompare(a, b) {
      if (a === b) return 0;
      if (~~a === a && ~~b === b) {
        if (0 === a || 0 === b) return a < b ? -1 : 1;
        if (a < 0 || b < 0) {
          if (b >= 0) return -1;
          if (a >= 0) return 1;
          a = -a;
          b = -b;
        }
        var al = log10(a);
        var bl = log10(b);
        var t = 0;
        if (al < bl) {
          a *= POWERS_OF_TEN[bl - al - 1];
          b /= 10;
          t = -1;
        } else if (al > bl) {
          b *= POWERS_OF_TEN[al - bl - 1];
          a /= 10;
          t = 1;
        }
        if (a === b) return t;
        return a < b ? -1 : 1;
      }
      var aStr = String(a);
      var bStr = String(b);
      if (aStr === bStr) return 0;
      return aStr < bStr ? -1 : 1;
    }
    function minRunLength(n) {
      var r = 0;
      while (n >= DEFAULT_MIN_MERGE) {
        r |= 1 & n;
        n >>= 1;
      }
      return n + r;
    }
    function makeAscendingRun(array, lo, hi, compare) {
      var runHi = lo + 1;
      if (runHi === hi) return 1;
      if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) runHi++;
        reverseRun(array, lo, runHi);
      } else while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) runHi++;
      return runHi - lo;
    }
    function reverseRun(array, lo, hi) {
      hi--;
      while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }
    function binaryInsertionSort(array, lo, hi, start, compare) {
      start === lo && start++;
      for (;start < hi; start++) {
        var pivot = array[start];
        var left = lo;
        var right = start;
        while (left < right) {
          var mid = left + right >>> 1;
          compare(pivot, array[mid]) < 0 ? right = mid : left = mid + 1;
        }
        var n = start - left;
        switch (n) {
         case 3:
          array[left + 3] = array[left + 2];

         case 2:
          array[left + 2] = array[left + 1];

         case 1:
          array[left + 1] = array[left];
          break;

         default:
          while (n > 0) {
            array[left + n] = array[left + n - 1];
            n--;
          }
        }
        array[left] = pivot;
      }
    }
    function gallopLeft(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;
      if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = 1 + (offset << 1);
          offset <= 0 && (offset = maxOffset);
        }
        offset > maxOffset && (offset = maxOffset);
        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = 1 + (offset << 1);
          offset <= 0 && (offset = maxOffset);
        }
        offset > maxOffset && (offset = maxOffset);
        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }
      lastOffset++;
      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        compare(value, array[start + m]) > 0 ? lastOffset = m + 1 : offset = m;
      }
      return offset;
    }
    function gallopRight(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;
      if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = 1 + (offset << 1);
          offset <= 0 && (offset = maxOffset);
        }
        offset > maxOffset && (offset = maxOffset);
        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = 1 + (offset << 1);
          offset <= 0 && (offset = maxOffset);
        }
        offset > maxOffset && (offset = maxOffset);
        lastOffset += hint;
        offset += hint;
      }
      lastOffset++;
      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        compare(value, array[start + m]) < 0 ? offset = m : lastOffset = m + 1;
      }
      return offset;
    }
    var TimSort = (function() {
      function TimSort(array, compare) {
        this.array = array;
        this.compare = compare;
        this.minGallop = DEFAULT_MIN_GALLOPING;
        this.length = array.length;
        this.tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
        this.length < 2 * DEFAULT_TMP_STORAGE_LENGTH && (this.tmpStorageLength = this.length >>> 1);
        this.tmp = new Array(this.tmpStorageLength);
        this.stackLength = this.length < 120 ? 5 : this.length < 1542 ? 10 : this.length < 119151 ? 19 : 40;
        this.runStart = new Array(this.stackLength);
        this.runLength = new Array(this.stackLength);
        this.stackSize = 0;
      }
      var _proto = TimSort.prototype;
      _proto.pushRun = function pushRun(runStart, runLength) {
        this.runStart[this.stackSize] = runStart;
        this.runLength[this.stackSize] = runLength;
        this.stackSize += 1;
      };
      _proto.mergeRuns = function mergeRuns() {
        while (this.stackSize > 1) {
          var n = this.stackSize - 2;
          if (n >= 1 && this.runLength[n - 1] <= this.runLength[n] + this.runLength[n + 1] || n >= 2 && this.runLength[n - 2] <= this.runLength[n] + this.runLength[n - 1]) this.runLength[n - 1] < this.runLength[n + 1] && n--; else if (this.runLength[n] > this.runLength[n + 1]) break;
          this.mergeAt(n);
        }
      };
      _proto.forceMergeRuns = function forceMergeRuns() {
        while (this.stackSize > 1) {
          var n = this.stackSize - 2;
          n > 0 && this.runLength[n - 1] < this.runLength[n + 1] && n--;
          this.mergeAt(n);
        }
      };
      _proto.mergeAt = function mergeAt(i) {
        var compare = this.compare;
        var array = this.array;
        var start1 = this.runStart[i];
        var length1 = this.runLength[i];
        var start2 = this.runStart[i + 1];
        var length2 = this.runLength[i + 1];
        this.runLength[i] = length1 + length2;
        if (i === this.stackSize - 3) {
          this.runStart[i + 1] = this.runStart[i + 2];
          this.runLength[i + 1] = this.runLength[i + 2];
        }
        this.stackSize--;
        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;
        if (0 === length1) return;
        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
        if (0 === length2) return;
        length1 <= length2 ? this.mergeLow(start1, length1, start2, length2) : this.mergeHigh(start1, length1, start2, length2);
      };
      _proto.mergeLow = function mergeLow(start1, length1, start2, length2) {
        var compare = this.compare;
        var array = this.array;
        var tmp = this.tmp;
        var i = 0;
        for (i = 0; i < length1; i++) tmp[i] = array[start1 + i];
        var cursor1 = 0;
        var cursor2 = start2;
        var dest = start1;
        array[dest++] = array[cursor2++];
        if (0 === --length2) {
          for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
          return;
        }
        if (1 === length1) {
          for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
          array[dest + length2] = tmp[cursor1];
          return;
        }
        var minGallop = this.minGallop;
        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;
          do {
            if (compare(array[cursor2], tmp[cursor1]) < 0) {
              array[dest++] = array[cursor2++];
              count2++;
              count1 = 0;
              if (0 === --length2) {
                exit = true;
                break;
              }
            } else {
              array[dest++] = tmp[cursor1++];
              count1++;
              count2 = 0;
              if (1 === --length1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);
          if (exit) break;
          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
            if (0 !== count1) {
              for (i = 0; i < count1; i++) array[dest + i] = tmp[cursor1 + i];
              dest += count1;
              cursor1 += count1;
              length1 -= count1;
              if (length1 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest++] = array[cursor2++];
            if (0 === --length2) {
              exit = true;
              break;
            }
            count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
            if (0 !== count2) {
              for (i = 0; i < count2; i++) array[dest + i] = array[cursor2 + i];
              dest += count2;
              cursor2 += count2;
              length2 -= count2;
              if (0 === length2) {
                exit = true;
                break;
              }
            }
            array[dest++] = tmp[cursor1++];
            if (1 === --length1) {
              exit = true;
              break;
            }
            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
          if (exit) break;
          minGallop < 0 && (minGallop = 0);
          minGallop += 2;
        }
        this.minGallop = minGallop;
        minGallop < 1 && (this.minGallop = 1);
        if (1 === length1) {
          for (i = 0; i < length2; i++) array[dest + i] = array[cursor2 + i];
          array[dest + length2] = tmp[cursor1];
        } else {
          if (0 === length1) throw new Error("mergeLow preconditions were not respected");
          for (i = 0; i < length1; i++) array[dest + i] = tmp[cursor1 + i];
        }
      };
      _proto.mergeHigh = function mergeHigh(start1, length1, start2, length2) {
        var compare = this.compare;
        var array = this.array;
        var tmp = this.tmp;
        var i = 0;
        for (i = 0; i < length2; i++) tmp[i] = array[start2 + i];
        var cursor1 = start1 + length1 - 1;
        var cursor2 = length2 - 1;
        var dest = start2 + length2 - 1;
        var customCursor = 0;
        var customDest = 0;
        array[dest--] = array[cursor1--];
        if (0 === --length1) {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
          return;
        }
        if (1 === length2) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
          array[dest] = tmp[cursor2];
          return;
        }
        var minGallop = this.minGallop;
        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;
          do {
            if (compare(tmp[cursor2], array[cursor1]) < 0) {
              array[dest--] = array[cursor1--];
              count1++;
              count2 = 0;
              if (0 === --length1) {
                exit = true;
                break;
              }
            } else {
              array[dest--] = tmp[cursor2--];
              count2++;
              count1 = 0;
              if (1 === --length2) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < minGallop);
          if (exit) break;
          do {
            count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
            if (0 !== count1) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;
              for (i = count1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
              if (0 === length1) {
                exit = true;
                break;
              }
            }
            array[dest--] = tmp[cursor2--];
            if (1 === --length2) {
              exit = true;
              break;
            }
            count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
            if (0 !== count2) {
              dest -= count2;
              cursor2 -= count2;
              length2 -= count2;
              customDest = dest + 1;
              customCursor = cursor2 + 1;
              for (i = 0; i < count2; i++) array[customDest + i] = tmp[customCursor + i];
              if (length2 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest--] = array[cursor1--];
            if (0 === --length1) {
              exit = true;
              break;
            }
            minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
          if (exit) break;
          minGallop < 0 && (minGallop = 0);
          minGallop += 2;
        }
        this.minGallop = minGallop;
        minGallop < 1 && (this.minGallop = 1);
        if (1 === length2) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) array[customDest + i] = array[customCursor + i];
          array[dest] = tmp[cursor2];
        } else {
          if (0 === length2) throw new Error("mergeHigh preconditions were not respected");
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) array[customCursor + i] = tmp[i];
        }
      };
      return TimSort;
    })();
    function _default(array, lo, hi, compare) {
      if (!Array.isArray(array)) throw new TypeError("Can only sort arrays");
      void 0 === lo && (lo = 0);
      void 0 === hi && (hi = array.length);
      void 0 === compare && (compare = alphabeticalCompare);
      var remaining = hi - lo;
      if (remaining < 2) return;
      var runLength = 0;
      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
      }
      var ts = new TimSort(array, compare);
      var minRun = minRunLength(remaining);
      do {
        runLength = makeAscendingRun(array, lo, hi, compare);
        if (runLength < minRun) {
          var force = remaining;
          force > minRun && (force = minRun);
          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
          runLength = force;
        }
        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (0 !== remaining);
      ts.forceMergeRuns();
    }
    module.exports = exports["default"];
  }), {} ],
  431: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = murmurhash2_32_gc;
    function murmurhash2_32_gc(str, seed) {
      var l = str.length, h = seed ^ l, i = 0, k;
      while (l >= 4) {
        k = 255 & str.charCodeAt(i) | (255 & str.charCodeAt(++i)) << 8 | (255 & str.charCodeAt(++i)) << 16 | (255 & str.charCodeAt(++i)) << 24;
        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16);
        k ^= k >>> 24;
        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16);
        h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16) ^ k;
        l -= 4;
        ++i;
      }
      switch (l) {
       case 3:
        h ^= (255 & str.charCodeAt(i + 2)) << 16;

       case 2:
        h ^= (255 & str.charCodeAt(i + 1)) << 8;

       case 1:
        h ^= 255 & str.charCodeAt(i);
        h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16);
      }
      h ^= h >>> 13;
      h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16);
      h ^= h >>> 15;
      return h >>> 0;
    }
    module.exports = exports["default"];
  }), {} ],
  432: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports.getClassName = exports.enums2default = exports.ctor2enums = void 0;
    exports.getInspectorProps = getInspectorProps;
    exports.getInstanceType = exports.getInstanceCtor = void 0;
    var _enums = _interopRequireDefault(require("./enums"));
    var _valueTypes = require("../core/value-types");
    var _CCTexture2D = _interopRequireDefault(require("../core/assets/CCTexture2D"));
    var _ctor2default, _enums2ctor, _ctor2enums, _enums2default;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var gfxTexture2D = null, gfxTextureCube = null;
    true, true;
    gfxTexture2D = gfx.Texture2D;
    var CCObject = cc.Object;
    var ctor2default = (_ctor2default = {}, _ctor2default[Boolean] = function(v) {
      return v || false;
    }, _ctor2default[Number] = function(v) {
      return v ? ArrayBuffer.isView(v) ? v[0] : v : 0;
    }, _ctor2default[_valueTypes.Vec2] = function(v) {
      return v ? cc.v2(v[0], v[1]) : cc.v2();
    }, _ctor2default[_valueTypes.Vec3] = function(v) {
      return v ? cc.v3(v[0], v[1], v[2]) : cc.v3();
    }, _ctor2default[_valueTypes.Vec4] = function(v) {
      return v ? cc.v4(v[0], v[1], v[2], v[3]) : cc.v4();
    }, _ctor2default[_valueTypes.Color] = function(v) {
      return v ? cc.color(255 * v[0], 255 * v[1], 255 * v[2], 255 * (v[3] || 1)) : cc.color();
    }, _ctor2default[_valueTypes.Mat4] = function(v) {
      return v ? cc.mat4(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9], v[10], v[11], v[12], v[13], v[14], v[15]) : cc.mat4();
    }, _ctor2default[_CCTexture2D["default"]] = function() {
      return null;
    }, _ctor2default[CCObject] = function() {
      return null;
    }, _ctor2default);
    var enums2ctor = (_enums2ctor = {}, _enums2ctor[_enums["default"].PARAM_INT] = Number, 
    _enums2ctor[_enums["default"].PARAM_INT2] = _valueTypes.Vec2, _enums2ctor[_enums["default"].PARAM_INT3] = _valueTypes.Vec3, 
    _enums2ctor[_enums["default"].PARAM_INT4] = _valueTypes.Vec4, _enums2ctor[_enums["default"].PARAM_FLOAT] = Number, 
    _enums2ctor[_enums["default"].PARAM_FLOAT2] = _valueTypes.Vec2, _enums2ctor[_enums["default"].PARAM_FLOAT3] = _valueTypes.Vec3, 
    _enums2ctor[_enums["default"].PARAM_FLOAT4] = _valueTypes.Vec4, _enums2ctor[_enums["default"].PARAM_MAT4] = _valueTypes.Mat4, 
    _enums2ctor[_enums["default"].PARAM_TEXTURE_2D] = _CCTexture2D["default"], _enums2ctor.color = _valueTypes.Color, 
    _enums2ctor.number = Number, _enums2ctor["boolean"] = Boolean, _enums2ctor["default"] = CCObject, 
    _enums2ctor);
    var ctor2enums = (_ctor2enums = {}, _ctor2enums[Number] = _enums["default"].PARAM_FLOAT, 
    _ctor2enums[_valueTypes.Vec2] = _enums["default"].PARAM_FLOAT2, _ctor2enums[_valueTypes.Vec3] = _enums["default"].PARAM_FLOAT3, 
    _ctor2enums[_valueTypes.Vec4] = _enums["default"].PARAM_FLOAT4, _ctor2enums[_valueTypes.Color] = _enums["default"].PARAM_COLOR3, 
    _ctor2enums[_valueTypes.Color] = _enums["default"].PARAM_COLOR4, _ctor2enums[_valueTypes.Mat4] = _enums["default"].PARAM_MAT4, 
    _ctor2enums[_CCTexture2D["default"]] = _enums["default"].PARAM_TEXTURE_2D, _ctor2enums[gfxTexture2D] = _enums["default"].PARAM_TEXTURE_2D, 
    _ctor2enums);
    exports.ctor2enums = ctor2enums;
    var enums2default = (_enums2default = {}, _enums2default[_enums["default"].PARAM_INT] = new Uint32Array([ 0 ]), 
    _enums2default[_enums["default"].PARAM_INT2] = new Uint32Array([ 0, 0 ]), _enums2default[_enums["default"].PARAM_INT3] = new Uint32Array([ 0, 0, 0 ]), 
    _enums2default[_enums["default"].PARAM_INT4] = new Uint32Array([ 0, 0, 0, 0 ]), 
    _enums2default[_enums["default"].PARAM_FLOAT] = new Float32Array([ 0 ]), _enums2default[_enums["default"].PARAM_FLOAT2] = new Float32Array([ 0, 0 ]), 
    _enums2default[_enums["default"].PARAM_FLOAT3] = new Float32Array([ 0, 0, 0 ]), 
    _enums2default[_enums["default"].PARAM_FLOAT4] = new Float32Array([ 0, 0, 0, 0 ]), 
    _enums2default[_enums["default"].PARAM_MAT4] = new Float32Array([ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]), 
    _enums2default[_enums["default"].PARAM_TEXTURE_2D] = null, _enums2default.number = 0, 
    _enums2default["boolean"] = false, _enums2default);
    exports.enums2default = enums2default;
    var getInstanceType = function getInstanceType(t) {
      return enums2ctor[t] || enums2ctor["default"];
    };
    exports.getInstanceType = getInstanceType;
    var getInstanceCtor = function getInstanceCtor(t) {
      return ctor2default[getInstanceType(t)];
    };
    exports.getInstanceCtor = getInstanceCtor;
    var getClassName = function getClassName(t) {
      return cc.js.getClassName(getInstanceType(t));
    };
    exports.getClassName = getClassName;
    var className2InspectorName = {
      Number: "number",
      Boolean: "boolean"
    };
    function getInspectorProps(prop) {
      var editor = {
        type: prop.type
      };
      Object.assign(editor, prop.editor || prop.inspector);
      editor.defines = prop.defines;
      editor.value = getInstanceCtor(editor.type)(prop.value);
      prop.range && (editor.range = prop.range);
      var className = getClassName(editor.type);
      editor.typeName = className2InspectorName[className] || className;
      editor.valueCtor = enums2ctor[editor.type];
      if ("cc.Texture2D" == editor.typeName) {
        editor.typeName = "cc.Asset";
        editor.assetType = "cc.Texture2D";
      }
      return editor;
    }
  }), {
    "../core/assets/CCTexture2D": 152,
    "../core/value-types": 401,
    "./enums": 426,
    "./gfx/texture-2d": void 0
  } ],
  433: [ (function(require, module, exports) {
    "use strict";
    var codec = require("../compression/ZipUtils");
    var zlib = require("../compression/zlib.min");
    var js = require("../core/platform/js");
    require("../core/platform/CCSAXParser");
    function uint8ArrayToUint32Array(uint8Arr) {
      if (uint8Arr.length % 4 !== 0) return null;
      var arrLen = uint8Arr.length / 4;
      var retArr = window.Uint32Array ? new Uint32Array(arrLen) : [];
      for (var i = 0; i < arrLen; i++) {
        var offset = 4 * i;
        retArr[i] = uint8Arr[offset] + 256 * uint8Arr[offset + 1] + 65536 * uint8Arr[offset + 2] + uint8Arr[offset + 3] * (1 << 24);
      }
      return retArr;
    }
    cc.TMXLayerInfo = function() {
      this.properties = {};
      this.name = "";
      this._layerSize = null;
      this._tiles = [];
      this.visible = true;
      this._opacity = 0;
      this.ownTiles = true;
      this._minGID = 1e5;
      this._maxGID = 0;
      this.offset = cc.v2(0, 0);
    };
    cc.TMXLayerInfo.prototype = {
      constructor: cc.TMXLayerInfo,
      getProperties: function getProperties() {
        return this.properties;
      },
      setProperties: function setProperties(value) {
        this.properties = value;
      }
    };
    cc.TMXImageLayerInfo = function() {
      this.name = "";
      this.visible = true;
      this.width = 0;
      this.height = 0;
      this.offset = cc.v2(0, 0);
      this._opacity = 0;
      this._trans = new cc.Color(255, 255, 255, 255);
      this.sourceImage = null;
    };
    cc.TMXObjectGroupInfo = function() {
      this.properties = {};
      this.name = "";
      this._objects = [];
      this.visible = true;
      this._opacity = 0;
      this._color = new cc.Color(255, 255, 255, 255);
      this.offset = cc.v2(0, 0);
      this._draworder = "topdown";
    };
    cc.TMXObjectGroupInfo.prototype = {
      constructor: cc.TMXObjectGroupInfo,
      getProperties: function getProperties() {
        return this.properties;
      },
      setProperties: function setProperties(value) {
        this.properties = value;
      }
    };
    cc.TMXTilesetInfo = function() {
      this.name = "";
      this.firstGid = 0;
      this.spacing = 0;
      this.margin = 0;
      this.sourceImage = null;
      this.imageSize = cc.size(0, 0);
      this.tileOffset = cc.v2(0, 0);
      this._tileSize = cc.size(0, 0);
    };
    cc.TMXTilesetInfo.prototype = {
      constructor: cc.TMXTilesetInfo,
      rectForGID: function rectForGID(gid, result) {
        var rect = result || cc.rect(0, 0, 0, 0);
        rect.width = this._tileSize.width;
        rect.height = this._tileSize.height;
        gid &= cc.TiledMap.TileFlag.FLIPPED_MASK;
        gid -= parseInt(this.firstGid, 10);
        var max_x = parseInt((this.imageSize.width - 2 * this.margin + this.spacing) / (this._tileSize.width + this.spacing), 10);
        rect.x = parseInt(gid % max_x * (this._tileSize.width + this.spacing) + this.margin, 10);
        rect.y = parseInt(parseInt(gid / max_x, 10) * (this._tileSize.height + this.spacing) + this.margin, 10);
        return rect;
      }
    };
    function strToHAlign(value) {
      var hAlign = cc.Label.HorizontalAlign;
      switch (value) {
       case "center":
        return hAlign.CENTER;

       case "right":
        return hAlign.RIGHT;

       default:
        return hAlign.LEFT;
      }
    }
    function strToVAlign(value) {
      var vAlign = cc.Label.VerticalAlign;
      switch (value) {
       case "center":
        return vAlign.CENTER;

       case "bottom":
        return vAlign.BOTTOM;

       default:
        return vAlign.TOP;
      }
    }
    function strToColor(value) {
      if (!value) return cc.color(0, 0, 0, 255);
      value = -1 !== value.indexOf("#") ? value.substring(1) : value;
      if (8 === value.length) {
        var a = parseInt(value.substr(0, 2), 16) || 255;
        var r = parseInt(value.substr(2, 2), 16) || 0;
        var g = parseInt(value.substr(4, 2), 16) || 0;
        var b = parseInt(value.substr(6, 2), 16) || 0;
        return cc.color(r, g, b, a);
      }
      var _r = parseInt(value.substr(0, 2), 16) || 0;
      var _g = parseInt(value.substr(2, 2), 16) || 0;
      var _b = parseInt(value.substr(4, 2), 16) || 0;
      return cc.color(_r, _g, _b, 255);
    }
    function getPropertyList(node, map) {
      var res = [];
      var properties = node.getElementsByTagName("properties");
      for (var i = 0; i < properties.length; ++i) {
        var property = properties[i].getElementsByTagName("property");
        for (var j = 0; j < property.length; ++j) res.push(property[j]);
      }
      map = map || {};
      for (var _i = 0; _i < res.length; _i++) {
        var element = res[_i];
        var name = element.getAttribute("name");
        var type = element.getAttribute("type") || "string";
        var value = element.getAttribute("value");
        "int" === type ? value = parseInt(value) : "float" === type ? value = parseFloat(value) : "bool" === type ? value = "true" === value : "color" === type && (value = strToColor(value));
        map[name] = value;
      }
      return map;
    }
    cc.TMXMapInfo = function(tmxFile, tsxMap, textures, textureSizes, imageLayerTextures) {
      this.properties = [];
      this.orientation = null;
      this.parentElement = null;
      this.parentGID = null;
      this.layerAttrs = 0;
      this.storingCharacters = false;
      this.currentString = null;
      this.renderOrder = cc.TiledMap.RenderOrder.RightDown;
      this._supportVersion = [ 1, 2, 0 ];
      this._parser = new cc.SAXParser();
      this._objectGroups = [];
      this._allChildren = [];
      this._mapSize = cc.size(0, 0);
      this._tileSize = cc.size(0, 0);
      this._layers = [];
      this._tilesets = [];
      this._imageLayers = [];
      this._tileProperties = {};
      this._tileAnimations = {};
      this._tsxMap = null;
      this._textures = null;
      this._staggerAxis = null;
      this._staggerIndex = null;
      this._hexSideLength = 0;
      this._imageLayerTextures = null;
      this.initWithXML(tmxFile, tsxMap, textures, textureSizes, imageLayerTextures);
    };
    cc.TMXMapInfo.prototype = {
      constructor: cc.TMXMapInfo,
      getOrientation: function getOrientation() {
        return this.orientation;
      },
      setOrientation: function setOrientation(value) {
        this.orientation = value;
      },
      getStaggerAxis: function getStaggerAxis() {
        return this._staggerAxis;
      },
      setStaggerAxis: function setStaggerAxis(value) {
        this._staggerAxis = value;
      },
      getStaggerIndex: function getStaggerIndex() {
        return this._staggerIndex;
      },
      setStaggerIndex: function setStaggerIndex(value) {
        this._staggerIndex = value;
      },
      getHexSideLength: function getHexSideLength() {
        return this._hexSideLength;
      },
      setHexSideLength: function setHexSideLength(value) {
        this._hexSideLength = value;
      },
      getMapSize: function getMapSize() {
        return cc.size(this._mapSize.width, this._mapSize.height);
      },
      setMapSize: function setMapSize(value) {
        this._mapSize.width = value.width;
        this._mapSize.height = value.height;
      },
      _getMapWidth: function _getMapWidth() {
        return this._mapSize.width;
      },
      _setMapWidth: function _setMapWidth(width) {
        this._mapSize.width = width;
      },
      _getMapHeight: function _getMapHeight() {
        return this._mapSize.height;
      },
      _setMapHeight: function _setMapHeight(height) {
        this._mapSize.height = height;
      },
      getTileSize: function getTileSize() {
        return cc.size(this._tileSize.width, this._tileSize.height);
      },
      setTileSize: function setTileSize(value) {
        this._tileSize.width = value.width;
        this._tileSize.height = value.height;
      },
      _getTileWidth: function _getTileWidth() {
        return this._tileSize.width;
      },
      _setTileWidth: function _setTileWidth(width) {
        this._tileSize.width = width;
      },
      _getTileHeight: function _getTileHeight() {
        return this._tileSize.height;
      },
      _setTileHeight: function _setTileHeight(height) {
        this._tileSize.height = height;
      },
      getLayers: function getLayers() {
        return this._layers;
      },
      setLayers: function setLayers(value) {
        this._allChildren.push(value);
        this._layers.push(value);
      },
      getImageLayers: function getImageLayers() {
        return this._imageLayers;
      },
      setImageLayers: function setImageLayers(value) {
        this._allChildren.push(value);
        this._imageLayers.push(value);
      },
      getTilesets: function getTilesets() {
        return this._tilesets;
      },
      setTilesets: function setTilesets(value) {
        this._tilesets.push(value);
      },
      getObjectGroups: function getObjectGroups() {
        return this._objectGroups;
      },
      setObjectGroups: function setObjectGroups(value) {
        this._allChildren.push(value);
        this._objectGroups.push(value);
      },
      getAllChildren: function getAllChildren() {
        return this._allChildren;
      },
      getParentElement: function getParentElement() {
        return this.parentElement;
      },
      setParentElement: function setParentElement(value) {
        this.parentElement = value;
      },
      getParentGID: function getParentGID() {
        return this.parentGID;
      },
      setParentGID: function setParentGID(value) {
        this.parentGID = value;
      },
      getLayerAttribs: function getLayerAttribs() {
        return this.layerAttrs;
      },
      setLayerAttribs: function setLayerAttribs(value) {
        this.layerAttrs = value;
      },
      getStoringCharacters: function getStoringCharacters() {
        return this.storingCharacters;
      },
      setStoringCharacters: function setStoringCharacters(value) {
        this.storingCharacters = value;
      },
      getProperties: function getProperties() {
        return this.properties;
      },
      setProperties: function setProperties(value) {
        this.properties = value;
      },
      initWithXML: function initWithXML(tmxString, tsxMap, textures, textureSizes, imageLayerTextures) {
        this._tilesets.length = 0;
        this._layers.length = 0;
        this._imageLayers.length = 0;
        this._tsxMap = tsxMap;
        this._textures = textures;
        this._imageLayerTextures = imageLayerTextures;
        this._textureSizes = textureSizes;
        this._objectGroups.length = 0;
        this._allChildren.length = 0;
        this.properties.length = 0;
        this._tileProperties = {};
        this._tileAnimations = {};
        this.currentString = "";
        this.storingCharacters = false;
        this.layerAttrs = cc.TMXLayerInfo.ATTRIB_NONE;
        this.parentElement = cc.TiledMap.NONE;
        return this.parseXMLString(tmxString);
      },
      parseXMLString: function parseXMLString(xmlStr, tilesetFirstGid) {
        var mapXML = this._parser._parseXML(xmlStr);
        var i;
        var map = mapXML.documentElement;
        var orientationStr = map.getAttribute("orientation");
        var staggerAxisStr = map.getAttribute("staggeraxis");
        var staggerIndexStr = map.getAttribute("staggerindex");
        var hexSideLengthStr = map.getAttribute("hexsidelength");
        var renderorderStr = map.getAttribute("renderorder");
        var version = map.getAttribute("version") || "1.0.0";
        if ("map" === map.nodeName) {
          var versionArr = version.split(".");
          var supportVersion = this._supportVersion;
          for (var _i2 = 0; _i2 < supportVersion.length; _i2++) {
            var v = parseInt(versionArr[_i2]) || 0;
            var sv = supportVersion[_i2];
            if (sv < v) {
              cc.logID(7216, version);
              break;
            }
          }
          "orthogonal" === orientationStr ? this.orientation = cc.TiledMap.Orientation.ORTHO : "isometric" === orientationStr ? this.orientation = cc.TiledMap.Orientation.ISO : "hexagonal" === orientationStr ? this.orientation = cc.TiledMap.Orientation.HEX : null !== orientationStr && cc.logID(7217, orientationStr);
          this.renderOrder = "right-up" === renderorderStr ? cc.TiledMap.RenderOrder.RightUp : "left-up" === renderorderStr ? cc.TiledMap.RenderOrder.LeftUp : "left-down" === renderorderStr ? cc.TiledMap.RenderOrder.LeftDown : cc.TiledMap.RenderOrder.RightDown;
          "x" === staggerAxisStr ? this.setStaggerAxis(cc.TiledMap.StaggerAxis.STAGGERAXIS_X) : "y" === staggerAxisStr && this.setStaggerAxis(cc.TiledMap.StaggerAxis.STAGGERAXIS_Y);
          "odd" === staggerIndexStr ? this.setStaggerIndex(cc.TiledMap.StaggerIndex.STAGGERINDEX_ODD) : "even" === staggerIndexStr && this.setStaggerIndex(cc.TiledMap.StaggerIndex.STAGGERINDEX_EVEN);
          hexSideLengthStr && this.setHexSideLength(parseFloat(hexSideLengthStr));
          var mapSize = cc.size(0, 0);
          mapSize.width = parseFloat(map.getAttribute("width"));
          mapSize.height = parseFloat(map.getAttribute("height"));
          this.setMapSize(mapSize);
          mapSize = cc.size(0, 0);
          mapSize.width = parseFloat(map.getAttribute("tilewidth"));
          mapSize.height = parseFloat(map.getAttribute("tileheight"));
          this.setTileSize(mapSize);
          this.properties = getPropertyList(map);
        }
        var tilesets = map.getElementsByTagName("tileset");
        if ("map" !== map.nodeName) {
          tilesets = [];
          tilesets.push(map);
        }
        for (i = 0; i < tilesets.length; i++) {
          var selTileset = tilesets[i];
          var tsxName = selTileset.getAttribute("source");
          if (tsxName) {
            var currentFirstGID = parseInt(selTileset.getAttribute("firstgid"));
            var tsxXmlString = this._tsxMap[tsxName];
            tsxXmlString && this.parseXMLString(tsxXmlString, currentFirstGID);
          } else {
            var images = selTileset.getElementsByTagName("image");
            var multiTextures = images.length > 1;
            var image = images[0];
            var firstImageName = image.getAttribute("source");
            firstImageName = firstImageName.replace(/\\/g, "/");
            var tiles = selTileset.getElementsByTagName("tile");
            var tileCount = tiles && tiles.length || 1;
            var tile = null;
            var tilesetName = selTileset.getAttribute("name") || "";
            var tilesetSpacing = parseInt(selTileset.getAttribute("spacing")) || 0;
            var tilesetMargin = parseInt(selTileset.getAttribute("margin")) || 0;
            var fgid = parseInt(tilesetFirstGid);
            fgid || (fgid = parseInt(selTileset.getAttribute("firstgid")) || 0);
            var tilesetSize = cc.size(0, 0);
            tilesetSize.width = parseFloat(selTileset.getAttribute("tilewidth"));
            tilesetSize.height = parseFloat(selTileset.getAttribute("tileheight"));
            var offset = selTileset.getElementsByTagName("tileoffset")[0];
            var tileOffset = cc.v2(0, 0);
            if (offset) {
              tileOffset.x = parseFloat(offset.getAttribute("x"));
              tileOffset.y = parseFloat(offset.getAttribute("y"));
            }
            var tileset = null;
            for (var tileIdx = 0; tileIdx < tileCount; tileIdx++) {
              if (!tileset || multiTextures) {
                tileset = new cc.TMXTilesetInfo();
                tileset.name = tilesetName;
                tileset.firstGid = fgid;
                tileset.spacing = tilesetSpacing;
                tileset.margin = tilesetMargin;
                tileset._tileSize = tilesetSize;
                tileset.tileOffset = tileOffset;
                tileset.sourceImage = this._textures[firstImageName];
                tileset.imageSize = this._textureSizes[firstImageName] || tileset.imageSize;
                tileset.sourceImage || cc.errorID(7221, firstImageName);
                this.setTilesets(tileset);
              }
              tile = tiles && tiles[tileIdx];
              if (!tile) continue;
              this.parentGID = parseInt(fgid) + parseInt(tile.getAttribute("id") || 0);
              var tileImages = tile.getElementsByTagName("image");
              if (tileImages && tileImages.length > 0) {
                image = tileImages[0];
                var imageName = image.getAttribute("source");
                imageName = imageName.replace(/\\/g, "/");
                tileset.sourceImage = this._textures[imageName];
                tileset.sourceImage || cc.errorID(7221, imageName);
                var tileSize = cc.size(0, 0);
                tileSize.width = parseFloat(image.getAttribute("width"));
                tileSize.height = parseFloat(image.getAttribute("height"));
                tileset._tileSize = tileSize;
                tileset.firstGid = this.parentGID;
              }
              this._tileProperties[this.parentGID] = getPropertyList(tile);
              var animations = tile.getElementsByTagName("animation");
              if (animations && animations.length > 0) {
                var animation = animations[0];
                var framesData = animation.getElementsByTagName("frame");
                var animationProp = {
                  frames: [],
                  dt: 0,
                  frameIdx: 0
                };
                this._tileAnimations[this.parentGID] = animationProp;
                var frames = animationProp.frames;
                for (var frameIdx = 0; frameIdx < framesData.length; frameIdx++) {
                  var frame = framesData[frameIdx];
                  var tileid = parseInt(fgid) + parseInt(frame.getAttribute("tileid"));
                  var duration = parseFloat(frame.getAttribute("duration"));
                  frames.push({
                    tileid: tileid,
                    duration: duration / 1e3,
                    grid: null
                  });
                }
              }
            }
          }
        }
        var childNodes = map.childNodes;
        for (i = 0; i < childNodes.length; i++) {
          var childNode = childNodes[i];
          if (this._shouldIgnoreNode(childNode)) continue;
          if ("imagelayer" === childNode.nodeName) {
            var imageLayer = this._parseImageLayer(childNode);
            imageLayer && this.setImageLayers(imageLayer);
          }
          if ("layer" === childNode.nodeName) {
            var layer = this._parseLayer(childNode);
            this.setLayers(layer);
          }
          if ("objectgroup" === childNode.nodeName) {
            var objectGroup = this._parseObjectGroup(childNode);
            this.setObjectGroups(objectGroup);
          }
        }
        return map;
      },
      _shouldIgnoreNode: function _shouldIgnoreNode(node) {
        return 3 === node.nodeType || 8 === node.nodeType || 4 === node.nodeType;
      },
      _parseImageLayer: function _parseImageLayer(selLayer) {
        var datas = selLayer.getElementsByTagName("image");
        if (!datas || 0 == datas.length) return null;
        var imageLayer = new cc.TMXImageLayerInfo();
        imageLayer.name = selLayer.getAttribute("name");
        imageLayer.offset.x = parseFloat(selLayer.getAttribute("offsetx")) || 0;
        imageLayer.offset.y = parseFloat(selLayer.getAttribute("offsety")) || 0;
        var visible = selLayer.getAttribute("visible");
        imageLayer.visible = !("0" === visible);
        var opacity = selLayer.getAttribute("opacity") || 1;
        imageLayer.opacity = parseInt(255 * parseFloat(opacity)) || 255;
        var data = datas[0];
        var source = data.getAttribute("source");
        imageLayer.sourceImage = this._imageLayerTextures[source];
        imageLayer.width = parseInt(data.getAttribute("width")) || 0;
        imageLayer.height = parseInt(data.getAttribute("height")) || 0;
        imageLayer.trans = strToColor(data.getAttribute("trans"));
        if (!imageLayer.sourceImage) {
          cc.errorID(7221, source);
          return null;
        }
        return imageLayer;
      },
      _parseLayer: function _parseLayer(selLayer) {
        var data = selLayer.getElementsByTagName("data")[0];
        var layer = new cc.TMXLayerInfo();
        layer.name = selLayer.getAttribute("name");
        var layerSize = cc.size(0, 0);
        layerSize.width = parseFloat(selLayer.getAttribute("width"));
        layerSize.height = parseFloat(selLayer.getAttribute("height"));
        layer._layerSize = layerSize;
        var visible = selLayer.getAttribute("visible");
        layer.visible = !("0" === visible);
        var opacity = selLayer.getAttribute("opacity") || 1;
        layer._opacity = opacity ? parseInt(255 * parseFloat(opacity)) : 255;
        layer.offset = cc.v2(parseFloat(selLayer.getAttribute("offsetx")) || 0, parseFloat(selLayer.getAttribute("offsety")) || 0);
        var nodeValue = "";
        for (var j = 0; j < data.childNodes.length; j++) nodeValue += data.childNodes[j].nodeValue;
        nodeValue = nodeValue.trim();
        var compression = data.getAttribute("compression");
        var encoding = data.getAttribute("encoding");
        if (compression && "gzip" !== compression && "zlib" !== compression) {
          cc.logID(7218);
          return null;
        }
        var tiles;
        switch (compression) {
         case "gzip":
          tiles = codec.unzipBase64AsArray(nodeValue, 4);
          break;

         case "zlib":
          var inflator = new zlib.Inflate(codec.Base64.decodeAsArray(nodeValue, 1));
          tiles = uint8ArrayToUint32Array(inflator.decompress());
          break;

         case null:
         case "":
          if ("base64" === encoding) tiles = codec.Base64.decodeAsArray(nodeValue, 4); else if ("csv" === encoding) {
            tiles = [];
            var csvTiles = nodeValue.split(",");
            for (var csvIdx = 0; csvIdx < csvTiles.length; csvIdx++) tiles.push(parseInt(csvTiles[csvIdx]));
          } else {
            var selDataTiles = data.getElementsByTagName("tile");
            tiles = [];
            for (var xmlIdx = 0; xmlIdx < selDataTiles.length; xmlIdx++) tiles.push(parseInt(selDataTiles[xmlIdx].getAttribute("gid")));
          }
          break;

         default:
          this.layerAttrs === cc.TMXLayerInfo.ATTRIB_NONE && cc.logID(7219);
        }
        tiles && (layer._tiles = new Uint32Array(tiles));
        layer.properties = getPropertyList(selLayer);
        return layer;
      },
      _parseObjectGroup: function _parseObjectGroup(selGroup) {
        var objectGroup = new cc.TMXObjectGroupInfo();
        objectGroup.name = selGroup.getAttribute("name") || "";
        objectGroup.offset = cc.v2(parseFloat(selGroup.getAttribute("offsetx")), parseFloat(selGroup.getAttribute("offsety")));
        var opacity = selGroup.getAttribute("opacity") || 1;
        objectGroup._opacity = opacity ? parseInt(255 * parseFloat(opacity)) : 255;
        var visible = selGroup.getAttribute("visible");
        visible && 0 === parseInt(visible) && (objectGroup.visible = false);
        var color = selGroup.getAttribute("color");
        color && objectGroup._color.fromHEX(color);
        var draworder = selGroup.getAttribute("draworder");
        draworder && (objectGroup._draworder = draworder);
        objectGroup.setProperties(getPropertyList(selGroup));
        var objects = selGroup.getElementsByTagName("object");
        if (objects) {
          for (var j = 0; j < objects.length; j++) {
            var selObj = objects[j];
            var objectProp = {};
            objectProp["id"] = selObj.getAttribute("id") || j;
            objectProp["name"] = selObj.getAttribute("name") || "";
            objectProp["width"] = parseFloat(selObj.getAttribute("width")) || 0;
            objectProp["height"] = parseFloat(selObj.getAttribute("height")) || 0;
            objectProp["x"] = parseFloat(selObj.getAttribute("x")) || 0;
            objectProp["y"] = parseFloat(selObj.getAttribute("y")) || 0;
            objectProp["rotation"] = parseFloat(selObj.getAttribute("rotation")) || 0;
            getPropertyList(selObj, objectProp);
            var visibleAttr = selObj.getAttribute("visible");
            objectProp["visible"] = !(visibleAttr && 0 === parseInt(visibleAttr));
            var texts = selObj.getElementsByTagName("text");
            if (texts && texts.length > 0) {
              var text = texts[0];
              objectProp["type"] = cc.TiledMap.TMXObjectType.TEXT;
              objectProp["wrap"] = "1" == text.getAttribute("wrap");
              objectProp["color"] = strToColor(text.getAttribute("color"));
              objectProp["halign"] = strToHAlign(text.getAttribute("halign"));
              objectProp["valign"] = strToVAlign(text.getAttribute("valign"));
              objectProp["pixelsize"] = parseInt(text.getAttribute("pixelsize")) || 16;
              objectProp["text"] = text.childNodes[0].nodeValue;
            }
            var gid = selObj.getAttribute("gid");
            if (gid) {
              objectProp["gid"] = parseInt(gid);
              objectProp["type"] = cc.TiledMap.TMXObjectType.IMAGE;
            }
            var ellipse = selObj.getElementsByTagName("ellipse");
            ellipse && ellipse.length > 0 && (objectProp["type"] = cc.TiledMap.TMXObjectType.ELLIPSE);
            var polygonProps = selObj.getElementsByTagName("polygon");
            if (polygonProps && polygonProps.length > 0) {
              objectProp["type"] = cc.TiledMap.TMXObjectType.POLYGON;
              var selPgPointStr = polygonProps[0].getAttribute("points");
              selPgPointStr && (objectProp["points"] = this._parsePointsString(selPgPointStr));
            }
            var polylineProps = selObj.getElementsByTagName("polyline");
            if (polylineProps && polylineProps.length > 0) {
              objectProp["type"] = cc.TiledMap.TMXObjectType.POLYLINE;
              var selPlPointStr = polylineProps[0].getAttribute("points");
              selPlPointStr && (objectProp["polylinePoints"] = this._parsePointsString(selPlPointStr));
            }
            objectProp["type"] || (objectProp["type"] = cc.TiledMap.TMXObjectType.RECT);
            objectGroup._objects.push(objectProp);
          }
          "index" !== draworder && objectGroup._objects.sort((function(a, b) {
            return a.y - b.y;
          }));
        }
        return objectGroup;
      },
      _parsePointsString: function _parsePointsString(pointsString) {
        if (!pointsString) return null;
        var points = [];
        var pointsStr = pointsString.split(" ");
        for (var i = 0; i < pointsStr.length; i++) {
          var selPointStr = pointsStr[i].split(",");
          points.push({
            x: parseFloat(selPointStr[0]),
            y: parseFloat(selPointStr[1])
          });
        }
        return points;
      },
      setTileAnimations: function setTileAnimations(animations) {
        this._tileAnimations = animations;
      },
      getTileAnimations: function getTileAnimations() {
        return this._tileAnimations;
      },
      getTileProperties: function getTileProperties() {
        return this._tileProperties;
      },
      setTileProperties: function setTileProperties(tileProperties) {
        this._tileProperties = tileProperties;
      },
      getCurrentString: function getCurrentString() {
        return this.currentString;
      },
      setCurrentString: function setCurrentString(currentString) {
        this.currentString = currentString;
      }
    };
    var _p = cc.TMXMapInfo.prototype;
    js.getset(_p, "mapWidth", _p._getMapWidth, _p._setMapWidth);
    js.getset(_p, "mapHeight", _p._getMapHeight, _p._setMapHeight);
    js.getset(_p, "tileWidth", _p._getTileWidth, _p._setTileWidth);
    js.getset(_p, "tileHeight", _p._getTileHeight, _p._setTileHeight);
    cc.TMXLayerInfo.ATTRIB_NONE = 1;
    cc.TMXLayerInfo.ATTRIB_BASE64 = 2;
    cc.TMXLayerInfo.ATTRIB_GZIP = 4;
    cc.TMXLayerInfo.ATTRIB_ZLIB = 8;
  }), {
    "../compression/ZipUtils": 23,
    "../compression/zlib.min": 26,
    "../core/platform/CCSAXParser": 279,
    "../core/platform/js": 294
  } ],
  434: [ (function(require, module, exports) {
    "use strict";
    var _valueTypes = require("../core/value-types");
    var _materialVariant = _interopRequireDefault(require("../core/assets/material/material-variant"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RenderComponent = require("../core/components/CCRenderComponent");
    var Material = require("../core/assets/material/CCMaterial");
    var RenderFlow = require("../core/renderer/render-flow");
    var _mat4_temp = cc.mat4();
    var _vec2_temp = cc.v2();
    var _vec2_temp2 = cc.v2();
    var _vec2_temp3 = cc.v2();
    var _tempRowCol = {
      row: 0,
      col: 0
    };
    var TiledUserNodeData = cc.Class({
      name: "cc.TiledUserNodeData",
      extends: cc.Component,
      ctor: function ctor() {
        this._index = -1;
        this._row = -1;
        this._col = -1;
        this._tiledLayer = null;
      }
    });
    var TiledLayer = cc.Class({
      name: "cc.TiledLayer",
      extends: RenderComponent,
      editor: {
        inspector: "packages://inspector/inspectors/comps/tiled-layer.js"
      },
      ctor: function ctor() {
        this._userNodeGrid = {};
        this._userNodeMap = {};
        this._userNodeDirty = false;
        this._tiledTiles = [];
        this._tilesetIndexArr = [];
        this._tilesetIndexToArrIndex = {};
        this._texIdToMatIndex = {};
        this._viewPort = {
          x: -1,
          y: -1,
          width: -1,
          height: -1
        };
        this._cullingRect = {
          leftDown: {
            row: -1,
            col: -1
          },
          rightTop: {
            row: -1,
            col: -1
          }
        };
        this._cullingDirty = true;
        this._rightTop = {
          row: -1,
          col: -1
        };
        this._layerInfo = null;
        this._mapInfo = null;
        this._topOffset = 0;
        this._downOffset = 0;
        this._leftOffset = 0;
        this._rightOffset = 0;
        this._tiles = [];
        this._vertices = [];
        this._verticesDirty = true;
        this._layerName = "";
        this._layerOrientation = null;
        this._texGrids = null;
        this._textures = null;
        this._tilesets = null;
        this._leftDownToCenterX = 0;
        this._leftDownToCenterY = 0;
        this._hasTiledNodeGrid = false;
        this._hasAniGrid = false;
        this._animations = null;
        this._enableCulling = cc.macro.ENABLE_TILEDMAP_CULLING;
      },
      _hasTiledNode: function _hasTiledNode() {
        return this._hasTiledNodeGrid;
      },
      _hasAnimation: function _hasAnimation() {
        return this._hasAniGrid;
      },
      enableCulling: function enableCulling(value) {
        if (this._enableCulling != value) {
          this._enableCulling = value;
          this._cullingDirty = true;
        }
      },
      addUserNode: function addUserNode(node) {
        var dataComp = node.getComponent(TiledUserNodeData);
        if (dataComp) {
          cc.warn("CCTiledLayer:addUserNode node has been added");
          return false;
        }
        dataComp = node.addComponent(TiledUserNodeData);
        node.parent = this.node;
        node._renderFlag |= RenderFlow.FLAG_BREAK_FLOW;
        this._userNodeMap[node._id] = dataComp;
        dataComp._row = -1;
        dataComp._col = -1;
        dataComp._tiledLayer = this;
        this._nodeLocalPosToLayerPos(node, _vec2_temp);
        this._positionToRowCol(_vec2_temp.x, _vec2_temp.y, _tempRowCol);
        this._addUserNodeToGrid(dataComp, _tempRowCol);
        this._updateCullingOffsetByUserNode(node);
        node.on(cc.Node.EventType.POSITION_CHANGED, this._userNodePosChange, dataComp);
        node.on(cc.Node.EventType.SIZE_CHANGED, this._userNodeSizeChange, dataComp);
        return true;
      },
      removeUserNode: function removeUserNode(node) {
        var dataComp = node.getComponent(TiledUserNodeData);
        if (!dataComp) {
          cc.warn("CCTiledLayer:removeUserNode node is not exist");
          return false;
        }
        node.off(cc.Node.EventType.POSITION_CHANGED, this._userNodePosChange, dataComp);
        node.off(cc.Node.EventType.SIZE_CHANGED, this._userNodeSizeChange, dataComp);
        this._removeUserNodeFromGrid(dataComp);
        delete this._userNodeMap[node._id];
        node._removeComponent(dataComp);
        dataComp.destroy();
        node.removeFromParent(true);
        node._renderFlag &= ~RenderFlow.FLAG_BREAK_FLOW;
        return true;
      },
      destroyUserNode: function destroyUserNode(node) {
        this.removeUserNode(node);
        node.destroy();
      },
      _nodeLocalPosToLayerPos: function _nodeLocalPosToLayerPos(nodePos, out) {
        out.x = nodePos.x + this._leftDownToCenterX;
        out.y = nodePos.y + this._leftDownToCenterY;
      },
      _getNodesByRowCol: function _getNodesByRowCol(row, col) {
        var rowData = this._userNodeGrid[row];
        if (!rowData) return null;
        return rowData[col];
      },
      _getNodesCountByRow: function _getNodesCountByRow(row) {
        var rowData = this._userNodeGrid[row];
        if (!rowData) return 0;
        return rowData.count;
      },
      _updateAllUserNode: function _updateAllUserNode() {
        this._userNodeGrid = {};
        for (var dataId in this._userNodeMap) {
          var dataComp = this._userNodeMap[dataId];
          this._nodeLocalPosToLayerPos(dataComp.node, _vec2_temp);
          this._positionToRowCol(_vec2_temp.x, _vec2_temp.y, _tempRowCol);
          this._addUserNodeToGrid(dataComp, _tempRowCol);
          this._updateCullingOffsetByUserNode(dataComp.node);
        }
      },
      _updateCullingOffsetByUserNode: function _updateCullingOffsetByUserNode(node) {
        this._topOffset < node.height && (this._topOffset = node.height);
        this._downOffset < node.height && (this._downOffset = node.height);
        this._leftOffset < node.width && (this._leftOffset = node.width);
        this._rightOffset < node.width && (this._rightOffset = node.width);
      },
      _userNodeSizeChange: function _userNodeSizeChange() {
        var dataComp = this;
        var node = dataComp.node;
        var self = dataComp._tiledLayer;
        self._updateCullingOffsetByUserNode(node);
      },
      _userNodePosChange: function _userNodePosChange() {
        var dataComp = this;
        var node = dataComp.node;
        var self = dataComp._tiledLayer;
        self._nodeLocalPosToLayerPos(node, _vec2_temp);
        self._positionToRowCol(_vec2_temp.x, _vec2_temp.y, _tempRowCol);
        self._limitInLayer(_tempRowCol);
        if (_tempRowCol.row === dataComp._row && _tempRowCol.col === dataComp._col) return;
        self._removeUserNodeFromGrid(dataComp);
        self._addUserNodeToGrid(dataComp, _tempRowCol);
      },
      _removeUserNodeFromGrid: function _removeUserNodeFromGrid(dataComp) {
        var row = dataComp._row;
        var col = dataComp._col;
        var index = dataComp._index;
        var rowData = this._userNodeGrid[row];
        var colData = rowData && rowData[col];
        if (colData) {
          rowData.count--;
          colData.count--;
          colData.list[index] = null;
          if (colData.count <= 0) {
            colData.list.length = 0;
            colData.count = 0;
          }
        }
        dataComp._row = -1;
        dataComp._col = -1;
        dataComp._index = -1;
        this._userNodeDirty = true;
      },
      _limitInLayer: function _limitInLayer(rowCol) {
        var row = rowCol.row;
        var col = rowCol.col;
        row < 0 && (rowCol.row = 0);
        row > this._rightTop.row && (rowCol.row = this._rightTop.row);
        col < 0 && (rowCol.col = 0);
        col > this._rightTop.col && (rowCol.col = this._rightTop.col);
      },
      _addUserNodeToGrid: function _addUserNodeToGrid(dataComp, tempRowCol) {
        var row = tempRowCol.row;
        var col = tempRowCol.col;
        var rowData = this._userNodeGrid[row] = this._userNodeGrid[row] || {
          count: 0
        };
        var colData = rowData[col] = rowData[col] || {
          count: 0,
          list: []
        };
        dataComp._row = row;
        dataComp._col = col;
        dataComp._index = colData.list.length;
        rowData.count++;
        colData.count++;
        colData.list.push(dataComp);
        this._userNodeDirty = true;
      },
      _isUserNodeDirty: function _isUserNodeDirty() {
        return this._userNodeDirty;
      },
      _setUserNodeDirty: function _setUserNodeDirty(value) {
        this._userNodeDirty = value;
      },
      onEnable: function onEnable() {
        this._super();
        this.node.on(cc.Node.EventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);
        this._activateMaterial();
      },
      onDisable: function onDisable() {
        this._super();
        this.node.off(cc.Node.EventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);
      },
      _syncAnchorPoint: function _syncAnchorPoint() {
        var node = this.node;
        this._leftDownToCenterX = node.width * node.anchorX * node.scaleX;
        this._leftDownToCenterY = node.height * node.anchorY * node.scaleY;
        this._cullingDirty = true;
      },
      onDestroy: function onDestroy() {
        this._super();
        if (this._buffer) {
          this._buffer.destroy();
          this._buffer = null;
        }
        this._renderDataList = null;
      },
      getLayerName: function getLayerName() {
        return this._layerName;
      },
      setLayerName: function setLayerName(layerName) {
        this._layerName = layerName;
      },
      getProperty: function getProperty(propertyName) {
        return this._properties[propertyName];
      },
      getPositionAt: function getPositionAt(pos, y) {
        var x;
        if (void 0 !== y) {
          x = Math.floor(pos);
          y = Math.floor(y);
        } else {
          x = Math.floor(pos.x);
          y = Math.floor(pos.y);
        }
        var ret;
        switch (this._layerOrientation) {
         case cc.TiledMap.Orientation.ORTHO:
          ret = this._positionForOrthoAt(x, y);
          break;

         case cc.TiledMap.Orientation.ISO:
          ret = this._positionForIsoAt(x, y);
          break;

         case cc.TiledMap.Orientation.HEX:
          ret = this._positionForHexAt(x, y);
        }
        return ret;
      },
      _isInvalidPosition: function _isInvalidPosition(x, y) {
        if (x && "object" === typeof x) {
          var pos = x;
          y = pos.y;
          x = pos.x;
        }
        return x >= this._layerSize.width || y >= this._layerSize.height || x < 0 || y < 0;
      },
      _positionForIsoAt: function _positionForIsoAt(x, y) {
        var offsetX = 0, offsetY = 0;
        var index = Math.floor(x) + Math.floor(y) * this._layerSize.width;
        var gidAndFlags = this._tiles[index];
        if (gidAndFlags) {
          var gid = (gidAndFlags & cc.TiledMap.TileFlag.FLIPPED_MASK) >>> 0;
          var tileset = this._texGrids[gid].tileset;
          var offset = tileset.tileOffset;
          offsetX = offset.x;
          offsetY = offset.y;
        }
        return cc.v2(.5 * this._mapTileSize.width * (this._layerSize.height + x - y - 1) + offsetX, .5 * this._mapTileSize.height * (this._layerSize.width - x + this._layerSize.height - y - 2) - offsetY);
      },
      _positionForOrthoAt: function _positionForOrthoAt(x, y) {
        var offsetX = 0, offsetY = 0;
        var index = Math.floor(x) + Math.floor(y) * this._layerSize.width;
        var gidAndFlags = this._tiles[index];
        if (gidAndFlags) {
          var gid = (gidAndFlags & cc.TiledMap.TileFlag.FLIPPED_MASK) >>> 0;
          var tileset = this._texGrids[gid].tileset;
          var offset = tileset.tileOffset;
          offsetX = offset.x;
          offsetY = offset.y;
        }
        return cc.v2(x * this._mapTileSize.width + offsetX, (this._layerSize.height - y - 1) * this._mapTileSize.height - offsetY);
      },
      _positionForHexAt: function _positionForHexAt(col, row) {
        var tileWidth = this._mapTileSize.width;
        var tileHeight = this._mapTileSize.height;
        var rows = this._layerSize.height;
        var index = Math.floor(col) + Math.floor(row) * this._layerSize.width;
        var gid = this._tiles[index];
        var offset;
        offset = this._texGrids[gid] ? this._texGrids[gid].tileset.tileOffset : {
          x: 0,
          y: 0
        };
        var odd_even = this._staggerIndex === cc.TiledMap.StaggerIndex.STAGGERINDEX_ODD ? 1 : -1;
        var x = 0, y = 0;
        var diffX = 0;
        var diffY = 0;
        switch (this._staggerAxis) {
         case cc.TiledMap.StaggerAxis.STAGGERAXIS_Y:
          diffX = 0;
          row % 2 === 1 && (diffX = tileWidth / 2 * odd_even);
          x = col * tileWidth + diffX + offset.x;
          y = (rows - row - 1) * (tileHeight - (tileHeight - this._hexSideLength) / 2) - offset.y;
          break;

         case cc.TiledMap.StaggerAxis.STAGGERAXIS_X:
          diffY = 0;
          col % 2 === 1 && (diffY = tileHeight / 2 * -odd_even);
          x = col * (tileWidth - (tileWidth - this._hexSideLength) / 2) + offset.x;
          y = (rows - row - 1) * tileHeight + diffY - offset.y;
        }
        return cc.v2(x, y);
      },
      setTilesGIDAt: function setTilesGIDAt(gids, beginCol, beginRow, totalCols) {
        if (!gids || 0 === gids.length || totalCols <= 0) return;
        beginRow < 0 && (beginRow = 0);
        beginCol < 0 && (beginCol = 0);
        var gidsIdx = 0;
        var endCol = beginCol + totalCols;
        for (var row = beginRow; ;row++) for (var col = beginCol; col < endCol; col++) {
          if (gidsIdx >= gids.length) return;
          this._updateTileForGID(gids[gidsIdx], col, row);
          gidsIdx++;
        }
      },
      setTileGIDAt: function setTileGIDAt(gid, posOrX, flagsOrY, flags) {
        if (void 0 === posOrX) throw new Error("cc.TiledLayer.setTileGIDAt(): pos should be non-null");
        var pos;
        if (void 0 === flags && posOrX instanceof cc.Vec2) {
          pos = posOrX;
          flags = flagsOrY;
        } else {
          _vec2_temp3.x = posOrX;
          _vec2_temp3.y = flagsOrY;
          pos = _vec2_temp3;
        }
        var ugid = gid & cc.TiledMap.TileFlag.FLIPPED_MASK;
        pos.x = Math.floor(pos.x);
        pos.y = Math.floor(pos.y);
        if (this._isInvalidPosition(pos)) throw new Error("cc.TiledLayer.setTileGIDAt(): invalid position");
        if (!this._tiles || !this._tilesets || 0 == this._tilesets.length) {
          cc.logID(7238);
          return;
        }
        if (0 !== ugid && ugid < this._tilesets[0].firstGid) {
          cc.logID(7239, gid);
          return;
        }
        flags = flags || 0;
        this._updateTileForGID((gid | flags) >>> 0, pos.x, pos.y);
      },
      _updateTileForGID: function _updateTileForGID(gidAndFlags, x, y) {
        var idx = 0 | x + y * this._layerSize.width;
        if (idx >= this._tiles.length) return;
        var oldGIDAndFlags = this._tiles[idx];
        if (gidAndFlags === oldGIDAndFlags) return;
        var gid = (gidAndFlags & cc.TiledMap.TileFlag.FLIPPED_MASK) >>> 0;
        var grid = this._texGrids[gid];
        var tilesetIdx = grid && grid.texId;
        if (grid) {
          this._tiles[idx] = gidAndFlags;
          this._updateVertex(x, y);
          this._buildMaterial(tilesetIdx);
        } else this._tiles[idx] = 0;
        this._cullingDirty = true;
      },
      getTiles: function getTiles() {
        return this._tiles;
      },
      getTileGIDAt: function getTileGIDAt(pos, y) {
        if (void 0 === pos) throw new Error("cc.TiledLayer.getTileGIDAt(): pos should be non-null");
        var x = pos;
        if (void 0 === y) {
          x = pos.x;
          y = pos.y;
        }
        if (this._isInvalidPosition(x, y)) throw new Error("cc.TiledLayer.getTileGIDAt(): invalid position");
        if (!this._tiles) {
          cc.logID(7237);
          return null;
        }
        var index = Math.floor(x) + Math.floor(y) * this._layerSize.width;
        var tile = this._tiles[index];
        return (tile & cc.TiledMap.TileFlag.FLIPPED_MASK) >>> 0;
      },
      getTileFlagsAt: function getTileFlagsAt(pos, y) {
        if (!pos) throw new Error("TiledLayer.getTileFlagsAt: pos should be non-null");
        void 0 !== y && (pos = cc.v2(pos, y));
        if (this._isInvalidPosition(pos)) throw new Error("TiledLayer.getTileFlagsAt: invalid position");
        if (!this._tiles) {
          cc.logID(7240);
          return null;
        }
        var idx = Math.floor(pos.x) + Math.floor(pos.y) * this._layerSize.width;
        var tile = this._tiles[idx];
        return (tile & cc.TiledMap.TileFlag.FLIPPED_ALL) >>> 0;
      },
      _setCullingDirty: function _setCullingDirty(value) {
        this._cullingDirty = value;
      },
      _isCullingDirty: function _isCullingDirty() {
        return this._cullingDirty;
      },
      _updateViewPort: function _updateViewPort(x, y, width, height) {
        if (this._viewPort.width === width && this._viewPort.height === height && this._viewPort.x === x && this._viewPort.y === y) return;
        this._viewPort.x = x;
        this._viewPort.y = y;
        this._viewPort.width = width;
        this._viewPort.height = height;
        var reserveLine = 1;
        this._layerOrientation === cc.TiledMap.Orientation.ISO && (reserveLine = 2);
        var vpx = this._viewPort.x - this._offset.x + this._leftDownToCenterX;
        var vpy = this._viewPort.y - this._offset.y + this._leftDownToCenterY;
        var leftDownX = vpx - this._leftOffset;
        var leftDownY = vpy - this._downOffset;
        var rightTopX = vpx + width + this._rightOffset;
        var rightTopY = vpy + height + this._topOffset;
        var leftDown = this._cullingRect.leftDown;
        var rightTop = this._cullingRect.rightTop;
        leftDownX < 0 && (leftDownX = 0);
        leftDownY < 0 && (leftDownY = 0);
        this._positionToRowCol(leftDownX, leftDownY, _tempRowCol);
        _tempRowCol.row -= reserveLine;
        _tempRowCol.col -= reserveLine;
        _tempRowCol.row = _tempRowCol.row > 0 ? _tempRowCol.row : 0;
        _tempRowCol.col = _tempRowCol.col > 0 ? _tempRowCol.col : 0;
        if (_tempRowCol.row !== leftDown.row || _tempRowCol.col !== leftDown.col) {
          leftDown.row = _tempRowCol.row;
          leftDown.col = _tempRowCol.col;
          this._cullingDirty = true;
        }
        if (rightTopX < 0 || rightTopY < 0) {
          _tempRowCol.row = -1;
          _tempRowCol.col = -1;
        } else {
          this._positionToRowCol(rightTopX, rightTopY, _tempRowCol);
          _tempRowCol.row++;
          _tempRowCol.col++;
        }
        _tempRowCol.row > this._rightTop.row && (_tempRowCol.row = this._rightTop.row);
        _tempRowCol.col > this._rightTop.col && (_tempRowCol.col = this._rightTop.col);
        if (_tempRowCol.row !== rightTop.row || _tempRowCol.col !== rightTop.col) {
          rightTop.row = _tempRowCol.row;
          rightTop.col = _tempRowCol.col;
          this._cullingDirty = true;
        }
      },
      _positionToRowCol: function _positionToRowCol(x, y, result) {
        var TiledMap = cc.TiledMap;
        var Orientation = TiledMap.Orientation;
        var StaggerAxis = TiledMap.StaggerAxis;
        var maptw = this._mapTileSize.width, mapth = this._mapTileSize.height, maptw2 = .5 * maptw, mapth2 = .5 * mapth;
        var row = 0, col = 0, diffX2 = 0, diffY2 = 0, axis = this._staggerAxis;
        var cols = this._layerSize.width;
        switch (this._layerOrientation) {
         case Orientation.ORTHO:
          col = Math.floor(x / maptw);
          row = Math.floor(y / mapth);
          break;

         case Orientation.ISO:
          col = Math.floor(x / maptw2);
          row = Math.floor(y / mapth2);
          break;

         case Orientation.HEX:
          if (axis === StaggerAxis.STAGGERAXIS_Y) {
            row = Math.floor(y / (mapth - this._diffY1));
            diffX2 = row % 2 === 1 ? maptw2 * this._odd_even : 0;
            col = Math.floor((x - diffX2) / maptw);
          } else {
            col = Math.floor(x / (maptw - this._diffX1));
            diffY2 = col % 2 === 1 ? mapth2 * -this._odd_even : 0;
            row = Math.floor((y - diffY2) / mapth);
          }
        }
        result.row = row;
        result.col = col;
        return result;
      },
      _updateCulling: function _updateCulling() {
        false;
        if (this._enableCulling) {
          this.node._updateWorldMatrix();
          _valueTypes.Mat4.invert(_mat4_temp, this.node._worldMatrix);
          var rect = cc.visibleRect;
          var camera = cc.Camera.findCamera(this.node);
          if (camera) {
            _vec2_temp.x = 0;
            _vec2_temp.y = 0;
            _vec2_temp2.x = _vec2_temp.x + rect.width;
            _vec2_temp2.y = _vec2_temp.y + rect.height;
            camera.getScreenToWorldPoint(_vec2_temp, _vec2_temp);
            camera.getScreenToWorldPoint(_vec2_temp2, _vec2_temp2);
            _valueTypes.Vec2.transformMat4(_vec2_temp, _vec2_temp, _mat4_temp);
            _valueTypes.Vec2.transformMat4(_vec2_temp2, _vec2_temp2, _mat4_temp);
            this._updateViewPort(_vec2_temp.x, _vec2_temp.y, _vec2_temp2.x - _vec2_temp.x, _vec2_temp2.y - _vec2_temp.y);
          }
        }
      },
      getLayerOrientation: function getLayerOrientation() {
        return this._layerOrientation;
      },
      getProperties: function getProperties() {
        return this._properties;
      },
      _updateVertex: function _updateVertex(col, row) {
        var TiledMap = cc.TiledMap;
        var TileFlag = TiledMap.TileFlag;
        var FLIPPED_MASK = TileFlag.FLIPPED_MASK;
        var StaggerAxis = TiledMap.StaggerAxis;
        var Orientation = TiledMap.Orientation;
        var vertices = this._vertices;
        var layerOrientation = this._layerOrientation, tiles = this._tiles;
        if (!tiles) return;
        var rightTop = this._rightTop;
        var maptw = this._mapTileSize.width, mapth = this._mapTileSize.height, maptw2 = .5 * maptw, mapth2 = .5 * mapth, rows = this._layerSize.height, cols = this._layerSize.width, grids = this._texGrids;
        var gid, grid, left, bottom, axis, diffX1, diffY1, odd_even, diffX2, diffY2;
        if (layerOrientation === Orientation.HEX) {
          axis = this._staggerAxis;
          diffX1 = this._diffX1;
          diffY1 = this._diffY1;
          odd_even = this._odd_even;
        }
        var cullingCol = 0, cullingRow = 0;
        var tileOffset = null, gridGID = 0;
        var topBorder = 0, downBorder = 0, leftBorder = 0, rightBorder = 0;
        var index = row * cols + col;
        gid = tiles[index];
        gridGID = (gid & FLIPPED_MASK) >>> 0;
        grid = grids[gridGID];
        if (!grid) return;
        this._animations[gridGID] && (this._hasAniGrid = this._hasAniGrid || true);
        switch (layerOrientation) {
         case Orientation.ORTHO:
          cullingCol = col;
          cullingRow = rows - row - 1;
          left = cullingCol * maptw;
          bottom = cullingRow * mapth;
          break;

         case Orientation.ISO:
          cullingCol = rows + col - row - 1;
          cullingRow = rows + cols - col - row - 2;
          left = maptw2 * cullingCol;
          bottom = mapth2 * cullingRow;
          break;

         case Orientation.HEX:
          diffX2 = axis === StaggerAxis.STAGGERAXIS_Y && row % 2 === 1 ? maptw2 * odd_even : 0;
          diffY2 = axis === StaggerAxis.STAGGERAXIS_X && col % 2 === 1 ? mapth2 * -odd_even : 0;
          left = col * (maptw - diffX1) + diffX2;
          bottom = (rows - row - 1) * (mapth - diffY1) + diffY2;
          cullingCol = col;
          cullingRow = rows - row - 1;
        }
        var rowData = vertices[cullingRow] = vertices[cullingRow] || {
          minCol: 0,
          maxCol: 0
        };
        var colData = rowData[cullingCol] = rowData[cullingCol] || {};
        rowData.minCol > cullingCol && (rowData.minCol = cullingCol);
        rowData.maxCol < cullingCol && (rowData.maxCol = cullingCol);
        rightTop.row < cullingRow && (rightTop.row = cullingRow);
        rightTop.col < cullingCol && (rightTop.col = cullingCol);
        tileOffset = grid.tileset.tileOffset;
        left += this._offset.x + tileOffset.x;
        bottom += this._offset.y - tileOffset.y;
        topBorder = -tileOffset.y + grid.tileset._tileSize.height - mapth;
        topBorder = topBorder < 0 ? 0 : topBorder;
        downBorder = tileOffset.y < 0 ? 0 : tileOffset.y;
        leftBorder = -tileOffset.x < 0 ? 0 : -tileOffset.x;
        rightBorder = tileOffset.x + grid.tileset._tileSize.width - maptw;
        rightBorder = rightBorder < 0 ? 0 : rightBorder;
        this._rightOffset < leftBorder && (this._rightOffset = leftBorder);
        this._leftOffset < rightBorder && (this._leftOffset = rightBorder);
        this._topOffset < downBorder && (this._topOffset = downBorder);
        this._downOffset < topBorder && (this._downOffset = topBorder);
        colData.left = left;
        colData.bottom = bottom;
        colData.index = index;
        this._cullingDirty = true;
      },
      _updateVertices: function _updateVertices() {
        var vertices = this._vertices;
        vertices.length = 0;
        var tiles = this._tiles;
        if (!tiles) return;
        var rightTop = this._rightTop;
        rightTop.row = -1;
        rightTop.col = -1;
        var rows = this._layerSize.height, cols = this._layerSize.width;
        this._topOffset = 0;
        this._downOffset = 0;
        this._leftOffset = 0;
        this._rightOffset = 0;
        this._hasAniGrid = false;
        for (var row = 0; row < rows; ++row) for (var col = 0; col < cols; ++col) this._updateVertex(col, row);
        this._verticesDirty = false;
      },
      getTiledTileAt: function getTiledTileAt(x, y, forceCreate) {
        if (this._isInvalidPosition(x, y)) throw new Error("TiledLayer.getTiledTileAt: invalid position");
        if (!this._tiles) {
          cc.logID(7236);
          return null;
        }
        var index = Math.floor(x) + Math.floor(y) * this._layerSize.width;
        var tile = this._tiledTiles[index];
        if (!tile && forceCreate) {
          var node = new cc.Node();
          tile = node.addComponent(cc.TiledTile);
          tile._x = x;
          tile._y = y;
          tile._layer = this;
          tile._updateInfo();
          node.parent = this.node;
          return tile;
        }
        return tile;
      },
      setTiledTileAt: function setTiledTileAt(x, y, tiledTile) {
        if (this._isInvalidPosition(x, y)) throw new Error("TiledLayer.setTiledTileAt: invalid position");
        if (!this._tiles) {
          cc.logID(7236);
          return null;
        }
        var index = Math.floor(x) + Math.floor(y) * this._layerSize.width;
        this._tiledTiles[index] = tiledTile;
        this._cullingDirty = true;
        this._hasTiledNodeGrid = !!tiledTile || this._tiledTiles.some((function(tiledNode, index) {
          return !!tiledNode;
        }));
        return tiledTile;
      },
      getTexture: function getTexture(index) {
        index = index || 0;
        if (this._textures && index >= 0 && this._textures.length > index) return this._textures[index];
        return null;
      },
      getTextures: function getTextures() {
        return this._textures;
      },
      setTexture: function setTexture(texture) {
        this.setTextures([ texture ]);
      },
      setTextures: function setTextures(textures) {
        this._textures = textures;
        this._activateMaterial();
      },
      getLayerSize: function getLayerSize() {
        return this._layerSize;
      },
      getMapTileSize: function getMapTileSize() {
        return this._mapTileSize;
      },
      getTileSet: function getTileSet(index) {
        index = index || 0;
        if (this._tilesets && index >= 0 && this._tilesets.length > index) return this._tilesets[index];
        return null;
      },
      getTileSets: function getTileSets() {
        return this._tilesets;
      },
      setTileSet: function setTileSet(tileset) {
        this.setTileSets([ tileset ]);
      },
      setTileSets: function setTileSets(tilesets) {
        this._tilesets = tilesets;
        var textures = this._textures = [];
        var texGrids = this._texGrids = [];
        for (var i = 0; i < tilesets.length; i++) {
          var tileset = tilesets[i];
          tileset && (textures[i] = tileset.sourceImage);
        }
        cc.TiledMap.loadAllTextures(textures, function() {
          for (var _i = 0, l = tilesets.length; _i < l; ++_i) {
            var tilesetInfo = tilesets[_i];
            if (!tilesetInfo) continue;
            cc.TiledMap.fillTextureGrids(tilesetInfo, texGrids, _i);
          }
          this._prepareToRender();
        }.bind(this));
      },
      _traverseAllGrid: function _traverseAllGrid() {
        var tiles = this._tiles;
        var texGrids = this._texGrids;
        var tilesetIndexArr = this._tilesetIndexArr;
        var tilesetIndexToArrIndex = this._tilesetIndexToArrIndex = {};
        var TiledMap = cc.TiledMap;
        var TileFlag = TiledMap.TileFlag;
        var FLIPPED_MASK = TileFlag.FLIPPED_MASK;
        tilesetIndexArr.length = 0;
        for (var i = 0; i < tiles.length; i++) {
          var gid = tiles[i];
          if (0 === gid) continue;
          gid = (gid & FLIPPED_MASK) >>> 0;
          var grid = texGrids[gid];
          if (!grid) {
            cc.error("CCTiledLayer:_traverseAllGrid grid is null, gid is:", gid);
            continue;
          }
          var tilesetIdx = grid.texId;
          if (void 0 !== tilesetIndexToArrIndex[tilesetIdx]) continue;
          tilesetIndexToArrIndex[tilesetIdx] = tilesetIndexArr.length;
          tilesetIndexArr.push(tilesetIdx);
        }
      },
      _init: function _init(layerInfo, mapInfo, tilesets, textures, texGrids) {
        this._cullingDirty = true;
        this._layerInfo = layerInfo;
        this._mapInfo = mapInfo;
        var size = layerInfo._layerSize;
        this._layerName = layerInfo.name;
        this._tiles = layerInfo._tiles;
        this._properties = layerInfo.properties;
        this._layerSize = size;
        this._minGID = layerInfo._minGID;
        this._maxGID = layerInfo._maxGID;
        this._opacity = layerInfo._opacity;
        this._renderOrder = mapInfo.renderOrder;
        this._staggerAxis = mapInfo.getStaggerAxis();
        this._staggerIndex = mapInfo.getStaggerIndex();
        this._hexSideLength = mapInfo.getHexSideLength();
        this._animations = mapInfo.getTileAnimations();
        this._tilesets = tilesets;
        this._textures = textures;
        this._texGrids = texGrids;
        this._layerOrientation = mapInfo.orientation;
        this._mapTileSize = mapInfo.getTileSize();
        var maptw = this._mapTileSize.width;
        var mapth = this._mapTileSize.height;
        var layerW = this._layerSize.width;
        var layerH = this._layerSize.height;
        if (this._layerOrientation === cc.TiledMap.Orientation.HEX) {
          var TiledMap = cc.TiledMap;
          var StaggerAxis = TiledMap.StaggerAxis;
          var StaggerIndex = TiledMap.StaggerIndex;
          var width = 0, height = 0;
          this._odd_even = this._staggerIndex === StaggerIndex.STAGGERINDEX_ODD ? 1 : -1;
          if (this._staggerAxis === StaggerAxis.STAGGERAXIS_X) {
            this._diffX1 = (maptw - this._hexSideLength) / 2;
            this._diffY1 = 0;
            height = mapth * (layerH + .5);
            width = (maptw + this._hexSideLength) * Math.floor(layerW / 2) + maptw * (layerW % 2);
          } else {
            this._diffX1 = 0;
            this._diffY1 = (mapth - this._hexSideLength) / 2;
            width = maptw * (layerW + .5);
            height = (mapth + this._hexSideLength) * Math.floor(layerH / 2) + mapth * (layerH % 2);
          }
          this.node.setContentSize(width, height);
        } else if (this._layerOrientation === cc.TiledMap.Orientation.ISO) {
          var wh = layerW + layerH;
          this.node.setContentSize(.5 * maptw * wh, .5 * mapth * wh);
        } else this.node.setContentSize(layerW * maptw, layerH * mapth);
        this._offset = cc.v2(layerInfo.offset.x, -layerInfo.offset.y);
        this._useAutomaticVertexZ = false;
        this._vertexZvalue = 0;
        this._syncAnchorPoint();
        this._prepareToRender();
      },
      _prepareToRender: function _prepareToRender() {
        this._updateVertices();
        this._traverseAllGrid();
        this._updateAllUserNode();
        this._activateMaterial();
      },
      _buildMaterial: function _buildMaterial(tilesetIdx) {
        var texIdMatIdx = this._texIdToMatIndex;
        if (void 0 !== texIdMatIdx[tilesetIdx]) return null;
        var tilesetIndexArr = this._tilesetIndexArr;
        var tilesetIndexToArrIndex = this._tilesetIndexToArrIndex;
        var index = tilesetIndexToArrIndex[tilesetIdx];
        if (void 0 === index) {
          tilesetIndexToArrIndex[tilesetIdx] = index = tilesetIndexArr.length;
          tilesetIndexArr.push(tilesetIdx);
        }
        var texture = this._textures[tilesetIdx];
        var material = this._materials[index];
        material || (material = Material.getBuiltinMaterial("2d-sprite"));
        material = _materialVariant["default"].create(material, this);
        material.define("CC_USE_MODEL", true);
        material.setProperty("texture", texture);
        this._materials[index] = material;
        texIdMatIdx[tilesetIdx] = index;
        return material;
      },
      _activateMaterial: function _activateMaterial() {
        var tilesetIndexArr = this._tilesetIndexArr;
        if (0 === tilesetIndexArr.length) {
          this.disableRender();
          return;
        }
        var matLen = tilesetIndexArr.length;
        for (var i = 0; i < matLen; i++) this._buildMaterial(tilesetIndexArr[i]);
        this._materials.length = matLen;
        this.markForRender(true);
      }
    });
    cc.TiledLayer = module.exports = TiledLayer;
  }), {
    "../core/assets/material/CCMaterial": 156,
    "../core/assets/material/material-variant": 163,
    "../core/components/CCRenderComponent": 192,
    "../core/renderer/render-flow": 323,
    "../core/value-types": 401
  } ],
  435: [ (function(require, module, exports) {
    "use strict";
    require("./CCTMXXMLParser");
    require("./CCTiledMapAsset");
    require("./CCTiledLayer");
    require("./CCTiledTile");
    require("./CCTiledObjectGroup");
    var Orientation = cc.Enum({
      ORTHO: 0,
      HEX: 1,
      ISO: 2
    });
    var Property = cc.Enum({
      NONE: 0,
      MAP: 1,
      LAYER: 2,
      OBJECTGROUP: 3,
      OBJECT: 4,
      TILE: 5
    });
    var TileFlag = cc.Enum({
      HORIZONTAL: 2147483648,
      VERTICAL: 1073741824,
      DIAGONAL: 536870912,
      FLIPPED_ALL: 4026531840,
      FLIPPED_MASK: 268435455
    });
    var StaggerAxis = cc.Enum({
      STAGGERAXIS_X: 0,
      STAGGERAXIS_Y: 1
    });
    var StaggerIndex = cc.Enum({
      STAGGERINDEX_ODD: 0,
      STAGGERINDEX_EVEN: 1
    });
    var RenderOrder = cc.Enum({
      RightDown: 0,
      RightUp: 1,
      LeftDown: 2,
      LeftUp: 3
    });
    var TMXObjectType = cc.Enum({
      RECT: 0,
      ELLIPSE: 1,
      POLYGON: 2,
      POLYLINE: 3,
      IMAGE: 4,
      TEXT: 5
    });
    var TiledMap = cc.Class({
      name: "cc.TiledMap",
      extends: cc.Component,
      editor: false,
      ctor: function ctor() {
        this._texGrids = [];
        this._textures = [];
        this._tilesets = [];
        this._animations = [];
        this._imageLayers = [];
        this._layers = [];
        this._groups = [];
        this._images = [];
        this._properties = [];
        this._tileProperties = [];
        this._mapSize = cc.size(0, 0);
        this._tileSize = cc.size(0, 0);
      },
      statics: {
        Orientation: Orientation,
        Property: Property,
        TileFlag: TileFlag,
        StaggerAxis: StaggerAxis,
        StaggerIndex: StaggerIndex,
        TMXObjectType: TMXObjectType,
        RenderOrder: RenderOrder
      },
      properties: {
        _tmxFile: {
          default: null,
          type: cc.TiledMapAsset
        },
        tmxAsset: {
          get: function get() {
            return this._tmxFile;
          },
          set: function set(value, force) {
            if (this._tmxFile !== value || false) {
              this._tmxFile = value;
              this._applyFile();
            }
          },
          type: cc.TiledMapAsset
        }
      },
      getMapSize: function getMapSize() {
        return this._mapSize;
      },
      getTileSize: function getTileSize() {
        return this._tileSize;
      },
      getMapOrientation: function getMapOrientation() {
        return this._mapOrientation;
      },
      getObjectGroups: function getObjectGroups() {
        return this._groups;
      },
      getObjectGroup: function getObjectGroup(groupName) {
        var groups = this._groups;
        for (var i = 0, l = groups.length; i < l; i++) {
          var group = groups[i];
          if (group && group.getGroupName() === groupName) return group;
        }
        return null;
      },
      enableCulling: function enableCulling(value) {
        var layers = this._layers;
        for (var i = 0; i < layers.length; ++i) layers[i].enableCulling(value);
      },
      getProperties: function getProperties() {
        return this._properties;
      },
      getLayers: function getLayers() {
        return this._layers;
      },
      getLayer: function getLayer(layerName) {
        var layers = this._layers;
        for (var i = 0, l = layers.length; i < l; i++) {
          var layer = layers[i];
          if (layer && layer.getLayerName() === layerName) return layer;
        }
        return null;
      },
      _changeLayer: function _changeLayer(layerName, replaceLayer) {
        var layers = this._layers;
        for (var i = 0, l = layers.length; i < l; i++) {
          var layer = layers[i];
          if (layer && layer.getLayerName() === layerName) {
            layers[i] = replaceLayer;
            return;
          }
        }
      },
      getProperty: function getProperty(propertyName) {
        return this._properties[propertyName.toString()];
      },
      getPropertiesForGID: function getPropertiesForGID(GID) {
        return this._tileProperties[GID];
      },
      __preload: function __preload() {
        this._tmxFile && this._applyFile();
      },
      onEnable: function onEnable() {
        this.node.on(cc.Node.EventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);
      },
      onDisable: function onDisable() {
        this.node.off(cc.Node.EventType.ANCHOR_CHANGED, this._syncAnchorPoint, this);
      },
      _applyFile: function _applyFile() {
        var file = this._tmxFile;
        if (file) {
          var texValues = file.textures;
          var texKeys = file.textureNames;
          var texSizes = file.textureSizes;
          var textures = {};
          var textureSizes = {};
          for (var i = 0; i < texValues.length; ++i) {
            var texName = texKeys[i];
            textures[texName] = texValues[i];
            textureSizes[texName] = texSizes[i];
          }
          var imageLayerTextures = {};
          texValues = file.imageLayerTextures;
          texKeys = file.imageLayerTextureNames;
          for (var _i = 0; _i < texValues.length; ++_i) imageLayerTextures[texKeys[_i]] = texValues[_i];
          var tsxFileNames = file.tsxFileNames;
          var tsxFiles = file.tsxFiles;
          var tsxMap = {};
          for (var _i2 = 0; _i2 < tsxFileNames.length; ++_i2) tsxFileNames[_i2].length > 0 && (tsxMap[tsxFileNames[_i2]] = tsxFiles[_i2].text);
          var mapInfo = new cc.TMXMapInfo(file.tmxXmlStr, tsxMap, textures, textureSizes, imageLayerTextures);
          var tilesets = mapInfo.getTilesets();
          tilesets && 0 !== tilesets.length || cc.logID(7241);
          this._buildWithMapInfo(mapInfo);
        } else this._releaseMapInfo();
      },
      _releaseMapInfo: function _releaseMapInfo() {
        var layers = this._layers;
        for (var i = 0, l = layers.length; i < l; i++) {
          layers[i].node.removeFromParent(true);
          layers[i].node.destroy();
        }
        layers.length = 0;
        var groups = this._groups;
        for (var _i3 = 0, _l = groups.length; _i3 < _l; _i3++) {
          groups[_i3].node.removeFromParent(true);
          groups[_i3].node.destroy();
        }
        groups.length = 0;
        var images = this._images;
        for (var _i4 = 0, _l2 = images.length; _i4 < _l2; _i4++) {
          images[_i4].removeFromParent(true);
          images[_i4].destroy();
        }
        images.length = 0;
      },
      _syncAnchorPoint: function _syncAnchorPoint() {
        var anchor = this.node.getAnchorPoint();
        var leftTopX = this.node.width * anchor.x;
        var leftTopY = this.node.height * (1 - anchor.y);
        var i, l;
        for (i = 0, l = this._layers.length; i < l; i++) {
          var layerInfo = this._layers[i];
          var layerNode = layerInfo.node;
          layerNode.setAnchorPoint(anchor);
        }
        for (i = 0, l = this._groups.length; i < l; i++) {
          var groupInfo = this._groups[i];
          var groupNode = groupInfo.node;
          groupNode.anchorX = .5;
          groupNode.anchorY = .5;
          groupNode.x = groupInfo._offset.x - leftTopX + groupNode.width * groupNode.anchorX;
          groupNode.y = groupInfo._offset.y + leftTopY - groupNode.height * groupNode.anchorY;
        }
        for (i = 0, l = this._images.length; i < l; i++) {
          var image = this._images[i];
          image.anchorX = .5;
          image.anchorY = .5;
          image.x = image._offset.x - leftTopX + image.width * image.anchorX;
          image.y = image._offset.y + leftTopY - image.height * image.anchorY;
        }
      },
      _fillAniGrids: function _fillAniGrids(texGrids, animations) {
        for (var i in animations) {
          var animation = animations[i];
          if (!animation) continue;
          var frames = animation.frames;
          for (var j = 0; j < frames.length; j++) {
            var frame = frames[j];
            frame.grid = texGrids[frame.tileid];
          }
        }
      },
      _buildLayerAndGroup: function _buildLayerAndGroup() {
        var tilesets = this._tilesets;
        var texGrids = this._texGrids;
        var animations = this._animations;
        texGrids.length = 0;
        for (var i = 0, l = tilesets.length; i < l; ++i) {
          var tilesetInfo = tilesets[i];
          if (!tilesetInfo) continue;
          cc.TiledMap.fillTextureGrids(tilesetInfo, texGrids, i);
        }
        this._fillAniGrids(texGrids, animations);
        var layers = this._layers;
        var groups = this._groups;
        var images = this._images;
        var oldNodeNames = {};
        for (var _i5 = 0, n = layers.length; _i5 < n; _i5++) oldNodeNames[layers[_i5].node._name] = true;
        for (var _i6 = 0, _n = groups.length; _i6 < _n; _i6++) oldNodeNames[groups[_i6].node._name] = true;
        for (var _i7 = 0, _n2 = images.length; _i7 < _n2; _i7++) oldNodeNames[images[_i7]._name] = true;
        layers = this._layers = [];
        groups = this._groups = [];
        images = this._images = [];
        var mapInfo = this._mapInfo;
        var node = this.node;
        var layerInfos = mapInfo.getAllChildren();
        var textures = this._textures;
        var maxWidth = 0;
        var maxHeight = 0;
        if (layerInfos && layerInfos.length > 0) for (var _i8 = 0, len = layerInfos.length; _i8 < len; _i8++) {
          var layerInfo = layerInfos[_i8];
          var name = layerInfo.name;
          var child = this.node.getChildByName(name);
          oldNodeNames[name] = false;
          if (!child) {
            child = new cc.Node();
            child.name = name;
            node.addChild(child);
          }
          child.setSiblingIndex(_i8);
          child.active = layerInfo.visible;
          if (layerInfo instanceof cc.TMXLayerInfo) {
            var layer = child.getComponent(cc.TiledLayer);
            layer || (layer = child.addComponent(cc.TiledLayer));
            layer._init(layerInfo, mapInfo, tilesets, textures, texGrids);
            layerInfo.ownTiles = false;
            layers.push(layer);
          } else if (layerInfo instanceof cc.TMXObjectGroupInfo) {
            var group = child.getComponent(cc.TiledObjectGroup);
            group || (group = child.addComponent(cc.TiledObjectGroup));
            group._init(layerInfo, mapInfo, texGrids);
            groups.push(group);
          } else if (layerInfo instanceof cc.TMXImageLayerInfo) {
            var texture = layerInfo.sourceImage;
            child.opacity = layerInfo.opacity;
            child.layerInfo = layerInfo;
            child._offset = cc.v2(layerInfo.offset.x, -layerInfo.offset.y);
            var image = child.getComponent(cc.Sprite);
            image || (image = child.addComponent(cc.Sprite));
            var spf = image.spriteFrame || new cc.SpriteFrame();
            spf.setTexture(texture);
            image.spriteFrame = spf;
            child.width = texture.width;
            child.height = texture.height;
            images.push(child);
          }
          maxWidth = Math.max(maxWidth, child.width);
          maxHeight = Math.max(maxHeight, child.height);
        }
        var children = node.children;
        for (var _i9 = 0, _n3 = children.length; _i9 < _n3; _i9++) {
          var c = children[_i9];
          oldNodeNames[c._name] && c.destroy();
        }
        this.node.width = maxWidth;
        this.node.height = maxHeight;
        this._syncAnchorPoint();
      },
      _buildWithMapInfo: function _buildWithMapInfo(mapInfo) {
        this._mapInfo = mapInfo;
        this._mapSize = mapInfo.getMapSize();
        this._tileSize = mapInfo.getTileSize();
        this._mapOrientation = mapInfo.orientation;
        this._properties = mapInfo.properties;
        this._tileProperties = mapInfo.getTileProperties();
        this._imageLayers = mapInfo.getImageLayers();
        this._animations = mapInfo.getTileAnimations();
        this._tilesets = mapInfo.getTilesets();
        var tilesets = this._tilesets;
        this._textures.length = 0;
        var totalTextures = [];
        for (var i = 0, l = tilesets.length; i < l; ++i) {
          var tilesetInfo = tilesets[i];
          if (!tilesetInfo || !tilesetInfo.sourceImage) continue;
          this._textures[i] = tilesetInfo.sourceImage;
          totalTextures.push(tilesetInfo.sourceImage);
        }
        for (var _i10 = 0; _i10 < this._imageLayers.length; _i10++) {
          var imageLayer = this._imageLayers[_i10];
          if (!imageLayer || !imageLayer.sourceImage) continue;
          totalTextures.push(imageLayer.sourceImage);
        }
        cc.TiledMap.loadAllTextures(totalTextures, function() {
          this._buildLayerAndGroup();
        }.bind(this));
      },
      update: function update(dt) {
        var animations = this._animations;
        var texGrids = this._texGrids;
        for (var aniGID in animations) {
          var animation = animations[aniGID];
          var frames = animation.frames;
          var frame = frames[animation.frameIdx];
          animation.dt += dt;
          if (frame.duration < animation.dt) {
            animation.dt = 0;
            animation.frameIdx++;
            animation.frameIdx >= frames.length && (animation.frameIdx = 0);
            frame = frames[animation.frameIdx];
          }
          texGrids[aniGID] = frame.grid;
        }
      }
    });
    cc.TiledMap = module.exports = TiledMap;
    cc.TiledMap.loadAllTextures = function(textures, loadedCallback) {
      var totalNum = textures.length;
      if (0 === totalNum) {
        loadedCallback();
        return;
      }
      var curNum = 0;
      var itemCallback = function itemCallback() {
        curNum++;
        curNum >= totalNum && loadedCallback();
      };
      for (var i = 0; i < totalNum; i++) {
        var tex = textures[i];
        tex.loaded ? itemCallback() : tex.once("load", (function() {
          itemCallback();
        }));
      }
    };
    cc.TiledMap.fillTextureGrids = function(tileset, texGrids, texId) {
      var tex = tileset.sourceImage;
      if (!tileset.imageSize.width || !tileset.imageSize.height) {
        tileset.imageSize.width = tex.width;
        tileset.imageSize.height = tex.height;
      }
      var tw = tileset._tileSize.width, th = tileset._tileSize.height, imageW = tex.width, imageH = tex.height, spacing = tileset.spacing, margin = tileset.margin, cols = Math.floor((imageW - 2 * margin + spacing) / (tw + spacing)), rows = Math.floor((imageH - 2 * margin + spacing) / (th + spacing)), count = rows * cols, gid = tileset.firstGid, grid = null, override = !!texGrids[gid], texelCorrect = cc.macro.FIX_ARTIFACTS_BY_STRECHING_TEXEL_TMX ? .5 : 0;
      count <= 0 && (count = 1);
      var maxGid = tileset.firstGid + count;
      for (;gid < maxGid; ++gid) {
        override && !texGrids[gid] && (override = false);
        if (!override && texGrids[gid]) break;
        grid = {
          texId: texId,
          tileset: tileset,
          x: 0,
          y: 0,
          width: tw,
          height: th,
          t: 0,
          l: 0,
          r: 0,
          b: 0,
          gid: gid
        };
        tileset.rectForGID(gid, grid);
        grid.x += texelCorrect;
        grid.y += texelCorrect;
        grid.width -= 2 * texelCorrect;
        grid.height -= 2 * texelCorrect;
        grid.t = grid.y / imageH;
        grid.l = grid.x / imageW;
        grid.r = (grid.x + grid.width) / imageW;
        grid.b = (grid.y + grid.height) / imageH;
        texGrids[gid] = grid;
      }
    };
    cc.js.obsolete(cc.TiledMap.prototype, "cc.TiledMap.tmxFile", "tmxAsset", true);
    cc.js.get(cc.TiledMap.prototype, "mapLoaded", (function() {
      cc.errorID(7203);
      return [];
    }), false);
  }), {
    "./CCTMXXMLParser": 433,
    "./CCTiledLayer": 434,
    "./CCTiledMapAsset": 436,
    "./CCTiledObjectGroup": 438,
    "./CCTiledTile": 439
  } ],
  436: [ (function(require, module, exports) {
    "use strict";
    var TiledMapAsset = cc.Class({
      name: "cc.TiledMapAsset",
      extends: cc.Asset,
      properties: {
        tmxXmlStr: "",
        textures: {
          default: [],
          type: [ cc.Texture2D ]
        },
        textureNames: [ cc.String ],
        textureSizes: {
          default: [],
          type: [ cc.Size ]
        },
        imageLayerTextures: {
          default: [],
          type: [ cc.Texture2D ]
        },
        imageLayerTextureNames: [ cc.String ],
        tsxFiles: [ cc.TextAsset ],
        tsxFileNames: [ cc.String ]
      },
      statics: {
        preventDeferredLoadDependents: true
      },
      createNode: false
    });
    cc.TiledMapAsset = TiledMapAsset;
    module.exports = TiledMapAsset;
  }), {} ],
  437: [ (function(require, module, exports) {
    "use strict";
    var _inputAssembler = _interopRequireDefault(require("../renderer/core/input-assembler"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var TiledMapRenderDataList = cc.Class({
      name: "cc.TiledMapRenderDataList",
      ctor: function ctor() {
        this._dataList = [];
        this._offset = 0;
      },
      _pushRenderData: function _pushRenderData() {
        var renderData = {};
        renderData.ia = new _inputAssembler["default"]();
        renderData.nodesRenderList = [];
        this._dataList.push(renderData);
      },
      popRenderData: function popRenderData(buffer) {
        this._offset >= this._dataList.length && this._pushRenderData();
        var renderData = this._dataList[this._offset];
        renderData.nodesRenderList.length = 0;
        var ia = renderData.ia;
        ia._vertexBuffer = buffer._vb;
        ia._indexBuffer = buffer._ib;
        ia._start = buffer.indiceOffset;
        ia._count = 0;
        this._offset++;
        return renderData;
      },
      pushNodesList: function pushNodesList(renderData, nodesList) {
        renderData.nodesRenderList.push(nodesList);
      },
      reset: function reset() {
        this._offset = 0;
      }
    });
    cc.TiledMapRenderDataList = module.exports = TiledMapRenderDataList;
  }), {
    "../renderer/core/input-assembler": 423
  } ],
  438: [ (function(require, module, exports) {
    "use strict";
    var TiledObjectGroup = cc.Class({
      name: "cc.TiledObjectGroup",
      extends: cc.Component,
      getPositionOffset: function getPositionOffset() {
        return this._positionOffset;
      },
      getProperties: function getProperties() {
        return this._properties;
      },
      getGroupName: function getGroupName() {
        return this._groupName;
      },
      getProperty: function getProperty(propertyName) {
        return this._properties[propertyName.toString()];
      },
      getObject: function getObject(objectName) {
        for (var i = 0, len = this._objects.length; i < len; i++) {
          var obj = this._objects[i];
          if (obj && obj.name === objectName) return obj;
        }
        return null;
      },
      getObjects: function getObjects() {
        return this._objects;
      },
      _init: function _init(groupInfo, mapInfo, texGrids) {
        var TiledMap = cc.TiledMap;
        var TMXObjectType = TiledMap.TMXObjectType;
        var Orientation = TiledMap.Orientation;
        var StaggerAxis = TiledMap.StaggerAxis;
        var TileFlag = TiledMap.TileFlag;
        var FLIPPED_MASK = TileFlag.FLIPPED_MASK;
        var FLAG_HORIZONTAL = TileFlag.HORIZONTAL;
        var FLAG_VERTICAL = TileFlag.VERTICAL;
        this._groupName = groupInfo.name;
        this._positionOffset = groupInfo.offset;
        this._mapInfo = mapInfo;
        this._properties = groupInfo.getProperties();
        this._offset = cc.v2(groupInfo.offset.x, -groupInfo.offset.y);
        this._opacity = groupInfo._opacity;
        var mapSize = mapInfo._mapSize;
        var tileSize = mapInfo._tileSize;
        var width = 0, height = 0;
        if (mapInfo.orientation === Orientation.HEX) if (mapInfo.getStaggerAxis() === StaggerAxis.STAGGERAXIS_X) {
          height = tileSize.height * (mapSize.height + .5);
          width = (tileSize.width + mapInfo.getHexSideLength()) * Math.floor(mapSize.width / 2) + tileSize.width * (mapSize.width % 2);
        } else {
          width = tileSize.width * (mapSize.width + .5);
          height = (tileSize.height + mapInfo.getHexSideLength()) * Math.floor(mapSize.height / 2) + tileSize.height * (mapSize.height % 2);
        } else if (mapInfo.orientation === Orientation.ISO) {
          var wh = mapSize.width + mapSize.height;
          width = .5 * tileSize.width * wh;
          height = .5 * tileSize.height * wh;
        } else {
          width = mapSize.width * tileSize.width;
          height = mapSize.height * tileSize.height;
        }
        this.node.setContentSize(width, height);
        var leftTopX = width * this.node.anchorX;
        var leftTopY = height * (1 - this.node.anchorY);
        var objects = groupInfo._objects;
        var aliveNodes = {};
        for (var i = 0, l = objects.length; i < l; i++) {
          var object = objects[i];
          var objType = object.type;
          object.offset = cc.v2(object.x, object.y);
          var points = object.points || object.polylinePoints;
          if (points) for (var pi = 0; pi < points.length; pi++) points[pi].y *= -1;
          if (Orientation.ISO !== mapInfo.orientation) object.y = height - object.y; else {
            var posIdxX = object.x / tileSize.height;
            var posIdxY = object.y / tileSize.height;
            object.x = .5 * tileSize.width * (mapSize.height + posIdxX - posIdxY);
            object.y = .5 * tileSize.height * (mapSize.width + mapSize.height - posIdxX - posIdxY);
          }
          if (objType === TMXObjectType.TEXT) {
            var textName = "text" + object.id;
            aliveNodes[textName] = true;
            var textNode = this.node.getChildByName(textName);
            textNode || (textNode = new cc.Node());
            textNode.active = object.visible;
            textNode.anchorX = 0;
            textNode.anchorY = 1;
            textNode.angle = -object.rotation;
            textNode.x = object.x - leftTopX;
            textNode.y = object.y - leftTopY;
            textNode.name = textName;
            textNode.parent = this.node;
            textNode.color = object.color;
            textNode.opacity = this._opacity;
            textNode.setSiblingIndex(i);
            var label = textNode.getComponent(cc.Label);
            label || (label = textNode.addComponent(cc.Label));
            label.overflow = cc.Label.Overflow.SHRINK;
            label.lineHeight = object.height;
            label.string = object.text;
            label.horizontalAlign = object.halign;
            label.verticalAlign = object.valign;
            label.fontSize = object.pixelsize;
            textNode.width = object.width;
            textNode.height = object.height;
          }
          if (objType === TMXObjectType.IMAGE) {
            var gid = object.gid;
            var grid = texGrids[(gid & FLIPPED_MASK) >>> 0];
            if (!grid) continue;
            var tileset = grid.tileset;
            var imgName = "img" + object.id;
            aliveNodes[imgName] = true;
            var imgNode = this.node.getChildByName(imgName);
            var imgWidth = object.width || grid.width;
            var imgHeight = object.height || grid.height;
            var tileOffsetX = tileset.tileOffset.x;
            var tileOffsetY = tileset.tileOffset.y;
            if (imgNode instanceof cc.PrivateNode) {
              imgNode.removeFromParent();
              imgNode.destroy();
              imgNode = null;
            }
            imgNode || (imgNode = new cc.Node());
            if (Orientation.ISO == mapInfo.orientation) {
              imgNode.anchorX = .5 + tileOffsetX / imgWidth;
              imgNode.anchorY = tileOffsetY / imgHeight;
            } else {
              imgNode.anchorX = tileOffsetX / imgWidth;
              imgNode.anchorY = tileOffsetY / imgHeight;
            }
            imgNode.active = object.visible;
            imgNode.angle = -object.rotation;
            imgNode.x = object.x - leftTopX;
            imgNode.y = object.y - leftTopY;
            imgNode.name = imgName;
            imgNode.parent = this.node;
            imgNode.opacity = this._opacity;
            imgNode.setSiblingIndex(i);
            var sp = imgNode.getComponent(cc.Sprite);
            sp || (sp = imgNode.addComponent(cc.Sprite));
            var spf = sp.spriteFrame;
            spf || (spf = new cc.SpriteFrame());
            (gid & FLAG_HORIZONTAL) >>> 0 ? spf.setFlipX(true) : spf.setFlipX(false);
            (gid & FLAG_VERTICAL) >>> 0 ? spf.setFlipY(true) : spf.setFlipY(false);
            spf.setTexture(grid.tileset.sourceImage, cc.rect(grid));
            sp.spriteFrame = spf;
            sp.setVertsDirty();
            imgNode.width = imgWidth;
            imgNode.height = imgHeight;
          }
        }
        this._objects = objects;
        var children = this.node.children;
        var uselessExp = /^(?:img|text)\d+$/;
        for (var _i = 0, n = children.length; _i < n; _i++) {
          var c = children[_i];
          var cName = c._name;
          var isUseless = uselessExp.test(cName);
          isUseless && !aliveNodes[cName] && c.destroy();
        }
      }
    });
    cc.TiledObjectGroup = module.exports = TiledObjectGroup;
  }), {} ],
  439: [ (function(require, module, exports) {
    "use strict";
    var TiledTile = cc.Class({
      name: "cc.TiledTile",
      extends: cc.Component,
      editor: false,
      ctor: function ctor() {
        this._layer = null;
      },
      properties: {
        _x: 0,
        _y: 0,
        x: {
          get: function get() {
            return this._x;
          },
          set: function set(value) {
            if (value === this._x) return;
            if (this._layer && this._layer._isInvalidPosition(value, this._y)) {
              cc.warn("Invalid x, the valid value is between [%s] ~ [%s]", 0, this._layer._layerSize.width);
              return;
            }
            this._resetTile();
            this._x = value;
            this._updateInfo();
          },
          type: cc.Integer
        },
        y: {
          get: function get() {
            return this._y;
          },
          set: function set(value) {
            if (value === this._y) return;
            if (this._layer && this._layer._isInvalidPosition(this._x, value)) {
              cc.warn("Invalid y, the valid value is between [%s] ~ [%s]", 0, this._layer._layerSize.height);
              return;
            }
            this._resetTile();
            this._y = value;
            this._updateInfo();
          },
          type: cc.Integer
        },
        gid: {
          get: function get() {
            if (this._layer) return this._layer.getTileGIDAt(this._x, this._y);
            return 0;
          },
          set: function set(value) {
            this._layer && this._layer.setTileGIDAt(value, this._x, this._y);
          },
          type: cc.Integer
        }
      },
      onEnable: function onEnable() {
        var parent = this.node.parent;
        this._layer = parent.getComponent(cc.TiledLayer);
        this._resetTile();
        this._updateInfo();
      },
      onDisable: function onDisable() {
        this._resetTile();
      },
      _resetTile: function _resetTile() {
        this._layer && this._layer.getTiledTileAt(this._x, this._y) === this && this._layer.setTiledTileAt(this._x, this._y, null);
      },
      _updateInfo: function _updateInfo() {
        if (!this._layer) return;
        var x = this._x, y = this._y;
        if (this._layer.getTiledTileAt(x, y)) {
          cc.warn("There is already a TiledTile at [%s, %s]", x, y);
          return;
        }
        this.node.setPosition(this._layer.getPositionAt(x, y));
        this._layer.setTiledTileAt(x, y, this);
      }
    });
    cc.TiledTile = module.exports = TiledTile;
  }), {} ],
  440: [ (function(require, module, exports) {
    "use strict";
    require("./CCTiledMap");
    require("./CCTiledMapRenderDataList");
    require("./tiledmap-buffer");
    require("./tmx-layer-assembler");
  }), {
    "./CCTiledMap": 435,
    "./CCTiledMapRenderDataList": 437,
    "./tiledmap-buffer": 441,
    "./tmx-layer-assembler": 442
  } ],
  441: [ (function(require, module, exports) {
    "use strict";
    var TiledMapBuffer = cc.Class({
      name: "cc.TiledMapBuffer",
      extends: require("../core/renderer/webgl/quad-buffer"),
      _updateOffset: function _updateOffset() {
        var offsetInfo = this._offsetInfo;
        offsetInfo.vertexOffset = this.vertexOffset;
        offsetInfo.indiceOffset = this.indiceOffset;
        offsetInfo.byteOffset = this.byteOffset;
      },
      adjust: function adjust(vertexCount, indiceCount) {
        this.vertexOffset += vertexCount;
        this.indiceOffset += indiceCount;
        this.indiceStart = this.indiceOffset;
        this.byteOffset = this.byteOffset + vertexCount * this._vertexBytes;
        this._dirty = true;
      }
    });
    cc.TiledMapBuffer = module.exports = TiledMapBuffer;
  }), {
    "../core/renderer/webgl/quad-buffer": 369
  } ],
  442: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler = _interopRequireDefault(require("../core/renderer/assembler"));
    var _valueTypes = require("../core/value-types");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var TiledLayer = require("./CCTiledLayer");
    var TiledMap = require("./CCTiledMap");
    var TileFlag = TiledMap.TileFlag;
    var FLIPPED_MASK = TileFlag.FLIPPED_MASK;
    var renderer = require("../core/renderer/");
    var vfmtPosUvColor = require("../core/renderer/webgl/vertex-format").vfmtPosUvColor;
    var MaxGridsLimit = parseInt(10922.5);
    var RenderOrder = TiledMap.RenderOrder;
    var RenderFlow = require("../core/renderer/render-flow");
    var _mat4_temp = cc.mat4();
    var _vec3_temp = cc.v3();
    var _leftDown = {
      row: 0,
      col: 0
    };
    var _uva = {
      x: 0,
      y: 0
    };
    var _uvb = {
      x: 0,
      y: 0
    };
    var _uvc = {
      x: 0,
      y: 0
    };
    var _uvd = {
      x: 0,
      y: 0
    };
    var _renderData = null, _ia = null, _fillGrids = 0, _vfOffset = 0, _moveX = 0, _moveY = 0, _layerMat = null, _renderer = null, _renderDataList = null, _buffer = null, _curMaterial = null, _comp = null, _vbuf = null, _uintbuf = null;
    function _visitUserNode(userNode) {
      true;
      return;
    }
    function _flush() {
      if (0 === _ia._count) return;
      _renderer.material = _renderData.material;
      _renderer.node = _comp.node;
      _renderer._flushIA(_renderData.ia);
      var needSwitchBuffer = _fillGrids >= MaxGridsLimit;
      if (needSwitchBuffer) {
        _buffer.uploadData();
        _buffer.switchBuffer();
        _vbuf = _buffer._vData;
        _uintbuf = _buffer._uintVData;
        _renderData = _renderDataList.popRenderData(_buffer);
        _ia = _renderData.ia;
        _vfOffset = 0;
        _fillGrids = 0;
      } else {
        _renderData = _renderDataList.popRenderData(_buffer);
        _ia = _renderData.ia;
      }
      _renderData.material = _curMaterial;
    }
    function _renderNodes(nodeRow, nodeCol) {
      var nodesInfo = _comp._getNodesByRowCol(nodeRow, nodeCol);
      if (!nodesInfo || 0 == nodesInfo.count) return;
      var nodesList = nodesInfo.list;
      var newIdx = 0, oldIdx = 0;
      _flush();
      _renderer.worldMatDirty++;
      for (;newIdx < nodesInfo.count; ) {
        var dataComp = nodesList[oldIdx];
        oldIdx++;
        if (!dataComp) continue;
        _visitUserNode(dataComp.node);
        if (newIdx !== oldIdx) {
          nodesList[newIdx] = dataComp;
          dataComp._index = newIdx;
        }
        newIdx++;
      }
      nodesList.length = newIdx;
      _renderer.worldMatDirty--;
      _renderDataList.pushNodesList(_renderData, nodesList);
      _renderer._flush();
      _renderer.node = _comp.node;
    }
    function _flipTexture(inGrid, gid) {
      _uva.x = inGrid.l;
      _uva.y = inGrid.t;
      _uvb.x = inGrid.r;
      _uvb.y = inGrid.t;
      _uvc.x = inGrid.l;
      _uvc.y = inGrid.b;
      _uvd.x = inGrid.r;
      _uvd.y = inGrid.b;
      var tempVal = null;
      if ((gid & TileFlag.DIAGONAL) >>> 0) {
        tempVal = _uvb;
        _uvb = _uvc;
        _uvc = tempVal;
      }
      if ((gid & TileFlag.HORIZONTAL) >>> 0) {
        tempVal = _uva;
        _uva = _uvb;
        _uvb = tempVal;
        tempVal = _uvc;
        _uvc = _uvd;
        _uvd = tempVal;
      }
      if ((gid & TileFlag.VERTICAL) >>> 0) {
        tempVal = _uva;
        _uva = _uvc;
        _uvc = tempVal;
        tempVal = _uvb;
        _uvb = _uvd;
        _uvd = tempVal;
      }
    }
    var TmxAssembler = (function(_Assembler) {
      _inheritsLoose(TmxAssembler, _Assembler);
      function TmxAssembler() {
        return _Assembler.apply(this, arguments) || this;
      }
      var _proto = TmxAssembler.prototype;
      _proto.updateRenderData = function updateRenderData(comp) {
        if (!comp._renderDataList) {
          comp._buffer = new cc.TiledMapBuffer(renderer._handle, vfmtPosUvColor);
          comp._renderDataList = new cc.TiledMapRenderDataList();
        }
      };
      _proto.fillBuffers = function fillBuffers(comp, renderer) {
        var vertices = comp._vertices;
        if (0 === vertices.length) return;
        comp._updateCulling();
        var layerNode = comp.node;
        _moveX = comp._leftDownToCenterX;
        _moveY = comp._leftDownToCenterY;
        _layerMat = layerNode._worldMatrix;
        _renderer = renderer;
        _comp = comp;
        _renderDataList = comp._renderDataList;
        _buffer = comp._buffer;
        if (comp._isCullingDirty() || comp._isUserNodeDirty() || comp._hasAnimation() || comp._hasTiledNode()) {
          _buffer.reset();
          var leftDown, rightTop;
          if (comp._enableCulling) {
            var cullingRect = comp._cullingRect;
            leftDown = cullingRect.leftDown;
            rightTop = cullingRect.rightTop;
          } else {
            leftDown = _leftDown;
            rightTop = comp._rightTop;
          }
          var maxRows = rightTop.row - leftDown.row + 1;
          var maxCols = rightTop.col - leftDown.col + 1;
          var maxGrids = maxRows * maxCols;
          maxGrids > MaxGridsLimit && (maxGrids = MaxGridsLimit);
          _buffer.request(4 * maxGrids, 6 * maxGrids);
          switch (comp._renderOrder) {
           case RenderOrder.RightDown:
            this.traverseGrids(leftDown, rightTop, -1, 1);
            break;

           case RenderOrder.LeftDown:
            this.traverseGrids(leftDown, rightTop, -1, -1);
            break;

           case RenderOrder.RightUp:
            this.traverseGrids(leftDown, rightTop, 1, 1);
            break;

           case RenderOrder.LeftUp:
            this.traverseGrids(leftDown, rightTop, 1, -1);
          }
          comp._setCullingDirty(false);
          comp._setUserNodeDirty(false);
        } else {
          var renderData;
          var nodesRenderList;
          var nodesList;
          var i;
          var j;
          var idx;
          var dataComp;
          false;
        }
        _renderData = null;
        _ia = null;
        _layerMat = null;
        _renderer = null;
        _renderDataList = null;
        _buffer = null;
        _curMaterial = null;
        _comp = null;
        _vbuf = null;
        _uintbuf = null;
      };
      _proto.traverseGrids = function traverseGrids(leftDown, rightTop, rowMoveDir, colMoveDir) {
        _renderDataList.reset();
        if (rightTop.row < 0 || rightTop.col < 0) return;
        _renderData = _renderDataList.popRenderData(_buffer);
        _ia = _renderData.ia;
        _vbuf = _buffer._vData;
        _uintbuf = _buffer._uintVData;
        _fillGrids = 0;
        _vfOffset = 0;
        _curMaterial = null;
        var layerNode = _comp.node;
        var pOpacity = layerNode.parent ? layerNode.parent._opacity / 255 : 1;
        var opacity = pOpacity * layerNode._opacity;
        layerNode._color._fastSetA(opacity);
        var color = layerNode._color._val;
        var tiledTiles = _comp._tiledTiles;
        var texGrids = _comp._texGrids;
        var tiles = _comp._tiles;
        var texIdToMatIdx = _comp._texIdToMatIndex;
        var mats = _comp._materials;
        var vertices = _comp._vertices;
        var rowData, col, cols, row, rows, colData, tileSize, grid = null, gid = 0;
        var left = 0, bottom = 0, right = 0, top = 0;
        var tiledNode = null, curTexIdx = -1, matIdx;
        var colNodesCount = 0, checkColRange = true;
        if (-1 == rowMoveDir) {
          row = rightTop.row;
          rows = leftDown.row;
        } else {
          row = leftDown.row;
          rows = rightTop.row;
        }
        for (;(rows - row) * rowMoveDir >= 0; row += rowMoveDir) {
          rowData = vertices[row];
          colNodesCount = _comp._getNodesCountByRow(row);
          checkColRange = 0 == colNodesCount && void 0 != rowData;
          if (1 == colMoveDir) {
            col = checkColRange && leftDown.col < rowData.minCol ? rowData.minCol : leftDown.col;
            cols = checkColRange && rightTop.col > rowData.maxCol ? rowData.maxCol : rightTop.col;
          } else {
            col = checkColRange && rightTop.col > rowData.maxCol ? rowData.maxCol : rightTop.col;
            cols = checkColRange && leftDown.col < rowData.minCol ? rowData.minCol : leftDown.col;
          }
          for (;(cols - col) * colMoveDir >= 0; col += colMoveDir) {
            colData = rowData && rowData[col];
            if (!colData) {
              colNodesCount > 0 && _renderNodes(row, col);
              continue;
            }
            gid = tiles[colData.index];
            grid = texGrids[(gid & FLIPPED_MASK) >>> 0];
            if (!grid) continue;
            if (curTexIdx !== grid.texId) {
              -1 !== curTexIdx && _flush();
              curTexIdx = grid.texId;
              matIdx = texIdToMatIdx[curTexIdx];
              _curMaterial = mats[matIdx];
              _renderData.material = _curMaterial;
            }
            if (!_curMaterial) continue;
            left = colData.left - _moveX;
            bottom = colData.bottom - _moveY;
            tileSize = grid.tileset._tileSize;
            right = left + tileSize.width;
            top = bottom + tileSize.height;
            tiledNode = tiledTiles[colData.index];
            if (tiledNode) {
              if (tiledNode.node.active) {
                tiledNode.node._color._fastSetA(tiledNode.node._opacity * opacity / 255);
                this.fillByTiledNode(tiledNode.node, _vbuf, _uintbuf, left, right, top, bottom);
              }
            } else {
              _vbuf[_vfOffset] = left;
              _vbuf[_vfOffset + 1] = top;
              _uintbuf[_vfOffset + 4] = color;
              _vbuf[_vfOffset + 5] = left;
              _vbuf[_vfOffset + 6] = bottom;
              _uintbuf[_vfOffset + 9] = color;
              _vbuf[_vfOffset + 10] = right;
              _vbuf[_vfOffset + 11] = top;
              _uintbuf[_vfOffset + 14] = color;
              _vbuf[_vfOffset + 15] = right;
              _vbuf[_vfOffset + 16] = bottom;
              _uintbuf[_vfOffset + 19] = color;
            }
            _flipTexture(grid, gid);
            _vbuf[_vfOffset + 2] = _uva.x;
            _vbuf[_vfOffset + 3] = _uva.y;
            _vbuf[_vfOffset + 7] = _uvc.x;
            _vbuf[_vfOffset + 8] = _uvc.y;
            _vbuf[_vfOffset + 12] = _uvb.x;
            _vbuf[_vfOffset + 13] = _uvb.y;
            _vbuf[_vfOffset + 17] = _uvd.x;
            _vbuf[_vfOffset + 18] = _uvd.y;
            _vfOffset += 20;
            _buffer.adjust(4, 6);
            _ia._count += 6;
            _fillGrids++;
            colNodesCount > 0 && _renderNodes(row, col);
            _fillGrids >= MaxGridsLimit && _flush();
          }
        }
        _buffer.uploadData();
        if (_ia._count > 0) {
          _renderer.material = _renderData.material;
          _renderer.node = _comp.node;
          _renderer._flushIA(_renderData.ia);
        }
      };
      _proto.fillByTiledNode = function fillByTiledNode(tiledNode, vbuf, uintbuf, left, right, top, bottom) {
        tiledNode._updateLocalMatrix();
        _valueTypes.Mat4.copy(_mat4_temp, tiledNode._matrix);
        _valueTypes.Vec3.set(_vec3_temp, -(left + _moveX), -(bottom + _moveY), 0);
        _valueTypes.Mat4.transform(_mat4_temp, _mat4_temp, _vec3_temp);
        var m = _mat4_temp.m;
        var a = m[0];
        var b = m[1];
        var c = m[4];
        var d = m[5];
        var tx = m[12];
        var ty = m[13];
        var color = tiledNode._color._val;
        vbuf[_vfOffset] = left * a + top * c + tx;
        vbuf[_vfOffset + 1] = left * b + top * d + ty;
        uintbuf[_vfOffset + 4] = color;
        vbuf[_vfOffset + 5] = left * a + bottom * c + tx;
        vbuf[_vfOffset + 6] = left * b + bottom * d + ty;
        uintbuf[_vfOffset + 9] = color;
        vbuf[_vfOffset + 10] = right * a + top * c + tx;
        vbuf[_vfOffset + 11] = right * b + top * d + ty;
        uintbuf[_vfOffset + 14] = color;
        vbuf[_vfOffset + 15] = right * a + bottom * c + tx;
        vbuf[_vfOffset + 16] = right * b + bottom * d + ty;
        uintbuf[_vfOffset + 19] = color;
      };
      return TmxAssembler;
    })(_assembler["default"]);
    exports["default"] = TmxAssembler;
    _assembler["default"].register(TiledLayer, TmxAssembler);
    module.exports = exports["default"];
  }), {
    "../core/renderer/": 322,
    "../core/renderer/assembler": 302,
    "../core/renderer/render-flow": 323,
    "../core/renderer/webgl/vertex-format": 371,
    "../core/value-types": 401,
    "./CCTiledLayer": 434,
    "./CCTiledMap": 435
  } ],
  443: [ (function(require, module, exports) {
    "use strict";
    var VideoPlayerImpl = require("./video-player-impl");
    var EventType = VideoPlayerImpl.EventType;
    var ResourceType = cc.Enum({
      REMOTE: 0,
      LOCAL: 1
    });
    var VideoPlayer = cc.Class({
      name: "cc.VideoPlayer",
      extends: cc.Component,
      editor: false,
      properties: {
        _resourceType: ResourceType.REMOTE,
        resourceType: {
          tooltip: (true, "i18n:COMPONENT.videoplayer.resourceType"),
          type: ResourceType,
          set: function set(value) {
            this._resourceType = value;
            this._updateVideoSource();
          },
          get: function get() {
            return this._resourceType;
          }
        },
        _remoteURL: "",
        remoteURL: {
          tooltip: (true, "i18n:COMPONENT.videoplayer.url"),
          type: cc.String,
          set: function set(url) {
            this._remoteURL = url;
            this._updateVideoSource();
          },
          get: function get() {
            return this._remoteURL;
          }
        },
        _clip: {
          default: null,
          type: cc.VideoClip
        },
        clip: {
          tooltip: (true, "i18n:COMPONENT.videoplayer.video"),
          get: function get() {
            return this._clip;
          },
          set: function set(value) {
            this._clip = value;
            this._updateVideoSource();
          },
          type: cc.VideoClip
        },
        currentTime: {
          tooltip: (true, "i18n:COMPONENT.videoplayer.currentTime"),
          type: cc.Float,
          set: function set(time) {
            this._impl && this._impl.seekTo(time);
          },
          get: function get() {
            if (this._impl) {
              if (this._currentStatus === EventType.NONE || this._currentStatus === EventType.STOPPED || this._currentStatus === EventType.META_LOADED || this._currentStatus === EventType.READY_TO_PLAY) return 0;
              if (this._currentStatus === EventType.COMPLETED) return this._impl.duration();
              return this._impl.currentTime();
            }
            return -1;
          }
        },
        _volume: 1,
        volume: {
          get: function get() {
            return this._volume;
          },
          set: function set(value) {
            this._volume = value;
            this.isPlaying() && !this._mute && this._syncVolume();
          },
          range: [ 0, 1 ],
          type: cc.Float,
          tooltip: (true, "i18n:COMPONENT.videoplayer.volume")
        },
        _mute: false,
        mute: {
          get: function get() {
            return this._mute;
          },
          set: function set(value) {
            this._mute = value;
            this._syncVolume();
          },
          tooltip: (true, "i18n:COMPONENT.videoplayer.mute")
        },
        keepAspectRatio: {
          tooltip: (true, "i18n:COMPONENT.videoplayer.keepAspectRatio"),
          default: true,
          type: cc.Boolean,
          notify: function notify() {
            this._impl && this._impl.setKeepAspectRatioEnabled(this.keepAspectRatio);
          }
        },
        _isFullscreen: {
          default: false,
          formerlySerializedAs: "_N$isFullscreen"
        },
        isFullscreen: {
          get: function get() {
            true;
            this._isFullscreen = this._impl && this._impl.isFullScreenEnabled();
            return this._isFullscreen;
          },
          set: function set(enable) {
            this._isFullscreen = enable;
            true;
            this._impl && this._impl.setFullScreenEnabled(enable);
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.videoplayer.isFullscreen")
        },
        _stayOnBottom: false,
        stayOnBottom: {
          get: function get() {
            return this._stayOnBottom;
          },
          set: function set(enable) {
            this._stayOnBottom = enable;
            this._impl && this._impl.setStayOnBottom(enable);
          },
          animatable: false,
          tooltip: (true, "i18n:COMPONENT.videoplayer.stayOnBottom")
        },
        videoPlayerEvent: {
          default: [],
          type: cc.Component.EventHandler
        }
      },
      statics: {
        EventType: EventType,
        ResourceType: ResourceType,
        Impl: VideoPlayerImpl
      },
      ctor: function ctor() {
        this._impl = new VideoPlayerImpl();
        this._currentStatus = EventType.NONE;
      },
      _syncVolume: function _syncVolume() {
        var impl = this._impl;
        if (impl) {
          var volume = this._mute ? 0 : this._volume;
          impl.setVolume(volume);
        }
      },
      _updateVideoSource: function _updateVideoSource() {
        var url = "";
        this.resourceType === ResourceType.REMOTE ? url = this.remoteURL : this._clip && (url = this._clip.nativeUrl);
        this._impl.setURL(url, this._mute || 0 === this._volume);
        this._impl.setKeepAspectRatioEnabled(this.keepAspectRatio);
      },
      onLoad: function onLoad() {
        var impl = this._impl;
        if (impl) {
          impl.createDomElementIfNeeded(this._mute || 0 === this._volume);
          impl.setStayOnBottom(this._stayOnBottom);
          this._updateVideoSource();
          true;
          impl.seekTo(this.currentTime);
          impl.setFullScreenEnabled(this._isFullscreen);
          this.pause();
          impl.setEventListener(EventType.PLAYING, this.onPlaying.bind(this));
          impl.setEventListener(EventType.PAUSED, this.onPasued.bind(this));
          impl.setEventListener(EventType.STOPPED, this.onStopped.bind(this));
          impl.setEventListener(EventType.COMPLETED, this.onCompleted.bind(this));
          impl.setEventListener(EventType.META_LOADED, this.onMetaLoaded.bind(this));
          impl.setEventListener(EventType.CLICKED, this.onClicked.bind(this));
          impl.setEventListener(EventType.READY_TO_PLAY, this.onReadyToPlay.bind(this));
        }
      },
      onRestore: function onRestore() {
        this._impl || (this._impl = new VideoPlayerImpl());
      },
      onEnable: function onEnable() {
        this._impl && this._impl.enable();
      },
      onDisable: function onDisable() {
        this._impl && this._impl.disable();
      },
      onDestroy: function onDestroy() {
        if (this._impl) {
          this._impl.destroy();
          this._impl = null;
        }
      },
      update: function update(dt) {
        this._impl && this._impl.updateMatrix(this.node);
      },
      onReadyToPlay: function onReadyToPlay() {
        this._currentStatus = EventType.READY_TO_PLAY;
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.READY_TO_PLAY);
        this.node.emit("ready-to-play", this);
      },
      onMetaLoaded: function onMetaLoaded() {
        this._currentStatus = EventType.META_LOADED;
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.META_LOADED);
        this.node.emit("meta-loaded", this);
      },
      onClicked: function onClicked() {
        this._currentStatus = EventType.CLICKED;
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.CLICKED);
        this.node.emit("clicked", this);
      },
      onPlaying: function onPlaying() {
        this._currentStatus = EventType.PLAYING;
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.PLAYING);
        this.node.emit("playing", this);
      },
      onPasued: function onPasued() {
        this._currentStatus = EventType.PAUSED;
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.PAUSED);
        this.node.emit("paused", this);
      },
      onStopped: function onStopped() {
        this._currentStatus = EventType.STOPPED;
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.STOPPED);
        this.node.emit("stopped", this);
      },
      onCompleted: function onCompleted() {
        this._currentStatus = EventType.COMPLETED;
        cc.Component.EventHandler.emitEvents(this.videoPlayerEvent, this, EventType.COMPLETED);
        this.node.emit("completed", this);
      },
      play: function play() {
        if (this._impl) {
          this._syncVolume();
          this._impl.play();
        }
      },
      resume: function resume() {
        if (this._impl) {
          this._syncVolume();
          this._impl.resume();
        }
      },
      pause: function pause() {
        this._impl && this._impl.pause();
      },
      stop: function stop() {
        this._impl && this._impl.stop();
      },
      getDuration: function getDuration() {
        if (this._impl) return this._impl.duration();
        return -1;
      },
      isPlaying: function isPlaying() {
        if (this._impl) return this._impl.isPlaying();
        return false;
      }
    });
    cc.VideoPlayer = module.exports = VideoPlayer;
  }), {
    "./video-player-impl": 444
  } ],
  444: [ (function(require, module, exports) {
    "use strict";
    var utils = require("../core/platform/utils");
    var sys = require("../core/platform/CCSys");
    var macro = require("../core/platform/CCMacro");
    var READY_STATE = {
      HAVE_NOTHING: 0,
      HAVE_METADATA: 1,
      HAVE_CURRENT_DATA: 2,
      HAVE_FUTURE_DATA: 3,
      HAVE_ENOUGH_DATA: 4
    };
    var _mat4_temp = cc.mat4();
    var VideoPlayerImpl = cc.Class({
      name: "VideoPlayerImpl",
      ctor: function ctor() {
        this._EventList = {};
        this._video = null;
        this._url = "";
        this._waitingFullscreen = false;
        this._fullScreenEnabled = false;
        this._stayOnBottom = false;
        this._loadedmeta = false;
        this._loaded = false;
        this._visible = false;
        this._playing = false;
        this._ignorePause = false;
        this._forceUpdate = false;
        this._m00 = 0;
        this._m01 = 0;
        this._m04 = 0;
        this._m05 = 0;
        this._m12 = 0;
        this._m13 = 0;
        this._w = 0;
        this._h = 0;
        this.__eventListeners = {};
      },
      _bindEvent: function _bindEvent() {
        var video = this._video, self = this;
        var cbs = this.__eventListeners;
        cbs.loadedmetadata = function() {
          self._loadedmeta = true;
          self._forceUpdate = true;
          if (self._waitingFullscreen) {
            self._waitingFullscreen = false;
            self._toggleFullscreen(true);
          }
          self._dispatchEvent(VideoPlayerImpl.EventType.META_LOADED);
        };
        cbs.ended = function() {
          if (self._video !== video) return;
          self._playing = false;
          self._dispatchEvent(VideoPlayerImpl.EventType.COMPLETED);
        };
        cbs.play = function() {
          if (self._video !== video) return;
          self._playing = true;
          self._updateVisibility();
          self._dispatchEvent(VideoPlayerImpl.EventType.PLAYING);
        };
        cbs.pause = function() {
          if (self._video !== video) return;
          self._playing = false;
          self._ignorePause || self._dispatchEvent(VideoPlayerImpl.EventType.PAUSED);
        };
        cbs.click = function() {
          self._dispatchEvent(VideoPlayerImpl.EventType.CLICKED);
        };
        video.addEventListener("loadedmetadata", cbs.loadedmetadata);
        video.addEventListener("ended", cbs.ended);
        video.addEventListener("play", cbs.play);
        video.addEventListener("pause", cbs.pause);
        video.addEventListener("click", cbs.click);
        function onCanPlay() {
          if (self._loaded || self._playing) return;
          var video = self._video;
          if (video.readyState === READY_STATE.HAVE_ENOUGH_DATA || video.readyState === READY_STATE.HAVE_METADATA) {
            video.currentTime = 0;
            self._loaded = true;
            self._forceUpdate = true;
            self._dispatchEvent(VideoPlayerImpl.EventType.READY_TO_PLAY);
            self._updateVisibility();
          }
        }
        cbs.onCanPlay = onCanPlay;
        video.addEventListener("canplay", cbs.onCanPlay);
        video.addEventListener("canplaythrough", cbs.onCanPlay);
        video.addEventListener("suspend", cbs.onCanPlay);
      },
      _updateVisibility: function _updateVisibility() {
        var video = this._video;
        if (!video) return;
        if (this._visible) video.style.visibility = "visible"; else {
          video.style.visibility = "hidden";
          video.pause();
          this._playing = false;
        }
      },
      _updateSize: function _updateSize(width, height) {
        var video = this._video;
        if (!video) return;
        video.style.width = width + "px";
        video.style.height = height + "px";
      },
      _createDom: function _createDom(muted) {
        var video = document.createElement("video");
        video.style.position = "absolute";
        video.style.bottom = "0px";
        video.style.left = "0px";
        video.style["z-index"] = this._stayOnBottom ? macro.MIN_ZINDEX : 0;
        video.className = "cocosVideo";
        video.setAttribute("preload", "auto");
        video.setAttribute("webkit-playsinline", "");
        video.setAttribute("x5-playsinline", "");
        video.setAttribute("playsinline", "");
        muted && video.setAttribute("muted", "");
        this._video = video;
        cc.game.container.appendChild(video);
      },
      createDomElementIfNeeded: function createDomElementIfNeeded(muted) {
        this._video || this._createDom(muted);
      },
      removeDom: function removeDom() {
        var video = this._video;
        if (video) {
          var hasChild = utils.contains(cc.game.container, video);
          hasChild && cc.game.container.removeChild(video);
          var cbs = this.__eventListeners;
          video.removeEventListener("loadedmetadata", cbs.loadedmetadata);
          video.removeEventListener("ended", cbs.ended);
          video.removeEventListener("play", cbs.play);
          video.removeEventListener("pause", cbs.pause);
          video.removeEventListener("click", cbs.click);
          video.removeEventListener("canplay", cbs.onCanPlay);
          video.removeEventListener("canplaythrough", cbs.onCanPlay);
          video.removeEventListener("suspend", cbs.onCanPlay);
          cbs.loadedmetadata = null;
          cbs.ended = null;
          cbs.play = null;
          cbs.pause = null;
          cbs.click = null;
          cbs.onCanPlay = null;
        }
        this._video = null;
        this._url = "";
      },
      setURL: function setURL(path, muted) {
        var source, extname;
        if (this._url === path) return;
        this.removeDom();
        this._url = path;
        this.createDomElementIfNeeded(muted);
        this._bindEvent();
        var video = this._video;
        video.style["visibility"] = "hidden";
        this._loaded = false;
        this._playing = false;
        this._loadedmeta = false;
        source = document.createElement("source");
        source.src = path;
        video.appendChild(source);
        extname = cc.path.extname(path);
        var polyfill = VideoPlayerImpl._polyfill;
        for (var i = 0; i < polyfill.canPlayType.length; i++) if (extname !== polyfill.canPlayType[i]) {
          source = document.createElement("source");
          source.src = path.replace(extname, polyfill.canPlayType[i]);
          video.appendChild(source);
        }
      },
      getURL: function getURL() {
        return this._url;
      },
      play: function play() {
        var video = this._video;
        if (!video || !this._visible || this._playing) return;
        video.play();
      },
      pause: function pause() {
        var video = this._video;
        if (!this._playing || !video) return;
        video.pause();
      },
      resume: function resume() {
        this.play();
      },
      stop: function stop() {
        var video = this._video;
        if (!video || !this._visible) return;
        this._ignorePause = true;
        video.currentTime = 0;
        video.pause();
        setTimeout(function() {
          this._dispatchEvent(VideoPlayerImpl.EventType.STOPPED);
          this._ignorePause = false;
        }.bind(this), 0);
      },
      setVolume: function setVolume(volume) {
        var video = this._video;
        video && (video.volume = volume);
      },
      seekTo: function seekTo(time) {
        var video = this._video;
        if (!video) return;
        if (this._loaded) video.currentTime = time; else {
          var cb = function cb() {
            video.currentTime = time;
            video.removeEventListener(VideoPlayerImpl._polyfill.event, cb);
          };
          video.addEventListener(VideoPlayerImpl._polyfill.event, cb);
        }
      },
      isPlaying: function isPlaying() {
        return this._playing;
      },
      duration: function duration() {
        var video = this._video;
        var duration = -1;
        if (!video) return duration;
        duration = video.duration;
        duration <= 0 && cc.logID(7702);
        return duration;
      },
      currentTime: function currentTime() {
        var video = this._video;
        if (!video) return -1;
        return video.currentTime;
      },
      setKeepAspectRatioEnabled: function setKeepAspectRatioEnabled() {
        false;
        cc.logID(7700);
      },
      isKeepAspectRatioEnabled: function isKeepAspectRatioEnabled() {
        return true;
      },
      _toggleFullscreen: function _toggleFullscreen(enable) {
        var self = this, video = this._video;
        if (!video) return;
        function handleFullscreenChange(event) {
          var fullscreenElement = sys.browserType === sys.BROWSER_TYPE_IE ? document.msFullscreenElement : document.fullscreenElement;
          self._fullScreenEnabled = fullscreenElement === video;
        }
        function handleFullScreenError(event) {
          self._fullScreenEnabled = false;
        }
        if (enable) {
          sys.browserType === sys.BROWSER_TYPE_IE && (video.style["transform"] = "");
          cc.screen.requestFullScreen(video, handleFullscreenChange, handleFullScreenError);
        } else cc.screen.fullScreen() && cc.screen.exitFullScreen(video);
      },
      setStayOnBottom: function setStayOnBottom(enabled) {
        this._stayOnBottom = enabled;
        if (!this._video) return;
        this._video.style["z-index"] = enabled ? macro.MIN_ZINDEX : 0;
      },
      setFullScreenEnabled: function setFullScreenEnabled(enable) {
        !this._loadedmeta && enable ? this._waitingFullscreen = true : this._toggleFullscreen(enable);
      },
      isFullScreenEnabled: function isFullScreenEnabled() {
        return this._fullScreenEnabled;
      },
      setEventListener: function setEventListener(event, callback) {
        this._EventList[event] = callback;
      },
      removeEventListener: function removeEventListener(event) {
        this._EventList[event] = null;
      },
      _dispatchEvent: function _dispatchEvent(event) {
        var callback = this._EventList[event];
        callback && callback.call(this, this, this._video.src);
      },
      onPlayEvent: function onPlayEvent() {
        var callback = this._EventList[VideoPlayerImpl.EventType.PLAYING];
        callback.call(this, this, this._video.src);
      },
      enable: function enable() {
        var list = VideoPlayerImpl.elements;
        -1 === list.indexOf(this) && list.push(this);
        this.setVisible(true);
      },
      disable: function disable() {
        var list = VideoPlayerImpl.elements;
        var index = list.indexOf(this);
        -1 !== index && list.splice(index, 1);
        this.setVisible(false);
      },
      destroy: function destroy() {
        this.disable();
        this.removeDom();
      },
      setVisible: function setVisible(visible) {
        if (this._visible !== visible) {
          this._visible = !!visible;
          this._updateVisibility();
        }
      },
      updateMatrix: function updateMatrix(node) {
        if (!this._video || !this._visible || this._fullScreenEnabled) return;
        node.getWorldMatrix(_mat4_temp);
        var renderCamera = cc.Camera._findRendererCamera(node);
        renderCamera && renderCamera.worldMatrixToScreen(_mat4_temp, _mat4_temp, cc.game.canvas.width, cc.game.canvas.height);
        var _mat4_tempm = _mat4_temp.m;
        if (!this._forceUpdate && this._m00 === _mat4_tempm[0] && this._m01 === _mat4_tempm[1] && this._m04 === _mat4_tempm[4] && this._m05 === _mat4_tempm[5] && this._m12 === _mat4_tempm[12] && this._m13 === _mat4_tempm[13] && this._w === node._contentSize.width && this._h === node._contentSize.height) return;
        this._m00 = _mat4_tempm[0];
        this._m01 = _mat4_tempm[1];
        this._m04 = _mat4_tempm[4];
        this._m05 = _mat4_tempm[5];
        this._m12 = _mat4_tempm[12];
        this._m13 = _mat4_tempm[13];
        this._w = node._contentSize.width;
        this._h = node._contentSize.height;
        var dpr = cc.view._devicePixelRatio;
        var scaleX = 1 / dpr;
        var scaleY = 1 / dpr;
        var container = cc.game.container;
        var a = _mat4_tempm[0] * scaleX, b = _mat4_tempm[1], c = _mat4_tempm[4], d = _mat4_tempm[5] * scaleY;
        var offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0;
        var offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
        var w, h;
        if (VideoPlayerImpl._polyfill.zoomInvalid) {
          this._updateSize(this._w * a, this._h * d);
          a = 1;
          d = 1;
          w = this._w * scaleX;
          h = this._h * scaleY;
        } else {
          w = this._w * scaleX;
          h = this._h * scaleY;
          this._updateSize(this._w, this._h);
        }
        var appx = w * _mat4_tempm[0] * node._anchorPoint.x;
        var appy = h * _mat4_tempm[5] * node._anchorPoint.y;
        var tx = _mat4_tempm[12] * scaleX - appx + offsetX, ty = _mat4_tempm[13] * scaleY - appy + offsetY;
        var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
        this._video.style["transform"] = matrix;
        this._video.style["-webkit-transform"] = matrix;
        this._video.style["transform-origin"] = "0px 100% 0px";
        this._video.style["-webkit-transform-origin"] = "0px 100% 0px";
        sys.browserType !== sys.BROWSER_TYPE_IE && (this._forceUpdate = false);
      }
    });
    VideoPlayerImpl.EventType = {
      NONE: -1,
      PLAYING: 0,
      PAUSED: 1,
      STOPPED: 2,
      COMPLETED: 3,
      META_LOADED: 4,
      CLICKED: 5,
      READY_TO_PLAY: 6
    };
    VideoPlayerImpl.elements = [];
    VideoPlayerImpl.pauseElements = [];
    cc.game.on(cc.game.EVENT_HIDE, (function() {
      var list = VideoPlayerImpl.elements;
      for (var element, i = 0; i < list.length; i++) {
        element = list[i];
        if (element.isPlaying()) {
          element.pause();
          VideoPlayerImpl.pauseElements.push(element);
        }
      }
    }));
    cc.game.on(cc.game.EVENT_SHOW, (function() {
      var list = VideoPlayerImpl.pauseElements;
      var element = list.pop();
      while (element) {
        element.play();
        element = list.pop();
      }
    }));
    VideoPlayerImpl._polyfill = {
      devicePixelRatio: false,
      event: "canplay",
      canPlayType: []
    };
    var dom = document.createElement("video");
    if (dom.canPlayType) {
      if (dom.canPlayType("video/ogg")) {
        VideoPlayerImpl._polyfill.canPlayType.push(".ogg");
        VideoPlayerImpl._polyfill.canPlayType.push(".ogv");
      }
      dom.canPlayType("video/mp4") && VideoPlayerImpl._polyfill.canPlayType.push(".mp4");
      dom.canPlayType("video/webm") && VideoPlayerImpl._polyfill.canPlayType.push(".webm");
    }
    sys.OS_ANDROID !== sys.os || sys.browserType !== sys.BROWSER_TYPE_SOUGOU && sys.browserType !== sys.BROWSER_TYPE_360 || (VideoPlayerImpl._polyfill.zoomInvalid = true);
    var style = document.createElement("style");
    style.innerHTML = ".cocosVideo:-moz-full-screen{transform:matrix(1,0,0,1,0,0) !important;}.cocosVideo:full-screen{transform:matrix(1,0,0,1,0,0) !important;}.cocosVideo:-webkit-full-screen{transform:matrix(1,0,0,1,0,0) !important;}";
    document.head.appendChild(style);
    module.exports = VideoPlayerImpl;
  }), {
    "../core/platform/CCMacro": 277,
    "../core/platform/CCSys": 281,
    "../core/platform/utils": 297
  } ],
  445: [ (function(require, module, exports) {
    "use strict";
    var WebViewImpl = require("./webview-impl");
    var EventType = WebViewImpl.EventType;
    function emptyCallback() {}
    var WebView = cc.Class({
      name: "cc.WebView",
      extends: cc.Component,
      editor: false,
      properties: {
        _url: "",
        url: {
          type: cc.String,
          tooltip: (true, "i18n:COMPONENT.webview.url"),
          get: function get() {
            return this._url;
          },
          set: function set(url) {
            this._url = url;
            var impl = this._impl;
            impl && impl.loadURL(url);
          }
        },
        webviewEvents: {
          default: [],
          type: cc.Component.EventHandler
        }
      },
      statics: {
        EventType: EventType,
        Impl: WebViewImpl
      },
      ctor: function ctor() {
        this._impl = new WebView.Impl();
      },
      onRestore: function onRestore() {
        this._impl || (this._impl = new WebView.Impl());
      },
      onEnable: function onEnable() {
        var impl = this._impl;
        impl.createDomElementIfNeeded(this.node.width, this.node.height);
        true;
        impl.setEventListener(EventType.LOADED, this._onWebViewLoaded.bind(this));
        impl.setEventListener(EventType.LOADING, this._onWebViewLoading.bind(this));
        impl.setEventListener(EventType.ERROR, this._onWebViewLoadError.bind(this));
        impl.loadURL(this._url);
        impl.setVisible(true);
      },
      onDisable: function onDisable() {
        var impl = this._impl;
        impl.setVisible(false);
        true;
        impl.setEventListener(EventType.LOADED, emptyCallback);
        impl.setEventListener(EventType.LOADING, emptyCallback);
        impl.setEventListener(EventType.ERROR, emptyCallback);
      },
      onDestroy: function onDestroy() {
        if (this._impl) {
          this._impl.destroy();
          this._impl = null;
        }
      },
      update: function update(dt) {
        this._impl && this._impl.updateMatrix(this.node);
      },
      _onWebViewLoaded: function _onWebViewLoaded() {
        cc.Component.EventHandler.emitEvents(this.webviewEvents, this, EventType.LOADED);
        this.node.emit("loaded", this);
      },
      _onWebViewLoading: function _onWebViewLoading() {
        cc.Component.EventHandler.emitEvents(this.webviewEvents, this, EventType.LOADING);
        this.node.emit("loading", this);
        return true;
      },
      _onWebViewLoadError: function _onWebViewLoadError() {
        cc.Component.EventHandler.emitEvents(this.webviewEvents, this, EventType.ERROR);
        this.node.emit("error", this);
      },
      setJavascriptInterfaceScheme: function setJavascriptInterfaceScheme(scheme) {
        this._impl && this._impl.setJavascriptInterfaceScheme(scheme);
      },
      setOnJSCallback: function setOnJSCallback(callback) {
        this._impl && this._impl.setOnJSCallback(callback);
      },
      evaluateJS: function evaluateJS(str) {
        this._impl && this._impl.evaluateJS(str);
      }
    });
    cc.WebView = module.exports = WebView;
  }), {
    "./webview-impl": 446
  } ],
  446: [ (function(require, module, exports) {
    "use strict";
    var utils = require("../core/platform/utils");
    var sys = require("../core/platform/CCSys");
    var _mat4_temp = cc.mat4();
    var WebViewImpl = cc.Class({
      name: "WebViewImpl",
      ctor: function ctor() {
        this._EventList = {};
        this._visible = false;
        this._parent = null;
        this._div = null;
        this._iframe = null;
        this._listener = null;
        this._forceUpdate = false;
        this._m00 = 0;
        this._m01 = 0;
        this._m04 = 0;
        this._m05 = 0;
        this._m12 = 0;
        this._m13 = 0;
        this._w = 0;
        this._h = 0;
        this.__eventListeners = {};
      },
      _updateVisibility: function _updateVisibility() {
        if (!this._div) return;
        var div = this._div;
        this._visible ? div.style.visibility = "visible" : div.style.visibility = "hidden";
      },
      _updateSize: function _updateSize(w, h) {
        var div = this._div;
        if (div) {
          div.style.width = w + "px";
          div.style.height = h + "px";
        }
      },
      _initEvent: function _initEvent() {
        var iframe = this._iframe;
        if (iframe) {
          var cbs = this.__eventListeners, self = this;
          cbs.load = function() {
            self._forceUpdate = true;
            self._dispatchEvent(WebViewImpl.EventType.LOADED);
          };
          cbs.error = function() {
            self._dispatchEvent(WebViewImpl.EventType.ERROR);
          };
          iframe.addEventListener("load", cbs.load);
          iframe.addEventListener("error", cbs.error);
        }
      },
      _initStyle: function _initStyle() {
        if (!this._div) return;
        var div = this._div;
        div.style.position = "absolute";
        div.style.bottom = "0px";
        div.style.left = "0px";
      },
      _setOpacity: function _setOpacity(opacity) {
        var iframe = this._iframe;
        iframe && iframe.style && (iframe.style.opacity = opacity / 255);
      },
      _createDom: function _createDom(w, h) {
        if (WebViewImpl._polyfill.enableDiv) {
          this._div = document.createElement("div");
          this._div.style["-webkit-overflow"] = "auto";
          this._div.style["-webkit-overflow-scrolling"] = "touch";
          this._iframe = document.createElement("iframe");
          this._div.appendChild(this._iframe);
          this._iframe.style.width = "100%";
          this._iframe.style.height = "100%";
        } else this._div = this._iframe = document.createElement("iframe");
        WebViewImpl._polyfill.enableBG && (this._div.style["background"] = "#FFF");
        this._div.style.height = h + "px";
        this._div.style.width = w + "px";
        this._div.style.overflow = "scroll";
        this._iframe.style.border = "none";
        cc.game.container.appendChild(this._div);
        this._updateVisibility();
      },
      _createNativeControl: function _createNativeControl(w, h) {
        this._createDom(w, h);
        this._initStyle();
        this._initEvent();
      },
      createDomElementIfNeeded: function(w, h) {
        this._div ? this._updateSize(w, h) : this._createNativeControl(w, h);
      },
      removeDom: function removeDom() {
        var div = this._div;
        if (div) {
          var hasChild = utils.contains(cc.game.container, div);
          hasChild && cc.game.container.removeChild(div);
          this._div = null;
        }
        var iframe = this._iframe;
        if (iframe) {
          var cbs = this.__eventListeners;
          iframe.removeEventListener("load", cbs.load);
          iframe.removeEventListener("error", cbs.error);
          cbs.load = null;
          cbs.error = null;
          this._iframe = null;
        }
      },
      setOnJSCallback: function setOnJSCallback(callback) {},
      setJavascriptInterfaceScheme: function setJavascriptInterfaceScheme(scheme) {},
      loadData: function loadData(data, MIMEType, encoding, baseURL) {},
      loadHTMLString: function loadHTMLString(string, baseURL) {},
      loadURL: function(url) {
        var iframe = this._iframe;
        if (iframe) {
          iframe.src = url;
          var self = this;
          var cb = function cb() {
            self._loaded = true;
            self._updateVisibility();
            iframe.removeEventListener("load", cb);
          };
          iframe.addEventListener("load", cb);
          this._dispatchEvent(WebViewImpl.EventType.LOADING);
        }
      },
      stopLoading: function stopLoading() {
        cc.logID(7800);
      },
      reload: function reload() {
        var iframe = this._iframe;
        if (iframe) {
          var win = iframe.contentWindow;
          win && win.location && win.location.reload();
        }
      },
      canGoBack: function canGoBack() {
        cc.logID(7801);
        return true;
      },
      canGoForward: function canGoForward() {
        cc.logID(7802);
        return true;
      },
      goBack: function goBack() {
        try {
          if (WebViewImpl._polyfill.closeHistory) return cc.logID(7803);
          var iframe = this._iframe;
          if (iframe) {
            var win = iframe.contentWindow;
            win && win.location && win.history.back.call(win);
          }
        } catch (err) {
          cc.log(err);
        }
      },
      goForward: function goForward() {
        try {
          if (WebViewImpl._polyfill.closeHistory) return cc.logID(7804);
          var iframe = this._iframe;
          if (iframe) {
            var win = iframe.contentWindow;
            win && win.location && win.history.forward.call(win);
          }
        } catch (err) {
          cc.log(err);
        }
      },
      evaluateJS: function evaluateJS(str) {
        var iframe = this._iframe;
        if (iframe) {
          var win = iframe.contentWindow;
          try {
            win.eval(str);
            this._dispatchEvent(WebViewImpl.EventType.JS_EVALUATED);
          } catch (err) {
            console.error(err);
          }
        }
      },
      setScalesPageToFit: function setScalesPageToFit() {
        cc.logID(7805);
      },
      setEventListener: function setEventListener(event, callback) {
        this._EventList[event] = callback;
      },
      removeEventListener: function removeEventListener(event) {
        this._EventList[event] = null;
      },
      _dispatchEvent: function _dispatchEvent(event) {
        var callback = this._EventList[event];
        callback && callback.call(this, this, this._iframe.src);
      },
      _createRenderCmd: function _createRenderCmd() {
        return new WebViewImpl.RenderCmd(this);
      },
      destroy: function destroy() {
        this.removeDom();
      },
      setVisible: function setVisible(visible) {
        if (this._visible !== visible) {
          this._visible = !!visible;
          this._updateVisibility();
        }
      },
      updateMatrix: function updateMatrix(node) {
        if (!this._div || !this._visible) return;
        node.getWorldMatrix(_mat4_temp);
        var renderCamera = cc.Camera._findRendererCamera(node);
        renderCamera && renderCamera.worldMatrixToScreen(_mat4_temp, _mat4_temp, cc.game.canvas.width, cc.game.canvas.height);
        var _mat4_tempm = _mat4_temp.m;
        if (!this._forceUpdate && this._m00 === _mat4_tempm[0] && this._m01 === _mat4_tempm[1] && this._m04 === _mat4_tempm[4] && this._m05 === _mat4_tempm[5] && this._m12 === _mat4_tempm[12] && this._m13 === _mat4_tempm[13] && this._w === node._contentSize.width && this._h === node._contentSize.height) return;
        this._m00 = _mat4_tempm[0];
        this._m01 = _mat4_tempm[1];
        this._m04 = _mat4_tempm[4];
        this._m05 = _mat4_tempm[5];
        this._m12 = _mat4_tempm[12];
        this._m13 = _mat4_tempm[13];
        this._w = node._contentSize.width;
        this._h = node._contentSize.height;
        var dpr = cc.view._devicePixelRatio;
        var scaleX = 1 / dpr;
        var scaleY = 1 / dpr;
        var container = cc.game.container;
        var a = _mat4_tempm[0] * scaleX, b = _mat4_tempm[1], c = _mat4_tempm[4], d = _mat4_tempm[5] * scaleY;
        var offsetX = container && container.style.paddingLeft ? parseInt(container.style.paddingLeft) : 0;
        var offsetY = container && container.style.paddingBottom ? parseInt(container.style.paddingBottom) : 0;
        this._updateSize(this._w, this._h);
        var w = this._w * scaleX;
        var h = this._h * scaleY;
        var appx = w * _mat4_tempm[0] * node._anchorPoint.x;
        var appy = h * _mat4_tempm[5] * node._anchorPoint.y;
        var tx = _mat4_tempm[12] * scaleX - appx + offsetX, ty = _mat4_tempm[13] * scaleY - appy + offsetY;
        var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
        this._div.style["transform"] = matrix;
        this._div.style["-webkit-transform"] = matrix;
        this._div.style["transform-origin"] = "0px 100% 0px";
        this._div.style["-webkit-transform-origin"] = "0px 100% 0px";
        this._setOpacity(node.opacity);
        this._forceUpdate = false;
      }
    });
    WebViewImpl.EventType = {
      LOADING: 0,
      LOADED: 1,
      ERROR: 2,
      JS_EVALUATED: 3
    };
    var polyfill = WebViewImpl._polyfill = {
      devicePixelRatio: false,
      enableDiv: false
    };
    sys.os === sys.OS_IOS && (polyfill.enableDiv = true);
    sys.isMobile ? sys.browserType === sys.BROWSER_TYPE_FIREFOX && (polyfill.enableBG = true) : sys.browserType === sys.BROWSER_TYPE_IE && (polyfill.closeHistory = true);
    module.exports = WebViewImpl;
  }), {
    "../core/platform/CCSys": 281,
    "../core/platform/utils": 297
  } ],
  447: [ (function(require, module, exports) {
    "use strict";
    require("./cocos2d/core");
    require("./cocos2d/animation");
    false;
    require("./cocos2d/particle");
    require("./cocos2d/tilemap");
    require("./cocos2d/videoplayer/CCVideoPlayer");
    require("./cocos2d/webview/CCWebView");
    require("./cocos2d/core/components/CCStudioComponent");
    require("./extensions/ccpool/CCNodePool");
    require("./cocos2d/actions");
    require("./extensions/spine");
    require("./extensions/dragonbones");
    true;
    require("./cocos2d/deprecated");
  }), {
    "./cocos2d/actions": 8,
    "./cocos2d/animation": 17,
    "./cocos2d/core": 239,
    "./cocos2d/core/components/CCStudioComponent": 199,
    "./cocos2d/deprecated": 413,
    "./cocos2d/particle": 419,
    "./cocos2d/particle/CCParticleAsset": 416,
    "./cocos2d/tilemap": 440,
    "./cocos2d/tilemap/CCTiledMapAsset": 436,
    "./cocos2d/videoplayer/CCVideoPlayer": 443,
    "./cocos2d/webview/CCWebView": 445,
    "./extensions/ccpool/CCNodePool": 448,
    "./extensions/dragonbones": 453,
    "./extensions/spine": 457
  } ],
  448: [ (function(require, module, exports) {
    "use strict";
    cc.NodePool = function(poolHandlerComp) {
      this.poolHandlerComp = poolHandlerComp;
      this._pool = [];
    };
    cc.NodePool.prototype = {
      constructor: cc.NodePool,
      size: function size() {
        return this._pool.length;
      },
      clear: function clear() {
        var count = this._pool.length;
        for (var i = 0; i < count; ++i) this._pool[i].destroy();
        this._pool.length = 0;
      },
      put: function put(obj) {
        if (obj && -1 === this._pool.indexOf(obj)) {
          obj.removeFromParent(false);
          var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
          handler && handler.unuse && handler.unuse();
          this._pool.push(obj);
        }
      },
      get: function get() {
        var last = this._pool.length - 1;
        if (last < 0) return null;
        var obj = this._pool[last];
        this._pool.length = last;
        var handler = this.poolHandlerComp ? obj.getComponent(this.poolHandlerComp) : null;
        handler && handler.reuse && handler.reuse.apply(handler, arguments);
        return obj;
      }
    };
    module.exports = cc.NodePool;
  }), {} ],
  449: [ (function(require, module, exports) {
    "use strict";
    var RenderComponent = require("../../cocos2d/core/components/CCRenderComponent");
    var EventTarget = require("../../cocos2d/core/event/event-target");
    var Graphics = require("../../cocos2d/core/graphics/graphics");
    var RenderFlow = require("../../cocos2d/core/renderer/render-flow");
    var FLAG_POST_RENDER = RenderFlow.FLAG_POST_RENDER;
    var ArmatureCache = require("./ArmatureCache");
    var AttachUtil = require("./AttachUtil");
    var DefaultArmaturesEnum = cc.Enum({
      default: -1
    });
    var DefaultAnimsEnum = cc.Enum({
      "<None>": 0
    });
    var DefaultCacheMode = cc.Enum({
      REALTIME: 0
    });
    var AnimationCacheMode = cc.Enum({
      REALTIME: 0,
      SHARED_CACHE: 1,
      PRIVATE_CACHE: 2
    });
    function setEnumAttr(obj, propName, enumDef) {
      cc.Class.Attr.setClassAttr(obj, propName, "type", "Enum");
      cc.Class.Attr.setClassAttr(obj, propName, "enumList", cc.Enum.getList(enumDef));
    }
    var ArmatureDisplay = cc.Class({
      name: "dragonBones.ArmatureDisplay",
      extends: RenderComponent,
      editor: false,
      statics: {
        AnimationCacheMode: AnimationCacheMode
      },
      properties: {
        _factory: {
          default: null,
          type: dragonBones.CCFactory,
          serializable: false
        },
        dragonAsset: {
          default: null,
          type: dragonBones.DragonBonesAsset,
          notify: function notify() {
            this._refresh();
            false;
          },
          tooltip: (true, "i18n:COMPONENT.dragon_bones.dragon_bones_asset")
        },
        dragonAtlasAsset: {
          default: null,
          type: dragonBones.DragonBonesAtlasAsset,
          notify: function notify() {
            this._parseDragonAtlasAsset();
            this._refresh();
          },
          tooltip: (true, "i18n:COMPONENT.dragon_bones.dragon_bones_atlas_asset")
        },
        _armatureName: "",
        armatureName: {
          get: function get() {
            return this._armatureName;
          },
          set: function set(value) {
            this._armatureName = value;
            var animNames = this.getAnimationNames(this._armatureName);
            if (!this.animationName || animNames.indexOf(this.animationName) < 0) {
              false;
              this.animationName = "";
            }
            this._armature && !this.isAnimationCached() && this._factory._dragonBones.clock.remove(this._armature);
            this._refresh();
            this._armature && !this.isAnimationCached() && this._factory._dragonBones.clock.add(this._armature);
          },
          visible: false
        },
        _animationName: "",
        animationName: {
          get: function get() {
            return this._animationName;
          },
          set: function set(value) {
            this._animationName = value;
          },
          visible: false
        },
        _defaultArmatureIndex: {
          default: 0,
          notify: function notify() {
            var armatureName = "";
            if (this.dragonAsset) {
              var armaturesEnum;
              this.dragonAsset && (armaturesEnum = this.dragonAsset.getArmatureEnum());
              if (!armaturesEnum) return cc.errorID(7400, this.name);
              armatureName = armaturesEnum[this._defaultArmatureIndex];
            }
            void 0 !== armatureName ? this.armatureName = armatureName : cc.errorID(7401, this.name);
          },
          type: DefaultArmaturesEnum,
          visible: true,
          editorOnly: true,
          animatable: false,
          displayName: "Armature",
          tooltip: (true, "i18n:COMPONENT.dragon_bones.armature_name")
        },
        _animationIndex: {
          default: 0,
          notify: function notify() {
            if (0 === this._animationIndex) {
              this.animationName = "";
              return;
            }
            var animsEnum;
            this.dragonAsset && (animsEnum = this.dragonAsset.getAnimsEnum(this.armatureName));
            if (!animsEnum) return;
            var animName = animsEnum[this._animationIndex];
            void 0 !== animName ? this.playAnimation(animName, this.playTimes) : cc.errorID(7402, this.name);
          },
          type: DefaultAnimsEnum,
          visible: true,
          editorOnly: true,
          animatable: false,
          displayName: "Animation",
          tooltip: (true, "i18n:COMPONENT.dragon_bones.animation_name")
        },
        _preCacheMode: -1,
        _cacheMode: AnimationCacheMode.REALTIME,
        _defaultCacheMode: {
          default: 0,
          type: AnimationCacheMode,
          notify: function notify() {
            if (this._defaultCacheMode !== AnimationCacheMode.REALTIME && this._armature && !ArmatureCache.canCache(this._armature)) {
              this._defaultCacheMode = AnimationCacheMode.REALTIME;
              cc.warn("Animation cache mode doesn't support skeletal nesting");
              return;
            }
            this.setAnimationCacheMode(this._defaultCacheMode);
          },
          editorOnly: true,
          visible: true,
          animatable: false,
          displayName: "Animation Cache Mode",
          tooltip: (true, "i18n:COMPONENT.dragon_bones.animation_cache_mode")
        },
        timeScale: {
          default: 1,
          notify: function notify() {
            this._armature && !this.isAnimationCached() && (this._armature.animation.timeScale = this.timeScale);
          },
          tooltip: (true, "i18n:COMPONENT.dragon_bones.time_scale")
        },
        playTimes: {
          default: -1,
          tooltip: (true, "i18n:COMPONENT.dragon_bones.play_times")
        },
        premultipliedAlpha: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.skeleton.premultipliedAlpha")
        },
        debugBones: {
          default: false,
          notify: function notify() {
            this._updateDebugDraw();
          },
          tooltip: (true, "i18n:COMPONENT.dragon_bones.debug_bones")
        },
        enableBatch: {
          default: false,
          notify: function notify() {
            this._updateBatch();
          },
          tooltip: (true, "i18n:COMPONENT.dragon_bones.enabled_batch")
        },
        _armatureKey: "",
        _accTime: 0,
        _playCount: 0,
        _frameCache: null,
        _curFrame: null,
        _playing: false,
        _armatureCache: null
      },
      ctor: function ctor() {
        this._eventTarget = new EventTarget();
        this._materialCache = {};
        this._inited = false;
        this.attachUtil = new AttachUtil();
        this._factory = dragonBones.CCFactory.getInstance();
      },
      onLoad: function onLoad() {
        var children = this.node.children;
        for (var i = 0, n = children.length; i < n; i++) {
          var child = children[i];
          var pos = child._name && child._name.search("CHILD_ARMATURE-");
          0 === pos && child.destroy();
        }
      },
      _updateBatch: function _updateBatch() {
        var baseMaterial = this.getMaterial(0);
        baseMaterial && baseMaterial.define("CC_USE_MODEL", !this.enableBatch);
        this._materialCache = {};
      },
      _updateMaterial: function _updateMaterial() {
        var baseMaterial = this.getMaterial(0);
        if (baseMaterial) {
          baseMaterial.define("CC_USE_MODEL", !this.enableBatch);
          baseMaterial.define("USE_TEXTURE", true);
          var srcBlendFactor = this.premultipliedAlpha ? cc.gfx.BLEND_ONE : cc.gfx.BLEND_SRC_ALPHA;
          var dstBlendFactor = cc.gfx.BLEND_ONE_MINUS_SRC_ALPHA;
          baseMaterial.setBlend(true, cc.gfx.BLEND_FUNC_ADD, srcBlendFactor, srcBlendFactor, cc.gfx.BLEND_FUNC_ADD, dstBlendFactor, dstBlendFactor);
        }
        this._materialCache = {};
      },
      disableRender: function disableRender() {
        this._super();
        this.node._renderFlag &= ~FLAG_POST_RENDER;
      },
      markForRender: function markForRender(enable) {
        this._super(enable);
        enable ? this.node._renderFlag |= FLAG_POST_RENDER : this.node._renderFlag &= ~FLAG_POST_RENDER;
      },
      _validateRender: function _validateRender() {
        var texture = this.dragonAtlasAsset && this.dragonAtlasAsset.texture;
        if (!texture || !texture.loaded) {
          this.disableRender();
          return;
        }
        this._super();
      },
      __preload: function __preload() {
        this._init();
      },
      _init: function _init() {
        if (this._inited) return;
        this._inited = true;
        this._resetAssembler();
        this._activateMaterial();
        this._parseDragonAtlasAsset();
        this._refresh();
        var children = this.node.children;
        for (var i = 0, n = children.length; i < n; i++) {
          var child = children[i];
          child && "DEBUG_DRAW_NODE" === child._name && child.destroy();
        }
        this._updateDebugDraw();
      },
      getArmatureKey: function getArmatureKey() {
        return this._armatureKey;
      },
      setAnimationCacheMode: function setAnimationCacheMode(cacheMode) {
        if (this._preCacheMode !== cacheMode) {
          this._cacheMode = cacheMode;
          this._buildArmature();
          this._armature && !this.isAnimationCached() && this._factory._dragonBones.clock.add(this._armature);
        }
      },
      isAnimationCached: function isAnimationCached() {
        false;
        return this._cacheMode !== AnimationCacheMode.REALTIME;
      },
      onEnable: function onEnable() {
        this._super();
        this._armature && !this.isAnimationCached() && this._factory._dragonBones.clock.add(this._armature);
      },
      onDisable: function onDisable() {
        this._super();
        this._armature && !this.isAnimationCached() && this._factory._dragonBones.clock.remove(this._armature);
      },
      _emitCacheCompleteEvent: function _emitCacheCompleteEvent() {
        this._eventTarget.emit(dragonBones.EventObject.LOOP_COMPLETE);
        this._eventTarget.emit(dragonBones.EventObject.COMPLETE);
      },
      update: function update(dt) {
        if (!this.isAnimationCached()) return;
        if (!this._frameCache) return;
        var frameCache = this._frameCache;
        if (!frameCache.isInited()) return;
        var frames = frameCache.frames;
        if (!this._playing) {
          if (frameCache.isInvalid()) {
            frameCache.updateToFrame();
            this._curFrame = frames[frames.length - 1];
          }
          return;
        }
        var frameTime = ArmatureCache.FrameTime;
        0 == this._accTime && 0 == this._playCount && this._eventTarget.emit(dragonBones.EventObject.START);
        var globalTimeScale = dragonBones.timeScale;
        this._accTime += dt * this.timeScale * globalTimeScale;
        var frameIdx = Math.floor(this._accTime / frameTime);
        frameCache.isCompleted || frameCache.updateToFrame(frameIdx);
        if (frameCache.isCompleted && frameIdx >= frames.length) {
          this._playCount++;
          if (this.playTimes > 0 && this._playCount >= this.playTimes) {
            this._curFrame = frames[frames.length - 1];
            this._accTime = 0;
            this._playing = false;
            this._playCount = 0;
            this._emitCacheCompleteEvent();
            return;
          }
          this._accTime = 0;
          frameIdx = 0;
          this._emitCacheCompleteEvent();
        }
        this._curFrame = frames[frameIdx];
      },
      onDestroy: function onDestroy() {
        this._super();
        this._inited = false;
        true;
        if (this._cacheMode === AnimationCacheMode.PRIVATE_CACHE) {
          this._armatureCache.dispose();
          this._armatureCache = null;
          this._armature = null;
        } else if (this._cacheMode === AnimationCacheMode.SHARED_CACHE) {
          this._armatureCache = null;
          this._armature = null;
        } else if (this._armature) {
          this._armature.dispose();
          this._armature = null;
        }
      },
      _updateDebugDraw: function _updateDebugDraw() {
        if (this.debugBones) {
          if (!this._debugDraw) {
            var debugDrawNode = new cc.PrivateNode();
            debugDrawNode.name = "DEBUG_DRAW_NODE";
            var debugDraw = debugDrawNode.addComponent(Graphics);
            debugDraw.lineWidth = 1;
            debugDraw.strokeColor = cc.color(255, 0, 0, 255);
            this._debugDraw = debugDraw;
          }
          this._debugDraw.node.parent = this.node;
        } else this._debugDraw && (this._debugDraw.node.parent = null);
      },
      _buildArmature: function _buildArmature() {
        if (!this.dragonAsset || !this.dragonAtlasAsset || !this.armatureName) return;
        if (this._armature) {
          true;
          this._preCacheMode === AnimationCacheMode.PRIVATE_CACHE ? this._armatureCache.dispose() : this._preCacheMode === AnimationCacheMode.REALTIME && this._armature.dispose();
          this._armatureCache = null;
          this._armature = null;
          this._displayProxy = null;
          this._frameCache = null;
          this._curFrame = null;
          this._playing = false;
          this._preCacheMode = null;
        }
        true;
        if (this._cacheMode === AnimationCacheMode.SHARED_CACHE) this._armatureCache = ArmatureCache.sharedCache; else if (this._cacheMode === AnimationCacheMode.PRIVATE_CACHE) {
          this._armatureCache = new ArmatureCache();
          this._armatureCache.enablePrivateMode();
        }
        var atlasUUID = this.dragonAtlasAsset._uuid;
        this._armatureKey = this.dragonAsset.init(this._factory, atlasUUID);
        if (this.isAnimationCached()) {
          this._armature = this._armatureCache.getArmatureCache(this.armatureName, this._armatureKey, atlasUUID);
          this._armature || (this._cacheMode = AnimationCacheMode.REALTIME);
        }
        this._preCacheMode = this._cacheMode;
        if (false, this._cacheMode === AnimationCacheMode.REALTIME) {
          this._displayProxy = this._factory.buildArmatureDisplay(this.armatureName, this._armatureKey, "", atlasUUID);
          if (!this._displayProxy) return;
          this._displayProxy._ccNode = this.node;
          this._displayProxy.setEventTarget(this._eventTarget);
          this._armature = this._displayProxy._armature;
          this._armature.animation.timeScale = this.timeScale;
        }
        this._cacheMode !== AnimationCacheMode.REALTIME && this.debugBones && cc.warn("Debug bones is invalid in cached mode");
        if (this._armature) {
          var armatureData = this._armature.armatureData;
          var aabb = armatureData.aabb;
          this.node.setContentSize(aabb.width, aabb.height);
        }
        this._updateBatch();
        this.attachUtil.init(this);
        this.attachUtil._associateAttachedNode();
        this.animationName && this.playAnimation(this.animationName, this.playTimes);
        this.markForRender(true);
      },
      _parseDragonAtlasAsset: function _parseDragonAtlasAsset() {
        this.dragonAtlasAsset && this.dragonAtlasAsset.init(this._factory);
      },
      _refresh: function _refresh() {
        this._buildArmature();
        false;
      },
      _updateCacheModeEnum: false,
      _updateAnimEnum: false,
      _updateArmatureEnum: false,
      playAnimation: function playAnimation(animName, playTimes) {
        this.playTimes = void 0 === playTimes ? -1 : playTimes;
        this.animationName = animName;
        if (this.isAnimationCached()) {
          var cache = this._armatureCache.getAnimationCache(this._armatureKey, animName);
          cache || (cache = this._armatureCache.initAnimationCache(this._armatureKey, animName));
          if (cache) {
            this._accTime = 0;
            this._playCount = 0;
            this._frameCache = cache;
            this.attachUtil._hasAttachedNode() && this._frameCache.enableCacheAttachedInfo();
            this._frameCache.updateToFrame(0);
            this._playing = true;
            this._curFrame = this._frameCache.frames[0];
          }
        } else if (this._armature) return this._armature.animation.play(animName, this.playTimes);
      },
      updateAnimationCache: function updateAnimationCache(animName) {
        if (!this.isAnimationCached()) return;
        this._armatureCache.updateAnimationCache(this._armatureKey, animName);
      },
      invalidAnimationCache: function invalidAnimationCache() {
        if (!this.isAnimationCached()) return;
        this._armatureCache.invalidAnimationCache(this._armatureKey);
      },
      getArmatureNames: function getArmatureNames() {
        var dragonBonesData = this._factory.getDragonBonesData(this._armatureKey);
        return dragonBonesData && dragonBonesData.armatureNames || [];
      },
      getAnimationNames: function getAnimationNames(armatureName) {
        var ret = [];
        var dragonBonesData = this._factory.getDragonBonesData(this._armatureKey);
        if (dragonBonesData) {
          var armatureData = dragonBonesData.getArmature(armatureName);
          if (armatureData) for (var animName in armatureData.animations) armatureData.animations.hasOwnProperty(animName) && ret.push(animName);
        }
        return ret;
      },
      on: function on(eventType, listener, target) {
        this.addEventListener(eventType, listener, target);
      },
      off: function off(eventType, listener, target) {
        this.removeEventListener(eventType, listener, target);
      },
      once: function once(eventType, listener, target) {
        this._eventTarget.once(eventType, listener, target);
      },
      addEventListener: function addEventListener(eventType, listener, target) {
        this._eventTarget.on(eventType, listener, target);
      },
      removeEventListener: function removeEventListener(eventType, listener, target) {
        this._eventTarget.off(eventType, listener, target);
      },
      buildArmature: function buildArmature(armatureName, node) {
        return this._factory.createArmatureNode(this, armatureName, node);
      },
      armature: function armature() {
        return this._armature;
      }
    });
    module.exports = dragonBones.ArmatureDisplay = ArmatureDisplay;
  }), {
    "../../cocos2d/core/components/CCRenderComponent": 192,
    "../../cocos2d/core/event/event-target": 219,
    "../../cocos2d/core/graphics/graphics": 235,
    "../../cocos2d/core/renderer/render-flow": 323,
    "./ArmatureCache": void 0,
    "./AttachUtil": 450
  } ],
  450: [ (function(require, module, exports) {
    "use strict";
    var _mat = _interopRequireDefault(require("../../cocos2d/core/value-types/mat4"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RenderFlow = require("../../cocos2d/core/renderer/render-flow");
    var FLAG_TRANSFORM = RenderFlow.FLAG_TRANSFORM;
    var EmptyHandle = function EmptyHandle() {};
    var ATTACHED_ROOT_NAME = "ATTACHED_NODE_TREE";
    var ATTACHED_PRE_NAME = "ATTACHED_NODE:";
    var limitNode = function limitNode(node) {
      Object.defineProperty(node, "_worldMatDirty", {
        get: function get() {
          return true;
        },
        set: function set(value) {}
      });
      node._calculWorldMatrix = EmptyHandle;
      node._mulMat = EmptyHandle;
    };
    var _tempMat4 = new _mat["default"]();
    var AttachUtil = cc.Class({
      name: "dragonBones.AttachUtil",
      ctor: function ctor() {
        this._inited = false;
        this._armature = null;
        this._armatureNode = null;
        this._armatureDisplay = null;
        this._attachedRootNode = null;
        this._attachedNodeArray = [];
        this._boneIndexToNode = {};
      },
      init: function init(armatureDisplay) {
        this._inited = true;
        this._armature = armatureDisplay._armature;
        this._armatureNode = armatureDisplay.node;
        this._armatureDisplay = armatureDisplay;
      },
      reset: function reset() {
        this._inited = false;
        this._armature = null;
        this._armatureNode = null;
        this._armatureDisplay = null;
      },
      _prepareAttachNode: function _prepareAttachNode() {
        var armature = this._armature;
        if (!armature) return;
        var rootNode = this._armatureNode.getChildByName(ATTACHED_ROOT_NAME);
        if (!rootNode || !rootNode.isValid) {
          rootNode = new cc.Node(ATTACHED_ROOT_NAME);
          limitNode(rootNode);
          this._armatureNode.addChild(rootNode);
        }
        var isCached = this._armatureDisplay.isAnimationCached();
        isCached && this._armatureDisplay._frameCache && this._armatureDisplay._frameCache.enableCacheAttachedInfo();
        this._attachedRootNode = rootNode;
        return rootNode;
      },
      _buildBoneAttachedNode: function _buildBoneAttachedNode(bone, boneIndex) {
        var boneNodeName = ATTACHED_PRE_NAME + bone.name;
        var boneNode = new cc.Node(boneNodeName);
        this._buildBoneRelation(boneNode, bone, boneIndex);
        return boneNode;
      },
      _buildBoneRelation: function _buildBoneRelation(boneNode, bone, boneIndex) {
        limitNode(boneNode);
        boneNode._bone = bone;
        boneNode._boneIndex = boneIndex;
        this._attachedNodeArray.push(boneNode);
        this._boneIndexToNode[boneIndex] = boneNode;
      },
      getAttachedRootNode: function getAttachedRootNode() {
        return this._attachedRootNode;
      },
      getAttachedNodes: function getAttachedNodes(boneName) {
        var nodeArray = this._attachedNodeArray;
        var res = [];
        if (!this._inited) return res;
        for (var i = 0, n = nodeArray.length; i < n; i++) {
          var boneNode = nodeArray[i];
          if (!boneNode || !boneNode.isValid) continue;
          boneNode.name === ATTACHED_PRE_NAME + boneName && res.push(boneNode);
        }
        return res;
      },
      _rebuildNodeArray: function _rebuildNodeArray() {
        var findMap = this._boneIndexToNode = {};
        var oldNodeArray = this._attachedNodeArray;
        var nodeArray = this._attachedNodeArray = [];
        for (var i = 0, n = oldNodeArray.length; i < n; i++) {
          var boneNode = oldNodeArray[i];
          if (!boneNode || !boneNode.isValid || boneNode._toRemove) continue;
          nodeArray.push(boneNode);
          findMap[boneNode._boneIndex] = boneNode;
        }
      },
      _sortNodeArray: function _sortNodeArray() {
        var nodeArray = this._attachedNodeArray;
        nodeArray.sort((function(a, b) {
          return a._boneIndex < b._boneIndex ? -1 : 1;
        }));
      },
      _getNodeByBoneIndex: function _getNodeByBoneIndex(boneIndex) {
        var findMap = this._boneIndexToNode;
        var boneNode = findMap[boneIndex];
        if (!boneNode || !boneNode.isValid) return null;
        return boneNode;
      },
      destroyAttachedNodes: function destroyAttachedNodes(boneName) {
        if (!this._inited) return;
        var nodeArray = this._attachedNodeArray;
        var markTree = function markTree(rootNode) {
          var children = rootNode.children;
          for (var i = 0, n = children.length; i < n; i++) {
            var c = children[i];
            c && markTree(c);
          }
          rootNode._toRemove = true;
        };
        for (var i = 0, n = nodeArray.length; i < n; i++) {
          var boneNode = nodeArray[i];
          if (!boneNode || !boneNode.isValid) continue;
          var delName = boneNode.name.split(ATTACHED_PRE_NAME)[1];
          if (delName === boneName) {
            markTree(boneNode);
            boneNode.removeFromParent(true);
            boneNode.destroy();
            nodeArray[i] = null;
          }
        }
        this._rebuildNodeArray();
      },
      generateAttachedNodes: function generateAttachedNodes(boneName) {
        var targetNodes = [];
        if (!this._inited) return targetNodes;
        var rootNode = this._prepareAttachNode();
        if (!rootNode) return targetNodes;
        var boneIndex = 0;
        var res = [];
        var attachedTraverse = function(armature) {
          if (!armature) return;
          var bones = armature.getBones(), bone;
          for (var i = 0, l = bones.length; i < l; i++) {
            bone = bones[i];
            bone._boneIndex = boneIndex++;
            boneName === bone.name && res.push(bone);
          }
          var slots = armature.getSlots(), slot;
          for (var _i = 0, _l = slots.length; _i < _l; _i++) {
            slot = slots[_i];
            slot.childArmature && attachedTraverse(slot.childArmature);
          }
        }.bind(this);
        attachedTraverse(this._armature);
        var buildBoneTree = function(bone) {
          if (!bone) return;
          var boneNode = this._getNodeByBoneIndex(bone._boneIndex);
          if (boneNode) return boneNode;
          boneNode = this._buildBoneAttachedNode(bone, bone._boneIndex);
          var subArmatureParentBone = null;
          if (bone.armature.parent) {
            var parentSlot = bone.armature.parent;
            subArmatureParentBone = parentSlot.parent;
          }
          var parentBoneNode = buildBoneTree(bone.parent || subArmatureParentBone) || rootNode;
          boneNode.parent = parentBoneNode;
          bone.parent ? boneNode._rootNode = parentBoneNode._rootNode : boneNode._rootNode = parentBoneNode;
          return boneNode;
        }.bind(this);
        for (var i = 0, n = res.length; i < n; i++) {
          var targetNode = buildBoneTree(res[i]);
          targetNode && targetNodes.push(targetNode);
        }
        this._sortNodeArray();
        return targetNodes;
      },
      destroyAllAttachedNodes: function destroyAllAttachedNodes() {
        this._attachedRootNode = null;
        this._attachedNodeArray.length = 0;
        this._boneIndexToNode = {};
        if (!this._inited) return;
        var rootNode = this._armatureNode.getChildByName(ATTACHED_ROOT_NAME);
        if (rootNode) {
          rootNode.removeFromParent(true);
          rootNode.destroy();
          rootNode = null;
        }
      },
      generateAllAttachedNodes: function generateAllAttachedNodes() {
        if (!this._inited) return;
        this._boneIndexToNode = {};
        this._attachedNodeArray.length = 0;
        var rootNode = this._prepareAttachNode();
        if (!rootNode) return;
        var boneIndex = 0;
        var attachedTraverse = function(armature) {
          if (!armature) return;
          var subArmatureParentNode = rootNode;
          if (armature.parent) {
            var parentSlot = armature.parent;
            var parentBone = parentSlot.parent;
            subArmatureParentNode = parentBone._attachedNode;
          }
          var bones = armature.getBones(), bone;
          for (var i = 0, l = bones.length; i < l; i++) {
            var curBoneIndex = boneIndex++;
            bone = bones[i];
            bone._attachedNode = null;
            var parentNode = null;
            parentNode = bone.parent ? bone.parent._attachedNode : subArmatureParentNode;
            if (parentNode) {
              var boneNode = parentNode.getChildByName(ATTACHED_PRE_NAME + bone.name);
              if (boneNode && boneNode.isValid) this._buildBoneRelation(boneNode, bone, curBoneIndex); else {
                boneNode = this._buildBoneAttachedNode(bone, curBoneIndex);
                parentNode.addChild(boneNode);
              }
              boneNode._rootNode = subArmatureParentNode;
              bone._attachedNode = boneNode;
            }
          }
          var slots = armature.getSlots(), slot;
          for (var _i2 = 0, _l2 = slots.length; _i2 < _l2; _i2++) {
            slot = slots[_i2];
            slot.childArmature && attachedTraverse(slot.childArmature);
          }
        }.bind(this);
        attachedTraverse(this._armature);
        return rootNode;
      },
      _hasAttachedNode: function _hasAttachedNode() {
        if (!this._inited) return false;
        var attachedRootNode = this._armatureNode.getChildByName(ATTACHED_ROOT_NAME);
        return !!attachedRootNode;
      },
      _associateAttachedNode: function _associateAttachedNode() {
        if (!this._inited) return;
        var rootNode = this._armatureNode.getChildByName(ATTACHED_ROOT_NAME);
        if (!rootNode || !rootNode.isValid) return;
        this._attachedRootNode = rootNode;
        this._boneIndexToNode = {};
        var nodeArray = this._attachedNodeArray;
        nodeArray.length = 0;
        var armature = this._armature;
        if (!armature) return;
        limitNode(rootNode);
        var isCached;
        false;
        var boneIndex = 0;
        var attachedTraverse = function(armature) {
          if (!armature) return;
          var subArmatureParentNode = rootNode;
          if (armature.parent) {
            var parentSlot = armature.parent;
            var parentBone = parentSlot.parent;
            subArmatureParentNode = parentBone._attachedNode;
          }
          var bones = armature.getBones(), bone;
          for (var i = 0, l = bones.length; i < l; i++) {
            var curBoneIndex = boneIndex++;
            bone = bones[i];
            bone._attachedNode = null;
            var parentNode = null;
            parentNode = bone.parent ? bone.parent._attachedNode : subArmatureParentNode;
            if (parentNode) {
              var boneNode = parentNode.getChildByName(ATTACHED_PRE_NAME + bone.name);
              if (boneNode && boneNode.isValid) {
                this._buildBoneRelation(boneNode, bone, curBoneIndex);
                boneNode._rootNode = subArmatureParentNode;
                bone._attachedNode = boneNode;
              }
            }
          }
          var slots = armature.getSlots(), slot;
          for (var _i3 = 0, _l3 = slots.length; _i3 < _l3; _i3++) {
            slot = slots[_i3];
            slot.childArmature && attachedTraverse(slot.childArmature);
          }
        }.bind(this);
        attachedTraverse(armature);
      },
      _syncAttachedNode: function _syncAttachedNode() {
        if (!this._inited) return;
        var rootNode = this._attachedRootNode;
        var nodeArray = this._attachedNodeArray;
        if (!rootNode || !rootNode.isValid) {
          this._attachedRootNode = null;
          nodeArray.length = 0;
          return;
        }
        var rootMatrix = this._armatureNode._worldMatrix;
        _mat["default"].copy(rootNode._worldMatrix, rootMatrix);
        rootNode._renderFlag &= ~FLAG_TRANSFORM;
        var boneInfos = null;
        var isCached = this._armatureDisplay.isAnimationCached();
        if (isCached) {
          boneInfos = this._armatureDisplay._curFrame && this._armatureDisplay._curFrame.boneInfos;
          if (!boneInfos) return;
        }
        var mulMat = this._armatureNode._mulMat;
        var matrixHandle = function matrixHandle(nodeMat, parentMat, boneMat) {
          var tm = _tempMat4.m;
          tm[0] = boneMat.a;
          tm[1] = boneMat.b;
          tm[4] = -boneMat.c;
          tm[5] = -boneMat.d;
          tm[12] = boneMat.tx;
          tm[13] = boneMat.ty;
          mulMat(nodeMat, parentMat, _tempMat4);
        };
        var nodeArrayDirty = false;
        for (var i = 0, n = nodeArray.length; i < n; i++) {
          var boneNode = nodeArray[i];
          if (!boneNode || !boneNode.isValid) {
            nodeArray[i] = null;
            nodeArrayDirty = true;
            continue;
          }
          var bone = isCached ? boneInfos[boneNode._boneIndex] : boneNode._bone;
          if (!bone || bone._isInPool) {
            boneNode.removeFromParent(true);
            boneNode.destroy();
            nodeArray[i] = null;
            nodeArrayDirty = true;
            continue;
          }
          matrixHandle(boneNode._worldMatrix, boneNode._rootNode._worldMatrix, bone.globalTransformMatrix);
          boneNode._renderFlag &= ~FLAG_TRANSFORM;
        }
        nodeArrayDirty && this._rebuildNodeArray();
      }
    });
    module.exports = dragonBones.AttachUtil = AttachUtil;
  }), {
    "../../cocos2d/core/renderer/render-flow": 323,
    "../../cocos2d/core/value-types/mat4": 403
  } ],
  451: [ (function(require, module, exports) {
    "use strict";
    var ArmatureCache = false;
    var DragonBonesAsset = cc.Class({
      name: "dragonBones.DragonBonesAsset",
      extends: cc.Asset,
      ctor: function ctor() {
        this.reset();
      },
      properties: {
        _dragonBonesJson: "",
        dragonBonesJson: {
          get: function get() {
            return this._dragonBonesJson;
          },
          set: function set(value) {
            this._dragonBonesJson = value;
            this._dragonBonesJsonData = JSON.parse(value);
            this.reset();
          }
        },
        _nativeAsset: {
          get: function get() {
            return this._buffer;
          },
          set: function set(bin) {
            this._buffer = bin.buffer || bin;
            this.reset();
          },
          override: true
        }
      },
      statics: {
        preventDeferredLoadDependents: true
      },
      createNode: false,
      reset: function reset() {
        this._clear();
        false;
      },
      init: function init(factory, atlasUUID) {
        false;
        this._factory = factory;
        !this._dragonBonesJsonData && this.dragonBonesJson && (this._dragonBonesJsonData = JSON.parse(this.dragonBonesJson));
        var rawData = null;
        rawData = this._dragonBonesJsonData ? this._dragonBonesJsonData : this._nativeAsset;
        if (!this._uuid) {
          var dbData = this._factory.getDragonBonesDataByRawData(rawData);
          dbData ? this._uuid = dbData.name : cc.warn("dragonbones name is empty");
        }
        var armatureKey = this._uuid + "#" + atlasUUID;
        var dragonBonesData = this._factory.getDragonBonesData(armatureKey);
        if (dragonBonesData) return armatureKey;
        this._factory.parseDragonBonesData(rawData, armatureKey);
        return armatureKey;
      },
      getArmatureEnum: false,
      getAnimsEnum: false,
      _clear: function _clear() {
        if (this._factory) {
          ArmatureCache.resetArmature(this._uuid);
          this._factory.removeDragonBonesDataByUUID(this._uuid, true);
        }
      },
      destroy: function destroy() {
        this._clear();
        this._super();
      }
    });
    dragonBones.DragonBonesAsset = module.exports = DragonBonesAsset;
  }), {
    "./ArmatureCache": void 0
  } ],
  452: [ (function(require, module, exports) {
    "use strict";
    var ArmatureCache = false;
    var DragonBonesAtlasAsset = cc.Class({
      name: "dragonBones.DragonBonesAtlasAsset",
      extends: cc.Asset,
      ctor: function ctor() {
        this._clear();
      },
      properties: {
        _atlasJson: "",
        atlasJson: {
          get: function get() {
            return this._atlasJson;
          },
          set: function set(value) {
            this._atlasJson = value;
            this._atlasJsonData = JSON.parse(this.atlasJson);
            this._clear();
          }
        },
        _texture: {
          default: null,
          type: cc.Texture2D,
          formerlySerializedAs: "texture"
        },
        texture: {
          get: function get() {
            return this._texture;
          },
          set: function set(value) {
            this._texture = value;
            this._clear();
          }
        },
        _textureAtlasData: null
      },
      statics: {
        preventDeferredLoadDependents: true
      },
      createNode: false,
      init: function init(factory) {
        this._factory = factory;
        this._atlasJsonData || (this._atlasJsonData = JSON.parse(this.atlasJson));
        var atlasJsonObj = this._atlasJsonData;
        this._uuid = this._uuid || atlasJsonObj.name;
        this._textureAtlasData ? factory.addTextureAtlasData(this._textureAtlasData, this._uuid) : this._textureAtlasData = factory.parseTextureAtlasData(atlasJsonObj, this.texture, this._uuid);
      },
      _clear: function _clear() {
        true;
        return;
      },
      destroy: function destroy() {
        this._clear();
        this._super();
      }
    });
    dragonBones.DragonBonesAtlasAsset = module.exports = DragonBonesAtlasAsset;
  }), {
    "./ArmatureCache": void 0
  } ],
  453: [ (function(require, module, exports) {
    "use strict";
    var _global = "undefined" === typeof window ? global : window;
    false;
    if (void 0 !== _global.dragonBones) {
      dragonBones._timeScale = 1;
      Object.defineProperty(dragonBones, "timeScale", {
        get: function get() {
          return this._timeScale;
        },
        set: function set(value) {
          this._timeScale = value;
          var factory = this.CCFactory.getInstance();
          factory._dragonBones.clock.timeScale = value;
        },
        configurable: true
      });
      dragonBones.DisplayType = {
        Image: 0,
        Armature: 1,
        Mesh: 2
      };
      dragonBones.ArmatureType = {
        Armature: 0,
        MovieClip: 1,
        Stage: 2
      };
      dragonBones.ExtensionType = {
        FFD: 0,
        AdjustColor: 10,
        BevelFilter: 11,
        BlurFilter: 12,
        DropShadowFilter: 13,
        GlowFilter: 14,
        GradientBevelFilter: 15,
        GradientGlowFilter: 16
      };
      dragonBones.EventType = {
        Frame: 0,
        Sound: 1
      };
      dragonBones.ActionType = {
        Play: 0,
        Stop: 1,
        GotoAndPlay: 2,
        GotoAndStop: 3,
        FadeIn: 4,
        FadeOut: 5
      };
      dragonBones.AnimationFadeOutMode = {
        None: 0,
        SameLayer: 1,
        SameGroup: 2,
        SameLayerAndGroup: 3,
        All: 4
      };
      dragonBones.BinaryOffset = {
        WeigthBoneCount: 0,
        WeigthFloatOffset: 1,
        WeigthBoneIndices: 2,
        MeshVertexCount: 0,
        MeshTriangleCount: 1,
        MeshFloatOffset: 2,
        MeshWeightOffset: 3,
        MeshVertexIndices: 4,
        TimelineScale: 0,
        TimelineOffset: 1,
        TimelineKeyFrameCount: 2,
        TimelineFrameValueCount: 3,
        TimelineFrameValueOffset: 4,
        TimelineFrameOffset: 5,
        FramePosition: 0,
        FrameTweenType: 1,
        FrameTweenEasingOrCurveSampleCount: 2,
        FrameCurveSamples: 3,
        DeformMeshOffset: 0,
        DeformCount: 1,
        DeformValueCount: 2,
        DeformValueOffset: 3,
        DeformFloatOffset: 4
      };
      dragonBones.BoneType = {
        Bone: 0,
        Surface: 1
      };
      true;
      false;
      require("./DragonBonesAsset");
      require("./DragonBonesAtlasAsset");
      require("./ArmatureDisplay");
      require("./webgl-assembler");
    }
  }), {
    "./ArmatureCache": void 0,
    "./ArmatureDisplay": 449,
    "./CCArmatureDisplay": void 0,
    "./CCFactory": void 0,
    "./CCSlot": void 0,
    "./CCTextureData": void 0,
    "./DragonBonesAsset": 451,
    "./DragonBonesAtlasAsset": 452,
    "./lib/dragonBones": void 0,
    "./webgl-assembler": 454
  } ],
  454: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler = _interopRequireDefault(require("../../cocos2d/core/renderer/assembler"));
    var _mat = _interopRequireDefault(require("../../cocos2d/core/value-types/mat4"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Armature = require("./ArmatureDisplay");
    var RenderFlow = require("../../cocos2d/core/renderer/render-flow");
    var gfx = cc.gfx;
    var NEED_COLOR = 1;
    var NEED_BATCH = 16;
    var _boneColor = cc.color(255, 0, 0, 255);
    var _slotColor = cc.color(0, 0, 255, 255);
    var _originColor = cc.color(0, 255, 0, 255);
    var _nodeR, _nodeG, _nodeB, _nodeA, _premultipliedAlpha, _multiply, _mustFlush, _buffer, _node, _renderer, _comp, _vfOffset, _indexOffset, _vertexOffset, _vertexCount, _indexCount, _x, _y, _c, _r, _g, _b, _a, _handleVal, _m00, _m04, _m12, _m01, _m05, _m13;
    function _getSlotMaterial(tex, blendMode) {
      if (!tex) return null;
      var src, dst;
      switch (blendMode) {
       case 1:
        src = _premultipliedAlpha ? cc.macro.ONE : cc.macro.SRC_ALPHA;
        dst = cc.macro.ONE;
        break;

       case 10:
        src = cc.macro.DST_COLOR;
        dst = cc.macro.ONE_MINUS_SRC_ALPHA;
        break;

       case 12:
        src = cc.macro.ONE;
        dst = cc.macro.ONE_MINUS_SRC_COLOR;
        break;

       case 0:
       default:
        src = _premultipliedAlpha ? cc.macro.ONE : cc.macro.SRC_ALPHA;
        dst = cc.macro.ONE_MINUS_SRC_ALPHA;
      }
      var useModel = !_comp.enableBatch;
      var baseMaterial = _comp._materials[0];
      if (!baseMaterial) return null;
      var materialCache = _comp._materialCache;
      var key = tex.getId() + src + dst + useModel;
      var material = materialCache[key];
      if (!material) {
        if (materialCache.baseMaterial) material = cc.MaterialVariant.create(baseMaterial); else {
          material = baseMaterial;
          materialCache.baseMaterial = baseMaterial;
        }
        material.define("CC_USE_MODEL", useModel);
        material.setProperty("texture", tex);
        material.setBlend(true, gfx.BLEND_FUNC_ADD, src, dst, gfx.BLEND_FUNC_ADD, src, dst);
        materialCache[key] = material;
      }
      return material;
    }
    function _handleColor(color, parentOpacity) {
      _a = color.a * parentOpacity * _nodeA;
      _multiply = _premultipliedAlpha ? _a / 255 : 1;
      _r = color.r * _nodeR * _multiply;
      _g = color.g * _nodeG * _multiply;
      _b = color.b * _nodeB * _multiply;
      _c = (_a << 24 >>> 0) + (_b << 16) + (_g << 8) + _r;
    }
    var ArmatureAssembler = (function(_Assembler) {
      _inheritsLoose(ArmatureAssembler, _Assembler);
      function ArmatureAssembler() {
        return _Assembler.apply(this, arguments) || this;
      }
      var _proto = ArmatureAssembler.prototype;
      _proto.updateRenderData = function updateRenderData(comp, batchData) {};
      _proto.realTimeTraverse = function realTimeTraverse(armature, parentMat, parentOpacity) {
        var slots = armature._slots;
        var vbuf, ibuf, uintbuf;
        var material;
        var vertices, indices;
        var slotColor;
        var slot;
        var slotMat;
        var slotMatm;
        var offsetInfo;
        for (var i = 0, l = slots.length; i < l; i++) {
          slot = slots[i];
          slotColor = slot._color;
          if (!slot._visible || !slot._displayData) continue;
          parentMat ? slot._mulMat(slot._worldMatrix, parentMat, slot._matrix) : _mat["default"].copy(slot._worldMatrix, slot._matrix);
          if (slot.childArmature) {
            this.realTimeTraverse(slot.childArmature, slot._worldMatrix, parentOpacity * slotColor.a / 255);
            continue;
          }
          material = _getSlotMaterial(slot.getTexture(), slot._blendMode);
          if (!material) continue;
          if (_mustFlush || material.getHash() !== _renderer.material.getHash()) {
            _mustFlush = false;
            _renderer._flush();
            _renderer.node = _node;
            _renderer.material = material;
          }
          _handleColor(slotColor, parentOpacity);
          slotMat = slot._worldMatrix;
          slotMatm = slotMat.m;
          vertices = slot._localVertices;
          _vertexCount = vertices.length >> 2;
          indices = slot._indices;
          _indexCount = indices.length;
          offsetInfo = _buffer.request(_vertexCount, _indexCount);
          _indexOffset = offsetInfo.indiceOffset;
          _vfOffset = offsetInfo.byteOffset >> 2;
          _vertexOffset = offsetInfo.vertexOffset;
          vbuf = _buffer._vData;
          ibuf = _buffer._iData;
          uintbuf = _buffer._uintVData;
          _m00 = slotMatm[0];
          _m04 = slotMatm[4];
          _m12 = slotMatm[12];
          _m01 = slotMatm[1];
          _m05 = slotMatm[5];
          _m13 = slotMatm[13];
          for (var vi = 0, vl = vertices.length; vi < vl; ) {
            _x = vertices[vi++];
            _y = vertices[vi++];
            vbuf[_vfOffset++] = _x * _m00 + _y * _m04 + _m12;
            vbuf[_vfOffset++] = _x * _m01 + _y * _m05 + _m13;
            vbuf[_vfOffset++] = vertices[vi++];
            vbuf[_vfOffset++] = vertices[vi++];
            uintbuf[_vfOffset++] = _c;
          }
          for (var ii = 0, il = indices.length; ii < il; ii++) ibuf[_indexOffset++] = _vertexOffset + indices[ii];
        }
      };
      _proto.cacheTraverse = function cacheTraverse(frame, parentMat) {
        if (!frame) return;
        var segments = frame.segments;
        if (0 == segments.length) return;
        var vbuf, ibuf, uintbuf;
        var material;
        var offsetInfo;
        var vertices = frame.vertices;
        var indices = frame.indices;
        var frameVFOffset = 0, frameIndexOffset = 0, segVFCount = 0;
        if (parentMat) {
          var parentMatm = parentMat.m;
          _m00 = parentMatm[0];
          _m01 = parentMatm[1];
          _m04 = parentMatm[4];
          _m05 = parentMatm[5];
          _m12 = parentMatm[12];
          _m13 = parentMatm[13];
        }
        var justTranslate = 1 === _m00 && 0 === _m01 && 0 === _m04 && 1 === _m05;
        var needBatch = _handleVal & NEED_BATCH;
        var calcTranslate = needBatch && justTranslate;
        var colorOffset = 0;
        var colors = frame.colors;
        var nowColor = colors[colorOffset++];
        var maxVFOffset = nowColor.vfOffset;
        _handleColor(nowColor, 1);
        for (var i = 0, n = segments.length; i < n; i++) {
          var segInfo = segments[i];
          material = _getSlotMaterial(segInfo.tex, segInfo.blendMode);
          if (_mustFlush || material.getHash() !== _renderer.material.getHash()) {
            _mustFlush = false;
            _renderer._flush();
            _renderer.node = _node;
            _renderer.material = material;
          }
          _vertexCount = segInfo.vertexCount;
          _indexCount = segInfo.indexCount;
          offsetInfo = _buffer.request(_vertexCount, _indexCount);
          _indexOffset = offsetInfo.indiceOffset;
          _vertexOffset = offsetInfo.vertexOffset;
          _vfOffset = offsetInfo.byteOffset >> 2;
          vbuf = _buffer._vData;
          ibuf = _buffer._iData;
          uintbuf = _buffer._uintVData;
          for (var ii = _indexOffset, il = _indexOffset + _indexCount; ii < il; ii++) ibuf[ii] = _vertexOffset + indices[frameIndexOffset++];
          segVFCount = segInfo.vfCount;
          vbuf.set(vertices.subarray(frameVFOffset, frameVFOffset + segVFCount), _vfOffset);
          frameVFOffset += segVFCount;
          if (calcTranslate) for (var _ii = _vfOffset, _il = _vfOffset + segVFCount; _ii < _il; _ii += 5) {
            vbuf[_ii] += _m12;
            vbuf[_ii + 1] += _m13;
          } else if (needBatch) for (var _ii2 = _vfOffset, _il2 = _vfOffset + segVFCount; _ii2 < _il2; _ii2 += 5) {
            _x = vbuf[_ii2];
            _y = vbuf[_ii2 + 1];
            vbuf[_ii2] = _x * _m00 + _y * _m04 + _m12;
            vbuf[_ii2 + 1] = _x * _m01 + _y * _m05 + _m13;
          }
          if (!(_handleVal & NEED_COLOR)) continue;
          var frameColorOffset = frameVFOffset - segVFCount;
          for (var _ii3 = _vfOffset + 4, _il3 = _vfOffset + 4 + segVFCount; _ii3 < _il3; _ii3 += 5, 
          frameColorOffset += 5) {
            if (frameColorOffset >= maxVFOffset) {
              nowColor = colors[colorOffset++];
              _handleColor(nowColor, 1);
              maxVFOffset = nowColor.vfOffset;
            }
            uintbuf[_ii3] = _c;
          }
        }
      };
      _proto.fillBuffers = function fillBuffers(comp, renderer) {
        comp.node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
        var armature = comp._armature;
        if (!armature) return;
        _mustFlush = true;
        _premultipliedAlpha = comp.premultipliedAlpha;
        _node = comp.node;
        _buffer = renderer._meshBuffer;
        _renderer = renderer;
        _comp = comp;
        _handleVal = 0;
        var nodeColor = _node._color;
        _nodeR = nodeColor.r / 255;
        _nodeG = nodeColor.g / 255;
        _nodeB = nodeColor.b / 255;
        _nodeA = nodeColor.a / 255;
        4294967295 !== nodeColor._val && (_handleVal |= NEED_COLOR);
        var worldMat = void 0;
        if (_comp.enableBatch) {
          worldMat = _node._worldMatrix;
          _mustFlush = false;
          _handleVal |= NEED_BATCH;
        }
        if (comp.isAnimationCached()) this.cacheTraverse(comp._curFrame, worldMat); else {
          this.realTimeTraverse(armature, worldMat, 1);
          var graphics = comp._debugDraw;
          if (comp.debugBones && graphics) {
            graphics.clear();
            graphics.lineWidth = 5;
            graphics.strokeColor = _boneColor;
            graphics.fillColor = _slotColor;
            var bones = armature.getBones();
            for (var i = 0, l = bones.length; i < l; i++) {
              var bone = bones[i];
              var boneLength = Math.max(bone.boneData.length, 5);
              var startX = bone.globalTransformMatrix.tx;
              var startY = bone.globalTransformMatrix.ty;
              var endX = startX + bone.globalTransformMatrix.a * boneLength;
              var endY = startY + bone.globalTransformMatrix.b * boneLength;
              graphics.moveTo(startX, startY);
              graphics.lineTo(endX, endY);
              graphics.stroke();
              graphics.circle(startX, startY, 2 * Math.PI);
              graphics.fill();
              0 === i && (graphics.fillColor = _originColor);
            }
          }
        }
        renderer.worldMatDirty++;
        comp.attachUtil._syncAttachedNode();
        _node = void 0;
        _buffer = void 0;
        _renderer = void 0;
        _comp = void 0;
      };
      _proto.postFillBuffers = function postFillBuffers(comp, renderer) {
        renderer.worldMatDirty--;
      };
      return ArmatureAssembler;
    })(_assembler["default"]);
    exports["default"] = ArmatureAssembler;
    _assembler["default"].register(Armature, ArmatureAssembler);
    module.exports = exports["default"];
  }), {
    "../../cocos2d/core/renderer/assembler": 302,
    "../../cocos2d/core/renderer/render-flow": 323,
    "../../cocos2d/core/value-types/mat4": 403,
    "./ArmatureDisplay": 449
  } ],
  455: [ (function(require, module, exports) {
    "use strict";
    var _mat = _interopRequireDefault(require("../../cocos2d/core/value-types/mat4"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var RenderFlow = require("../../cocos2d/core/renderer/render-flow");
    var FLAG_TRANSFORM = RenderFlow.FLAG_TRANSFORM;
    var EmptyHandle = function EmptyHandle() {};
    var ATTACHED_ROOT_NAME = "ATTACHED_NODE_TREE";
    var ATTACHED_PRE_NAME = "ATTACHED_NODE:";
    var limitNode = function limitNode(node) {
      Object.defineProperty(node, "_worldMatDirty", {
        get: function get() {
          return true;
        },
        set: function set(value) {}
      });
      node._calculWorldMatrix = EmptyHandle;
      node._mulMat = EmptyHandle;
    };
    var _tempMat4 = new _mat["default"]();
    var AttachUtil = cc.Class({
      name: "sp.AttachUtil",
      ctor: function ctor() {
        this._inited = false;
        this._skeleton = null;
        this._skeletonNode = null;
        this._skeletonComp = null;
        this._attachedRootNode = null;
        this._attachedNodeArray = [];
        this._boneIndexToNode = {};
      },
      init: function init(skeletonComp) {
        this._inited = true;
        this._skeleton = skeletonComp._skeleton;
        this._skeletonNode = skeletonComp.node;
        this._skeletonComp = skeletonComp;
      },
      reset: function reset() {
        this._inited = false;
        this._skeleton = null;
        this._skeletonNode = null;
        this._skeletonComp = null;
      },
      _prepareAttachNode: function _prepareAttachNode() {
        var armature = this._skeleton;
        if (!armature) return;
        var rootNode = this._skeletonNode.getChildByName(ATTACHED_ROOT_NAME);
        if (!rootNode || !rootNode.isValid) {
          rootNode = new cc.Node(ATTACHED_ROOT_NAME);
          limitNode(rootNode);
          this._skeletonNode.addChild(rootNode);
        }
        var isCached = this._skeletonComp.isAnimationCached();
        isCached && this._skeletonComp._frameCache && this._skeletonComp._frameCache.enableCacheAttachedInfo();
        this._attachedRootNode = rootNode;
        return rootNode;
      },
      _buildBoneAttachedNode: function _buildBoneAttachedNode(bone, boneIndex) {
        var boneNodeName = ATTACHED_PRE_NAME + bone.data.name;
        var boneNode = new cc.Node(boneNodeName);
        this._buildBoneRelation(boneNode, bone, boneIndex);
        return boneNode;
      },
      _buildBoneRelation: function _buildBoneRelation(boneNode, bone, boneIndex) {
        limitNode(boneNode);
        boneNode._bone = bone;
        boneNode._boneIndex = boneIndex;
        this._attachedNodeArray.push(boneNode);
        this._boneIndexToNode[boneIndex] = boneNode;
      },
      getAttachedRootNode: function getAttachedRootNode() {
        return this._attachedRootNode;
      },
      getAttachedNodes: function getAttachedNodes(boneName) {
        var nodeArray = this._attachedNodeArray;
        var res = [];
        if (!this._inited) return res;
        for (var i = 0, n = nodeArray.length; i < n; i++) {
          var boneNode = nodeArray[i];
          if (!boneNode || !boneNode.isValid) continue;
          boneNode.name === ATTACHED_PRE_NAME + boneName && res.push(boneNode);
        }
        return res;
      },
      _rebuildNodeArray: function _rebuildNodeArray() {
        var findMap = this._boneIndexToNode = {};
        var oldNodeArray = this._attachedNodeArray;
        var nodeArray = this._attachedNodeArray = [];
        for (var i = 0, n = oldNodeArray.length; i < n; i++) {
          var boneNode = oldNodeArray[i];
          if (!boneNode || !boneNode.isValid || boneNode._toRemove) continue;
          nodeArray.push(boneNode);
          findMap[boneNode._boneIndex] = boneNode;
        }
      },
      _sortNodeArray: function _sortNodeArray() {
        var nodeArray = this._attachedNodeArray;
        nodeArray.sort((function(a, b) {
          return a._boneIndex < b._boneIndex ? -1 : 1;
        }));
      },
      _getNodeByBoneIndex: function _getNodeByBoneIndex(boneIndex) {
        var findMap = this._boneIndexToNode;
        var boneNode = findMap[boneIndex];
        if (!boneNode || !boneNode.isValid) return null;
        return boneNode;
      },
      destroyAttachedNodes: function destroyAttachedNodes(boneName) {
        if (!this._inited) return;
        var nodeArray = this._attachedNodeArray;
        var markTree = function markTree(rootNode) {
          var children = rootNode.children;
          for (var i = 0, n = children.length; i < n; i++) {
            var c = children[i];
            c && markTree(c);
          }
          rootNode._toRemove = true;
        };
        for (var i = 0, n = nodeArray.length; i < n; i++) {
          var boneNode = nodeArray[i];
          if (!boneNode || !boneNode.isValid) continue;
          var delName = boneNode.name.split(ATTACHED_PRE_NAME)[1];
          if (delName === boneName) {
            markTree(boneNode);
            boneNode.removeFromParent(true);
            boneNode.destroy();
            nodeArray[i] = null;
          }
        }
        this._rebuildNodeArray();
      },
      generateAttachedNodes: function generateAttachedNodes(boneName) {
        var targetNodes = [];
        if (!this._inited) return targetNodes;
        var rootNode = this._prepareAttachNode();
        if (!rootNode) return targetNodes;
        var res = [];
        var bones = this._skeleton.bones;
        for (var i = 0, n = bones.length; i < n; i++) {
          var bone = bones[i];
          var boneData = bone.data;
          boneData.name == boneName && res.push(bone);
        }
        var buildBoneTree = function(bone) {
          if (!bone) return;
          var boneData = bone.data;
          var boneNode = this._getNodeByBoneIndex(boneData.index);
          if (boneNode) return boneNode;
          boneNode = this._buildBoneAttachedNode(bone, boneData.index);
          var parentBoneNode = buildBoneTree(bone.parent) || rootNode;
          boneNode.parent = parentBoneNode;
          return boneNode;
        }.bind(this);
        for (var _i = 0, _n = res.length; _i < _n; _i++) {
          var targetNode = buildBoneTree(res[_i]);
          targetNodes.push(targetNode);
        }
        this._sortNodeArray();
        return targetNodes;
      },
      destroyAllAttachedNodes: function destroyAllAttachedNodes() {
        this._attachedRootNode = null;
        this._attachedNodeArray.length = 0;
        this._boneIndexToNode = {};
        if (!this._inited) return;
        var rootNode = this._skeletonNode.getChildByName(ATTACHED_ROOT_NAME);
        if (rootNode) {
          rootNode.removeFromParent(true);
          rootNode.destroy();
          rootNode = null;
        }
      },
      generateAllAttachedNodes: function generateAllAttachedNodes() {
        if (!this._inited) return;
        this._boneIndexToNode = {};
        this._attachedNodeArray.length = 0;
        var rootNode = this._prepareAttachNode();
        if (!rootNode) return;
        var bones = this._skeleton.bones;
        for (var i = 0, n = bones.length; i < n; i++) {
          var bone = bones[i];
          var boneData = bone.data;
          var parentNode = null;
          if (bone.parent) {
            var parentIndex = bone.parent.data.index;
            parentNode = this._boneIndexToNode[parentIndex];
          } else parentNode = rootNode;
          if (parentNode) {
            var boneNode = parentNode.getChildByName(ATTACHED_PRE_NAME + boneData.name);
            if (boneNode && boneNode.isValid) this._buildBoneRelation(boneNode, bone, boneData.index); else {
              boneNode = this._buildBoneAttachedNode(bone, boneData.index);
              parentNode.addChild(boneNode);
            }
          }
        }
        return rootNode;
      },
      _hasAttachedNode: function _hasAttachedNode() {
        if (!this._inited) return false;
        var attachedRootNode = this._skeletonNode.getChildByName(ATTACHED_ROOT_NAME);
        return !!attachedRootNode;
      },
      _associateAttachedNode: function _associateAttachedNode() {
        if (!this._inited) return;
        var rootNode = this._skeletonNode.getChildByName(ATTACHED_ROOT_NAME);
        if (!rootNode || !rootNode.isValid) return;
        this._attachedRootNode = rootNode;
        this._boneIndexToNode = {};
        var nodeArray = this._attachedNodeArray;
        nodeArray.length = 0;
        limitNode(rootNode);
        var isCached;
        false;
        var bones = this._skeleton.bones;
        for (var i = 0, n = bones.length; i < n; i++) {
          var bone = bones[i];
          var boneData = bone.data;
          var parentNode = null;
          if (bone.parent) {
            var parentIndex = bone.parent.data.index;
            parentNode = this._boneIndexToNode[parentIndex];
          } else parentNode = rootNode;
          if (parentNode) {
            var boneNode = parentNode.getChildByName(ATTACHED_PRE_NAME + boneData.name);
            boneNode && boneNode.isValid && this._buildBoneRelation(boneNode, bone, boneData.index);
          }
        }
      },
      _syncAttachedNode: function _syncAttachedNode() {
        if (!this._inited) return;
        var rootNode = this._attachedRootNode;
        var nodeArray = this._attachedNodeArray;
        if (!rootNode || !rootNode.isValid) {
          this._attachedRootNode = null;
          nodeArray.length = 0;
          return;
        }
        var rootMatrix = this._skeletonNode._worldMatrix;
        _mat["default"].copy(rootNode._worldMatrix, rootMatrix);
        rootNode._renderFlag &= ~FLAG_TRANSFORM;
        var boneInfos = null;
        var isCached = this._skeletonComp.isAnimationCached();
        boneInfos = isCached ? this._skeletonComp._curFrame && this._skeletonComp._curFrame.boneInfos : this._skeleton.bones;
        if (!boneInfos) return;
        var mulMat = this._skeletonNode._mulMat;
        var matrixHandle = function matrixHandle(nodeMat, parentMat, bone) {
          var tm = _tempMat4.m;
          tm[0] = bone.a;
          tm[1] = bone.c;
          tm[4] = bone.b;
          tm[5] = bone.d;
          tm[12] = bone.worldX;
          tm[13] = bone.worldY;
          mulMat(nodeMat, parentMat, _tempMat4);
        };
        var nodeArrayDirty = false;
        for (var i = 0, n = nodeArray.length; i < n; i++) {
          var boneNode = nodeArray[i];
          if (!boneNode || !boneNode.isValid) {
            nodeArray[i] = null;
            nodeArrayDirty = true;
            continue;
          }
          var bone = boneInfos[boneNode._boneIndex];
          if (!bone) {
            boneNode.removeFromParent(true);
            boneNode.destroy();
            nodeArray[i] = null;
            nodeArrayDirty = true;
            continue;
          }
          matrixHandle(boneNode._worldMatrix, rootNode._worldMatrix, bone);
          boneNode._renderFlag &= ~FLAG_TRANSFORM;
        }
        nodeArrayDirty && this._rebuildNodeArray();
      }
    });
    module.exports = sp.AttachUtil = AttachUtil;
  }), {
    "../../cocos2d/core/renderer/render-flow": 323,
    "../../cocos2d/core/value-types/mat4": 403
  } ],
  456: [ (function(require, module, exports) {
    "use strict";
    var TrackEntryListeners = require("./track-entry-listeners");
    var RenderComponent = require("../../cocos2d/core/components/CCRenderComponent");
    var spine = require("./lib/spine");
    var Graphics = require("../../cocos2d/core/graphics/graphics");
    var RenderFlow = require("../../cocos2d/core/renderer/render-flow");
    var FLAG_POST_RENDER = RenderFlow.FLAG_POST_RENDER;
    var SkeletonCache = require("./skeleton-cache");
    var AttachUtil = require("./AttachUtil");
    var DefaultSkinsEnum = cc.Enum({
      default: -1
    });
    var DefaultAnimsEnum = cc.Enum({
      "<None>": 0
    });
    var AnimationCacheMode = cc.Enum({
      REALTIME: 0,
      SHARED_CACHE: 1,
      PRIVATE_CACHE: 2
    });
    function setEnumAttr(obj, propName, enumDef) {
      cc.Class.Attr.setClassAttr(obj, propName, "type", "Enum");
      cc.Class.Attr.setClassAttr(obj, propName, "enumList", cc.Enum.getList(enumDef));
    }
    sp.Skeleton = cc.Class({
      name: "sp.Skeleton",
      extends: RenderComponent,
      editor: false,
      statics: {
        AnimationCacheMode: AnimationCacheMode
      },
      properties: {
        paused: {
          default: false,
          visible: false
        },
        skeletonData: {
          default: null,
          type: sp.SkeletonData,
          notify: function notify() {
            false;
            this.defaultSkin = "";
            this.defaultAnimation = "";
            this._updateSkeletonData();
          },
          tooltip: (true, "i18n:COMPONENT.skeleton.skeleton_data")
        },
        defaultSkin: {
          default: "",
          visible: false
        },
        defaultAnimation: {
          default: "",
          visible: false
        },
        animation: {
          get: function get() {
            if (this.isAnimationCached()) return this._animationName;
            var entry = this.getCurrent(0);
            return entry && entry.animation.name || "";
          },
          set: function set(value) {
            this.defaultAnimation = value;
            if (value) this.setAnimation(0, value, this.loop); else if (!this.isAnimationCached()) {
              this.clearTrack(0);
              this.setToSetupPose();
            }
          },
          visible: false
        },
        _defaultSkinIndex: {
          get: function get() {
            if (this.skeletonData) {
              var skinsEnum = this.skeletonData.getSkinsEnum();
              if (skinsEnum) if ("" === this.defaultSkin) {
                if (skinsEnum.hasOwnProperty(0)) {
                  this._defaultSkinIndex = 0;
                  return 0;
                }
              } else {
                var skinIndex = skinsEnum[this.defaultSkin];
                if (void 0 !== skinIndex) return skinIndex;
              }
            }
            return 0;
          },
          set: function set(value) {
            var skinsEnum;
            this.skeletonData && (skinsEnum = this.skeletonData.getSkinsEnum());
            if (!skinsEnum) return cc.errorID("", this.name);
            var skinName = skinsEnum[value];
            if (void 0 !== skinName) {
              this.defaultSkin = skinName;
              this.setSkin(this.defaultSkin);
              false;
            } else cc.errorID(7501, this.name);
          },
          type: DefaultSkinsEnum,
          visible: true,
          animatable: false,
          displayName: "Default Skin",
          tooltip: (true, "i18n:COMPONENT.skeleton.default_skin")
        },
        _animationIndex: {
          get: function get() {
            var animationName = this.animation;
            if (this.skeletonData && animationName) {
              var animsEnum = this.skeletonData.getAnimsEnum();
              if (animsEnum) {
                var animIndex = animsEnum[animationName];
                if (void 0 !== animIndex) return animIndex;
              }
            }
            return 0;
          },
          set: function set(value) {
            if (0 === value) {
              this.animation = "";
              return;
            }
            var animsEnum;
            this.skeletonData && (animsEnum = this.skeletonData.getAnimsEnum());
            if (!animsEnum) return cc.errorID(7502, this.name);
            var animName = animsEnum[value];
            void 0 !== animName ? this.animation = animName : cc.errorID(7503, this.name);
          },
          type: DefaultAnimsEnum,
          visible: true,
          animatable: false,
          displayName: "Animation",
          tooltip: (true, "i18n:COMPONENT.skeleton.animation")
        },
        _preCacheMode: -1,
        _cacheMode: AnimationCacheMode.REALTIME,
        _defaultCacheMode: {
          default: 0,
          type: AnimationCacheMode,
          notify: function notify() {
            this.setAnimationCacheMode(this._defaultCacheMode);
          },
          editorOnly: true,
          visible: true,
          animatable: false,
          displayName: "Animation Cache Mode",
          tooltip: (true, "i18n:COMPONENT.skeleton.animation_cache_mode")
        },
        loop: {
          default: true,
          tooltip: (true, "i18n:COMPONENT.skeleton.loop")
        },
        premultipliedAlpha: {
          default: true,
          tooltip: (true, "i18n:COMPONENT.skeleton.premultipliedAlpha")
        },
        timeScale: {
          default: 1,
          tooltip: (true, "i18n:COMPONENT.skeleton.time_scale")
        },
        debugSlots: {
          default: false,
          editorOnly: true,
          tooltip: (true, "i18n:COMPONENT.skeleton.debug_slots"),
          notify: function notify() {
            this._updateDebugDraw();
          }
        },
        debugBones: {
          default: false,
          editorOnly: true,
          tooltip: (true, "i18n:COMPONENT.skeleton.debug_bones"),
          notify: function notify() {
            this._updateDebugDraw();
          }
        },
        debugMesh: {
          default: false,
          editorOnly: true,
          tooltip: (true, "i18n:COMPONENT.skeleton.debug_mesh"),
          notify: function notify() {
            this._updateDebugDraw();
          }
        },
        useTint: {
          default: false,
          tooltip: (true, "i18n:COMPONENT.skeleton.use_tint"),
          notify: function notify() {
            this._updateUseTint();
          }
        },
        enableBatch: {
          default: false,
          notify: function notify() {
            this._updateBatch();
          },
          tooltip: (true, "i18n:COMPONENT.skeleton.enabled_batch")
        },
        _accTime: 0,
        _playCount: 0,
        _frameCache: null,
        _curFrame: null,
        _skeletonCache: null,
        _animationName: "",
        _animationQueue: [],
        _headAniInfo: null,
        _playTimes: 0,
        _isAniComplete: true,
        autoSwitchMaterial: {
          type: RenderComponent.EnableType,
          default: RenderComponent.EnableType.GLOBAL,
          notify: function notify(oldValue) {
            if (this.autoSwitchMaterial === oldValue) return;
            this.setVertsDirty();
          }
        },
        allowDynamicAtlas: {
          type: RenderComponent.EnableType,
          default: RenderComponent.EnableType.GLOBAL,
          notify: function notify(oldValue) {
            if (this.allowDynamicAtlas === oldValue) return;
            this.setVertsDirty();
          }
        }
      },
      ctor: function ctor() {
        this._effectDelegate = null;
        this._skeleton = null;
        this._rootBone = null;
        this._listener = null;
        this._materialCache = {};
        this._debugRenderer = null;
        this._startSlotIndex = -1;
        this._endSlotIndex = -1;
        this._startEntry = {
          animation: {
            name: ""
          },
          trackIndex: 0
        };
        this._endEntry = {
          animation: {
            name: ""
          },
          trackIndex: 0
        };
        this.attachUtil = new AttachUtil();
        this._dataDirty = true;
      },
      setVertsDirty: function setVertsDirty() {
        this._dataDirty = true;
        this.invalidAnimationCache();
        this._materialCache = {};
        this._super();
      },
      _getDefaultMaterial: function _getDefaultMaterial() {
        return cc.Material.getBuiltinMaterial("2d-spine");
      },
      _updateMaterial: function _updateMaterial() {
        var useTint = this.useTint;
        var baseMaterial = this.getMaterial(0);
        if (baseMaterial) {
          var isMultiSupport = baseMaterial.material.isMultiSupport();
          if (isMultiSupport) this._defineMaterialTint(baseMaterial, useTint); else {
            baseMaterial.define("USE_TINT", useTint);
            baseMaterial.define("CC_USE_MODEL", !this.enableBatch);
          }
          var srcBlendFactor = this.premultipliedAlpha ? cc.gfx.BLEND_ONE : cc.gfx.BLEND_SRC_ALPHA;
          var dstBlendFactor = cc.gfx.BLEND_ONE_MINUS_SRC_ALPHA;
          baseMaterial.setBlend(true, cc.gfx.BLEND_FUNC_ADD, srcBlendFactor, srcBlendFactor, cc.gfx.BLEND_FUNC_ADD, dstBlendFactor, dstBlendFactor);
          isMultiSupport && (this.enableBatch || (this.enableBatch = true));
          true;
          this._nativeSkeleton && this._nativeSkeleton.setUseMulti(isMultiSupport);
        }
        this._materialCache = {};
      },
      disableRender: function disableRender() {
        this._super();
        this.node._renderFlag &= ~FLAG_POST_RENDER;
      },
      markForRender: function markForRender(enable) {
        this._super(enable);
        enable ? this.node._renderFlag |= FLAG_POST_RENDER : this.node._renderFlag &= ~FLAG_POST_RENDER;
      },
      _updateUseTint: function _updateUseTint() {
        var baseMaterial = this.getMaterial(0);
        if (baseMaterial) {
          var useTint = this.useTint;
          baseMaterial.material.isMultiSupport() ? this._defineMaterialTint(baseMaterial, useTint) : baseMaterial.define("USE_TINT", useTint);
        }
        this._materialCache = {};
      },
      _defineMaterialTint: function _defineMaterialTint(material, useTint) {
        var passes = material._effect._passes;
        passes && passes.length > 0 && passes[0]._defines["USE_TINT"] != useTint && material.define("USE_TINT", useTint);
      },
      _updateBatch: function _updateBatch() {
        var baseMaterial = this.getMaterial(0);
        baseMaterial && (baseMaterial.material.isMultiSupport() ? this.enableBatch || (this.enableBatch = true) : baseMaterial.define("CC_USE_MODEL", !this.enableBatch));
        this._materialCache = {};
      },
      _validateRender: function _validateRender() {
        var skeletonData = this.skeletonData;
        if (!skeletonData || !skeletonData.isTexturesLoaded()) {
          this.disableRender();
          return;
        }
        this._super();
      },
      setSkeletonData: function setSkeletonData(skeletonData) {
        null != skeletonData.width && null != skeletonData.height && this.node.setContentSize(skeletonData.width, skeletonData.height);
        true;
        if (this._cacheMode === AnimationCacheMode.SHARED_CACHE) this._skeletonCache = SkeletonCache.sharedCache; else if (this._cacheMode === AnimationCacheMode.PRIVATE_CACHE) {
          this._skeletonCache = new SkeletonCache();
          this._skeletonCache.enablePrivateMode();
        }
        if (this.isAnimationCached()) {
          (this.debugBones || this.debugSlots) && cc.warn("Debug bones or slots is invalid in cached mode");
          var skeletonInfo = this._skeletonCache.getSkeletonCache(this.skeletonData._uuid, skeletonData);
          this._skeleton = skeletonInfo.skeleton;
          this._clipper = skeletonInfo.clipper;
          this._rootBone = this._skeleton.getRootBone();
        } else {
          this._skeleton = new spine.Skeleton(skeletonData);
          this._clipper = new spine.SkeletonClipping();
          this._rootBone = this._skeleton.getRootBone();
        }
        this.markForRender(true);
      },
      setSlotsRange: function setSlotsRange(startSlotIndex, endSlotIndex) {
        if (this.isAnimationCached()) cc.warn("Slots visible range can not be modified in cached mode."); else {
          this._startSlotIndex = startSlotIndex;
          this._endSlotIndex = endSlotIndex;
        }
      },
      setAnimationStateData: function setAnimationStateData(stateData) {
        if (this.isAnimationCached()) cc.warn("'setAnimationStateData' interface can not be invoked in cached mode."); else {
          var state = new spine.AnimationState(stateData);
          if (this._listener) {
            this._state && this._state.removeListener(this._listener);
            state.addListener(this._listener);
          }
          this._state = state;
        }
      },
      __preload: function __preload() {
        this._super();
        var Flags;
        false;
        var children = this.node.children;
        for (var i = 0, n = children.length; i < n; i++) {
          var child = children[i];
          child && "DEBUG_DRAW_NODE" === child._name && child.destroy();
        }
        this._updateSkeletonData();
        this._updateDebugDraw();
        this._updateUseTint();
        this._updateBatch();
      },
      setAnimationCacheMode: function setAnimationCacheMode(cacheMode) {
        if (this._preCacheMode !== cacheMode) {
          this._cacheMode = cacheMode;
          this._updateSkeletonData();
          this._updateUseTint();
        }
      },
      isAnimationCached: function isAnimationCached() {
        false;
        return this._cacheMode !== AnimationCacheMode.REALTIME;
      },
      update: function update(dt) {
        false;
        if (this.paused) return;
        dt *= this.timeScale * sp.timeScale;
        if (this.isAnimationCached()) {
          this._assembler && this._assembler.handleDynamicAtlasAndSwitchMaterial(this);
          if (this._isAniComplete) {
            if (0 === this._animationQueue.length && !this._headAniInfo) {
              var frameCache = this._frameCache;
              if (frameCache && frameCache.isInvalid()) {
                frameCache.updateToFrame();
                var frames = frameCache.frames;
                this._curFrame = frames[frames.length - 1];
              }
              return;
            }
            this._headAniInfo || (this._headAniInfo = this._animationQueue.shift());
            this._accTime += dt;
            if (this._accTime > this._headAniInfo.delay) {
              var aniInfo = this._headAniInfo;
              this._headAniInfo = null;
              this.setAnimation(0, aniInfo.animationName, aniInfo.loop);
            }
            return;
          }
          this._updateCache(dt);
        } else this._updateRealtime(dt);
      },
      _emitCacheCompleteEvent: function _emitCacheCompleteEvent() {
        if (!this._listener) return;
        this._endEntry.animation.name = this._animationName;
        this._listener.complete && this._listener.complete(this._endEntry);
        this._listener.end && this._listener.end(this._endEntry);
      },
      _updateCache: function _updateCache(dt) {
        var frameCache = this._frameCache;
        if (!frameCache.isInited()) return;
        var frames = frameCache.frames;
        var frameTime = SkeletonCache.FrameTime;
        if (0 == this._accTime && 0 == this._playCount) {
          this._startEntry.animation.name = this._animationName;
          this._listener && this._listener.start && this._listener.start(this._startEntry);
        }
        this._accTime += dt;
        var frameIdx = Math.floor(this._accTime / frameTime);
        frameCache.isCompleted || frameCache.updateToFrame(frameIdx);
        if (frameCache.isCompleted && frameIdx >= frames.length) {
          this._playCount++;
          if (this._playTimes > 0 && this._playCount >= this._playTimes) {
            this._curFrame = frames[frames.length - 1];
            this._accTime = 0;
            this._playCount = 0;
            this._isAniComplete = true;
            this._emitCacheCompleteEvent();
            return;
          }
          this._accTime = 0;
          frameIdx = 0;
          this._emitCacheCompleteEvent();
        }
        this._curFrame = frames[frameIdx];
      },
      _updateRealtime: function _updateRealtime(dt) {
        var skeleton = this._skeleton;
        var state = this._state;
        if (skeleton) {
          skeleton.update(dt);
          if (state) {
            state.update(dt);
            state.apply(skeleton);
          }
        }
      },
      setVertexEffectDelegate: function setVertexEffectDelegate(effectDelegate) {
        this._effectDelegate = effectDelegate;
      },
      updateWorldTransform: function updateWorldTransform() {
        if (!this.isAnimationCached()) return;
        this._skeleton && this._skeleton.updateWorldTransform();
      },
      setToSetupPose: function setToSetupPose() {
        this._skeleton && this._skeleton.setToSetupPose();
      },
      setBonesToSetupPose: function setBonesToSetupPose() {
        this._skeleton && this._skeleton.setBonesToSetupPose();
      },
      setSlotsToSetupPose: function setSlotsToSetupPose() {
        this._skeleton && this._skeleton.setSlotsToSetupPose();
      },
      updateAnimationCache: function updateAnimationCache(animName) {
        if (!this.isAnimationCached()) return;
        var uuid = this.skeletonData._uuid;
        this._skeletonCache && this._skeletonCache.updateAnimationCache(uuid, animName);
      },
      invalidAnimationCache: function invalidAnimationCache() {
        if (!this.isAnimationCached()) return;
        this._skeletonCache && this._skeletonCache.invalidAnimationCache(this.skeletonData._uuid);
      },
      findBone: function findBone(boneName) {
        if (this._skeleton) return this._skeleton.findBone(boneName);
        return null;
      },
      findSlot: function findSlot(slotName) {
        if (this._skeleton) return this._skeleton.findSlot(slotName);
        return null;
      },
      setSkin: function setSkin(skinName) {
        if (this._skeleton) {
          this._skeleton.setSkinByName(skinName);
          this._skeleton.setSlotsToSetupPose();
        }
        this.invalidAnimationCache();
      },
      getAttachment: function getAttachment(slotName, attachmentName) {
        if (this._skeleton) return this._skeleton.getAttachmentByName(slotName, attachmentName);
        return null;
      },
      setAttachment: function setAttachment(slotName, attachmentName) {
        this._skeleton && this._skeleton.setAttachment(slotName, attachmentName);
        this.invalidAnimationCache();
      },
      getRegionData: function getRegionData(slotName, attachmentName) {
        var attachment = this.getAttachment(slotName, attachmentName);
        if (attachment) return new sp.RegionData(attachment);
        return null;
      },
      setRegionData: function setRegionData(slotName, attachmentName, regionData) {
        var attachment = this.getAttachment(slotName, attachmentName);
        if (attachment) {
          regionData.assignToAttachment(attachment);
          this.setVertsDirty();
          return true;
        }
        return false;
      },
      getTextureAtlas: function getTextureAtlas(regionAttachment) {
        return regionAttachment.region;
      },
      setMix: function setMix(fromAnimation, toAnimation, duration) {
        this._state && this._state.data.setMix(fromAnimation, toAnimation, duration);
      },
      setAnimation: function setAnimation(trackIndex, name, loop) {
        this._playTimes = loop ? 0 : 1;
        this._animationName = name;
        if (this.isAnimationCached()) {
          0 !== trackIndex && cc.warn("Track index can not greater than 0 in cached mode.");
          if (!this._skeletonCache) return null;
          var cache = this._skeletonCache.getAnimationCache(this.skeletonData._uuid, name);
          cache || (cache = this._skeletonCache.initAnimationCache(this.skeletonData._uuid, name));
          if (cache) {
            this._isAniComplete = false;
            this._accTime = 0;
            this._playCount = 0;
            this._frameCache = cache;
            this.attachUtil._hasAttachedNode() && this._frameCache.enableCacheAttachedInfo();
            this._assembler && this._assembler.handleDynamicAtlasAndSwitchMaterial(this);
            this._frameCache.updateToFrame(0);
            this._curFrame = this._frameCache.frames[0];
          }
        } else if (this._skeleton) {
          var animation = this._skeleton.data.findAnimation(name);
          if (!animation) {
            cc.logID(7509, name);
            return null;
          }
          var res = this._state.setAnimationWith(trackIndex, animation, loop);
          this._state.apply(this._skeleton);
          return res;
        }
        return null;
      },
      addAnimation: function addAnimation(trackIndex, name, loop, delay) {
        delay = delay || 0;
        if (this.isAnimationCached()) {
          0 !== trackIndex && cc.warn("Track index can not greater than 0 in cached mode.");
          this._animationQueue.push({
            animationName: name,
            loop: loop,
            delay: delay
          });
        } else if (this._skeleton) {
          var animation = this._skeleton.data.findAnimation(name);
          if (!animation) {
            cc.logID(7510, name);
            return null;
          }
          return this._state.addAnimationWith(trackIndex, animation, loop, delay);
        }
        return null;
      },
      findAnimation: function findAnimation(name) {
        if (this._skeleton) return this._skeleton.data.findAnimation(name);
        return null;
      },
      getCurrent: function getCurrent(trackIndex) {
        if (this.isAnimationCached()) cc.warn("'getCurrent' interface can not be invoked in cached mode."); else if (this._state) return this._state.getCurrent(trackIndex);
        return null;
      },
      clearTracks: function clearTracks() {
        this.isAnimationCached() ? cc.warn("'clearTracks' interface can not be invoked in cached mode.") : this._state && this._state.clearTracks();
      },
      clearTrack: function clearTrack(trackIndex) {
        if (this.isAnimationCached()) cc.warn("'clearTrack' interface can not be invoked in cached mode."); else if (this._state) {
          this._state.clearTrack(trackIndex);
          false;
        }
      },
      setStartListener: function setStartListener(listener) {
        this._ensureListener();
        this._listener.start = listener;
      },
      setInterruptListener: function setInterruptListener(listener) {
        this._ensureListener();
        this._listener.interrupt = listener;
      },
      setEndListener: function setEndListener(listener) {
        this._ensureListener();
        this._listener.end = listener;
      },
      setDisposeListener: function setDisposeListener(listener) {
        this._ensureListener();
        this._listener.dispose = listener;
      },
      setCompleteListener: function setCompleteListener(listener) {
        this._ensureListener();
        this._listener.complete = listener;
      },
      setEventListener: function setEventListener(listener) {
        this._ensureListener();
        this._listener.event = listener;
      },
      setTrackStartListener: function setTrackStartListener(entry, listener) {
        TrackEntryListeners.getListeners(entry).start = listener;
      },
      setTrackInterruptListener: function setTrackInterruptListener(entry, listener) {
        TrackEntryListeners.getListeners(entry).interrupt = listener;
      },
      setTrackEndListener: function setTrackEndListener(entry, listener) {
        TrackEntryListeners.getListeners(entry).end = listener;
      },
      setTrackDisposeListener: function setTrackDisposeListener(entry, listener) {
        TrackEntryListeners.getListeners(entry).dispose = listener;
      },
      setTrackCompleteListener: function setTrackCompleteListener(entry, listener) {
        TrackEntryListeners.getListeners(entry).complete = function(trackEntry) {
          var loopCount = Math.floor(trackEntry.trackTime / trackEntry.animationEnd);
          listener(trackEntry, loopCount);
        };
      },
      setTrackEventListener: function setTrackEventListener(entry, listener) {
        TrackEntryListeners.getListeners(entry).event = listener;
      },
      getState: function getState() {
        return this._state;
      },
      _resetDefaultAnim: false,
      _resetDefaultSkin: false,
      _updateAnimEnum: false,
      _updateSkinEnum: false,
      _ensureListener: function _ensureListener() {
        if (!this._listener) {
          this._listener = new TrackEntryListeners();
          this._state && this._state.addListener(this._listener);
        }
      },
      _updateSkeletonData: function _updateSkeletonData() {
        this._dataDirty = true;
        if (!this.skeletonData) {
          this.disableRender();
          return;
        }
        var data = this.skeletonData.getRuntimeData();
        if (!data) {
          this.disableRender();
          return;
        }
        try {
          this.setSkeletonData(data);
          this.isAnimationCached() || this.setAnimationStateData(new spine.AnimationStateData(this._skeleton.data));
          this.defaultSkin && this.setSkin(this.defaultSkin);
        } catch (e) {
          cc.warn(e);
        }
        this.attachUtil.init(this);
        this.attachUtil._associateAttachedNode();
        this._preCacheMode = this._cacheMode;
        this.animation = this.defaultAnimation;
      },
      _refreshInspector: function _refreshInspector() {
        this._updateAnimEnum();
        this._updateSkinEnum();
        Editor.Utils.refreshSelectedInspector("node", this.node.uuid);
      },
      _updateDebugDraw: function _updateDebugDraw() {
        if (this.debugBones || this.debugSlots) {
          if (!this._debugRenderer) {
            var debugDrawNode = new cc.PrivateNode();
            debugDrawNode.name = "DEBUG_DRAW_NODE";
            var debugDraw = debugDrawNode.addComponent(Graphics);
            debugDraw.lineWidth = 1;
            debugDraw.strokeColor = cc.color(255, 0, 0, 255);
            this._debugRenderer = debugDraw;
          }
          this._debugRenderer.node.parent = this.node;
          this.isAnimationCached() && cc.warn("Debug bones or slots is invalid in cached mode");
        } else this._debugRenderer && (this._debugRenderer.node.parent = null);
      }
    });
    module.exports = sp.Skeleton;
  }), {
    "../../cocos2d/core/components/CCRenderComponent": 192,
    "../../cocos2d/core/graphics/graphics": 235,
    "../../cocos2d/core/renderer/render-flow": 323,
    "./AttachUtil": 455,
    "./lib/spine": void 0,
    "./skeleton-cache": void 0,
    "./track-entry-listeners": 461
  } ],
  457: [ (function(require, module, exports) {
    "use strict";
    var _global = "undefined" === typeof window ? global : window;
    var _isUseSpine = true;
    false;
    _global.spine || (_isUseSpine = false);
    if (_isUseSpine) {
      _global.sp = _global.sp || {};
      sp._timeScale = 1;
      Object.defineProperty(sp, "timeScale", {
        get: function get() {
          return this._timeScale;
        },
        set: function set(value) {
          this._timeScale = value;
        },
        configurable: true
      });
      sp.ATTACHMENT_TYPE = {
        REGION: 0,
        BOUNDING_BOX: 1,
        MESH: 2,
        SKINNED_MESH: 3
      };
      sp.AnimationEventType = cc.Enum({
        START: 0,
        INTERRUPT: 1,
        END: 2,
        DISPOSE: 3,
        COMPLETE: 4,
        EVENT: 5
      });
      true;
      sp.spine = _global.spine;
      false;
      require("./skeleton-data");
      require("./vertex-effect-delegate");
      require("./Skeleton");
      require("./spine-assembler");
    }
  }), {
    "./Skeleton": 456,
    "./lib/spine": void 0,
    "./skeleton-data": 458,
    "./skeleton-texture": 459,
    "./spine-assembler": 460,
    "./vertex-effect-delegate": void 0
  } ],
  458: [ (function(require, module, exports) {
    "use strict";
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = "undefined" !== typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" === typeof o.length) {
        it && (o = it);
        var i = 0;
        return function() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if ("string" === typeof o) return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      "Object" === n && o.constructor && (n = o.constructor.name);
      if ("Map" === n || "Set" === n) return Array.from(o);
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      (null == len || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    var SkeletonCache = false;
    var RegionData = (function() {
      RegionData.updateUV = function updateUV(region) {
        var texture = region.texture2D;
        if (region.rotate) {
          region.u = region.x / texture.width;
          region.v = region.y / texture.height;
          region.u2 = (region.x + region.height) / texture.width;
          region.v2 = (region.y + region.width) / texture.height;
        } else {
          region.u = region.x / texture.width;
          region.v = region.y / texture.height;
          region.u2 = (region.x + region.width) / texture.width;
          region.v2 = (region.y + region.height) / texture.height;
        }
      };
      function RegionData(attachmentOrSpriteFrame) {
        this.x = void 0;
        this.y = void 0;
        this.degrees = void 0;
        this.texture = void 0;
        this.texture2D = void 0;
        this.u = void 0;
        this.v = void 0;
        this.u2 = void 0;
        this.v2 = void 0;
        this.width = void 0;
        this.height = void 0;
        this.rotate = void 0;
        this.offsetX = void 0;
        this.offsetY = void 0;
        this.originalWidth = void 0;
        this.originalHeight = void 0;
        attachmentOrSpriteFrame instanceof cc.SpriteFrame ? this.initWithSpriteFrame(attachmentOrSpriteFrame) : null != attachmentOrSpriteFrame && this.initWithAttachment(attachmentOrSpriteFrame);
      }
      var _proto = RegionData.prototype;
      _proto.initWithSpriteFrame = function initWithSpriteFrame(spriteFrame) {
        var texture = spriteFrame.getTexture();
        var rect = spriteFrame.getRect();
        var origSize = spriteFrame.getOriginalSize();
        var _offset = spriteFrame.getOffset();
        var rotate = spriteFrame.isRotated();
        var offset = cc.v2(.5 * (origSize.width - rect.width) + _offset.x, .5 * (origSize.height - rect.height) + _offset.y);
        var degrees = rotate ? 270 : 0;
        this.x = rect.x;
        this.y = rect.y;
        this.width = rect.width;
        this.height = rect.height;
        this.originalWidth = origSize.width;
        this.originalHeight = origSize.height;
        this.offsetX = offset.x;
        this.offsetY = offset.y;
        this.rotate = 0 != degrees;
        this.degrees = degrees;
        this.updateWithTexture2D(texture);
      };
      _proto.initWithAttachment = function initWithAttachment(attachment) {
        var region;
        true;
        this.x = attachment.regionX;
        this.y = attachment.regionY;
        this.width = attachment.regionWidth;
        this.height = attachment.regionHeight;
        this.originalWidth = attachment.regionOriginalWidth;
        this.originalHeight = attachment.regionOriginalHeight;
        this.offsetX = attachment.regionOffsetX;
        this.offsetY = attachment.regionOffsetY;
        this.degrees = attachment.regionDegrees;
        this.rotate = 0 !== this.degrees;
        this.texture = attachment.textureForJSB;
        this.texture2D = attachment.getTexture2D();
        this.updateUV();
      };
      _proto.updateUV = function updateUV() {
        RegionData.updateUV(this);
      };
      _proto.updateWithPackedFrame = function updateWithPackedFrame(packedFrame) {
        this.x = packedFrame.x;
        this.y = packedFrame.y;
        this.updateWithTexture2D(packedFrame.texture);
      };
      _proto.updateWithTexture2D = function updateWithTexture2D(texture2d) {
        true;
        var spTex = new middleware.Texture2D();
        spTex.setRealTextureIndex(RegionData.middlewareTextureID--);
        spTex.setPixelsWide(texture2d.width);
        spTex.setPixelsHigh(texture2d.height);
        spTex.setNativeTexture(texture2d.getImpl());
        this.texture = spTex;
        this.texture2D = texture2d;
        this.updateUV();
      };
      _proto.toSpriteFrame = function toSpriteFrame(strict) {
        if (strict && (270 !== this.degrees || 0 !== this.degrees)) return null;
        var frame = new cc.SpriteFrame(this.texture2D, cc.rect(this.x, this.y, this.width, this.height), this.rotate, cc.v2(this.offsetX - .5 * (this.originalWidth - this.width), this.offsetY - .5 * (this.originalHeight - this.height)), cc.size(this.originalWidth, this.originalHeight));
        return frame;
      };
      _proto.assignToAttachment = function assignToAttachment(attachment, strict, resetDynamicAtlas) {
        void 0 === strict && (strict = true);
        void 0 === resetDynamicAtlas && (resetDynamicAtlas = true);
        var region;
        var _spriteFrame;
        true;
        if (resetDynamicAtlas && attachment && attachment._spriteFrame) {
          var spriteFrame = attachment._spriteFrame;
          attachment._spriteFrame = null;
          spriteFrame.destroy();
        }
        attachment._texture2D = this.texture2D;
        attachment.setRegionForJSB(this.texture, {
          x: this.x,
          y: this.y,
          w: this.width,
          h: this.height
        }, cc.size(this.originalWidth, this.originalHeight), cc.v2(this.offsetX, this.offsetY), this.degrees);
      };
      _proto.reset = function reset() {
        this.texture = null;
        this.texture2D = null;
      };
      return RegionData;
    })();
    RegionData.middlewareTextureID = -1;
    var SkeletonData = cc.Class({
      name: "sp.SkeletonData",
      extends: cc.Asset,
      ctor: function ctor() {
        this.reset();
      },
      properties: {
        _skeletonJson: null,
        skeletonJsonStr: {
          get: function get() {
            return this._skeletonJson ? JSON.stringify(this._skeletonJson) : "";
          }
        },
        skeletonJson: {
          get: function get() {
            return this._skeletonJson;
          },
          set: function set(value) {
            this.reset();
            this._skeletonJson = "string" == typeof value ? JSON.parse(value) : value;
            !this._uuid && value.skeleton && (this._uuid = value.skeleton.hash);
          }
        },
        _atlasText: "",
        atlasText: {
          get: function get() {
            return this._atlasText;
          },
          set: function set(value) {
            this._atlasText = value;
            this.reset();
          }
        },
        textures: {
          default: [],
          type: [ cc.Texture2D ]
        },
        textureNames: {
          default: [],
          type: [ cc.String ]
        },
        scale: 1,
        _nativeAsset: {
          get: function get() {
            return this._buffer;
          },
          set: function set(bin) {
            this._buffer = bin.buffer || bin;
            this.reset();
          },
          override: true
        }
      },
      statics: {
        preventDeferredLoadDependents: true,
        cloneId: 0
      },
      createNode: false,
      reset: function reset() {
        this._skeletonCache = null;
        this._atlasCache = null;
        false;
      },
      ensureTexturesLoaded: function ensureTexturesLoaded(loaded, caller) {
        var textures = this.textures;
        var texsLen = textures.length;
        if (0 == texsLen) {
          loaded.call(caller, false);
          return;
        }
        var loadedCount = 0;
        var loadedItem = function loadedItem() {
          loadedCount++;
          if (loadedCount >= texsLen) {
            loaded && loaded.call(caller, true);
            loaded = null;
          }
        };
        for (var i = 0; i < texsLen; i++) {
          var tex = textures[i];
          tex.loaded ? loadedItem() : tex.once("load", loadedItem);
        }
      },
      isTexturesLoaded: function isTexturesLoaded() {
        var textures = this.textures;
        var texsLen = textures.length;
        for (var i = 0; i < texsLen; i++) {
          var tex = textures[i];
          if (!tex.loaded) return false;
        }
        return true;
      },
      getRuntimeData: function getRuntimeData(quiet) {
        if (this._skeletonCache) return this._skeletonCache;
        if (!(this.textures && this.textures.length > 0) && this.textureNames && this.textureNames.length > 0) {
          quiet || cc.errorID(7507, this.name);
          return null;
        }
        var atlas = this._getAtlas(quiet);
        if (!atlas) return null;
        var attachmentLoader = new sp.spine.AtlasAttachmentLoader(atlas);
        var resData = null;
        var reader = null;
        if (this.skeletonJson) {
          reader = new sp.spine.SkeletonJson(attachmentLoader);
          resData = this.skeletonJson;
        } else {
          reader = new sp.spine.SkeletonBinary(attachmentLoader);
          resData = new Uint8Array(this._nativeAsset);
        }
        reader.scale = this.scale;
        this._skeletonCache = reader.readSkeletonData(resData);
        atlas.dispose();
        return this._skeletonCache;
      },
      getSkinsEnum: false,
      getAnimsEnum: false,
      _getTexture: function _getTexture(line) {
        var names = this.textureNames;
        for (var i = 0; i < names.length; i++) if (names[i] === line) {
          var texture = this.textures[i];
          var tex = new sp.SkeletonTexture({
            width: texture.width,
            height: texture.height
          });
          tex.setRealTexture(texture);
          return tex;
        }
        cc.errorID(7506, line);
        return null;
      },
      _getAtlas: function _getAtlas(quiet) {
        if (this._atlasCache) return this._atlasCache;
        if (!this.atlasText) {
          quiet || cc.errorID(7508, this.name);
          return null;
        }
        return this._atlasCache = new sp.spine.TextureAtlas(this.atlasText, this._getTexture.bind(this));
      },
      clone: function clone() {
        var cloned = new SkeletonData();
        SkeletonData.cloneId++;
        var suffix = "(clone " + String(SkeletonData.cloneId) + ")";
        cloned._uuid = this._uuid.split("(")[0] + suffix;
        cloned.name = this.name + suffix;
        cloned.scale = this.scale;
        cloned._atlasText = this._atlasText;
        cloned.textureNames = this.textureNames;
        cloned._skeletonJson = this._skeletonJson;
        cloned.textures = this.textures;
        true;
        var realUuid = cloned._uuid;
        cloned._uuid = this._uuid;
        cloned._nativeUrl = this._nativeUrl;
        cloned._native = this._native;
        cloned.nativeUrl;
        cloned._uuid = realUuid;
        cloned.getRuntimeData();
        return cloned;
      },
      _destroyFromDynamicAtlas: function _destroyFromDynamicAtlas() {
        if (this._skeletonCache) {
          var skins = this._skeletonCache.skins;
          for (var _iterator = _createForOfIteratorHelperLoose(skins), _step; !(_step = _iterator()).done; ) {
            var skin = _step.value;
            for (var _iterator2 = _createForOfIteratorHelperLoose(skin.attachments), _step2; !(_step2 = _iterator2()).done; ) {
              var attachments = _step2.value;
              for (var key in attachments) {
                var region = attachments[key];
                if (region && region._spriteFrame) {
                  var spriteFrame = region._spriteFrame;
                  region._spriteFrame = null;
                  spriteFrame.destroy();
                }
              }
            }
          }
        }
      },
      destroy: function destroy() {
        this._destroyFromDynamicAtlas();
        SkeletonCache.removeSkeleton(this._uuid);
        this._super();
      }
    });
    sp.SkeletonData = module.exports = SkeletonData;
    sp.RegionData = RegionData;
  }), {
    "./skeleton-cache": void 0
  } ],
  459: [ (function(require, module, exports) {
    "use strict";
    sp.SkeletonTexture = cc.Class({
      name: "sp.SkeletonTexture",
      extends: sp.spine.Texture,
      _texture: null,
      _material: null,
      setRealTexture: function setRealTexture(tex) {
        this._texture = tex;
      },
      getRealTexture: function getRealTexture() {
        return this._texture;
      },
      setFilters: function setFilters(minFilter, magFilter) {
        this._texture && this._texture.setFilters(minFilter, magFilter);
      },
      setWraps: function setWraps(uWrap, vWrap) {
        this._texture && this._texture.setWrapMode(uWrap, vWrap);
      },
      dispose: function dispose() {}
    });
  }), {} ],
  460: [ (function(require, module, exports) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = void 0;
    var _assembler = _interopRequireDefault(require("../../cocos2d/core/renderer/assembler"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = "undefined" !== typeof Symbol && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" === typeof o.length) {
        it && (o = it);
        var i = 0;
        return function() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if ("string" === typeof o) return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      "Object" === n && o.constructor && (n = o.constructor.name);
      if ("Map" === n || "Set" === n) return Array.from(o);
      if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      (null == len || len > arr.length) && (len = arr.length);
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };
      return _setPrototypeOf(o, p);
    }
    var Skeleton = require("./Skeleton");
    var spine = require("./lib/spine");
    var RenderFlow = require("../../cocos2d/core/renderer/render-flow");
    var VertexFormat = require("../../cocos2d/core/renderer/webgl/vertex-format");
    var VFOneColor = VertexFormat.vfmtPosUvColor;
    var VFOneColorTexId = VertexFormat.vfmtPosUvColorTexId;
    var VFTwoColor = VertexFormat.vfmtPosUvTwoColor;
    var VFTwoColorTexId = VertexFormat.vfmtPosUvTwoColorTexId;
    var gfx = cc.gfx;
    var FLAG_BATCH = 16;
    var FLAG_TWO_COLOR = 1;
    var _handleVal = 0;
    var _quadTriangles = [ 0, 1, 2, 2, 3, 0 ];
    var _slotColor = cc.color(0, 0, 255, 255);
    var _boneColor = cc.color(255, 0, 0, 255);
    var _originColor = cc.color(0, 255, 0, 255);
    var _meshColor = cc.color(255, 255, 0, 255);
    var _finalColor = null;
    var _darkColor = null;
    var _tempPos = null, _tempUv = null;
    false;
    var _premultipliedAlpha;
    var _multiplier;
    var _slotRangeStart;
    var _slotRangeEnd;
    var _useTint;
    var _useMulti;
    var _texId;
    var _debugSlots;
    var _debugBones;
    var _debugMesh;
    var _nodeR, _nodeG, _nodeB, _nodeA;
    var _finalColor32, _darkColor32;
    var _vertexFormat;
    var _perVertexSize;
    var _perClipVertexSize;
    var _vertexFloatCount = 0, _vertexCount = 0, _vertexFloatOffset = 0, _vertexOffset = 0, _indexCount = 0, _indexOffset = 0, _vfOffset = 0;
    var _tempr, _tempg, _tempb;
    var _inRange;
    var _mustFlush;
    var _x, _y, _m00, _m04, _m12, _m01, _m05, _m13;
    var _r, _g, _b, _fr, _fg, _fb, _fa, _dr, _dg, _db, _da;
    var _comp, _buffer, _renderer, _node, _needColor, _vertexEffect;
    var _packedRegions = [];
    var _tmpRegionData = new sp.RegionData();
    function _getSlotMaterial(tex, blendMode) {
      var src, dst;
      switch (blendMode) {
       case spine.BlendMode.Additive:
        src = _premultipliedAlpha ? cc.macro.ONE : cc.macro.SRC_ALPHA;
        dst = cc.macro.ONE;
        break;

       case spine.BlendMode.Multiply:
        src = cc.macro.DST_COLOR;
        dst = cc.macro.ONE_MINUS_SRC_ALPHA;
        break;

       case spine.BlendMode.Screen:
        src = cc.macro.ONE;
        dst = cc.macro.ONE_MINUS_SRC_COLOR;
        break;

       case spine.BlendMode.Normal:
       default:
        src = _premultipliedAlpha ? cc.macro.ONE : cc.macro.SRC_ALPHA;
        dst = cc.macro.ONE_MINUS_SRC_ALPHA;
      }
      var useModel = !_comp.enableBatch;
      var baseMaterial = _comp._materials[0];
      if (!baseMaterial) return null;
      if (_useMulti) {
        var key = tex.getId() + src + dst + _useTint;
        var materialCache = _comp._materialCache;
        var materialInfo = materialCache[key];
        if (!materialInfo) {
          var texId = baseMaterial.material.getMultiHandler().getIndex(tex.getImpl());
          if (materialCache.baseMaterial) materialInfo = {
            material: cc.MaterialVariant.create(baseMaterial),
            texId: texId
          }; else {
            materialInfo = {
              material: baseMaterial,
              texId: texId
            };
            materialCache.baseMaterial = materialInfo;
          }
          _comp._defineMaterialTint(baseMaterial, _useTint);
          if (-1 === texId) {
            materialInfo.material.setProperty("texture", tex);
            materialInfo.texId = 0;
          }
          materialInfo.material.setBlend(true, gfx.BLEND_FUNC_ADD, src, dst, gfx.BLEND_FUNC_ADD, src, dst);
          materialCache[key] = materialInfo;
        }
        _texId = materialInfo.texId;
        return materialInfo.material;
      }
      var _key = tex.getId() + src + dst + _useTint + useModel;
      var _materialCache = _comp._materialCache;
      var material = _materialCache[_key];
      if (!material) {
        if (_materialCache.baseMaterial) material = cc.MaterialVariant.create(baseMaterial); else {
          material = baseMaterial;
          _materialCache.baseMaterial = baseMaterial;
        }
        material.define("CC_USE_MODEL", useModel);
        material.define("USE_TINT", _useTint);
        material.setProperty("texture", tex);
        material.setBlend(true, gfx.BLEND_FUNC_ADD, src, dst, gfx.BLEND_FUNC_ADD, src, dst);
        _materialCache[_key] = material;
      }
      return material;
    }
    function _handleColor(color) {
      _fa = color.fa * _nodeA;
      _multiplier = _premultipliedAlpha ? _fa / 255 : 1;
      _r = _nodeR * _multiplier;
      _g = _nodeG * _multiplier;
      _b = _nodeB * _multiplier;
      _fr = color.fr * _r;
      _fg = color.fg * _g;
      _fb = color.fb * _b;
      _finalColor32 = (_fa << 24 >>> 0) + (_fb << 16) + (_fg << 8) + _fr;
      _dr = color.dr * _r;
      _dg = color.dg * _g;
      _db = color.db * _b;
      _da = _premultipliedAlpha ? 255 : 0;
      _darkColor32 = (_da << 24 >>> 0) + (_db << 16) + (_dg << 8) + _dr;
    }
    function _spineColorToInt32(spineColor) {
      return (spineColor.a << 24 >>> 0) + (spineColor.b << 16) + (spineColor.g << 8) + spineColor.r;
    }
    var SpineAssembler = (function(_Assembler) {
      _inheritsLoose(SpineAssembler, _Assembler);
      function SpineAssembler() {
        return _Assembler.apply(this, arguments) || this;
      }
      var _proto = SpineAssembler.prototype;
      _proto.updateRenderData = function updateRenderData(comp) {
        if (comp.isAnimationCached()) return;
        this.handleDynamicAtlasAndSwitchMaterial(comp);
        var skeleton = comp._skeleton;
        skeleton && skeleton.updateWorldTransform();
      };
      _proto.handleDynamicAtlasAndSwitchMaterial = function handleDynamicAtlasAndSwitchMaterial(comp) {
        if (comp._dataDirty) {
          this.packDynamicAtlasForSpine(comp);
          var autoSwitchMaterial = comp.autoSwitchMaterial;
          if (cc.sp.autoSwitchMaterial && 0 === autoSwitchMaterial || 1 === autoSwitchMaterial) {
            var material = comp._materials[0];
            if (!material) return false;
            var skins = comp.skeletonData._skeletonCache.skins;
            root: for (var _iterator = _createForOfIteratorHelperLoose(skins), _step; !(_step = _iterator()).done; ) {
              var skin = _step.value;
              for (var _iterator2 = _createForOfIteratorHelperLoose(skin.attachments), _step2; !(_step2 = _iterator2()).done; ) {
                var attachments = _step2.value;
                for (var key in attachments) {
                  var region;
                  true;
                  var attachment = attachments[key];
                  if (attachment && attachment.getTexture2D) {
                    var texture = attachment.getTexture2D(comp.skeletonData);
                    if (texture) {
                      this.checkAndSwitchMaterial(comp, texture, material);
                      break root;
                    }
                  }
                }
              }
            }
          }
          comp._dataDirty = false;
        }
      };
      _proto.updatePackedAttachment = function updatePackedAttachment(attachment, strict) {
        _tmpRegionData.assignToAttachment(attachment, strict, false);
        var region = attachment;
        var frame = region._spriteFrame;
        region._original._ref++;
        frame.once("_resetDynamicAtlasFrame", (function() {
          _tmpRegionData.initWithAttachment(attachment);
          _tmpRegionData.x = region._original._x;
          _tmpRegionData.y = region._original._y;
          _tmpRegionData.texture = region._original._texture;
          true;
          _tmpRegionData.texture2D = region._original._texture2D;
          region._original._ref--;
          region._original._ref <= 0 && (region._original = null);
          _tmpRegionData.assignToAttachment(attachment, true, false);
          _tmpRegionData.reset();
        }));
      };
      _proto.packDynamicAtlasForSpine = function packDynamicAtlasForSpine(comp) {
        false;
        _packedRegions.length = 0;
        var allowDynamicAtlas = comp.allowDynamicAtlas;
        if ((cc.sp.allowDynamicAtlas && 0 === allowDynamicAtlas || 1 === allowDynamicAtlas) && cc.dynamicAtlasManager) {
          var skins = comp.skeletonData._skeletonCache.skins;
          for (var _iterator3 = _createForOfIteratorHelperLoose(skins), _step3; !(_step3 = _iterator3()).done; ) {
            var skin = _step3.value;
            for (var _iterator4 = _createForOfIteratorHelperLoose(skin.attachments), _step4; !(_step4 = _iterator4()).done; ) {
              var attachments = _step4.value;
              for (var key in attachments) {
                var attachment = attachments[key];
                if (attachment) {
                  var region;
                  var alreadyInAtlas;
                  var _spriteFrame;
                  var _frame;
                  var _packedFrame;
                  true;
                  if (!attachment._original && attachment.getTexture2D) {
                    var texture = attachment.getTexture2D(comp.skeletonData);
                    if (texture && texture.packable) {
                      if (attachment._spriteFrame) {
                        var spriteFrame = attachment._spriteFrame;
                        attachment._spriteFrame = null;
                        spriteFrame.destroy();
                      }
                      _tmpRegionData.initWithAttachment(attachment);
                      var frame = _tmpRegionData.toSpriteFrame();
                      var packedFrame = cc.dynamicAtlasManager.insertSpriteFrame(frame);
                      if (packedFrame) {
                        frame._setDynamicAtlasFrame(packedFrame);
                        attachment._original = {
                          _texture2D: texture,
                          _texture: _tmpRegionData.texture,
                          _x: attachment.regionX,
                          _y: attachment.regionY,
                          _ref: 0
                        };
                        attachment._spriteFrame = frame;
                        _tmpRegionData.updateWithPackedFrame(packedFrame);
                        this.updatePackedAttachment(attachment);
                      } else frame.destroy();
                    }
                  }
                }
              }
            }
          }
        }
        _tmpRegionData.reset();
        _packedRegions.length = 0;
      };
      _proto.fillVertices = function fillVertices(skeletonColor, attachmentColor, slotColor, clipper, slot) {
        var vbuf = _buffer._vData, ibuf = _buffer._iData, uintVData = _buffer._uintVData;
        var offsetInfo;
        _finalColor.a = slotColor.a * attachmentColor.a * skeletonColor.a * _nodeA * 255;
        _multiplier = _premultipliedAlpha ? _finalColor.a : 255;
        _tempr = _nodeR * attachmentColor.r * skeletonColor.r * _multiplier;
        _tempg = _nodeG * attachmentColor.g * skeletonColor.g * _multiplier;
        _tempb = _nodeB * attachmentColor.b * skeletonColor.b * _multiplier;
        _finalColor.r = _tempr * slotColor.r;
        _finalColor.g = _tempg * slotColor.g;
        _finalColor.b = _tempb * slotColor.b;
        if (null == slot.darkColor) _darkColor.set(0, 0, 0, 1); else {
          _darkColor.r = slot.darkColor.r * _tempr;
          _darkColor.g = slot.darkColor.g * _tempg;
          _darkColor.b = slot.darkColor.b * _tempb;
        }
        _darkColor.a = _premultipliedAlpha ? 255 : 0;
        if (clipper.isClipping()) {
          var uvs = vbuf.subarray(_vertexFloatOffset + 2);
          clipper.clipTriangles(vbuf.subarray(_vertexFloatOffset), _vertexFloatCount, ibuf.subarray(_indexOffset), _indexCount, uvs, _finalColor, _darkColor, _useTint, _perVertexSize);
          var clippedVertices = new Float32Array(clipper.clippedVertices);
          var clippedTriangles = clipper.clippedTriangles;
          _indexCount = clippedTriangles.length;
          _vertexFloatCount = clippedVertices.length / _perClipVertexSize * _perVertexSize;
          offsetInfo = _buffer.requestForSpine(_vertexFloatCount / _perVertexSize, _indexCount);
          _indexOffset = offsetInfo.indiceOffset, _vertexOffset = offsetInfo.vertexOffset, 
          _vertexFloatOffset = offsetInfo.byteOffset >> 2;
          vbuf = _buffer._vData, ibuf = _buffer._iData;
          uintVData = _buffer._uintVData;
          ibuf.set(clippedTriangles, _indexOffset);
          if (_vertexEffect) for (var _v2 = 0, _n2 = clippedVertices.length, offset = _vertexFloatOffset; _v2 < _n2; _v2 += _perClipVertexSize, 
          offset += _perVertexSize) {
            _tempPos.x = clippedVertices[_v2];
            _tempPos.y = clippedVertices[_v2 + 1];
            _finalColor.set(clippedVertices[_v2 + 2], clippedVertices[_v2 + 3], clippedVertices[_v2 + 4], clippedVertices[_v2 + 5]);
            _tempUv.x = clippedVertices[_v2 + 6];
            _tempUv.y = clippedVertices[_v2 + 7];
            _useTint ? _darkColor.set(clippedVertices[_v2 + 8], clippedVertices[_v2 + 9], clippedVertices[_v2 + 10], clippedVertices[_v2 + 11]) : _darkColor.set(0, 0, 0, 0);
            _vertexEffect.transform(_tempPos, _tempUv, _finalColor, _darkColor);
            vbuf[offset] = _tempPos.x;
            vbuf[offset + 1] = _tempPos.y;
            vbuf[offset + 2] = _tempUv.x;
            vbuf[offset + 3] = _tempUv.y;
            uintVData[offset + 4] = _spineColorToInt32(_finalColor);
            if (_useTint) {
              uintVData[offset + 5] = _spineColorToInt32(_darkColor);
              _useMulti && (vbuf[offset + 6] = _texId);
            } else _useMulti && (vbuf[offset + 5] = _texId);
          } else for (var _v3 = 0, _n3 = clippedVertices.length, _offset = _vertexFloatOffset; _v3 < _n3; _v3 += _perClipVertexSize, 
          _offset += _perVertexSize) {
            vbuf[_offset] = clippedVertices[_v3];
            vbuf[_offset + 1] = clippedVertices[_v3 + 1];
            vbuf[_offset + 2] = clippedVertices[_v3 + 6];
            vbuf[_offset + 3] = clippedVertices[_v3 + 7];
            _finalColor32 = (clippedVertices[_v3 + 5] << 24 >>> 0) + (clippedVertices[_v3 + 4] << 16) + (clippedVertices[_v3 + 3] << 8) + clippedVertices[_v3 + 2];
            uintVData[_offset + 4] = _finalColor32;
            if (_useTint) {
              _darkColor32 = (clippedVertices[_v3 + 11] << 24 >>> 0) + (clippedVertices[_v3 + 10] << 16) + (clippedVertices[_v3 + 9] << 8) + clippedVertices[_v3 + 8];
              uintVData[_offset + 5] = _darkColor32;
              _useMulti && (vbuf[_offset + 6] = _texId);
            } else _useMulti && (vbuf[_offset + 5] = _texId);
          }
        } else if (_vertexEffect) for (var v = _vertexFloatOffset, n = _vertexFloatOffset + _vertexFloatCount; v < n; v += _perVertexSize) {
          _tempPos.x = vbuf[v];
          _tempPos.y = vbuf[v + 1];
          _tempUv.x = vbuf[v + 2];
          _tempUv.y = vbuf[v + 3];
          _vertexEffect.transform(_tempPos, _tempUv, _finalColor, _darkColor);
          vbuf[v] = _tempPos.x;
          vbuf[v + 1] = _tempPos.y;
          vbuf[v + 2] = _tempUv.x;
          vbuf[v + 3] = _tempUv.y;
          uintVData[v + 4] = _spineColorToInt32(_finalColor);
          if (_useTint) {
            uintVData[v + 5] = _spineColorToInt32(_darkColor);
            _useMulti && (vbuf[v + 6] = _texId);
          } else _useMulti && (vbuf[v + 5] = _texId);
        } else {
          _finalColor32 = _spineColorToInt32(_finalColor);
          _darkColor32 = _spineColorToInt32(_darkColor);
          for (var _v = _vertexFloatOffset, _n = _vertexFloatOffset + _vertexFloatCount; _v < _n; _v += _perVertexSize) {
            uintVData[_v + 4] = _finalColor32;
            if (_useTint) {
              uintVData[_v + 5] = _darkColor32;
              _useMulti && (vbuf[_v + 6] = _texId);
            } else _useMulti && (vbuf[_v + 5] = _texId);
          }
        }
      };
      _proto.realTimeTraverse = function realTimeTraverse(worldMat) {
        var vbuf;
        var ibuf;
        var locSkeleton = _comp._skeleton;
        var skeletonColor = locSkeleton.color;
        var graphics = _comp._debugRenderer;
        var clipper = _comp._clipper;
        var material = null;
        var attachment, attachmentColor, slotColor, uvs, triangles;
        var isRegion, isMesh, isClip;
        var offsetInfo;
        var slot;
        var worldMatm;
        _slotRangeStart = _comp._startSlotIndex;
        _slotRangeEnd = _comp._endSlotIndex;
        _inRange = false;
        -1 == _slotRangeStart && (_inRange = true);
        _debugSlots = _comp.debugSlots;
        _debugBones = _comp.debugBones;
        _debugMesh = _comp.debugMesh;
        if (graphics && (_debugBones || _debugSlots || _debugMesh)) {
          graphics.clear();
          graphics.lineWidth = 2;
        }
        _perClipVertexSize = _useTint ? _useMulti ? 16 : 12 : _useMulti ? 12 : 8;
        _vertexFloatCount = 0;
        _vertexFloatOffset = 0;
        _vertexOffset = 0;
        _indexCount = 0;
        _indexOffset = 0;
        for (var slotIdx = 0, slotCount = locSkeleton.drawOrder.length; slotIdx < slotCount; slotIdx++) {
          slot = locSkeleton.drawOrder[slotIdx];
          if (void 0 == slot || !slot.bone.active) continue;
          _slotRangeStart >= 0 && _slotRangeStart == slot.data.index && (_inRange = true);
          if (!_inRange) {
            clipper.clipEndWithSlot(slot);
            continue;
          }
          _slotRangeEnd >= 0 && _slotRangeEnd == slot.data.index && (_inRange = false);
          _vertexFloatCount = 0;
          _indexCount = 0;
          attachment = slot.getAttachment();
          if (!attachment) {
            clipper.clipEndWithSlot(slot);
            continue;
          }
          isRegion = attachment instanceof spine.RegionAttachment;
          isMesh = attachment instanceof spine.MeshAttachment;
          isClip = attachment instanceof spine.ClippingAttachment;
          if (isClip) {
            clipper.clipStart(slot, attachment);
            continue;
          }
          if (!isRegion && !isMesh) {
            clipper.clipEndWithSlot(slot);
            continue;
          }
          material = _getSlotMaterial(attachment.region.texture._texture, slot.data.blendMode);
          if (!material) {
            clipper.clipEndWithSlot(slot);
            continue;
          }
          if (_mustFlush || material.getHash() !== _renderer.material.getHash()) {
            _mustFlush = false;
            _renderer._flush();
            _renderer.node = _node;
            _renderer.material = material;
          }
          if (isRegion) {
            triangles = _quadTriangles;
            _vertexFloatCount = 4 * _perVertexSize;
            _indexCount = 6;
            offsetInfo = _buffer.requestForSpine(4, 6);
            _indexOffset = offsetInfo.indiceOffset, _vertexOffset = offsetInfo.vertexOffset, 
            _vertexFloatOffset = offsetInfo.byteOffset >> 2;
            vbuf = _buffer._vData, ibuf = _buffer._iData;
            attachment.computeWorldVertices(slot.bone, vbuf, _vertexFloatOffset, _perVertexSize);
            if (graphics && _debugSlots) {
              graphics.strokeColor = _slotColor;
              graphics.moveTo(vbuf[_vertexFloatOffset], vbuf[_vertexFloatOffset + 1]);
              for (var ii = _vertexFloatOffset + _perVertexSize, nn = _vertexFloatOffset + _vertexFloatCount; ii < nn; ii += _perVertexSize) graphics.lineTo(vbuf[ii], vbuf[ii + 1]);
              graphics.close();
              graphics.stroke();
            }
          } else if (isMesh) {
            triangles = attachment.triangles;
            _vertexFloatCount = (attachment.worldVerticesLength >> 1) * _perVertexSize;
            _indexCount = triangles.length;
            offsetInfo = _buffer.requestForSpine(_vertexFloatCount / _perVertexSize, _indexCount);
            _indexOffset = offsetInfo.indiceOffset, _vertexOffset = offsetInfo.vertexOffset, 
            _vertexFloatOffset = offsetInfo.byteOffset >> 2;
            vbuf = _buffer._vData, ibuf = _buffer._iData;
            attachment.computeWorldVertices(slot, 0, attachment.worldVerticesLength, vbuf, _vertexFloatOffset, _perVertexSize);
            if (graphics && _debugMesh) {
              graphics.strokeColor = _meshColor;
              for (var _ii = 0, _nn = triangles.length; _ii < _nn; _ii += 3) {
                var v1 = triangles[_ii] * _perVertexSize + _vertexFloatOffset;
                var v2 = triangles[_ii + 1] * _perVertexSize + _vertexFloatOffset;
                var v3 = triangles[_ii + 2] * _perVertexSize + _vertexFloatOffset;
                graphics.moveTo(vbuf[v1], vbuf[v1 + 1]);
                graphics.lineTo(vbuf[v2], vbuf[v2 + 1]);
                graphics.lineTo(vbuf[v3], vbuf[v3 + 1]);
                graphics.close();
                graphics.stroke();
              }
            }
          }
          if (0 == _vertexFloatCount || 0 == _indexCount) {
            clipper.clipEndWithSlot(slot);
            continue;
          }
          ibuf.set(triangles, _indexOffset);
          uvs = attachment.uvs;
          for (var v = _vertexFloatOffset, n = _vertexFloatOffset + _vertexFloatCount, u = 0; v < n; v += _perVertexSize, 
          u += 2) {
            vbuf[v + 2] = uvs[u];
            vbuf[v + 3] = uvs[u + 1];
          }
          attachmentColor = attachment.color, slotColor = slot.color;
          this.fillVertices(skeletonColor, attachmentColor, slotColor, clipper, slot);
          vbuf = _buffer._vData, ibuf = _buffer._iData;
          if (_indexCount > 0) {
            for (var _ii2 = _indexOffset, _nn2 = _indexOffset + _indexCount; _ii2 < _nn2; _ii2++) ibuf[_ii2] += _vertexOffset;
            if (worldMat) {
              worldMatm = worldMat.m;
              _m00 = worldMatm[0];
              _m04 = worldMatm[4];
              _m12 = worldMatm[12];
              _m01 = worldMatm[1];
              _m05 = worldMatm[5];
              _m13 = worldMatm[13];
              for (var _ii3 = _vertexFloatOffset, _nn3 = _vertexFloatOffset + _vertexFloatCount; _ii3 < _nn3; _ii3 += _perVertexSize) {
                _x = vbuf[_ii3];
                _y = vbuf[_ii3 + 1];
                vbuf[_ii3] = _x * _m00 + _y * _m04 + _m12;
                vbuf[_ii3 + 1] = _x * _m01 + _y * _m05 + _m13;
              }
            }
            _buffer.adjustForSpine(_vertexFloatCount / _perVertexSize, _indexCount);
          }
          clipper.clipEndWithSlot(slot);
        }
        clipper.clipEnd();
        if (graphics && _debugBones) {
          var bone;
          graphics.strokeColor = _boneColor;
          graphics.fillColor = _slotColor;
          for (var i = 0, _n4 = locSkeleton.bones.length; i < _n4; i++) {
            bone = locSkeleton.bones[i];
            var x = bone.data.length * bone.a + bone.worldX;
            var y = bone.data.length * bone.c + bone.worldY;
            graphics.moveTo(bone.worldX, bone.worldY);
            graphics.lineTo(x, y);
            graphics.stroke();
            graphics.circle(bone.worldX, bone.worldY, 1.5 * Math.PI);
            graphics.fill();
            0 === i && (graphics.fillColor = _originColor);
          }
        }
      };
      _proto.cacheVerticesConvertToMulti = function cacheVerticesConvertToMulti(vertices) {
        var verticesMulti = new Float32Array(vertices.length + vertices.length / 6);
        for (var i = 0, j = 0; j < vertices.length; ) {
          verticesMulti[i++] = vertices[j++];
          verticesMulti[i++] = vertices[j++];
          verticesMulti[i++] = vertices[j++];
          verticesMulti[i++] = vertices[j++];
          verticesMulti[i++] = vertices[j++];
          verticesMulti[i++] = vertices[j++];
          verticesMulti[i++] = 0;
        }
        return verticesMulti;
      };
      _proto.cacheTraverse = function cacheTraverse(worldMat) {
        var frame = _comp._curFrame;
        if (!frame) return;
        var segments = frame.segments;
        if (0 == segments.length) return;
        var vbuf, ibuf, uintbuf;
        var material;
        var offsetInfo;
        var vertices = frame.vertices;
        var indices = frame.indices;
        var worldMatm;
        var useMultiTint = _useMulti && _useTint;
        if (useMultiTint) {
          frame.verticesMulti || (frame.verticesMulti = this.cacheVerticesConvertToMulti(frame.vertices));
          vertices = frame.verticesMulti;
        }
        var frameVFOffset = 0, frameIndexOffset = 0, segVFCount = 0;
        if (worldMat) {
          worldMatm = worldMat.m;
          _m00 = worldMatm[0];
          _m01 = worldMatm[1];
          _m04 = worldMatm[4];
          _m05 = worldMatm[5];
          _m12 = worldMatm[12];
          _m13 = worldMatm[13];
        }
        var justTranslate = 1 === _m00 && 0 === _m01 && 0 === _m04 && 1 === _m05;
        var needBatch = _handleVal & FLAG_BATCH;
        var calcTranslate = needBatch && justTranslate;
        var colorOffset = 0;
        var colors = frame.colors;
        var nowColor = colors[colorOffset++];
        var maxVFOffset = useMultiTint ? nowColor.vfOffset + nowColor.vfOffset / 6 : nowColor.vfOffset;
        _handleColor(nowColor);
        for (var i = 0, n = segments.length; i < n; i++) {
          var segInfo = segments[i];
          material = _getSlotMaterial(segInfo.tex, segInfo.blendMode);
          if (!material) continue;
          if (_mustFlush || material.getHash() !== _renderer.material.getHash()) {
            _mustFlush = false;
            _renderer._flush();
            _renderer.node = _node;
            _renderer.material = material;
          }
          _vertexCount = segInfo.vertexCount;
          _indexCount = segInfo.indexCount;
          offsetInfo = _buffer.requestForSpine(_vertexCount, _indexCount);
          _indexOffset = offsetInfo.indiceOffset;
          _vertexOffset = offsetInfo.vertexOffset;
          _vfOffset = offsetInfo.byteOffset >> 2;
          vbuf = _buffer._vData;
          ibuf = _buffer._iData;
          uintbuf = _buffer._uintVData;
          for (var ii = _indexOffset, il = _indexOffset + _indexCount; ii < il; ii++) ibuf[ii] = _vertexOffset + indices[frameIndexOffset++];
          segVFCount = useMultiTint ? segInfo.vfCount + segInfo.vfCount / 6 : segInfo.vfCount;
          vbuf.set(vertices.subarray(frameVFOffset, frameVFOffset + segVFCount), _vfOffset);
          frameVFOffset += segVFCount;
          if (calcTranslate) for (var _ii4 = _vfOffset, _il = _vfOffset + segVFCount; _ii4 < _il; _ii4 += _perVertexSize) {
            vbuf[_ii4] += _m12;
            vbuf[_ii4 + 1] += _m13;
          } else if (needBatch) for (var _ii5 = _vfOffset, _il2 = _vfOffset + segVFCount; _ii5 < _il2; _ii5 += _perVertexSize) {
            _x = vbuf[_ii5];
            _y = vbuf[_ii5 + 1];
            vbuf[_ii5] = _x * _m00 + _y * _m04 + _m12;
            vbuf[_ii5 + 1] = _x * _m01 + _y * _m05 + _m13;
          }
          _buffer.adjustForSpine(_vertexCount, _indexCount);
          if (_useMulti) if (_useTint) if (_needColor) {
            var frameColorOffset = frameVFOffset - segVFCount;
            for (var _ii6 = _vfOffset + 4, _il3 = _vfOffset + 4 + segVFCount; _ii6 < _il3; _ii6 += _perVertexSize, 
            frameColorOffset += _perVertexSize) {
              if (frameColorOffset >= maxVFOffset) {
                nowColor = colors[colorOffset++];
                _handleColor(nowColor);
                maxVFOffset = useMultiTint ? nowColor.vfOffset + nowColor.vfOffset / 6 : nowColor.vfOffset;
              }
              uintbuf[_ii6] = _finalColor32;
              uintbuf[_ii6 + 1] = _darkColor32;
              vbuf[_ii6 + 2] = _texId;
            }
          } else for (var _ii7 = _vfOffset + 4, _il4 = _vfOffset + 4 + segVFCount; _ii7 < _il4; _ii7 += _perVertexSize) vbuf[_ii7 + 2] = _texId; else if (_needColor) {
            var _frameColorOffset = frameVFOffset - segVFCount;
            for (var _ii8 = _vfOffset + 4, _il5 = _vfOffset + 4 + segVFCount; _ii8 < _il5; _ii8 += _perVertexSize, 
            _frameColorOffset += _perVertexSize) {
              if (_frameColorOffset >= maxVFOffset) {
                nowColor = colors[colorOffset++];
                _handleColor(nowColor);
                maxVFOffset = useMultiTint ? nowColor.vfOffset + nowColor.vfOffset / 6 : nowColor.vfOffset;
              }
              uintbuf[_ii8] = _finalColor32;
              vbuf[_ii8 + 1] = _texId;
            }
          } else for (var _ii9 = _vfOffset + 4, _il6 = _vfOffset + 4 + segVFCount; _ii9 < _il6; _ii9 += _perVertexSize) vbuf[_ii9 + 1] = _texId; else if (_needColor) {
            var _frameColorOffset2 = frameVFOffset - segVFCount;
            for (var _ii10 = _vfOffset + 4, _il7 = _vfOffset + 4 + segVFCount; _ii10 < _il7; _ii10 += _perVertexSize, 
            _frameColorOffset2 += _perVertexSize) {
              if (_frameColorOffset2 >= maxVFOffset) {
                nowColor = colors[colorOffset++];
                _handleColor(nowColor);
                maxVFOffset = useMultiTint ? nowColor.vfOffset + nowColor.vfOffset / 6 : nowColor.vfOffset;
              }
              uintbuf[_ii10] = _finalColor32;
              uintbuf[_ii10 + 1] = _darkColor32;
            }
          }
        }
      };
      _proto.fillBuffers = function fillBuffers(comp, renderer) {
        var node = comp.node;
        node._renderFlag |= RenderFlow.FLAG_UPDATE_RENDER_DATA;
        if (!comp._skeleton) return;
        var nodeColor = node._color;
        _nodeR = nodeColor.r / 255;
        _nodeG = nodeColor.g / 255;
        _nodeB = nodeColor.b / 255;
        _nodeA = nodeColor.a / 255;
        var baseMaterial = comp._materials[0];
        if (!baseMaterial) return;
        _useMulti = baseMaterial.material.isMultiSupport();
        _useTint = comp.useTint;
        _vertexFormat = _useTint ? _useMulti ? VFTwoColorTexId : VFTwoColor : _useMulti ? VFOneColorTexId : comp.isAnimationCached() ? VFTwoColor : VFOneColor;
        _perVertexSize = _useTint ? _useMulti ? 7 : 6 : _useMulti ? 6 : comp.isAnimationCached() ? 6 : 5;
        _node = comp.node;
        _buffer = renderer.getBuffer("mesh", _vertexFormat);
        _renderer = renderer;
        _comp = comp;
        _mustFlush = true;
        _premultipliedAlpha = comp.premultipliedAlpha;
        _multiplier = 1;
        _handleVal = 0;
        _needColor = false;
        _vertexEffect = comp._effectDelegate && comp._effectDelegate._vertexEffect;
        (4294967295 !== nodeColor._val || _premultipliedAlpha) && (_needColor = true);
        _useTint && (_handleVal |= FLAG_TWO_COLOR);
        var worldMat = void 0;
        if (_comp.enableBatch) {
          worldMat = _node._worldMatrix;
          _mustFlush = false;
          _handleVal |= FLAG_BATCH;
        }
        if (comp.isAnimationCached()) this.cacheTraverse(worldMat); else {
          _vertexEffect && _vertexEffect.begin(comp._skeleton);
          this.realTimeTraverse(worldMat);
          _vertexEffect && _vertexEffect.end();
        }
        renderer.worldMatDirty++;
        comp.attachUtil._syncAttachedNode();
        _node = void 0;
        _buffer = void 0;
        _renderer = void 0;
        _comp = void 0;
        _vertexEffect = null;
      };
      _proto.postFillBuffers = function postFillBuffers(comp, renderer) {
        renderer.worldMatDirty--;
      };
      return SpineAssembler;
    })(_assembler["default"]);
    exports["default"] = SpineAssembler;
    _assembler["default"].register(Skeleton, SpineAssembler);
    module.exports = exports["default"];
  }), {
    "../../cocos2d/core/renderer/assembler": 302,
    "../../cocos2d/core/renderer/render-flow": 323,
    "../../cocos2d/core/renderer/webgl/vertex-format": 371,
    "./Skeleton": 456,
    "./lib/spine": void 0
  } ],
  461: [ (function(require, module, exports) {
    "use strict";
    var TrackEntryListeners = function TrackEntryListeners() {
      this.start = null;
      this.end = null;
      this.complete = null;
      this.event = null;
      this.interrupt = null;
      this.dispose = null;
    };
    TrackEntryListeners.getListeners = function(entry) {
      entry.listener || (entry.listener = new TrackEntryListeners());
      return entry.listener;
    };
    module.exports = TrackEntryListeners;
  }), {} ],
  462: [ (function(require, module, exports) {
    "use strict";
    (function(global, factory) {
      "object" === typeof exports && "undefined" !== typeof module ? factory(exports) : "function" === typeof define && define.amd ? define([ "exports" ], factory) : factory(global.box2d = {});
    })(void 0, (function(exports) {
      function b2Assert(condition) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
        if (!condition) throw new (Error.bind.apply(Error, [ void 0 ].concat(args)))();
      }
      function b2Maybe(value, def) {
        return void 0 !== value ? value : def;
      }
      var b2_maxFloat = 1e37;
      var b2_epsilon = 1e-5;
      var b2_epsilon_sq = b2_epsilon * b2_epsilon;
      var b2_pi = 3.14159265359;
      var b2_maxManifoldPoints = 2;
      var b2_maxPolygonVertices = 8;
      var b2_aabbExtension = .1;
      var b2_aabbMultiplier = 2;
      var b2_linearSlop = .008;
      var b2_angularSlop = 2 / 180 * b2_pi;
      var b2_polygonRadius = 2 * b2_linearSlop;
      var b2_maxSubSteps = 8;
      var b2_maxTOIContacts = 32;
      var b2_velocityThreshold = 1;
      var b2_maxLinearCorrection = .2;
      var b2_maxAngularCorrection = 8 / 180 * b2_pi;
      var b2_maxTranslation = 2;
      var b2_maxTranslationSquared = b2_maxTranslation * b2_maxTranslation;
      var b2_maxRotation = .5 * b2_pi;
      var b2_maxRotationSquared = b2_maxRotation * b2_maxRotation;
      var b2_baumgarte = .2;
      var b2_toiBaumgarte = .75;
      var b2_invalidParticleIndex = -1;
      var b2_maxParticleIndex = 2147483647;
      var b2_particleStride = .75;
      var b2_minParticleWeight = 1;
      var b2_maxParticlePressure = .25;
      var b2_maxParticleForce = .5;
      var b2_maxTriadDistance = 2;
      var b2_maxTriadDistanceSquared = b2_maxTriadDistance * b2_maxTriadDistance;
      var b2_minParticleSystemBufferCapacity = 256;
      var b2_barrierCollisionTime = 2.5;
      var b2_timeToSleep = .5;
      var b2_linearSleepTolerance = .01;
      var b2_angularSleepTolerance = 2 / 180 * b2_pi;
      function b2Alloc(size) {
        return null;
      }
      function b2Free(mem) {}
      function b2Log(message) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
      }
      var b2Version = (function() {
        function b2Version(major, minor, revision) {
          void 0 === major && (major = 0);
          void 0 === minor && (minor = 0);
          void 0 === revision && (revision = 0);
          this.major = 0;
          this.minor = 0;
          this.revision = 0;
          this.major = major;
          this.minor = minor;
          this.revision = revision;
        }
        b2Version.prototype.toString = function() {
          return this.major + "." + this.minor + "." + this.revision;
        };
        return b2Version;
      })();
      var b2_version = new b2Version(2, 3, 2);
      var b2_branch = "master";
      var b2_commit = "fbf51801d80fc389d43dc46524520e89043b6faf";
      function b2ParseInt(v) {
        return parseInt(v, 10);
      }
      function b2ParseUInt(v) {
        return Math.abs(parseInt(v, 10));
      }
      function b2MakeArray(length, init) {
        var a = [];
        for (var i = 0; i < length; ++i) a.push(init(i));
        return a;
      }
      function b2MakeNullArray(length) {
        var a = [];
        for (var i = 0; i < length; ++i) a.push(null);
        return a;
      }
      function b2MakeNumberArray(length, init) {
        void 0 === init && (init = 0);
        var a = [];
        for (var i = 0; i < length; ++i) a.push(init);
        return a;
      }
      var b2_pi_over_180 = b2_pi / 180;
      var b2_180_over_pi = 180 / b2_pi;
      var b2_two_pi = 2 * b2_pi;
      var b2Abs = Math.abs;
      var b2Min = Math.min;
      var b2Max = Math.max;
      function b2Clamp(a, lo, hi) {
        return a < lo ? lo : a > hi ? hi : a;
      }
      function b2Swap(a, b) {
        var tmp = a[0];
        a[0] = b[0];
        b[0] = tmp;
      }
      var b2IsValid = isFinite;
      function b2Sq(n) {
        return n * n;
      }
      function b2InvSqrt(n) {
        return 1 / Math.sqrt(n);
      }
      var b2Sqrt = Math.sqrt;
      var b2Pow = Math.pow;
      function b2DegToRad(degrees) {
        return degrees * b2_pi_over_180;
      }
      function b2RadToDeg(radians) {
        return radians * b2_180_over_pi;
      }
      var b2Cos = Math.cos;
      var b2Sin = Math.sin;
      var b2Acos = Math.acos;
      var b2Asin = Math.asin;
      var b2Atan2 = Math.atan2;
      function b2NextPowerOfTwo(x) {
        x |= x >> 1 & 2147483647;
        x |= x >> 2 & 1073741823;
        x |= x >> 4 & 268435455;
        x |= x >> 8 & 16777215;
        x |= x >> 16 & 65535;
        return x + 1;
      }
      function b2IsPowerOfTwo(x) {
        return x > 0 && 0 === (x & x - 1);
      }
      function b2Random() {
        return 2 * Math.random() - 1;
      }
      function b2RandomRange(lo, hi) {
        return (hi - lo) * Math.random() + lo;
      }
      var b2Vec2 = (function() {
        function b2Vec2(x, y) {
          void 0 === x && (x = 0);
          void 0 === y && (y = 0);
          this.x = x;
          this.y = y;
        }
        b2Vec2.prototype.Clone = function() {
          return new b2Vec2(this.x, this.y);
        };
        b2Vec2.prototype.SetZero = function() {
          this.x = 0;
          this.y = 0;
          return this;
        };
        b2Vec2.prototype.Set = function(x, y) {
          this.x = x;
          this.y = y;
          return this;
        };
        b2Vec2.prototype.Copy = function(other) {
          this.x = other.x;
          this.y = other.y;
          return this;
        };
        b2Vec2.prototype.SelfAdd = function(v) {
          this.x += v.x;
          this.y += v.y;
          return this;
        };
        b2Vec2.prototype.SelfAddXY = function(x, y) {
          this.x += x;
          this.y += y;
          return this;
        };
        b2Vec2.prototype.SelfSub = function(v) {
          this.x -= v.x;
          this.y -= v.y;
          return this;
        };
        b2Vec2.prototype.SelfSubXY = function(x, y) {
          this.x -= x;
          this.y -= y;
          return this;
        };
        b2Vec2.prototype.SelfMul = function(s) {
          this.x *= s;
          this.y *= s;
          return this;
        };
        b2Vec2.prototype.SelfMulAdd = function(s, v) {
          this.x += s * v.x;
          this.y += s * v.y;
          return this;
        };
        b2Vec2.prototype.SelfMulSub = function(s, v) {
          this.x -= s * v.x;
          this.y -= s * v.y;
          return this;
        };
        b2Vec2.prototype.Dot = function(v) {
          return this.x * v.x + this.y * v.y;
        };
        b2Vec2.prototype.Cross = function(v) {
          return this.x * v.y - this.y * v.x;
        };
        b2Vec2.prototype.Length = function() {
          var x = this.x, y = this.y;
          return Math.sqrt(x * x + y * y);
        };
        b2Vec2.prototype.LengthSquared = function() {
          var x = this.x, y = this.y;
          return x * x + y * y;
        };
        b2Vec2.prototype.Normalize = function() {
          var length = this.Length();
          if (length >= b2_epsilon) {
            var inv_length = 1 / length;
            this.x *= inv_length;
            this.y *= inv_length;
          }
          return length;
        };
        b2Vec2.prototype.SelfNormalize = function() {
          var length = this.Length();
          if (length >= b2_epsilon) {
            var inv_length = 1 / length;
            this.x *= inv_length;
            this.y *= inv_length;
          }
          return this;
        };
        b2Vec2.prototype.SelfRotate = function(radians) {
          var c = Math.cos(radians);
          var s = Math.sin(radians);
          var x = this.x;
          this.x = c * x - s * this.y;
          this.y = s * x + c * this.y;
          return this;
        };
        b2Vec2.prototype.IsValid = function() {
          return isFinite(this.x) && isFinite(this.y);
        };
        b2Vec2.prototype.SelfCrossVS = function(s) {
          var x = this.x;
          this.x = s * this.y;
          this.y = -s * x;
          return this;
        };
        b2Vec2.prototype.SelfCrossSV = function(s) {
          var x = this.x;
          this.x = -s * this.y;
          this.y = s * x;
          return this;
        };
        b2Vec2.prototype.SelfMinV = function(v) {
          this.x = b2Min(this.x, v.x);
          this.y = b2Min(this.y, v.y);
          return this;
        };
        b2Vec2.prototype.SelfMaxV = function(v) {
          this.x = b2Max(this.x, v.x);
          this.y = b2Max(this.y, v.y);
          return this;
        };
        b2Vec2.prototype.SelfAbs = function() {
          this.x = b2Abs(this.x);
          this.y = b2Abs(this.y);
          return this;
        };
        b2Vec2.prototype.SelfNeg = function() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        };
        b2Vec2.prototype.SelfSkew = function() {
          var x = this.x;
          this.x = -this.y;
          this.y = x;
          return this;
        };
        b2Vec2.MakeArray = function(length) {
          return b2MakeArray(length, (function(i) {
            return new b2Vec2();
          }));
        };
        b2Vec2.AbsV = function(v, out) {
          out.x = b2Abs(v.x);
          out.y = b2Abs(v.y);
          return out;
        };
        b2Vec2.MinV = function(a, b, out) {
          out.x = b2Min(a.x, b.x);
          out.y = b2Min(a.y, b.y);
          return out;
        };
        b2Vec2.MaxV = function(a, b, out) {
          out.x = b2Max(a.x, b.x);
          out.y = b2Max(a.y, b.y);
          return out;
        };
        b2Vec2.ClampV = function(v, lo, hi, out) {
          out.x = b2Clamp(v.x, lo.x, hi.x);
          out.y = b2Clamp(v.y, lo.y, hi.y);
          return out;
        };
        b2Vec2.RotateV = function(v, radians, out) {
          var v_x = v.x, v_y = v.y;
          var c = Math.cos(radians);
          var s = Math.sin(radians);
          out.x = c * v_x - s * v_y;
          out.y = s * v_x + c * v_y;
          return out;
        };
        b2Vec2.DotVV = function(a, b) {
          return a.x * b.x + a.y * b.y;
        };
        b2Vec2.CrossVV = function(a, b) {
          return a.x * b.y - a.y * b.x;
        };
        b2Vec2.CrossVS = function(v, s, out) {
          var v_x = v.x;
          out.x = s * v.y;
          out.y = -s * v_x;
          return out;
        };
        b2Vec2.CrossVOne = function(v, out) {
          var v_x = v.x;
          out.x = v.y;
          out.y = -v_x;
          return out;
        };
        b2Vec2.CrossSV = function(s, v, out) {
          var v_x = v.x;
          out.x = -s * v.y;
          out.y = s * v_x;
          return out;
        };
        b2Vec2.CrossOneV = function(v, out) {
          var v_x = v.x;
          out.x = -v.y;
          out.y = v_x;
          return out;
        };
        b2Vec2.AddVV = function(a, b, out) {
          out.x = a.x + b.x;
          out.y = a.y + b.y;
          return out;
        };
        b2Vec2.SubVV = function(a, b, out) {
          out.x = a.x - b.x;
          out.y = a.y - b.y;
          return out;
        };
        b2Vec2.MulSV = function(s, v, out) {
          out.x = v.x * s;
          out.y = v.y * s;
          return out;
        };
        b2Vec2.MulVS = function(v, s, out) {
          out.x = v.x * s;
          out.y = v.y * s;
          return out;
        };
        b2Vec2.AddVMulSV = function(a, s, b, out) {
          out.x = a.x + s * b.x;
          out.y = a.y + s * b.y;
          return out;
        };
        b2Vec2.SubVMulSV = function(a, s, b, out) {
          out.x = a.x - s * b.x;
          out.y = a.y - s * b.y;
          return out;
        };
        b2Vec2.AddVCrossSV = function(a, s, v, out) {
          var v_x = v.x;
          out.x = a.x - s * v.y;
          out.y = a.y + s * v_x;
          return out;
        };
        b2Vec2.MidVV = function(a, b, out) {
          out.x = .5 * (a.x + b.x);
          out.y = .5 * (a.y + b.y);
          return out;
        };
        b2Vec2.ExtVV = function(a, b, out) {
          out.x = .5 * (b.x - a.x);
          out.y = .5 * (b.y - a.y);
          return out;
        };
        b2Vec2.IsEqualToV = function(a, b) {
          return a.x === b.x && a.y === b.y;
        };
        b2Vec2.DistanceVV = function(a, b) {
          var c_x = a.x - b.x;
          var c_y = a.y - b.y;
          return Math.sqrt(c_x * c_x + c_y * c_y);
        };
        b2Vec2.DistanceSquaredVV = function(a, b) {
          var c_x = a.x - b.x;
          var c_y = a.y - b.y;
          return c_x * c_x + c_y * c_y;
        };
        b2Vec2.NegV = function(v, out) {
          out.x = -v.x;
          out.y = -v.y;
          return out;
        };
        b2Vec2.ZERO = new b2Vec2(0, 0);
        b2Vec2.UNITX = new b2Vec2(1, 0);
        b2Vec2.UNITY = new b2Vec2(0, 1);
        b2Vec2.s_t0 = new b2Vec2();
        b2Vec2.s_t1 = new b2Vec2();
        b2Vec2.s_t2 = new b2Vec2();
        b2Vec2.s_t3 = new b2Vec2();
        return b2Vec2;
      })();
      var b2Vec2_zero = new b2Vec2(0, 0);
      var b2Vec3 = (function() {
        function b2Vec3(x, y, z) {
          void 0 === x && (x = 0);
          void 0 === y && (y = 0);
          void 0 === z && (z = 0);
          this.x = x;
          this.y = y;
          this.z = z;
        }
        b2Vec3.prototype.Clone = function() {
          return new b2Vec3(this.x, this.y, this.z);
        };
        b2Vec3.prototype.SetZero = function() {
          this.x = 0;
          this.y = 0;
          this.z = 0;
          return this;
        };
        b2Vec3.prototype.SetXYZ = function(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
          return this;
        };
        b2Vec3.prototype.Copy = function(other) {
          this.x = other.x;
          this.y = other.y;
          this.z = other.z;
          return this;
        };
        b2Vec3.prototype.SelfNeg = function() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        };
        b2Vec3.prototype.SelfAdd = function(v) {
          this.x += v.x;
          this.y += v.y;
          this.z += v.z;
          return this;
        };
        b2Vec3.prototype.SelfAddXYZ = function(x, y, z) {
          this.x += x;
          this.y += y;
          this.z += z;
          return this;
        };
        b2Vec3.prototype.SelfSub = function(v) {
          this.x -= v.x;
          this.y -= v.y;
          this.z -= v.z;
          return this;
        };
        b2Vec3.prototype.SelfSubXYZ = function(x, y, z) {
          this.x -= x;
          this.y -= y;
          this.z -= z;
          return this;
        };
        b2Vec3.prototype.SelfMul = function(s) {
          this.x *= s;
          this.y *= s;
          this.z *= s;
          return this;
        };
        b2Vec3.DotV3V3 = function(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z;
        };
        b2Vec3.CrossV3V3 = function(a, b, out) {
          var a_x = a.x, a_y = a.y, a_z = a.z;
          var b_x = b.x, b_y = b.y, b_z = b.z;
          out.x = a_y * b_z - a_z * b_y;
          out.y = a_z * b_x - a_x * b_z;
          out.z = a_x * b_y - a_y * b_x;
          return out;
        };
        b2Vec3.ZERO = new b2Vec3(0, 0, 0);
        b2Vec3.s_t0 = new b2Vec3();
        return b2Vec3;
      })();
      var b2Mat22 = (function() {
        function b2Mat22() {
          this.ex = new b2Vec2(1, 0);
          this.ey = new b2Vec2(0, 1);
        }
        b2Mat22.prototype.Clone = function() {
          return new b2Mat22().Copy(this);
        };
        b2Mat22.FromVV = function(c1, c2) {
          return new b2Mat22().SetVV(c1, c2);
        };
        b2Mat22.FromSSSS = function(r1c1, r1c2, r2c1, r2c2) {
          return new b2Mat22().SetSSSS(r1c1, r1c2, r2c1, r2c2);
        };
        b2Mat22.FromAngle = function(radians) {
          return new b2Mat22().SetAngle(radians);
        };
        b2Mat22.prototype.SetSSSS = function(r1c1, r1c2, r2c1, r2c2) {
          this.ex.Set(r1c1, r2c1);
          this.ey.Set(r1c2, r2c2);
          return this;
        };
        b2Mat22.prototype.SetVV = function(c1, c2) {
          this.ex.Copy(c1);
          this.ey.Copy(c2);
          return this;
        };
        b2Mat22.prototype.SetAngle = function(radians) {
          var c = Math.cos(radians);
          var s = Math.sin(radians);
          this.ex.Set(c, s);
          this.ey.Set(-s, c);
          return this;
        };
        b2Mat22.prototype.Copy = function(other) {
          this.ex.Copy(other.ex);
          this.ey.Copy(other.ey);
          return this;
        };
        b2Mat22.prototype.SetIdentity = function() {
          this.ex.Set(1, 0);
          this.ey.Set(0, 1);
          return this;
        };
        b2Mat22.prototype.SetZero = function() {
          this.ex.SetZero();
          this.ey.SetZero();
          return this;
        };
        b2Mat22.prototype.GetAngle = function() {
          return Math.atan2(this.ex.y, this.ex.x);
        };
        b2Mat22.prototype.GetInverse = function(out) {
          var a = this.ex.x;
          var b = this.ey.x;
          var c = this.ex.y;
          var d = this.ey.y;
          var det = a * d - b * c;
          0 !== det && (det = 1 / det);
          out.ex.x = det * d;
          out.ey.x = -det * b;
          out.ex.y = -det * c;
          out.ey.y = det * a;
          return out;
        };
        b2Mat22.prototype.Solve = function(b_x, b_y, out) {
          var a11 = this.ex.x, a12 = this.ey.x;
          var a21 = this.ex.y, a22 = this.ey.y;
          var det = a11 * a22 - a12 * a21;
          0 !== det && (det = 1 / det);
          out.x = det * (a22 * b_x - a12 * b_y);
          out.y = det * (a11 * b_y - a21 * b_x);
          return out;
        };
        b2Mat22.prototype.SelfAbs = function() {
          this.ex.SelfAbs();
          this.ey.SelfAbs();
          return this;
        };
        b2Mat22.prototype.SelfInv = function() {
          this.GetInverse(this);
          return this;
        };
        b2Mat22.prototype.SelfAddM = function(M) {
          this.ex.SelfAdd(M.ex);
          this.ey.SelfAdd(M.ey);
          return this;
        };
        b2Mat22.prototype.SelfSubM = function(M) {
          this.ex.SelfSub(M.ex);
          this.ey.SelfSub(M.ey);
          return this;
        };
        b2Mat22.AbsM = function(M, out) {
          var M_ex = M.ex, M_ey = M.ey;
          out.ex.x = b2Abs(M_ex.x);
          out.ex.y = b2Abs(M_ex.y);
          out.ey.x = b2Abs(M_ey.x);
          out.ey.y = b2Abs(M_ey.y);
          return out;
        };
        b2Mat22.MulMV = function(M, v, out) {
          var M_ex = M.ex, M_ey = M.ey;
          var v_x = v.x, v_y = v.y;
          out.x = M_ex.x * v_x + M_ey.x * v_y;
          out.y = M_ex.y * v_x + M_ey.y * v_y;
          return out;
        };
        b2Mat22.MulTMV = function(M, v, out) {
          var M_ex = M.ex, M_ey = M.ey;
          var v_x = v.x, v_y = v.y;
          out.x = M_ex.x * v_x + M_ex.y * v_y;
          out.y = M_ey.x * v_x + M_ey.y * v_y;
          return out;
        };
        b2Mat22.AddMM = function(A, B, out) {
          var A_ex = A.ex, A_ey = A.ey;
          var B_ex = B.ex, B_ey = B.ey;
          out.ex.x = A_ex.x + B_ex.x;
          out.ex.y = A_ex.y + B_ex.y;
          out.ey.x = A_ey.x + B_ey.x;
          out.ey.y = A_ey.y + B_ey.y;
          return out;
        };
        b2Mat22.MulMM = function(A, B, out) {
          var A_ex_x = A.ex.x, A_ex_y = A.ex.y;
          var A_ey_x = A.ey.x, A_ey_y = A.ey.y;
          var B_ex_x = B.ex.x, B_ex_y = B.ex.y;
          var B_ey_x = B.ey.x, B_ey_y = B.ey.y;
          out.ex.x = A_ex_x * B_ex_x + A_ey_x * B_ex_y;
          out.ex.y = A_ex_y * B_ex_x + A_ey_y * B_ex_y;
          out.ey.x = A_ex_x * B_ey_x + A_ey_x * B_ey_y;
          out.ey.y = A_ex_y * B_ey_x + A_ey_y * B_ey_y;
          return out;
        };
        b2Mat22.MulTMM = function(A, B, out) {
          var A_ex_x = A.ex.x, A_ex_y = A.ex.y;
          var A_ey_x = A.ey.x, A_ey_y = A.ey.y;
          var B_ex_x = B.ex.x, B_ex_y = B.ex.y;
          var B_ey_x = B.ey.x, B_ey_y = B.ey.y;
          out.ex.x = A_ex_x * B_ex_x + A_ex_y * B_ex_y;
          out.ex.y = A_ey_x * B_ex_x + A_ey_y * B_ex_y;
          out.ey.x = A_ex_x * B_ey_x + A_ex_y * B_ey_y;
          out.ey.y = A_ey_x * B_ey_x + A_ey_y * B_ey_y;
          return out;
        };
        b2Mat22.IDENTITY = new b2Mat22();
        return b2Mat22;
      })();
      var b2Mat33 = (function() {
        function b2Mat33() {
          this.ex = new b2Vec3(1, 0, 0);
          this.ey = new b2Vec3(0, 1, 0);
          this.ez = new b2Vec3(0, 0, 1);
        }
        b2Mat33.prototype.Clone = function() {
          return new b2Mat33().Copy(this);
        };
        b2Mat33.prototype.SetVVV = function(c1, c2, c3) {
          this.ex.Copy(c1);
          this.ey.Copy(c2);
          this.ez.Copy(c3);
          return this;
        };
        b2Mat33.prototype.Copy = function(other) {
          this.ex.Copy(other.ex);
          this.ey.Copy(other.ey);
          this.ez.Copy(other.ez);
          return this;
        };
        b2Mat33.prototype.SetIdentity = function() {
          this.ex.SetXYZ(1, 0, 0);
          this.ey.SetXYZ(0, 1, 0);
          this.ez.SetXYZ(0, 0, 1);
          return this;
        };
        b2Mat33.prototype.SetZero = function() {
          this.ex.SetZero();
          this.ey.SetZero();
          this.ez.SetZero();
          return this;
        };
        b2Mat33.prototype.SelfAddM = function(M) {
          this.ex.SelfAdd(M.ex);
          this.ey.SelfAdd(M.ey);
          this.ez.SelfAdd(M.ez);
          return this;
        };
        b2Mat33.prototype.Solve33 = function(b_x, b_y, b_z, out) {
          var a11 = this.ex.x, a21 = this.ex.y, a31 = this.ex.z;
          var a12 = this.ey.x, a22 = this.ey.y, a32 = this.ey.z;
          var a13 = this.ez.x, a23 = this.ez.y, a33 = this.ez.z;
          var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);
          0 !== det && (det = 1 / det);
          out.x = det * (b_x * (a22 * a33 - a32 * a23) + b_y * (a32 * a13 - a12 * a33) + b_z * (a12 * a23 - a22 * a13));
          out.y = det * (a11 * (b_y * a33 - b_z * a23) + a21 * (b_z * a13 - b_x * a33) + a31 * (b_x * a23 - b_y * a13));
          out.z = det * (a11 * (a22 * b_z - a32 * b_y) + a21 * (a32 * b_x - a12 * b_z) + a31 * (a12 * b_y - a22 * b_x));
          return out;
        };
        b2Mat33.prototype.Solve22 = function(b_x, b_y, out) {
          var a11 = this.ex.x, a12 = this.ey.x;
          var a21 = this.ex.y, a22 = this.ey.y;
          var det = a11 * a22 - a12 * a21;
          0 !== det && (det = 1 / det);
          out.x = det * (a22 * b_x - a12 * b_y);
          out.y = det * (a11 * b_y - a21 * b_x);
          return out;
        };
        b2Mat33.prototype.GetInverse22 = function(M) {
          var a = this.ex.x, b = this.ey.x, c = this.ex.y, d = this.ey.y;
          var det = a * d - b * c;
          0 !== det && (det = 1 / det);
          M.ex.x = det * d;
          M.ey.x = -det * b;
          M.ex.z = 0;
          M.ex.y = -det * c;
          M.ey.y = det * a;
          M.ey.z = 0;
          M.ez.x = 0;
          M.ez.y = 0;
          M.ez.z = 0;
        };
        b2Mat33.prototype.GetSymInverse33 = function(M) {
          var det = b2Vec3.DotV3V3(this.ex, b2Vec3.CrossV3V3(this.ey, this.ez, b2Vec3.s_t0));
          0 !== det && (det = 1 / det);
          var a11 = this.ex.x, a12 = this.ey.x, a13 = this.ez.x;
          var a22 = this.ey.y, a23 = this.ez.y;
          var a33 = this.ez.z;
          M.ex.x = det * (a22 * a33 - a23 * a23);
          M.ex.y = det * (a13 * a23 - a12 * a33);
          M.ex.z = det * (a12 * a23 - a13 * a22);
          M.ey.x = M.ex.y;
          M.ey.y = det * (a11 * a33 - a13 * a13);
          M.ey.z = det * (a13 * a12 - a11 * a23);
          M.ez.x = M.ex.z;
          M.ez.y = M.ey.z;
          M.ez.z = det * (a11 * a22 - a12 * a12);
        };
        b2Mat33.MulM33V3 = function(A, v, out) {
          var v_x = v.x, v_y = v.y, v_z = v.z;
          out.x = A.ex.x * v_x + A.ey.x * v_y + A.ez.x * v_z;
          out.y = A.ex.y * v_x + A.ey.y * v_y + A.ez.y * v_z;
          out.z = A.ex.z * v_x + A.ey.z * v_y + A.ez.z * v_z;
          return out;
        };
        b2Mat33.MulM33XYZ = function(A, x, y, z, out) {
          out.x = A.ex.x * x + A.ey.x * y + A.ez.x * z;
          out.y = A.ex.y * x + A.ey.y * y + A.ez.y * z;
          out.z = A.ex.z * x + A.ey.z * y + A.ez.z * z;
          return out;
        };
        b2Mat33.MulM33V2 = function(A, v, out) {
          var v_x = v.x, v_y = v.y;
          out.x = A.ex.x * v_x + A.ey.x * v_y;
          out.y = A.ex.y * v_x + A.ey.y * v_y;
          return out;
        };
        b2Mat33.MulM33XY = function(A, x, y, out) {
          out.x = A.ex.x * x + A.ey.x * y;
          out.y = A.ex.y * x + A.ey.y * y;
          return out;
        };
        b2Mat33.IDENTITY = new b2Mat33();
        return b2Mat33;
      })();
      var b2Rot = (function() {
        function b2Rot(angle) {
          void 0 === angle && (angle = 0);
          this.s = 0;
          this.c = 1;
          if (angle) {
            this.s = Math.sin(angle);
            this.c = Math.cos(angle);
          }
        }
        b2Rot.prototype.Clone = function() {
          return new b2Rot().Copy(this);
        };
        b2Rot.prototype.Copy = function(other) {
          this.s = other.s;
          this.c = other.c;
          return this;
        };
        b2Rot.prototype.SetAngle = function(angle) {
          this.s = Math.sin(angle);
          this.c = Math.cos(angle);
          return this;
        };
        b2Rot.prototype.SetIdentity = function() {
          this.s = 0;
          this.c = 1;
          return this;
        };
        b2Rot.prototype.GetAngle = function() {
          return Math.atan2(this.s, this.c);
        };
        b2Rot.prototype.GetXAxis = function(out) {
          out.x = this.c;
          out.y = this.s;
          return out;
        };
        b2Rot.prototype.GetYAxis = function(out) {
          out.x = -this.s;
          out.y = this.c;
          return out;
        };
        b2Rot.MulRR = function(q, r, out) {
          var q_c = q.c, q_s = q.s;
          var r_c = r.c, r_s = r.s;
          out.s = q_s * r_c + q_c * r_s;
          out.c = q_c * r_c - q_s * r_s;
          return out;
        };
        b2Rot.MulTRR = function(q, r, out) {
          var q_c = q.c, q_s = q.s;
          var r_c = r.c, r_s = r.s;
          out.s = q_c * r_s - q_s * r_c;
          out.c = q_c * r_c + q_s * r_s;
          return out;
        };
        b2Rot.MulRV = function(q, v, out) {
          var q_c = q.c, q_s = q.s;
          var v_x = v.x, v_y = v.y;
          out.x = q_c * v_x - q_s * v_y;
          out.y = q_s * v_x + q_c * v_y;
          return out;
        };
        b2Rot.MulTRV = function(q, v, out) {
          var q_c = q.c, q_s = q.s;
          var v_x = v.x, v_y = v.y;
          out.x = q_c * v_x + q_s * v_y;
          out.y = -q_s * v_x + q_c * v_y;
          return out;
        };
        b2Rot.IDENTITY = new b2Rot();
        return b2Rot;
      })();
      var b2Transform = (function() {
        function b2Transform() {
          this.p = new b2Vec2();
          this.q = new b2Rot();
        }
        b2Transform.prototype.Clone = function() {
          return new b2Transform().Copy(this);
        };
        b2Transform.prototype.Copy = function(other) {
          this.p.Copy(other.p);
          this.q.Copy(other.q);
          return this;
        };
        b2Transform.prototype.SetIdentity = function() {
          this.p.SetZero();
          this.q.SetIdentity();
          return this;
        };
        b2Transform.prototype.SetPositionRotation = function(position, q) {
          this.p.Copy(position);
          this.q.Copy(q);
          return this;
        };
        b2Transform.prototype.SetPositionAngle = function(pos, a) {
          this.p.Copy(pos);
          this.q.SetAngle(a);
          return this;
        };
        b2Transform.prototype.SetPosition = function(position) {
          this.p.Copy(position);
          return this;
        };
        b2Transform.prototype.SetPositionXY = function(x, y) {
          this.p.Set(x, y);
          return this;
        };
        b2Transform.prototype.SetRotation = function(rotation) {
          this.q.Copy(rotation);
          return this;
        };
        b2Transform.prototype.SetRotationAngle = function(radians) {
          this.q.SetAngle(radians);
          return this;
        };
        b2Transform.prototype.GetPosition = function() {
          return this.p;
        };
        b2Transform.prototype.GetRotation = function() {
          return this.q;
        };
        b2Transform.prototype.GetRotationAngle = function() {
          return this.q.GetAngle();
        };
        b2Transform.prototype.GetAngle = function() {
          return this.q.GetAngle();
        };
        b2Transform.MulXV = function(T, v, out) {
          var T_q_c = T.q.c, T_q_s = T.q.s;
          var v_x = v.x, v_y = v.y;
          out.x = T_q_c * v_x - T_q_s * v_y + T.p.x;
          out.y = T_q_s * v_x + T_q_c * v_y + T.p.y;
          return out;
        };
        b2Transform.MulTXV = function(T, v, out) {
          var T_q_c = T.q.c, T_q_s = T.q.s;
          var p_x = v.x - T.p.x;
          var p_y = v.y - T.p.y;
          out.x = T_q_c * p_x + T_q_s * p_y;
          out.y = -T_q_s * p_x + T_q_c * p_y;
          return out;
        };
        b2Transform.MulXX = function(A, B, out) {
          b2Rot.MulRR(A.q, B.q, out.q);
          b2Vec2.AddVV(b2Rot.MulRV(A.q, B.p, out.p), A.p, out.p);
          return out;
        };
        b2Transform.MulTXX = function(A, B, out) {
          b2Rot.MulTRR(A.q, B.q, out.q);
          b2Rot.MulTRV(A.q, b2Vec2.SubVV(B.p, A.p, out.p), out.p);
          return out;
        };
        b2Transform.IDENTITY = new b2Transform();
        return b2Transform;
      })();
      var b2Sweep = (function() {
        function b2Sweep() {
          this.localCenter = new b2Vec2();
          this.c0 = new b2Vec2();
          this.c = new b2Vec2();
          this.a0 = 0;
          this.a = 0;
          this.alpha0 = 0;
        }
        b2Sweep.prototype.Clone = function() {
          return new b2Sweep().Copy(this);
        };
        b2Sweep.prototype.Copy = function(other) {
          this.localCenter.Copy(other.localCenter);
          this.c0.Copy(other.c0);
          this.c.Copy(other.c);
          this.a0 = other.a0;
          this.a = other.a;
          this.alpha0 = other.alpha0;
          return this;
        };
        b2Sweep.prototype.GetTransform = function(xf, beta) {
          var one_minus_beta = 1 - beta;
          xf.p.x = one_minus_beta * this.c0.x + beta * this.c.x;
          xf.p.y = one_minus_beta * this.c0.y + beta * this.c.y;
          var angle = one_minus_beta * this.a0 + beta * this.a;
          xf.q.SetAngle(angle);
          xf.p.SelfSub(b2Rot.MulRV(xf.q, this.localCenter, b2Vec2.s_t0));
          return xf;
        };
        b2Sweep.prototype.Advance = function(alpha) {
          var beta = (alpha - this.alpha0) / (1 - this.alpha0);
          var one_minus_beta = 1 - beta;
          this.c0.x = one_minus_beta * this.c0.x + beta * this.c.x;
          this.c0.y = one_minus_beta * this.c0.y + beta * this.c.y;
          this.a0 = one_minus_beta * this.a0 + beta * this.a;
          this.alpha0 = alpha;
        };
        b2Sweep.prototype.Normalize = function() {
          var d = b2_two_pi * Math.floor(this.a0 / b2_two_pi);
          this.a0 -= d;
          this.a -= d;
        };
        return b2Sweep;
      })();
      var b2Color = (function() {
        function b2Color(rr, gg, bb, aa) {
          void 0 === rr && (rr = .5);
          void 0 === gg && (gg = .5);
          void 0 === bb && (bb = .5);
          void 0 === aa && (aa = 1);
          this.r = rr;
          this.g = gg;
          this.b = bb;
          this.a = aa;
        }
        b2Color.prototype.Clone = function() {
          return new b2Color().Copy(this);
        };
        b2Color.prototype.Copy = function(other) {
          this.r = other.r;
          this.g = other.g;
          this.b = other.b;
          this.a = other.a;
          return this;
        };
        b2Color.prototype.IsEqual = function(color) {
          return this.r === color.r && this.g === color.g && this.b === color.b && this.a === color.a;
        };
        b2Color.prototype.IsZero = function() {
          return 0 === this.r && 0 === this.g && 0 === this.b && 0 === this.a;
        };
        b2Color.prototype.Set = function(r, g, b, a) {
          void 0 === a && (a = this.a);
          this.SetRGBA(r, g, b, a);
        };
        b2Color.prototype.SetByteRGB = function(r, g, b) {
          this.r = r / 255;
          this.g = g / 255;
          this.b = b / 255;
          return this;
        };
        b2Color.prototype.SetByteRGBA = function(r, g, b, a) {
          this.r = r / 255;
          this.g = g / 255;
          this.b = b / 255;
          this.a = a / 255;
          return this;
        };
        b2Color.prototype.SetRGB = function(rr, gg, bb) {
          this.r = rr;
          this.g = gg;
          this.b = bb;
          return this;
        };
        b2Color.prototype.SetRGBA = function(rr, gg, bb, aa) {
          this.r = rr;
          this.g = gg;
          this.b = bb;
          this.a = aa;
          return this;
        };
        b2Color.prototype.SelfAdd = function(color) {
          this.r += color.r;
          this.g += color.g;
          this.b += color.b;
          this.a += color.a;
          return this;
        };
        b2Color.prototype.Add = function(color, out) {
          out.r = this.r + color.r;
          out.g = this.g + color.g;
          out.b = this.b + color.b;
          out.a = this.a + color.a;
          return out;
        };
        b2Color.prototype.SelfSub = function(color) {
          this.r -= color.r;
          this.g -= color.g;
          this.b -= color.b;
          this.a -= color.a;
          return this;
        };
        b2Color.prototype.Sub = function(color, out) {
          out.r = this.r - color.r;
          out.g = this.g - color.g;
          out.b = this.b - color.b;
          out.a = this.a - color.a;
          return out;
        };
        b2Color.prototype.SelfMul = function(s) {
          this.r *= s;
          this.g *= s;
          this.b *= s;
          this.a *= s;
          return this;
        };
        b2Color.prototype.Mul = function(s, out) {
          out.r = this.r * s;
          out.g = this.g * s;
          out.b = this.b * s;
          out.a = this.a * s;
          return out;
        };
        b2Color.prototype.Mix = function(mixColor, strength) {
          b2Color.MixColors(this, mixColor, strength);
        };
        b2Color.MixColors = function(colorA, colorB, strength) {
          var dr = strength * (colorB.r - colorA.r);
          var dg = strength * (colorB.g - colorA.g);
          var db = strength * (colorB.b - colorA.b);
          var da = strength * (colorB.a - colorA.a);
          colorA.r += dr;
          colorA.g += dg;
          colorA.b += db;
          colorA.a += da;
          colorB.r -= dr;
          colorB.g -= dg;
          colorB.b -= db;
          colorB.a -= da;
        };
        b2Color.prototype.MakeStyleString = function(alpha) {
          void 0 === alpha && (alpha = this.a);
          return b2Color.MakeStyleString(this.r, this.g, this.b, alpha);
        };
        b2Color.MakeStyleString = function(r, g, b, a) {
          void 0 === a && (a = 1);
          r *= 255;
          g *= 255;
          b *= 255;
          return a < 1 ? "rgba(" + r + "," + g + "," + b + "," + a + ")" : "rgb(" + r + "," + g + "," + b + ")";
        };
        b2Color.ZERO = new b2Color(0, 0, 0, 0);
        b2Color.RED = new b2Color(1, 0, 0);
        b2Color.GREEN = new b2Color(0, 1, 0);
        b2Color.BLUE = new b2Color(0, 0, 1);
        return b2Color;
      })();
      (function(b2DrawFlags) {
        b2DrawFlags[b2DrawFlags["e_none"] = 0] = "e_none";
        b2DrawFlags[b2DrawFlags["e_shapeBit"] = 1] = "e_shapeBit";
        b2DrawFlags[b2DrawFlags["e_jointBit"] = 2] = "e_jointBit";
        b2DrawFlags[b2DrawFlags["e_aabbBit"] = 4] = "e_aabbBit";
        b2DrawFlags[b2DrawFlags["e_pairBit"] = 8] = "e_pairBit";
        b2DrawFlags[b2DrawFlags["e_centerOfMassBit"] = 16] = "e_centerOfMassBit";
        b2DrawFlags[b2DrawFlags["e_particleBit"] = 32] = "e_particleBit";
        b2DrawFlags[b2DrawFlags["e_controllerBit"] = 64] = "e_controllerBit";
        b2DrawFlags[b2DrawFlags["e_all"] = 63] = "e_all";
      })(exports.b2DrawFlags || (exports.b2DrawFlags = {}));
      var b2Draw = (function() {
        function b2Draw() {
          this.m_drawFlags = 0;
        }
        b2Draw.prototype.SetFlags = function(flags) {
          this.m_drawFlags = flags;
        };
        b2Draw.prototype.GetFlags = function() {
          return this.m_drawFlags;
        };
        b2Draw.prototype.AppendFlags = function(flags) {
          this.m_drawFlags |= flags;
        };
        b2Draw.prototype.ClearFlags = function(flags) {
          this.m_drawFlags &= ~flags;
        };
        return b2Draw;
      })();
      var b2Timer = (function() {
        function b2Timer() {
          this.m_start = Date.now();
        }
        b2Timer.prototype.Reset = function() {
          this.m_start = Date.now();
          return this;
        };
        b2Timer.prototype.GetMilliseconds = function() {
          return Date.now() - this.m_start;
        };
        return b2Timer;
      })();
      var b2Counter = (function() {
        function b2Counter() {
          this.m_count = 0;
          this.m_min_count = 0;
          this.m_max_count = 0;
        }
        b2Counter.prototype.GetCount = function() {
          return this.m_count;
        };
        b2Counter.prototype.GetMinCount = function() {
          return this.m_min_count;
        };
        b2Counter.prototype.GetMaxCount = function() {
          return this.m_max_count;
        };
        b2Counter.prototype.ResetCount = function() {
          var count = this.m_count;
          this.m_count = 0;
          return count;
        };
        b2Counter.prototype.ResetMinCount = function() {
          this.m_min_count = 0;
        };
        b2Counter.prototype.ResetMaxCount = function() {
          this.m_max_count = 0;
        };
        b2Counter.prototype.Increment = function() {
          this.m_count++;
          this.m_max_count < this.m_count && (this.m_max_count = this.m_count);
        };
        b2Counter.prototype.Decrement = function() {
          this.m_count--;
          this.m_min_count > this.m_count && (this.m_min_count = this.m_count);
        };
        return b2Counter;
      })();
      var b2GrowableStack = (function() {
        function b2GrowableStack(N) {
          this.m_stack = [];
          this.m_count = 0;
          this.m_stack = b2MakeArray(N, (function(index) {
            return null;
          }));
          this.m_count = 0;
        }
        b2GrowableStack.prototype.Reset = function() {
          this.m_count = 0;
          return this;
        };
        b2GrowableStack.prototype.Push = function(element) {
          this.m_stack[this.m_count] = element;
          this.m_count++;
        };
        b2GrowableStack.prototype.Pop = function() {
          this.m_count--;
          var element = this.m_stack[this.m_count];
          this.m_stack[this.m_count] = null;
          if (null === element) throw new Error();
          return element;
        };
        b2GrowableStack.prototype.GetCount = function() {
          return this.m_count;
        };
        return b2GrowableStack;
      })();
      var b2BlockAllocator = (function() {
        function b2BlockAllocator() {}
        return b2BlockAllocator;
      })();
      var b2StackAllocator = (function() {
        function b2StackAllocator() {}
        return b2StackAllocator;
      })();
      var b2DistanceProxy = (function() {
        function b2DistanceProxy() {
          this.m_buffer = b2Vec2.MakeArray(2);
          this.m_vertices = this.m_buffer;
          this.m_count = 0;
          this.m_radius = 0;
        }
        b2DistanceProxy.prototype.Copy = function(other) {
          if (other.m_vertices === other.m_buffer) {
            this.m_vertices = this.m_buffer;
            this.m_buffer[0].Copy(other.m_buffer[0]);
            this.m_buffer[1].Copy(other.m_buffer[1]);
          } else this.m_vertices = other.m_vertices;
          this.m_count = other.m_count;
          this.m_radius = other.m_radius;
          return this;
        };
        b2DistanceProxy.prototype.Reset = function() {
          this.m_vertices = this.m_buffer;
          this.m_count = 0;
          this.m_radius = 0;
          return this;
        };
        b2DistanceProxy.prototype.SetShape = function(shape, index) {
          shape.SetupDistanceProxy(this, index);
        };
        b2DistanceProxy.prototype.SetVerticesRadius = function(vertices, count, radius) {
          this.m_vertices = vertices;
          this.m_count = count;
          this.m_radius = radius;
        };
        b2DistanceProxy.prototype.GetSupport = function(d) {
          var bestIndex = 0;
          var bestValue = b2Vec2.DotVV(this.m_vertices[0], d);
          for (var i = 1; i < this.m_count; ++i) {
            var value = b2Vec2.DotVV(this.m_vertices[i], d);
            if (value > bestValue) {
              bestIndex = i;
              bestValue = value;
            }
          }
          return bestIndex;
        };
        b2DistanceProxy.prototype.GetSupportVertex = function(d) {
          var bestIndex = 0;
          var bestValue = b2Vec2.DotVV(this.m_vertices[0], d);
          for (var i = 1; i < this.m_count; ++i) {
            var value = b2Vec2.DotVV(this.m_vertices[i], d);
            if (value > bestValue) {
              bestIndex = i;
              bestValue = value;
            }
          }
          return this.m_vertices[bestIndex];
        };
        b2DistanceProxy.prototype.GetVertexCount = function() {
          return this.m_count;
        };
        b2DistanceProxy.prototype.GetVertex = function(index) {
          return this.m_vertices[index];
        };
        return b2DistanceProxy;
      })();
      var b2SimplexCache = (function() {
        function b2SimplexCache() {
          this.metric = 0;
          this.count = 0;
          this.indexA = [ 0, 0, 0 ];
          this.indexB = [ 0, 0, 0 ];
        }
        b2SimplexCache.prototype.Reset = function() {
          this.metric = 0;
          this.count = 0;
          return this;
        };
        return b2SimplexCache;
      })();
      var b2DistanceInput = (function() {
        function b2DistanceInput() {
          this.proxyA = new b2DistanceProxy();
          this.proxyB = new b2DistanceProxy();
          this.transformA = new b2Transform();
          this.transformB = new b2Transform();
          this.useRadii = false;
        }
        b2DistanceInput.prototype.Reset = function() {
          this.proxyA.Reset();
          this.proxyB.Reset();
          this.transformA.SetIdentity();
          this.transformB.SetIdentity();
          this.useRadii = false;
          return this;
        };
        return b2DistanceInput;
      })();
      var b2DistanceOutput = (function() {
        function b2DistanceOutput() {
          this.pointA = new b2Vec2();
          this.pointB = new b2Vec2();
          this.distance = 0;
          this.iterations = 0;
        }
        b2DistanceOutput.prototype.Reset = function() {
          this.pointA.SetZero();
          this.pointB.SetZero();
          this.distance = 0;
          this.iterations = 0;
          return this;
        };
        return b2DistanceOutput;
      })();
      var b2ShapeCastInput = (function() {
        function b2ShapeCastInput() {
          this.proxyA = new b2DistanceProxy();
          this.proxyB = new b2DistanceProxy();
          this.transformA = new b2Transform();
          this.transformB = new b2Transform();
          this.translationB = new b2Vec2();
        }
        return b2ShapeCastInput;
      })();
      var b2ShapeCastOutput = (function() {
        function b2ShapeCastOutput() {
          this.point = new b2Vec2();
          this.normal = new b2Vec2();
          this.lambda = 0;
          this.iterations = 0;
        }
        return b2ShapeCastOutput;
      })();
      exports.b2_gjkCalls = 0;
      exports.b2_gjkIters = 0;
      exports.b2_gjkMaxIters = 0;
      function b2_gjk_reset() {
        exports.b2_gjkCalls = 0;
        exports.b2_gjkIters = 0;
        exports.b2_gjkMaxIters = 0;
      }
      var b2SimplexVertex = (function() {
        function b2SimplexVertex() {
          this.wA = new b2Vec2();
          this.wB = new b2Vec2();
          this.w = new b2Vec2();
          this.a = 0;
          this.indexA = 0;
          this.indexB = 0;
        }
        b2SimplexVertex.prototype.Copy = function(other) {
          this.wA.Copy(other.wA);
          this.wB.Copy(other.wB);
          this.w.Copy(other.w);
          this.a = other.a;
          this.indexA = other.indexA;
          this.indexB = other.indexB;
          return this;
        };
        return b2SimplexVertex;
      })();
      var b2Simplex = (function() {
        function b2Simplex() {
          this.m_v1 = new b2SimplexVertex();
          this.m_v2 = new b2SimplexVertex();
          this.m_v3 = new b2SimplexVertex();
          this.m_vertices = [];
          this.m_count = 0;
          this.m_vertices[0] = this.m_v1;
          this.m_vertices[1] = this.m_v2;
          this.m_vertices[2] = this.m_v3;
        }
        b2Simplex.prototype.ReadCache = function(cache, proxyA, transformA, proxyB, transformB) {
          this.m_count = cache.count;
          var vertices = this.m_vertices;
          for (var i = 0; i < this.m_count; ++i) {
            var v = vertices[i];
            v.indexA = cache.indexA[i];
            v.indexB = cache.indexB[i];
            var wALocal = proxyA.GetVertex(v.indexA);
            var wBLocal = proxyB.GetVertex(v.indexB);
            b2Transform.MulXV(transformA, wALocal, v.wA);
            b2Transform.MulXV(transformB, wBLocal, v.wB);
            b2Vec2.SubVV(v.wB, v.wA, v.w);
            v.a = 0;
          }
          if (this.m_count > 1) {
            var metric1 = cache.metric;
            var metric2 = this.GetMetric();
            (metric2 < .5 * metric1 || 2 * metric1 < metric2 || metric2 < b2_epsilon) && (this.m_count = 0);
          }
          if (0 === this.m_count) {
            var v = vertices[0];
            v.indexA = 0;
            v.indexB = 0;
            var wALocal = proxyA.GetVertex(0);
            var wBLocal = proxyB.GetVertex(0);
            b2Transform.MulXV(transformA, wALocal, v.wA);
            b2Transform.MulXV(transformB, wBLocal, v.wB);
            b2Vec2.SubVV(v.wB, v.wA, v.w);
            v.a = 1;
            this.m_count = 1;
          }
        };
        b2Simplex.prototype.WriteCache = function(cache) {
          cache.metric = this.GetMetric();
          cache.count = this.m_count;
          var vertices = this.m_vertices;
          for (var i = 0; i < this.m_count; ++i) {
            cache.indexA[i] = vertices[i].indexA;
            cache.indexB[i] = vertices[i].indexB;
          }
        };
        b2Simplex.prototype.GetSearchDirection = function(out) {
          switch (this.m_count) {
           case 1:
            return b2Vec2.NegV(this.m_v1.w, out);

           case 2:
            var e12 = b2Vec2.SubVV(this.m_v2.w, this.m_v1.w, out);
            var sgn = b2Vec2.CrossVV(e12, b2Vec2.NegV(this.m_v1.w, b2Vec2.s_t0));
            return sgn > 0 ? b2Vec2.CrossOneV(e12, out) : b2Vec2.CrossVOne(e12, out);

           default:
            return out.SetZero();
          }
        };
        b2Simplex.prototype.GetClosestPoint = function(out) {
          switch (this.m_count) {
           case 0:
            return out.SetZero();

           case 1:
            return out.Copy(this.m_v1.w);

           case 2:
            return out.Set(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);

           case 3:
           default:
            return out.SetZero();
          }
        };
        b2Simplex.prototype.GetWitnessPoints = function(pA, pB) {
          switch (this.m_count) {
           case 0:
            break;

           case 1:
            pA.Copy(this.m_v1.wA);
            pB.Copy(this.m_v1.wB);
            break;

           case 2:
            pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
            pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
            pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
            pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
            break;

           case 3:
            pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
            pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
          }
        };
        b2Simplex.prototype.GetMetric = function() {
          switch (this.m_count) {
           case 0:
           case 1:
            return 0;

           case 2:
            return b2Vec2.DistanceVV(this.m_v1.w, this.m_v2.w);

           case 3:
            return b2Vec2.CrossVV(b2Vec2.SubVV(this.m_v2.w, this.m_v1.w, b2Vec2.s_t0), b2Vec2.SubVV(this.m_v3.w, this.m_v1.w, b2Vec2.s_t1));

           default:
            return 0;
          }
        };
        b2Simplex.prototype.Solve2 = function() {
          var w1 = this.m_v1.w;
          var w2 = this.m_v2.w;
          var e12 = b2Vec2.SubVV(w2, w1, b2Simplex.s_e12);
          var d12_2 = -b2Vec2.DotVV(w1, e12);
          if (d12_2 <= 0) {
            this.m_v1.a = 1;
            this.m_count = 1;
            return;
          }
          var d12_1 = b2Vec2.DotVV(w2, e12);
          if (d12_1 <= 0) {
            this.m_v2.a = 1;
            this.m_count = 1;
            this.m_v1.Copy(this.m_v2);
            return;
          }
          var inv_d12 = 1 / (d12_1 + d12_2);
          this.m_v1.a = d12_1 * inv_d12;
          this.m_v2.a = d12_2 * inv_d12;
          this.m_count = 2;
        };
        b2Simplex.prototype.Solve3 = function() {
          var w1 = this.m_v1.w;
          var w2 = this.m_v2.w;
          var w3 = this.m_v3.w;
          var e12 = b2Vec2.SubVV(w2, w1, b2Simplex.s_e12);
          var w1e12 = b2Vec2.DotVV(w1, e12);
          var w2e12 = b2Vec2.DotVV(w2, e12);
          var d12_1 = w2e12;
          var d12_2 = -w1e12;
          var e13 = b2Vec2.SubVV(w3, w1, b2Simplex.s_e13);
          var w1e13 = b2Vec2.DotVV(w1, e13);
          var w3e13 = b2Vec2.DotVV(w3, e13);
          var d13_1 = w3e13;
          var d13_2 = -w1e13;
          var e23 = b2Vec2.SubVV(w3, w2, b2Simplex.s_e23);
          var w2e23 = b2Vec2.DotVV(w2, e23);
          var w3e23 = b2Vec2.DotVV(w3, e23);
          var d23_1 = w3e23;
          var d23_2 = -w2e23;
          var n123 = b2Vec2.CrossVV(e12, e13);
          var d123_1 = n123 * b2Vec2.CrossVV(w2, w3);
          var d123_2 = n123 * b2Vec2.CrossVV(w3, w1);
          var d123_3 = n123 * b2Vec2.CrossVV(w1, w2);
          if (d12_2 <= 0 && d13_2 <= 0) {
            this.m_v1.a = 1;
            this.m_count = 1;
            return;
          }
          if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {
            var inv_d12 = 1 / (d12_1 + d12_2);
            this.m_v1.a = d12_1 * inv_d12;
            this.m_v2.a = d12_2 * inv_d12;
            this.m_count = 2;
            return;
          }
          if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {
            var inv_d13 = 1 / (d13_1 + d13_2);
            this.m_v1.a = d13_1 * inv_d13;
            this.m_v3.a = d13_2 * inv_d13;
            this.m_count = 2;
            this.m_v2.Copy(this.m_v3);
            return;
          }
          if (d12_1 <= 0 && d23_2 <= 0) {
            this.m_v2.a = 1;
            this.m_count = 1;
            this.m_v1.Copy(this.m_v2);
            return;
          }
          if (d13_1 <= 0 && d23_1 <= 0) {
            this.m_v3.a = 1;
            this.m_count = 1;
            this.m_v1.Copy(this.m_v3);
            return;
          }
          if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {
            var inv_d23 = 1 / (d23_1 + d23_2);
            this.m_v2.a = d23_1 * inv_d23;
            this.m_v3.a = d23_2 * inv_d23;
            this.m_count = 2;
            this.m_v1.Copy(this.m_v3);
            return;
          }
          var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);
          this.m_v1.a = d123_1 * inv_d123;
          this.m_v2.a = d123_2 * inv_d123;
          this.m_v3.a = d123_3 * inv_d123;
          this.m_count = 3;
        };
        b2Simplex.s_e12 = new b2Vec2();
        b2Simplex.s_e13 = new b2Vec2();
        b2Simplex.s_e23 = new b2Vec2();
        return b2Simplex;
      })();
      var b2Distance_s_simplex = new b2Simplex();
      var b2Distance_s_saveA = [ 0, 0, 0 ];
      var b2Distance_s_saveB = [ 0, 0, 0 ];
      var b2Distance_s_p = new b2Vec2();
      var b2Distance_s_d = new b2Vec2();
      var b2Distance_s_normal = new b2Vec2();
      var b2Distance_s_supportA = new b2Vec2();
      var b2Distance_s_supportB = new b2Vec2();
      function b2Distance(output, cache, input) {
        ++exports.b2_gjkCalls;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var transformA = input.transformA;
        var transformB = input.transformB;
        var simplex = b2Distance_s_simplex;
        simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
        var vertices = simplex.m_vertices;
        var k_maxIters = 20;
        var saveA = b2Distance_s_saveA;
        var saveB = b2Distance_s_saveB;
        var saveCount = 0;
        var iter = 0;
        while (iter < k_maxIters) {
          saveCount = simplex.m_count;
          for (var i = 0; i < saveCount; ++i) {
            saveA[i] = vertices[i].indexA;
            saveB[i] = vertices[i].indexB;
          }
          switch (simplex.m_count) {
           case 1:
            break;

           case 2:
            simplex.Solve2();
            break;

           case 3:
            simplex.Solve3();
          }
          if (3 === simplex.m_count) break;
          var d = simplex.GetSearchDirection(b2Distance_s_d);
          if (d.LengthSquared() < b2_epsilon_sq) break;
          var vertex = vertices[simplex.m_count];
          vertex.indexA = proxyA.GetSupport(b2Rot.MulTRV(transformA.q, b2Vec2.NegV(d, b2Vec2.s_t0), b2Distance_s_supportA));
          b2Transform.MulXV(transformA, proxyA.GetVertex(vertex.indexA), vertex.wA);
          vertex.indexB = proxyB.GetSupport(b2Rot.MulTRV(transformB.q, d, b2Distance_s_supportB));
          b2Transform.MulXV(transformB, proxyB.GetVertex(vertex.indexB), vertex.wB);
          b2Vec2.SubVV(vertex.wB, vertex.wA, vertex.w);
          ++iter;
          ++exports.b2_gjkIters;
          var duplicate = false;
          for (var i = 0; i < saveCount; ++i) if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {
            duplicate = true;
            break;
          }
          if (duplicate) break;
          ++simplex.m_count;
        }
        exports.b2_gjkMaxIters = b2Max(exports.b2_gjkMaxIters, iter);
        simplex.GetWitnessPoints(output.pointA, output.pointB);
        output.distance = b2Vec2.DistanceVV(output.pointA, output.pointB);
        output.iterations = iter;
        simplex.WriteCache(cache);
        if (input.useRadii) {
          var rA = proxyA.m_radius;
          var rB = proxyB.m_radius;
          if (output.distance > rA + rB && output.distance > b2_epsilon) {
            output.distance -= rA + rB;
            var normal = b2Vec2.SubVV(output.pointB, output.pointA, b2Distance_s_normal);
            normal.Normalize();
            output.pointA.SelfMulAdd(rA, normal);
            output.pointB.SelfMulSub(rB, normal);
          } else {
            var p = b2Vec2.MidVV(output.pointA, output.pointB, b2Distance_s_p);
            output.pointA.Copy(p);
            output.pointB.Copy(p);
            output.distance = 0;
          }
        }
      }
      var b2ShapeCast_s_n = new b2Vec2();
      var b2ShapeCast_s_simplex = new b2Simplex();
      var b2ShapeCast_s_wA = new b2Vec2();
      var b2ShapeCast_s_wB = new b2Vec2();
      var b2ShapeCast_s_v = new b2Vec2();
      var b2ShapeCast_s_p = new b2Vec2();
      var b2ShapeCast_s_pointA = new b2Vec2();
      var b2ShapeCast_s_pointB = new b2Vec2();
      function b2ShapeCast(output, input) {
        output.iterations = 0;
        output.lambda = 1;
        output.normal.SetZero();
        output.point.SetZero();
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var radiusA = b2Max(proxyA.m_radius, b2_polygonRadius);
        var radiusB = b2Max(proxyB.m_radius, b2_polygonRadius);
        var radius = radiusA + radiusB;
        var xfA = input.transformA;
        var xfB = input.transformB;
        var r = input.translationB;
        var n = b2ShapeCast_s_n.Set(0, 0);
        var lambda = 0;
        var simplex = b2ShapeCast_s_simplex;
        simplex.m_count = 0;
        var vertices = simplex.m_vertices;
        var indexA = proxyA.GetSupport(b2Rot.MulTRV(xfA.q, b2Vec2.NegV(r, b2Vec2.s_t1), b2Vec2.s_t0));
        var wA = b2Transform.MulXV(xfA, proxyA.GetVertex(indexA), b2ShapeCast_s_wA);
        var indexB = proxyB.GetSupport(b2Rot.MulTRV(xfB.q, r, b2Vec2.s_t0));
        var wB = b2Transform.MulXV(xfB, proxyB.GetVertex(indexB), b2ShapeCast_s_wB);
        var v = b2Vec2.SubVV(wA, wB, b2ShapeCast_s_v);
        var sigma = b2Max(b2_polygonRadius, radius - b2_polygonRadius);
        var tolerance = .5 * b2_linearSlop;
        var k_maxIters = 20;
        var iter = 0;
        while (iter < k_maxIters && b2Abs(v.Length() - sigma) > tolerance) {
          output.iterations += 1;
          indexA = proxyA.GetSupport(b2Rot.MulTRV(xfA.q, b2Vec2.NegV(v, b2Vec2.s_t1), b2Vec2.s_t0));
          wA = b2Transform.MulXV(xfA, proxyA.GetVertex(indexA), b2ShapeCast_s_wA);
          indexB = proxyB.GetSupport(b2Rot.MulTRV(xfB.q, v, b2Vec2.s_t0));
          wB = b2Transform.MulXV(xfB, proxyB.GetVertex(indexB), b2ShapeCast_s_wB);
          var p = b2Vec2.SubVV(wA, wB, b2ShapeCast_s_p);
          v.Normalize();
          var vp = b2Vec2.DotVV(v, p);
          var vr = b2Vec2.DotVV(v, r);
          if (vp - sigma > lambda * vr) {
            if (vr <= 0) return false;
            lambda = (vp - sigma) / vr;
            if (lambda > 1) return false;
            n.Copy(v).SelfNeg();
            simplex.m_count = 0;
          }
          var vertex = vertices[simplex.m_count];
          vertex.indexA = indexB;
          vertex.wA.Copy(wB).SelfMulAdd(lambda, r);
          vertex.indexB = indexA;
          vertex.wB.Copy(wA);
          vertex.w.Copy(vertex.wB).SelfSub(vertex.wA);
          vertex.a = 1;
          simplex.m_count += 1;
          switch (simplex.m_count) {
           case 1:
            break;

           case 2:
            simplex.Solve2();
            break;

           case 3:
            simplex.Solve3();
          }
          if (3 === simplex.m_count) return false;
          simplex.GetClosestPoint(v);
          ++iter;
        }
        var pointA = b2ShapeCast_s_pointA;
        var pointB = b2ShapeCast_s_pointB;
        simplex.GetWitnessPoints(pointA, pointB);
        if (v.LengthSquared() > 0) {
          n.Copy(v).SelfNeg();
          n.Normalize();
        }
        output.normal.Copy(n);
        output.lambda = lambda;
        output.iterations = iter;
        return true;
      }
      (function(b2ContactFeatureType) {
        b2ContactFeatureType[b2ContactFeatureType["e_vertex"] = 0] = "e_vertex";
        b2ContactFeatureType[b2ContactFeatureType["e_face"] = 1] = "e_face";
      })(exports.b2ContactFeatureType || (exports.b2ContactFeatureType = {}));
      var b2ContactFeature = (function() {
        function b2ContactFeature() {
          this._key = 0;
          this._key_invalid = false;
          this._indexA = 0;
          this._indexB = 0;
          this._typeA = 0;
          this._typeB = 0;
        }
        Object.defineProperty(b2ContactFeature.prototype, "key", {
          get: function get() {
            if (this._key_invalid) {
              this._key_invalid = false;
              this._key = this._indexA | this._indexB << 8 | this._typeA << 16 | this._typeB << 24;
            }
            return this._key;
          },
          set: function set(value) {
            this._key = value;
            this._key_invalid = false;
            this._indexA = 255 & this._key;
            this._indexB = this._key >> 8 & 255;
            this._typeA = this._key >> 16 & 255;
            this._typeB = this._key >> 24 & 255;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(b2ContactFeature.prototype, "indexA", {
          get: function get() {
            return this._indexA;
          },
          set: function set(value) {
            this._indexA = value;
            this._key_invalid = true;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(b2ContactFeature.prototype, "indexB", {
          get: function get() {
            return this._indexB;
          },
          set: function set(value) {
            this._indexB = value;
            this._key_invalid = true;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(b2ContactFeature.prototype, "typeA", {
          get: function get() {
            return this._typeA;
          },
          set: function set(value) {
            this._typeA = value;
            this._key_invalid = true;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(b2ContactFeature.prototype, "typeB", {
          get: function get() {
            return this._typeB;
          },
          set: function set(value) {
            this._typeB = value;
            this._key_invalid = true;
          },
          enumerable: true,
          configurable: true
        });
        return b2ContactFeature;
      })();
      var b2ContactID = (function() {
        function b2ContactID() {
          this.cf = new b2ContactFeature();
        }
        b2ContactID.prototype.Copy = function(o) {
          this.key = o.key;
          return this;
        };
        b2ContactID.prototype.Clone = function() {
          return new b2ContactID().Copy(this);
        };
        Object.defineProperty(b2ContactID.prototype, "key", {
          get: function get() {
            return this.cf.key;
          },
          set: function set(value) {
            this.cf.key = value;
          },
          enumerable: true,
          configurable: true
        });
        return b2ContactID;
      })();
      var b2ManifoldPoint = (function() {
        function b2ManifoldPoint() {
          this.localPoint = new b2Vec2();
          this.normalImpulse = 0;
          this.tangentImpulse = 0;
          this.id = new b2ContactID();
        }
        b2ManifoldPoint.MakeArray = function(length) {
          return b2MakeArray(length, (function(i) {
            return new b2ManifoldPoint();
          }));
        };
        b2ManifoldPoint.prototype.Reset = function() {
          this.localPoint.SetZero();
          this.normalImpulse = 0;
          this.tangentImpulse = 0;
          this.id.key = 0;
        };
        b2ManifoldPoint.prototype.Copy = function(o) {
          this.localPoint.Copy(o.localPoint);
          this.normalImpulse = o.normalImpulse;
          this.tangentImpulse = o.tangentImpulse;
          this.id.Copy(o.id);
          return this;
        };
        return b2ManifoldPoint;
      })();
      (function(b2ManifoldType) {
        b2ManifoldType[b2ManifoldType["e_unknown"] = -1] = "e_unknown";
        b2ManifoldType[b2ManifoldType["e_circles"] = 0] = "e_circles";
        b2ManifoldType[b2ManifoldType["e_faceA"] = 1] = "e_faceA";
        b2ManifoldType[b2ManifoldType["e_faceB"] = 2] = "e_faceB";
      })(exports.b2ManifoldType || (exports.b2ManifoldType = {}));
      var b2Manifold = (function() {
        function b2Manifold() {
          this.points = b2ManifoldPoint.MakeArray(b2_maxManifoldPoints);
          this.localNormal = new b2Vec2();
          this.localPoint = new b2Vec2();
          this.type = exports.b2ManifoldType.e_unknown;
          this.pointCount = 0;
        }
        b2Manifold.prototype.Reset = function() {
          for (var i = 0; i < b2_maxManifoldPoints; ++i) this.points[i].Reset();
          this.localNormal.SetZero();
          this.localPoint.SetZero();
          this.type = exports.b2ManifoldType.e_unknown;
          this.pointCount = 0;
        };
        b2Manifold.prototype.Copy = function(o) {
          this.pointCount = o.pointCount;
          for (var i = 0; i < b2_maxManifoldPoints; ++i) this.points[i].Copy(o.points[i]);
          this.localNormal.Copy(o.localNormal);
          this.localPoint.Copy(o.localPoint);
          this.type = o.type;
          return this;
        };
        b2Manifold.prototype.Clone = function() {
          return new b2Manifold().Copy(this);
        };
        return b2Manifold;
      })();
      var b2WorldManifold = (function() {
        function b2WorldManifold() {
          this.normal = new b2Vec2();
          this.points = b2Vec2.MakeArray(b2_maxManifoldPoints);
          this.separations = b2MakeNumberArray(b2_maxManifoldPoints);
        }
        b2WorldManifold.prototype.Initialize = function(manifold, xfA, radiusA, xfB, radiusB) {
          if (0 === manifold.pointCount) return;
          switch (manifold.type) {
           case exports.b2ManifoldType.e_circles:
            this.normal.Set(1, 0);
            var pointA = b2Transform.MulXV(xfA, manifold.localPoint, b2WorldManifold.Initialize_s_pointA);
            var pointB = b2Transform.MulXV(xfB, manifold.points[0].localPoint, b2WorldManifold.Initialize_s_pointB);
            b2Vec2.DistanceSquaredVV(pointA, pointB) > b2_epsilon_sq && b2Vec2.SubVV(pointB, pointA, this.normal).SelfNormalize();
            var cA = b2Vec2.AddVMulSV(pointA, radiusA, this.normal, b2WorldManifold.Initialize_s_cA);
            var cB = b2Vec2.SubVMulSV(pointB, radiusB, this.normal, b2WorldManifold.Initialize_s_cB);
            b2Vec2.MidVV(cA, cB, this.points[0]);
            this.separations[0] = b2Vec2.DotVV(b2Vec2.SubVV(cB, cA, b2Vec2.s_t0), this.normal);
            break;

           case exports.b2ManifoldType.e_faceA:
            b2Rot.MulRV(xfA.q, manifold.localNormal, this.normal);
            var planePoint = b2Transform.MulXV(xfA, manifold.localPoint, b2WorldManifold.Initialize_s_planePoint);
            for (var i = 0; i < manifold.pointCount; ++i) {
              var clipPoint = b2Transform.MulXV(xfB, manifold.points[i].localPoint, b2WorldManifold.Initialize_s_clipPoint);
              var s = radiusA - b2Vec2.DotVV(b2Vec2.SubVV(clipPoint, planePoint, b2Vec2.s_t0), this.normal);
              var cA = b2Vec2.AddVMulSV(clipPoint, s, this.normal, b2WorldManifold.Initialize_s_cA);
              var cB = b2Vec2.SubVMulSV(clipPoint, radiusB, this.normal, b2WorldManifold.Initialize_s_cB);
              b2Vec2.MidVV(cA, cB, this.points[i]);
              this.separations[i] = b2Vec2.DotVV(b2Vec2.SubVV(cB, cA, b2Vec2.s_t0), this.normal);
            }
            break;

           case exports.b2ManifoldType.e_faceB:
            b2Rot.MulRV(xfB.q, manifold.localNormal, this.normal);
            var planePoint = b2Transform.MulXV(xfB, manifold.localPoint, b2WorldManifold.Initialize_s_planePoint);
            for (var i = 0; i < manifold.pointCount; ++i) {
              var clipPoint = b2Transform.MulXV(xfA, manifold.points[i].localPoint, b2WorldManifold.Initialize_s_clipPoint);
              var s = radiusB - b2Vec2.DotVV(b2Vec2.SubVV(clipPoint, planePoint, b2Vec2.s_t0), this.normal);
              var cB = b2Vec2.AddVMulSV(clipPoint, s, this.normal, b2WorldManifold.Initialize_s_cB);
              var cA = b2Vec2.SubVMulSV(clipPoint, radiusA, this.normal, b2WorldManifold.Initialize_s_cA);
              b2Vec2.MidVV(cA, cB, this.points[i]);
              this.separations[i] = b2Vec2.DotVV(b2Vec2.SubVV(cA, cB, b2Vec2.s_t0), this.normal);
            }
            this.normal.SelfNeg();
          }
        };
        b2WorldManifold.Initialize_s_pointA = new b2Vec2();
        b2WorldManifold.Initialize_s_pointB = new b2Vec2();
        b2WorldManifold.Initialize_s_cA = new b2Vec2();
        b2WorldManifold.Initialize_s_cB = new b2Vec2();
        b2WorldManifold.Initialize_s_planePoint = new b2Vec2();
        b2WorldManifold.Initialize_s_clipPoint = new b2Vec2();
        return b2WorldManifold;
      })();
      (function(b2PointState) {
        b2PointState[b2PointState["b2_nullState"] = 0] = "b2_nullState";
        b2PointState[b2PointState["b2_addState"] = 1] = "b2_addState";
        b2PointState[b2PointState["b2_persistState"] = 2] = "b2_persistState";
        b2PointState[b2PointState["b2_removeState"] = 3] = "b2_removeState";
      })(exports.b2PointState || (exports.b2PointState = {}));
      function b2GetPointStates(state1, state2, manifold1, manifold2) {
        var i;
        for (i = 0; i < manifold1.pointCount; ++i) {
          var id = manifold1.points[i].id;
          var key = id.key;
          state1[i] = exports.b2PointState.b2_removeState;
          for (var j = 0, jct = manifold2.pointCount; j < jct; ++j) if (manifold2.points[j].id.key === key) {
            state1[i] = exports.b2PointState.b2_persistState;
            break;
          }
        }
        for (;i < b2_maxManifoldPoints; ++i) state1[i] = exports.b2PointState.b2_nullState;
        for (i = 0; i < manifold2.pointCount; ++i) {
          var id = manifold2.points[i].id;
          var key = id.key;
          state2[i] = exports.b2PointState.b2_addState;
          for (var j = 0, jct = manifold1.pointCount; j < jct; ++j) if (manifold1.points[j].id.key === key) {
            state2[i] = exports.b2PointState.b2_persistState;
            break;
          }
        }
        for (;i < b2_maxManifoldPoints; ++i) state2[i] = exports.b2PointState.b2_nullState;
      }
      var b2ClipVertex = (function() {
        function b2ClipVertex() {
          this.v = new b2Vec2();
          this.id = new b2ContactID();
        }
        b2ClipVertex.MakeArray = function(length) {
          return b2MakeArray(length, (function(i) {
            return new b2ClipVertex();
          }));
        };
        b2ClipVertex.prototype.Copy = function(other) {
          this.v.Copy(other.v);
          this.id.Copy(other.id);
          return this;
        };
        return b2ClipVertex;
      })();
      var b2RayCastInput = (function() {
        function b2RayCastInput() {
          this.p1 = new b2Vec2();
          this.p2 = new b2Vec2();
          this.maxFraction = 1;
        }
        b2RayCastInput.prototype.Copy = function(o) {
          this.p1.Copy(o.p1);
          this.p2.Copy(o.p2);
          this.maxFraction = o.maxFraction;
          return this;
        };
        return b2RayCastInput;
      })();
      var b2RayCastOutput = (function() {
        function b2RayCastOutput() {
          this.normal = new b2Vec2();
          this.fraction = 0;
        }
        b2RayCastOutput.prototype.Copy = function(o) {
          this.normal.Copy(o.normal);
          this.fraction = o.fraction;
          return this;
        };
        return b2RayCastOutput;
      })();
      var b2AABB = (function() {
        function b2AABB() {
          this.lowerBound = new b2Vec2();
          this.upperBound = new b2Vec2();
          this.m_cache_center = new b2Vec2();
          this.m_cache_extent = new b2Vec2();
        }
        b2AABB.prototype.Copy = function(o) {
          this.lowerBound.Copy(o.lowerBound);
          this.upperBound.Copy(o.upperBound);
          return this;
        };
        b2AABB.prototype.IsValid = function() {
          var d_x = this.upperBound.x - this.lowerBound.x;
          var d_y = this.upperBound.y - this.lowerBound.y;
          var valid = d_x >= 0 && d_y >= 0;
          valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
          return valid;
        };
        b2AABB.prototype.GetCenter = function() {
          return b2Vec2.MidVV(this.lowerBound, this.upperBound, this.m_cache_center);
        };
        b2AABB.prototype.GetExtents = function() {
          return b2Vec2.ExtVV(this.lowerBound, this.upperBound, this.m_cache_extent);
        };
        b2AABB.prototype.GetPerimeter = function() {
          var wx = this.upperBound.x - this.lowerBound.x;
          var wy = this.upperBound.y - this.lowerBound.y;
          return 2 * (wx + wy);
        };
        b2AABB.prototype.Combine1 = function(aabb) {
          this.lowerBound.x = b2Min(this.lowerBound.x, aabb.lowerBound.x);
          this.lowerBound.y = b2Min(this.lowerBound.y, aabb.lowerBound.y);
          this.upperBound.x = b2Max(this.upperBound.x, aabb.upperBound.x);
          this.upperBound.y = b2Max(this.upperBound.y, aabb.upperBound.y);
          return this;
        };
        b2AABB.prototype.Combine2 = function(aabb1, aabb2) {
          this.lowerBound.x = b2Min(aabb1.lowerBound.x, aabb2.lowerBound.x);
          this.lowerBound.y = b2Min(aabb1.lowerBound.y, aabb2.lowerBound.y);
          this.upperBound.x = b2Max(aabb1.upperBound.x, aabb2.upperBound.x);
          this.upperBound.y = b2Max(aabb1.upperBound.y, aabb2.upperBound.y);
          return this;
        };
        b2AABB.Combine = function(aabb1, aabb2, out) {
          out.Combine2(aabb1, aabb2);
          return out;
        };
        b2AABB.prototype.Contains = function(aabb) {
          var result = true;
          result = result && this.lowerBound.x <= aabb.lowerBound.x;
          result = result && this.lowerBound.y <= aabb.lowerBound.y;
          result = result && aabb.upperBound.x <= this.upperBound.x;
          result = result && aabb.upperBound.y <= this.upperBound.y;
          return result;
        };
        b2AABB.prototype.RayCast = function(output, input) {
          var tmin = -b2_maxFloat;
          var tmax = b2_maxFloat;
          var p_x = input.p1.x;
          var p_y = input.p1.y;
          var d_x = input.p2.x - input.p1.x;
          var d_y = input.p2.y - input.p1.y;
          var absD_x = b2Abs(d_x);
          var absD_y = b2Abs(d_y);
          var normal = output.normal;
          if (absD_x < b2_epsilon) {
            if (p_x < this.lowerBound.x || this.upperBound.x < p_x) return false;
          } else {
            var inv_d = 1 / d_x;
            var t1 = (this.lowerBound.x - p_x) * inv_d;
            var t2 = (this.upperBound.x - p_x) * inv_d;
            var s = -1;
            if (t1 > t2) {
              var t3 = t1;
              t1 = t2;
              t2 = t3;
              s = 1;
            }
            if (t1 > tmin) {
              normal.x = s;
              normal.y = 0;
              tmin = t1;
            }
            tmax = b2Min(tmax, t2);
            if (tmin > tmax) return false;
          }
          if (absD_y < b2_epsilon) {
            if (p_y < this.lowerBound.y || this.upperBound.y < p_y) return false;
          } else {
            var inv_d = 1 / d_y;
            var t1 = (this.lowerBound.y - p_y) * inv_d;
            var t2 = (this.upperBound.y - p_y) * inv_d;
            var s = -1;
            if (t1 > t2) {
              var t3 = t1;
              t1 = t2;
              t2 = t3;
              s = 1;
            }
            if (t1 > tmin) {
              normal.x = 0;
              normal.y = s;
              tmin = t1;
            }
            tmax = b2Min(tmax, t2);
            if (tmin > tmax) return false;
          }
          if (tmin < 0 || input.maxFraction < tmin) return false;
          output.fraction = tmin;
          return true;
        };
        b2AABB.prototype.TestContain = function(point) {
          if (point.x < this.lowerBound.x || this.upperBound.x < point.x) return false;
          if (point.y < this.lowerBound.y || this.upperBound.y < point.y) return false;
          return true;
        };
        b2AABB.prototype.TestOverlap = function(other) {
          var d1_x = other.lowerBound.x - this.upperBound.x;
          var d1_y = other.lowerBound.y - this.upperBound.y;
          var d2_x = this.lowerBound.x - other.upperBound.x;
          var d2_y = this.lowerBound.y - other.upperBound.y;
          if (d1_x > 0 || d1_y > 0) return false;
          if (d2_x > 0 || d2_y > 0) return false;
          return true;
        };
        return b2AABB;
      })();
      function b2TestOverlapAABB(a, b) {
        var d1_x = b.lowerBound.x - a.upperBound.x;
        var d1_y = b.lowerBound.y - a.upperBound.y;
        var d2_x = a.lowerBound.x - b.upperBound.x;
        var d2_y = a.lowerBound.y - b.upperBound.y;
        if (d1_x > 0 || d1_y > 0) return false;
        if (d2_x > 0 || d2_y > 0) return false;
        return true;
      }
      function b2ClipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA) {
        var numOut = 0;
        var vIn0 = vIn[0];
        var vIn1 = vIn[1];
        var distance0 = b2Vec2.DotVV(normal, vIn0.v) - offset;
        var distance1 = b2Vec2.DotVV(normal, vIn1.v) - offset;
        distance0 <= 0 && vOut[numOut++].Copy(vIn0);
        distance1 <= 0 && vOut[numOut++].Copy(vIn1);
        if (distance0 * distance1 < 0) {
          var interp = distance0 / (distance0 - distance1);
          var v = vOut[numOut].v;
          v.x = vIn0.v.x + interp * (vIn1.v.x - vIn0.v.x);
          v.y = vIn0.v.y + interp * (vIn1.v.y - vIn0.v.y);
          var id = vOut[numOut].id;
          id.cf.indexA = vertexIndexA;
          id.cf.indexB = vIn0.id.cf.indexB;
          id.cf.typeA = exports.b2ContactFeatureType.e_vertex;
          id.cf.typeB = exports.b2ContactFeatureType.e_face;
          ++numOut;
        }
        return numOut;
      }
      var b2TestOverlapShape_s_input = new b2DistanceInput();
      var b2TestOverlapShape_s_simplexCache = new b2SimplexCache();
      var b2TestOverlapShape_s_output = new b2DistanceOutput();
      function b2TestOverlapShape(shapeA, indexA, shapeB, indexB, xfA, xfB) {
        var input = b2TestOverlapShape_s_input.Reset();
        input.proxyA.SetShape(shapeA, indexA);
        input.proxyB.SetShape(shapeB, indexB);
        input.transformA.Copy(xfA);
        input.transformB.Copy(xfB);
        input.useRadii = true;
        var simplexCache = b2TestOverlapShape_s_simplexCache.Reset();
        simplexCache.count = 0;
        var output = b2TestOverlapShape_s_output.Reset();
        b2Distance(output, simplexCache, input);
        return output.distance < 10 * b2_epsilon;
      }
      function verify(value) {
        if (null === value) throw new Error();
        return value;
      }
      var b2TreeNode = (function() {
        function b2TreeNode(id) {
          void 0 === id && (id = 0);
          this.m_id = 0;
          this.aabb = new b2AABB();
          this.parent = null;
          this.child1 = null;
          this.child2 = null;
          this.height = 0;
          this.m_id = id;
        }
        b2TreeNode.prototype.IsLeaf = function() {
          return null === this.child1;
        };
        return b2TreeNode;
      })();
      var b2DynamicTree = (function() {
        function b2DynamicTree() {
          this.m_root = null;
          this.m_freeList = null;
          this.m_path = 0;
          this.m_insertionCount = 0;
          this.m_stack = new b2GrowableStack(256);
        }
        b2DynamicTree.prototype.Query = function(aabb, callback) {
          if (null === this.m_root) return;
          var stack = this.m_stack.Reset();
          stack.Push(this.m_root);
          while (stack.GetCount() > 0) {
            var node = stack.Pop();
            if (node.aabb.TestOverlap(aabb)) if (node.IsLeaf()) {
              var proceed = callback(node);
              if (!proceed) return;
            } else {
              stack.Push(verify(node.child1));
              stack.Push(verify(node.child2));
            }
          }
        };
        b2DynamicTree.prototype.QueryPoint = function(point, callback) {
          if (null === this.m_root) return;
          var stack = this.m_stack.Reset();
          stack.Push(this.m_root);
          while (stack.GetCount() > 0) {
            var node = stack.Pop();
            if (node.aabb.TestContain(point)) if (node.IsLeaf()) {
              var proceed = callback(node);
              if (!proceed) return;
            } else {
              stack.Push(verify(node.child1));
              stack.Push(verify(node.child2));
            }
          }
        };
        b2DynamicTree.prototype.RayCast = function(input, callback) {
          if (null === this.m_root) return;
          var p1 = input.p1;
          var p2 = input.p2;
          var r = b2Vec2.SubVV(p2, p1, b2DynamicTree.s_r);
          r.Normalize();
          var v = b2Vec2.CrossOneV(r, b2DynamicTree.s_v);
          var abs_v = b2Vec2.AbsV(v, b2DynamicTree.s_abs_v);
          var maxFraction = input.maxFraction;
          var segmentAABB = b2DynamicTree.s_segmentAABB;
          var t_x = p1.x + maxFraction * (p2.x - p1.x);
          var t_y = p1.y + maxFraction * (p2.y - p1.y);
          segmentAABB.lowerBound.x = b2Min(p1.x, t_x);
          segmentAABB.lowerBound.y = b2Min(p1.y, t_y);
          segmentAABB.upperBound.x = b2Max(p1.x, t_x);
          segmentAABB.upperBound.y = b2Max(p1.y, t_y);
          var stack = this.m_stack.Reset();
          stack.Push(this.m_root);
          while (stack.GetCount() > 0) {
            var node = stack.Pop();
            if (!b2TestOverlapAABB(node.aabb, segmentAABB)) continue;
            var c = node.aabb.GetCenter();
            var h = node.aabb.GetExtents();
            var separation = b2Abs(b2Vec2.DotVV(v, b2Vec2.SubVV(p1, c, b2Vec2.s_t0))) - b2Vec2.DotVV(abs_v, h);
            if (separation > 0) continue;
            if (node.IsLeaf()) {
              var subInput = b2DynamicTree.s_subInput;
              subInput.p1.Copy(input.p1);
              subInput.p2.Copy(input.p2);
              subInput.maxFraction = maxFraction;
              var value = callback(subInput, node);
              if (0 === value) return;
              if (value > 0) {
                maxFraction = value;
                t_x = p1.x + maxFraction * (p2.x - p1.x);
                t_y = p1.y + maxFraction * (p2.y - p1.y);
                segmentAABB.lowerBound.x = b2Min(p1.x, t_x);
                segmentAABB.lowerBound.y = b2Min(p1.y, t_y);
                segmentAABB.upperBound.x = b2Max(p1.x, t_x);
                segmentAABB.upperBound.y = b2Max(p1.y, t_y);
              }
            } else {
              stack.Push(verify(node.child1));
              stack.Push(verify(node.child2));
            }
          }
        };
        b2DynamicTree.prototype.AllocateNode = function() {
          if (this.m_freeList) {
            var node = this.m_freeList;
            this.m_freeList = node.parent;
            node.parent = null;
            node.child1 = null;
            node.child2 = null;
            node.height = 0;
            delete node.userData;
            return node;
          }
          return new b2TreeNode(b2DynamicTree.s_node_id++);
        };
        b2DynamicTree.prototype.FreeNode = function(node) {
          node.parent = this.m_freeList;
          node.child1 = null;
          node.child2 = null;
          node.height = -1;
          delete node.userData;
          this.m_freeList = node;
        };
        b2DynamicTree.prototype.CreateProxy = function(aabb, userData) {
          var node = this.AllocateNode();
          var r_x = b2_aabbExtension;
          var r_y = b2_aabbExtension;
          node.aabb.lowerBound.x = aabb.lowerBound.x - r_x;
          node.aabb.lowerBound.y = aabb.lowerBound.y - r_y;
          node.aabb.upperBound.x = aabb.upperBound.x + r_x;
          node.aabb.upperBound.y = aabb.upperBound.y + r_y;
          node.userData = userData;
          node.height = 0;
          this.InsertLeaf(node);
          return node;
        };
        b2DynamicTree.prototype.DestroyProxy = function(proxy) {
          this.RemoveLeaf(proxy);
          this.FreeNode(proxy);
        };
        b2DynamicTree.prototype.MoveProxy = function(proxy, aabb, displacement) {
          if (proxy.aabb.Contains(aabb)) return false;
          this.RemoveLeaf(proxy);
          var r_x = b2_aabbExtension + b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : -displacement.x);
          var r_y = b2_aabbExtension + b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : -displacement.y);
          proxy.aabb.lowerBound.x = aabb.lowerBound.x - r_x;
          proxy.aabb.lowerBound.y = aabb.lowerBound.y - r_y;
          proxy.aabb.upperBound.x = aabb.upperBound.x + r_x;
          proxy.aabb.upperBound.y = aabb.upperBound.y + r_y;
          this.InsertLeaf(proxy);
          return true;
        };
        b2DynamicTree.prototype.InsertLeaf = function(leaf) {
          ++this.m_insertionCount;
          if (null === this.m_root) {
            this.m_root = leaf;
            this.m_root.parent = null;
            return;
          }
          var leafAABB = leaf.aabb;
          var index = this.m_root;
          while (!index.IsLeaf()) {
            var child1 = verify(index.child1);
            var child2 = verify(index.child2);
            var area = index.aabb.GetPerimeter();
            var combinedAABB = b2DynamicTree.s_combinedAABB;
            combinedAABB.Combine2(index.aabb, leafAABB);
            var combinedArea = combinedAABB.GetPerimeter();
            var cost = 2 * combinedArea;
            var inheritanceCost = 2 * (combinedArea - area);
            var cost1 = void 0;
            var aabb = b2DynamicTree.s_aabb;
            var oldArea = void 0;
            var newArea = void 0;
            if (child1.IsLeaf()) {
              aabb.Combine2(leafAABB, child1.aabb);
              cost1 = aabb.GetPerimeter() + inheritanceCost;
            } else {
              aabb.Combine2(leafAABB, child1.aabb);
              oldArea = child1.aabb.GetPerimeter();
              newArea = aabb.GetPerimeter();
              cost1 = newArea - oldArea + inheritanceCost;
            }
            var cost2 = void 0;
            if (child2.IsLeaf()) {
              aabb.Combine2(leafAABB, child2.aabb);
              cost2 = aabb.GetPerimeter() + inheritanceCost;
            } else {
              aabb.Combine2(leafAABB, child2.aabb);
              oldArea = child2.aabb.GetPerimeter();
              newArea = aabb.GetPerimeter();
              cost2 = newArea - oldArea + inheritanceCost;
            }
            if (cost < cost1 && cost < cost2) break;
            index = cost1 < cost2 ? child1 : child2;
          }
          var sibling = index;
          var oldParent = sibling.parent;
          var newParent = this.AllocateNode();
          newParent.parent = oldParent;
          delete newParent.userData;
          newParent.aabb.Combine2(leafAABB, sibling.aabb);
          newParent.height = sibling.height + 1;
          if (oldParent) {
            oldParent.child1 === sibling ? oldParent.child1 = newParent : oldParent.child2 = newParent;
            newParent.child1 = sibling;
            newParent.child2 = leaf;
            sibling.parent = newParent;
            leaf.parent = newParent;
          } else {
            newParent.child1 = sibling;
            newParent.child2 = leaf;
            sibling.parent = newParent;
            leaf.parent = newParent;
            this.m_root = newParent;
          }
          var index2 = leaf.parent;
          while (null !== index2) {
            index2 = this.Balance(index2);
            var child1 = verify(index2.child1);
            var child2 = verify(index2.child2);
            index2.height = 1 + b2Max(child1.height, child2.height);
            index2.aabb.Combine2(child1.aabb, child2.aabb);
            index2 = index2.parent;
          }
        };
        b2DynamicTree.prototype.RemoveLeaf = function(leaf) {
          if (leaf === this.m_root) {
            this.m_root = null;
            return;
          }
          var parent = verify(leaf.parent);
          var grandParent = parent && parent.parent;
          var sibling;
          sibling = parent.child1 === leaf ? verify(parent.child2) : verify(parent.child1);
          if (grandParent) {
            grandParent.child1 === parent ? grandParent.child1 = sibling : grandParent.child2 = sibling;
            sibling.parent = grandParent;
            this.FreeNode(parent);
            var index = grandParent;
            while (index) {
              index = this.Balance(index);
              var child1 = verify(index.child1);
              var child2 = verify(index.child2);
              index.aabb.Combine2(child1.aabb, child2.aabb);
              index.height = 1 + b2Max(child1.height, child2.height);
              index = index.parent;
            }
          } else {
            this.m_root = sibling;
            sibling.parent = null;
            this.FreeNode(parent);
          }
        };
        b2DynamicTree.prototype.Balance = function(A) {
          if (A.IsLeaf() || A.height < 2) return A;
          var B = verify(A.child1);
          var C = verify(A.child2);
          var balance = C.height - B.height;
          if (balance > 1) {
            var F = verify(C.child1);
            var G = verify(C.child2);
            C.child1 = A;
            C.parent = A.parent;
            A.parent = C;
            null !== C.parent ? C.parent.child1 === A ? C.parent.child1 = C : C.parent.child2 = C : this.m_root = C;
            if (F.height > G.height) {
              C.child2 = F;
              A.child2 = G;
              G.parent = A;
              A.aabb.Combine2(B.aabb, G.aabb);
              C.aabb.Combine2(A.aabb, F.aabb);
              A.height = 1 + b2Max(B.height, G.height);
              C.height = 1 + b2Max(A.height, F.height);
            } else {
              C.child2 = G;
              A.child2 = F;
              F.parent = A;
              A.aabb.Combine2(B.aabb, F.aabb);
              C.aabb.Combine2(A.aabb, G.aabb);
              A.height = 1 + b2Max(B.height, F.height);
              C.height = 1 + b2Max(A.height, G.height);
            }
            return C;
          }
          if (balance < -1) {
            var D = verify(B.child1);
            var E = verify(B.child2);
            B.child1 = A;
            B.parent = A.parent;
            A.parent = B;
            null !== B.parent ? B.parent.child1 === A ? B.parent.child1 = B : B.parent.child2 = B : this.m_root = B;
            if (D.height > E.height) {
              B.child2 = D;
              A.child1 = E;
              E.parent = A;
              A.aabb.Combine2(C.aabb, E.aabb);
              B.aabb.Combine2(A.aabb, D.aabb);
              A.height = 1 + b2Max(C.height, E.height);
              B.height = 1 + b2Max(A.height, D.height);
            } else {
              B.child2 = E;
              A.child1 = D;
              D.parent = A;
              A.aabb.Combine2(C.aabb, D.aabb);
              B.aabb.Combine2(A.aabb, E.aabb);
              A.height = 1 + b2Max(C.height, D.height);
              B.height = 1 + b2Max(A.height, E.height);
            }
            return B;
          }
          return A;
        };
        b2DynamicTree.prototype.GetHeight = function() {
          if (null === this.m_root) return 0;
          return this.m_root.height;
        };
        b2DynamicTree.GetAreaNode = function(node) {
          if (null === node) return 0;
          if (node.IsLeaf()) return 0;
          var area = node.aabb.GetPerimeter();
          area += b2DynamicTree.GetAreaNode(node.child1);
          area += b2DynamicTree.GetAreaNode(node.child2);
          return area;
        };
        b2DynamicTree.prototype.GetAreaRatio = function() {
          if (null === this.m_root) return 0;
          var root = this.m_root;
          var rootArea = root.aabb.GetPerimeter();
          var totalArea = b2DynamicTree.GetAreaNode(this.m_root);
          return totalArea / rootArea;
        };
        b2DynamicTree.prototype.ComputeHeightNode = function(node) {
          if (!node || node.IsLeaf()) return 0;
          var height1 = this.ComputeHeightNode(node.child1);
          var height2 = this.ComputeHeightNode(node.child2);
          return 1 + b2Max(height1, height2);
        };
        b2DynamicTree.prototype.ComputeHeight = function() {
          var height = this.ComputeHeightNode(this.m_root);
          return height;
        };
        b2DynamicTree.prototype.ValidateStructure = function(index) {
          if (null === index) return;
          index === this.m_root;
          var node = index;
          if (node.IsLeaf()) return;
          var child1 = verify(node.child1);
          var child2 = verify(node.child2);
          this.ValidateStructure(child1);
          this.ValidateStructure(child2);
        };
        b2DynamicTree.prototype.ValidateMetrics = function(index) {
          if (null === index) return;
          var node = index;
          if (node.IsLeaf()) return;
          var child1 = verify(node.child1);
          var child2 = verify(node.child2);
          var aabb = b2DynamicTree.s_aabb;
          aabb.Combine2(child1.aabb, child2.aabb);
          this.ValidateMetrics(child1);
          this.ValidateMetrics(child2);
        };
        b2DynamicTree.prototype.Validate = function() {};
        b2DynamicTree.GetMaxBalanceNode = function(node, maxBalance) {
          if (null === node) return maxBalance;
          if (node.height <= 1) return maxBalance;
          var child1 = verify(node.child1);
          var child2 = verify(node.child2);
          var balance = b2Abs(child2.height - child1.height);
          return b2Max(maxBalance, balance);
        };
        b2DynamicTree.prototype.GetMaxBalance = function() {
          var maxBalance = b2DynamicTree.GetMaxBalanceNode(this.m_root, 0);
          return maxBalance;
        };
        b2DynamicTree.prototype.RebuildBottomUp = function() {
          this.Validate();
        };
        b2DynamicTree.ShiftOriginNode = function(node, newOrigin) {
          if (null === node) return;
          if (node.height <= 1) return;
          var child1 = node.child1;
          var child2 = node.child2;
          b2DynamicTree.ShiftOriginNode(child1, newOrigin);
          b2DynamicTree.ShiftOriginNode(child2, newOrigin);
          node.aabb.lowerBound.SelfSub(newOrigin);
          node.aabb.upperBound.SelfSub(newOrigin);
        };
        b2DynamicTree.prototype.ShiftOrigin = function(newOrigin) {
          b2DynamicTree.ShiftOriginNode(this.m_root, newOrigin);
        };
        b2DynamicTree.s_r = new b2Vec2();
        b2DynamicTree.s_v = new b2Vec2();
        b2DynamicTree.s_abs_v = new b2Vec2();
        b2DynamicTree.s_segmentAABB = new b2AABB();
        b2DynamicTree.s_subInput = new b2RayCastInput();
        b2DynamicTree.s_combinedAABB = new b2AABB();
        b2DynamicTree.s_aabb = new b2AABB();
        b2DynamicTree.s_node_id = 0;
        return b2DynamicTree;
      })();
      var b2Pair = (function() {
        function b2Pair(proxyA, proxyB) {
          this.proxyA = proxyA;
          this.proxyB = proxyB;
        }
        return b2Pair;
      })();
      var b2BroadPhase = (function() {
        function b2BroadPhase() {
          this.m_tree = new b2DynamicTree();
          this.m_proxyCount = 0;
          this.m_moveCount = 0;
          this.m_moveBuffer = [];
          this.m_pairCount = 0;
          this.m_pairBuffer = [];
        }
        b2BroadPhase.prototype.CreateProxy = function(aabb, userData) {
          var proxy = this.m_tree.CreateProxy(aabb, userData);
          ++this.m_proxyCount;
          this.BufferMove(proxy);
          return proxy;
        };
        b2BroadPhase.prototype.DestroyProxy = function(proxy) {
          this.UnBufferMove(proxy);
          --this.m_proxyCount;
          this.m_tree.DestroyProxy(proxy);
        };
        b2BroadPhase.prototype.MoveProxy = function(proxy, aabb, displacement) {
          var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);
          buffer && this.BufferMove(proxy);
        };
        b2BroadPhase.prototype.TouchProxy = function(proxy) {
          this.BufferMove(proxy);
        };
        b2BroadPhase.prototype.GetProxyCount = function() {
          return this.m_proxyCount;
        };
        b2BroadPhase.prototype.UpdatePairs = function(callback) {
          var _this = this;
          this.m_pairCount = 0;
          var _loop_1 = function _loop_1(i_1) {
            var queryProxy = this_1.m_moveBuffer[i_1];
            if (null === queryProxy) return "continue";
            var fatAABB = queryProxy.aabb;
            this_1.m_tree.Query(fatAABB, (function(proxy) {
              if (proxy.m_id === queryProxy.m_id) return true;
              var proxyA;
              var proxyB;
              if (proxy.m_id < queryProxy.m_id) {
                proxyA = proxy;
                proxyB = queryProxy;
              } else {
                proxyA = queryProxy;
                proxyB = proxy;
              }
              if (_this.m_pairCount === _this.m_pairBuffer.length) _this.m_pairBuffer[_this.m_pairCount] = new b2Pair(proxyA, proxyB); else {
                var pair = _this.m_pairBuffer[_this.m_pairCount];
                pair.proxyA = proxyA;
                pair.proxyB = proxyB;
              }
              ++_this.m_pairCount;
              return true;
            }));
          };
          var this_1 = this;
          for (var i_1 = 0; i_1 < this.m_moveCount; ++i_1) _loop_1(i_1);
          this.m_moveCount = 0;
          this.m_pairBuffer.length = this.m_pairCount;
          this.m_pairBuffer.sort(b2PairLessThan);
          var i = 0;
          while (i < this.m_pairCount) {
            var primaryPair = this.m_pairBuffer[i];
            var userDataA = primaryPair.proxyA.userData;
            var userDataB = primaryPair.proxyB.userData;
            userDataA && userDataB && callback(userDataA, userDataB);
            ++i;
            while (i < this.m_pairCount) {
              var pair = this.m_pairBuffer[i];
              if (pair.proxyA.m_id !== primaryPair.proxyA.m_id || pair.proxyB.m_id !== primaryPair.proxyB.m_id) break;
              ++i;
            }
          }
        };
        b2BroadPhase.prototype.Query = function(aabb, callback) {
          this.m_tree.Query(aabb, callback);
        };
        b2BroadPhase.prototype.QueryPoint = function(point, callback) {
          this.m_tree.QueryPoint(point, callback);
        };
        b2BroadPhase.prototype.RayCast = function(input, callback) {
          this.m_tree.RayCast(input, callback);
        };
        b2BroadPhase.prototype.GetTreeHeight = function() {
          return this.m_tree.GetHeight();
        };
        b2BroadPhase.prototype.GetTreeBalance = function() {
          return this.m_tree.GetMaxBalance();
        };
        b2BroadPhase.prototype.GetTreeQuality = function() {
          return this.m_tree.GetAreaRatio();
        };
        b2BroadPhase.prototype.ShiftOrigin = function(newOrigin) {
          this.m_tree.ShiftOrigin(newOrigin);
        };
        b2BroadPhase.prototype.BufferMove = function(proxy) {
          this.m_moveBuffer[this.m_moveCount] = proxy;
          ++this.m_moveCount;
        };
        b2BroadPhase.prototype.UnBufferMove = function(proxy) {
          var i = this.m_moveBuffer.indexOf(proxy);
          this.m_moveBuffer[i] = null;
        };
        return b2BroadPhase;
      })();
      function b2PairLessThan(pair1, pair2) {
        if (pair1.proxyA.m_id === pair2.proxyA.m_id) return pair1.proxyB.m_id - pair2.proxyB.m_id;
        return pair1.proxyA.m_id - pair2.proxyA.m_id;
      }
      exports.b2_toiTime = 0;
      exports.b2_toiMaxTime = 0;
      exports.b2_toiCalls = 0;
      exports.b2_toiIters = 0;
      exports.b2_toiMaxIters = 0;
      exports.b2_toiRootIters = 0;
      exports.b2_toiMaxRootIters = 0;
      function b2_toi_reset() {
        exports.b2_toiTime = 0;
        exports.b2_toiMaxTime = 0;
        exports.b2_toiCalls = 0;
        exports.b2_toiIters = 0;
        exports.b2_toiMaxIters = 0;
        exports.b2_toiRootIters = 0;
        exports.b2_toiMaxRootIters = 0;
      }
      var b2TimeOfImpact_s_xfA = new b2Transform();
      var b2TimeOfImpact_s_xfB = new b2Transform();
      var b2TimeOfImpact_s_pointA = new b2Vec2();
      var b2TimeOfImpact_s_pointB = new b2Vec2();
      var b2TimeOfImpact_s_normal = new b2Vec2();
      var b2TimeOfImpact_s_axisA = new b2Vec2();
      var b2TimeOfImpact_s_axisB = new b2Vec2();
      var b2TOIInput = (function() {
        function b2TOIInput() {
          this.proxyA = new b2DistanceProxy();
          this.proxyB = new b2DistanceProxy();
          this.sweepA = new b2Sweep();
          this.sweepB = new b2Sweep();
          this.tMax = 0;
        }
        return b2TOIInput;
      })();
      (function(b2TOIOutputState) {
        b2TOIOutputState[b2TOIOutputState["e_unknown"] = 0] = "e_unknown";
        b2TOIOutputState[b2TOIOutputState["e_failed"] = 1] = "e_failed";
        b2TOIOutputState[b2TOIOutputState["e_overlapped"] = 2] = "e_overlapped";
        b2TOIOutputState[b2TOIOutputState["e_touching"] = 3] = "e_touching";
        b2TOIOutputState[b2TOIOutputState["e_separated"] = 4] = "e_separated";
      })(exports.b2TOIOutputState || (exports.b2TOIOutputState = {}));
      var b2TOIOutput = (function() {
        function b2TOIOutput() {
          this.state = exports.b2TOIOutputState.e_unknown;
          this.t = 0;
        }
        return b2TOIOutput;
      })();
      (function(b2SeparationFunctionType) {
        b2SeparationFunctionType[b2SeparationFunctionType["e_unknown"] = -1] = "e_unknown";
        b2SeparationFunctionType[b2SeparationFunctionType["e_points"] = 0] = "e_points";
        b2SeparationFunctionType[b2SeparationFunctionType["e_faceA"] = 1] = "e_faceA";
        b2SeparationFunctionType[b2SeparationFunctionType["e_faceB"] = 2] = "e_faceB";
      })(exports.b2SeparationFunctionType || (exports.b2SeparationFunctionType = {}));
      var b2SeparationFunction = (function() {
        function b2SeparationFunction() {
          this.m_sweepA = new b2Sweep();
          this.m_sweepB = new b2Sweep();
          this.m_type = exports.b2SeparationFunctionType.e_unknown;
          this.m_localPoint = new b2Vec2();
          this.m_axis = new b2Vec2();
        }
        b2SeparationFunction.prototype.Initialize = function(cache, proxyA, sweepA, proxyB, sweepB, t1) {
          this.m_proxyA = proxyA;
          this.m_proxyB = proxyB;
          var count = cache.count;
          this.m_sweepA.Copy(sweepA);
          this.m_sweepB.Copy(sweepB);
          var xfA = b2TimeOfImpact_s_xfA;
          var xfB = b2TimeOfImpact_s_xfB;
          this.m_sweepA.GetTransform(xfA, t1);
          this.m_sweepB.GetTransform(xfB, t1);
          if (1 === count) {
            this.m_type = exports.b2SeparationFunctionType.e_points;
            var localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
            var localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
            var pointA = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);
            var pointB = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);
            b2Vec2.SubVV(pointB, pointA, this.m_axis);
            var s = this.m_axis.Normalize();
            this.m_localPoint.SetZero();
            return s;
          }
          if (cache.indexA[0] === cache.indexA[1]) {
            this.m_type = exports.b2SeparationFunctionType.e_faceB;
            var localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
            var localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
            b2Vec2.CrossVOne(b2Vec2.SubVV(localPointB2, localPointB1, b2Vec2.s_t0), this.m_axis).SelfNormalize();
            var normal = b2Rot.MulRV(xfB.q, this.m_axis, b2TimeOfImpact_s_normal);
            b2Vec2.MidVV(localPointB1, localPointB2, this.m_localPoint);
            var pointB = b2Transform.MulXV(xfB, this.m_localPoint, b2TimeOfImpact_s_pointB);
            var localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
            var pointA = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);
            var s = b2Vec2.DotVV(b2Vec2.SubVV(pointA, pointB, b2Vec2.s_t0), normal);
            if (s < 0) {
              this.m_axis.SelfNeg();
              s = -s;
            }
            return s;
          }
          this.m_type = exports.b2SeparationFunctionType.e_faceA;
          var localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
          var localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
          b2Vec2.CrossVOne(b2Vec2.SubVV(localPointA2, localPointA1, b2Vec2.s_t0), this.m_axis).SelfNormalize();
          var normal = b2Rot.MulRV(xfA.q, this.m_axis, b2TimeOfImpact_s_normal);
          b2Vec2.MidVV(localPointA1, localPointA2, this.m_localPoint);
          var pointA = b2Transform.MulXV(xfA, this.m_localPoint, b2TimeOfImpact_s_pointA);
          var localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
          var pointB = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);
          var s = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), normal);
          if (s < 0) {
            this.m_axis.SelfNeg();
            s = -s;
          }
          return s;
        };
        b2SeparationFunction.prototype.FindMinSeparation = function(indexA, indexB, t) {
          var xfA = b2TimeOfImpact_s_xfA;
          var xfB = b2TimeOfImpact_s_xfB;
          this.m_sweepA.GetTransform(xfA, t);
          this.m_sweepB.GetTransform(xfB, t);
          switch (this.m_type) {
           case exports.b2SeparationFunctionType.e_points:
            var axisA = b2Rot.MulTRV(xfA.q, this.m_axis, b2TimeOfImpact_s_axisA);
            var axisB = b2Rot.MulTRV(xfB.q, b2Vec2.NegV(this.m_axis, b2Vec2.s_t0), b2TimeOfImpact_s_axisB);
            indexA[0] = this.m_proxyA.GetSupport(axisA);
            indexB[0] = this.m_proxyB.GetSupport(axisB);
            var localPointA = this.m_proxyA.GetVertex(indexA[0]);
            var localPointB = this.m_proxyB.GetVertex(indexB[0]);
            var pointA = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);
            var pointB = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);
            var separation = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), this.m_axis);
            return separation;

           case exports.b2SeparationFunctionType.e_faceA:
            var normal = b2Rot.MulRV(xfA.q, this.m_axis, b2TimeOfImpact_s_normal);
            var pointA = b2Transform.MulXV(xfA, this.m_localPoint, b2TimeOfImpact_s_pointA);
            var axisB = b2Rot.MulTRV(xfB.q, b2Vec2.NegV(normal, b2Vec2.s_t0), b2TimeOfImpact_s_axisB);
            indexA[0] = -1;
            indexB[0] = this.m_proxyB.GetSupport(axisB);
            var localPointB = this.m_proxyB.GetVertex(indexB[0]);
            var pointB = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);
            var separation = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), normal);
            return separation;

           case exports.b2SeparationFunctionType.e_faceB:
            var normal = b2Rot.MulRV(xfB.q, this.m_axis, b2TimeOfImpact_s_normal);
            var pointB = b2Transform.MulXV(xfB, this.m_localPoint, b2TimeOfImpact_s_pointB);
            var axisA = b2Rot.MulTRV(xfA.q, b2Vec2.NegV(normal, b2Vec2.s_t0), b2TimeOfImpact_s_axisA);
            indexB[0] = -1;
            indexA[0] = this.m_proxyA.GetSupport(axisA);
            var localPointA = this.m_proxyA.GetVertex(indexA[0]);
            var pointA = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);
            var separation = b2Vec2.DotVV(b2Vec2.SubVV(pointA, pointB, b2Vec2.s_t0), normal);
            return separation;

           default:
            indexA[0] = -1;
            indexB[0] = -1;
            return 0;
          }
        };
        b2SeparationFunction.prototype.Evaluate = function(indexA, indexB, t) {
          var xfA = b2TimeOfImpact_s_xfA;
          var xfB = b2TimeOfImpact_s_xfB;
          this.m_sweepA.GetTransform(xfA, t);
          this.m_sweepB.GetTransform(xfB, t);
          switch (this.m_type) {
           case exports.b2SeparationFunctionType.e_points:
            var localPointA = this.m_proxyA.GetVertex(indexA);
            var localPointB = this.m_proxyB.GetVertex(indexB);
            var pointA = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);
            var pointB = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);
            var separation = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), this.m_axis);
            return separation;

           case exports.b2SeparationFunctionType.e_faceA:
            var normal = b2Rot.MulRV(xfA.q, this.m_axis, b2TimeOfImpact_s_normal);
            var pointA = b2Transform.MulXV(xfA, this.m_localPoint, b2TimeOfImpact_s_pointA);
            var localPointB = this.m_proxyB.GetVertex(indexB);
            var pointB = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);
            var separation = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), normal);
            return separation;

           case exports.b2SeparationFunctionType.e_faceB:
            var normal = b2Rot.MulRV(xfB.q, this.m_axis, b2TimeOfImpact_s_normal);
            var pointB = b2Transform.MulXV(xfB, this.m_localPoint, b2TimeOfImpact_s_pointB);
            var localPointA = this.m_proxyA.GetVertex(indexA);
            var pointA = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);
            var separation = b2Vec2.DotVV(b2Vec2.SubVV(pointA, pointB, b2Vec2.s_t0), normal);
            return separation;

           default:
            return 0;
          }
        };
        return b2SeparationFunction;
      })();
      var b2TimeOfImpact_s_timer = new b2Timer();
      var b2TimeOfImpact_s_cache = new b2SimplexCache();
      var b2TimeOfImpact_s_distanceInput = new b2DistanceInput();
      var b2TimeOfImpact_s_distanceOutput = new b2DistanceOutput();
      var b2TimeOfImpact_s_fcn = new b2SeparationFunction();
      var b2TimeOfImpact_s_indexA = [ 0 ];
      var b2TimeOfImpact_s_indexB = [ 0 ];
      var b2TimeOfImpact_s_sweepA = new b2Sweep();
      var b2TimeOfImpact_s_sweepB = new b2Sweep();
      function b2TimeOfImpact(output, input) {
        var timer = b2TimeOfImpact_s_timer.Reset();
        ++exports.b2_toiCalls;
        output.state = exports.b2TOIOutputState.e_unknown;
        output.t = input.tMax;
        var proxyA = input.proxyA;
        var proxyB = input.proxyB;
        var sweepA = b2TimeOfImpact_s_sweepA.Copy(input.sweepA);
        var sweepB = b2TimeOfImpact_s_sweepB.Copy(input.sweepB);
        sweepA.Normalize();
        sweepB.Normalize();
        var tMax = input.tMax;
        var totalRadius = proxyA.m_radius + proxyB.m_radius;
        var target = b2Max(b2_linearSlop, totalRadius - 3 * b2_linearSlop);
        var tolerance = .25 * b2_linearSlop;
        var t1 = 0;
        var k_maxIterations = 20;
        var iter = 0;
        var cache = b2TimeOfImpact_s_cache;
        cache.count = 0;
        var distanceInput = b2TimeOfImpact_s_distanceInput;
        distanceInput.proxyA.Copy(input.proxyA);
        distanceInput.proxyB.Copy(input.proxyB);
        distanceInput.useRadii = false;
        for (;;) {
          var xfA = b2TimeOfImpact_s_xfA;
          var xfB = b2TimeOfImpact_s_xfB;
          sweepA.GetTransform(xfA, t1);
          sweepB.GetTransform(xfB, t1);
          distanceInput.transformA.Copy(xfA);
          distanceInput.transformB.Copy(xfB);
          var distanceOutput = b2TimeOfImpact_s_distanceOutput;
          b2Distance(distanceOutput, cache, distanceInput);
          if (distanceOutput.distance <= 0) {
            output.state = exports.b2TOIOutputState.e_overlapped;
            output.t = 0;
            break;
          }
          if (distanceOutput.distance < target + tolerance) {
            output.state = exports.b2TOIOutputState.e_touching;
            output.t = t1;
            break;
          }
          var fcn = b2TimeOfImpact_s_fcn;
          fcn.Initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);
          var done = false;
          var t2 = tMax;
          var pushBackIter = 0;
          for (;;) {
            var indexA = b2TimeOfImpact_s_indexA;
            var indexB = b2TimeOfImpact_s_indexB;
            var s2 = fcn.FindMinSeparation(indexA, indexB, t2);
            if (s2 > target + tolerance) {
              output.state = exports.b2TOIOutputState.e_separated;
              output.t = tMax;
              done = true;
              break;
            }
            if (s2 > target - tolerance) {
              t1 = t2;
              break;
            }
            var s1 = fcn.Evaluate(indexA[0], indexB[0], t1);
            if (s1 < target - tolerance) {
              output.state = exports.b2TOIOutputState.e_failed;
              output.t = t1;
              done = true;
              break;
            }
            if (s1 <= target + tolerance) {
              output.state = exports.b2TOIOutputState.e_touching;
              output.t = t1;
              done = true;
              break;
            }
            var rootIterCount = 0;
            var a1 = t1;
            var a2 = t2;
            for (;;) {
              var t = 0;
              t = 1 & rootIterCount ? a1 + (target - s1) * (a2 - a1) / (s2 - s1) : .5 * (a1 + a2);
              ++rootIterCount;
              ++exports.b2_toiRootIters;
              var s = fcn.Evaluate(indexA[0], indexB[0], t);
              if (b2Abs(s - target) < tolerance) {
                t2 = t;
                break;
              }
              if (s > target) {
                a1 = t;
                s1 = s;
              } else {
                a2 = t;
                s2 = s;
              }
              if (50 === rootIterCount) break;
            }
            exports.b2_toiMaxRootIters = b2Max(exports.b2_toiMaxRootIters, rootIterCount);
            ++pushBackIter;
            if (pushBackIter === b2_maxPolygonVertices) break;
          }
          ++iter;
          ++exports.b2_toiIters;
          if (done) break;
          if (iter === k_maxIterations) {
            output.state = exports.b2TOIOutputState.e_failed;
            output.t = t1;
            break;
          }
        }
        exports.b2_toiMaxIters = b2Max(exports.b2_toiMaxIters, iter);
        var time = timer.GetMilliseconds();
        exports.b2_toiMaxTime = b2Max(exports.b2_toiMaxTime, time);
        exports.b2_toiTime += time;
      }
      var b2CollideCircles_s_pA = new b2Vec2();
      var b2CollideCircles_s_pB = new b2Vec2();
      function b2CollideCircles(manifold, circleA, xfA, circleB, xfB) {
        manifold.pointCount = 0;
        var pA = b2Transform.MulXV(xfA, circleA.m_p, b2CollideCircles_s_pA);
        var pB = b2Transform.MulXV(xfB, circleB.m_p, b2CollideCircles_s_pB);
        var distSqr = b2Vec2.DistanceSquaredVV(pA, pB);
        var radius = circleA.m_radius + circleB.m_radius;
        if (distSqr > radius * radius) return;
        manifold.type = exports.b2ManifoldType.e_circles;
        manifold.localPoint.Copy(circleA.m_p);
        manifold.localNormal.SetZero();
        manifold.pointCount = 1;
        manifold.points[0].localPoint.Copy(circleB.m_p);
        manifold.points[0].id.key = 0;
      }
      var b2CollidePolygonAndCircle_s_c = new b2Vec2();
      var b2CollidePolygonAndCircle_s_cLocal = new b2Vec2();
      var b2CollidePolygonAndCircle_s_faceCenter = new b2Vec2();
      function b2CollidePolygonAndCircle(manifold, polygonA, xfA, circleB, xfB) {
        manifold.pointCount = 0;
        var c = b2Transform.MulXV(xfB, circleB.m_p, b2CollidePolygonAndCircle_s_c);
        var cLocal = b2Transform.MulTXV(xfA, c, b2CollidePolygonAndCircle_s_cLocal);
        var normalIndex = 0;
        var separation = -b2_maxFloat;
        var radius = polygonA.m_radius + circleB.m_radius;
        var vertexCount = polygonA.m_count;
        var vertices = polygonA.m_vertices;
        var normals = polygonA.m_normals;
        for (var i = 0; i < vertexCount; ++i) {
          var s = b2Vec2.DotVV(normals[i], b2Vec2.SubVV(cLocal, vertices[i], b2Vec2.s_t0));
          if (s > radius) return;
          if (s > separation) {
            separation = s;
            normalIndex = i;
          }
        }
        var vertIndex1 = normalIndex;
        var vertIndex2 = (vertIndex1 + 1) % vertexCount;
        var v1 = vertices[vertIndex1];
        var v2 = vertices[vertIndex2];
        if (separation < b2_epsilon) {
          manifold.pointCount = 1;
          manifold.type = exports.b2ManifoldType.e_faceA;
          manifold.localNormal.Copy(normals[normalIndex]);
          b2Vec2.MidVV(v1, v2, manifold.localPoint);
          manifold.points[0].localPoint.Copy(circleB.m_p);
          manifold.points[0].id.key = 0;
          return;
        }
        var u1 = b2Vec2.DotVV(b2Vec2.SubVV(cLocal, v1, b2Vec2.s_t0), b2Vec2.SubVV(v2, v1, b2Vec2.s_t1));
        var u2 = b2Vec2.DotVV(b2Vec2.SubVV(cLocal, v2, b2Vec2.s_t0), b2Vec2.SubVV(v1, v2, b2Vec2.s_t1));
        if (u1 <= 0) {
          if (b2Vec2.DistanceSquaredVV(cLocal, v1) > radius * radius) return;
          manifold.pointCount = 1;
          manifold.type = exports.b2ManifoldType.e_faceA;
          b2Vec2.SubVV(cLocal, v1, manifold.localNormal).SelfNormalize();
          manifold.localPoint.Copy(v1);
          manifold.points[0].localPoint.Copy(circleB.m_p);
          manifold.points[0].id.key = 0;
        } else if (u2 <= 0) {
          if (b2Vec2.DistanceSquaredVV(cLocal, v2) > radius * radius) return;
          manifold.pointCount = 1;
          manifold.type = exports.b2ManifoldType.e_faceA;
          b2Vec2.SubVV(cLocal, v2, manifold.localNormal).SelfNormalize();
          manifold.localPoint.Copy(v2);
          manifold.points[0].localPoint.Copy(circleB.m_p);
          manifold.points[0].id.key = 0;
        } else {
          var faceCenter = b2Vec2.MidVV(v1, v2, b2CollidePolygonAndCircle_s_faceCenter);
          var separation_1 = b2Vec2.DotVV(b2Vec2.SubVV(cLocal, faceCenter, b2Vec2.s_t1), normals[vertIndex1]);
          if (separation_1 > radius) return;
          manifold.pointCount = 1;
          manifold.type = exports.b2ManifoldType.e_faceA;
          manifold.localNormal.Copy(normals[vertIndex1]).SelfNormalize();
          manifold.localPoint.Copy(faceCenter);
          manifold.points[0].localPoint.Copy(circleB.m_p);
          manifold.points[0].id.key = 0;
        }
      }
      var b2EdgeSeparation_s_normal1World = new b2Vec2();
      var b2EdgeSeparation_s_normal1 = new b2Vec2();
      var b2EdgeSeparation_s_v1 = new b2Vec2();
      var b2EdgeSeparation_s_v2 = new b2Vec2();
      function b2EdgeSeparation(poly1, xf1, edge1, poly2, xf2) {
        var vertices1 = poly1.m_vertices;
        var normals1 = poly1.m_normals;
        var count2 = poly2.m_count;
        var vertices2 = poly2.m_vertices;
        var normal1World = b2Rot.MulRV(xf1.q, normals1[edge1], b2EdgeSeparation_s_normal1World);
        var normal1 = b2Rot.MulTRV(xf2.q, normal1World, b2EdgeSeparation_s_normal1);
        var index = 0;
        var minDot = b2_maxFloat;
        for (var i = 0; i < count2; ++i) {
          var dot = b2Vec2.DotVV(vertices2[i], normal1);
          if (dot < minDot) {
            minDot = dot;
            index = i;
          }
        }
        var v1 = b2Transform.MulXV(xf1, vertices1[edge1], b2EdgeSeparation_s_v1);
        var v2 = b2Transform.MulXV(xf2, vertices2[index], b2EdgeSeparation_s_v2);
        var separation = b2Vec2.DotVV(b2Vec2.SubVV(v2, v1, b2Vec2.s_t0), normal1World);
        return separation;
      }
      var b2FindMaxSeparation_s_d = new b2Vec2();
      var b2FindMaxSeparation_s_dLocal1 = new b2Vec2();
      function b2FindMaxSeparation(edgeIndex, poly1, xf1, poly2, xf2) {
        var count1 = poly1.m_count;
        var normals1 = poly1.m_normals;
        var d = b2Vec2.SubVV(b2Transform.MulXV(xf2, poly2.m_centroid, b2Vec2.s_t0), b2Transform.MulXV(xf1, poly1.m_centroid, b2Vec2.s_t1), b2FindMaxSeparation_s_d);
        var dLocal1 = b2Rot.MulTRV(xf1.q, d, b2FindMaxSeparation_s_dLocal1);
        var edge = 0;
        var maxDot = -b2_maxFloat;
        for (var i = 0; i < count1; ++i) {
          var dot = b2Vec2.DotVV(normals1[i], dLocal1);
          if (dot > maxDot) {
            maxDot = dot;
            edge = i;
          }
        }
        var s = b2EdgeSeparation(poly1, xf1, edge, poly2, xf2);
        var prevEdge = (edge + count1 - 1) % count1;
        var sPrev = b2EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
        var nextEdge = (edge + 1) % count1;
        var sNext = b2EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
        var bestEdge = 0;
        var bestSeparation = 0;
        var increment = 0;
        if (sPrev > s && sPrev > sNext) {
          increment = -1;
          bestEdge = prevEdge;
          bestSeparation = sPrev;
        } else {
          if (!(sNext > s)) {
            edgeIndex[0] = edge;
            return s;
          }
          increment = 1;
          bestEdge = nextEdge;
          bestSeparation = sNext;
        }
        while (true) {
          edge = -1 === increment ? (bestEdge + count1 - 1) % count1 : (bestEdge + 1) % count1;
          s = b2EdgeSeparation(poly1, xf1, edge, poly2, xf2);
          if (!(s > bestSeparation)) break;
          bestEdge = edge;
          bestSeparation = s;
        }
        edgeIndex[0] = bestEdge;
        return bestSeparation;
      }
      var b2FindIncidentEdge_s_normal1 = new b2Vec2();
      function b2FindIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {
        var normals1 = poly1.m_normals;
        var count2 = poly2.m_count;
        var vertices2 = poly2.m_vertices;
        var normals2 = poly2.m_normals;
        var normal1 = b2Rot.MulTRV(xf2.q, b2Rot.MulRV(xf1.q, normals1[edge1], b2Vec2.s_t0), b2FindIncidentEdge_s_normal1);
        var index = 0;
        var minDot = b2_maxFloat;
        for (var i = 0; i < count2; ++i) {
          var dot = b2Vec2.DotVV(normal1, normals2[i]);
          if (dot < minDot) {
            minDot = dot;
            index = i;
          }
        }
        var i1 = index;
        var i2 = (i1 + 1) % count2;
        var c0 = c[0];
        b2Transform.MulXV(xf2, vertices2[i1], c0.v);
        var cf0 = c0.id.cf;
        cf0.indexA = edge1;
        cf0.indexB = i1;
        cf0.typeA = exports.b2ContactFeatureType.e_face;
        cf0.typeB = exports.b2ContactFeatureType.e_vertex;
        var c1 = c[1];
        b2Transform.MulXV(xf2, vertices2[i2], c1.v);
        var cf1 = c1.id.cf;
        cf1.indexA = edge1;
        cf1.indexB = i2;
        cf1.typeA = exports.b2ContactFeatureType.e_face;
        cf1.typeB = exports.b2ContactFeatureType.e_vertex;
      }
      var b2CollidePolygons_s_incidentEdge = b2ClipVertex.MakeArray(2);
      var b2CollidePolygons_s_clipPoints1 = b2ClipVertex.MakeArray(2);
      var b2CollidePolygons_s_clipPoints2 = b2ClipVertex.MakeArray(2);
      var b2CollidePolygons_s_edgeA = [ 0 ];
      var b2CollidePolygons_s_edgeB = [ 0 ];
      var b2CollidePolygons_s_localTangent = new b2Vec2();
      var b2CollidePolygons_s_localNormal = new b2Vec2();
      var b2CollidePolygons_s_planePoint = new b2Vec2();
      var b2CollidePolygons_s_normal = new b2Vec2();
      var b2CollidePolygons_s_tangent = new b2Vec2();
      var b2CollidePolygons_s_ntangent = new b2Vec2();
      var b2CollidePolygons_s_v11 = new b2Vec2();
      var b2CollidePolygons_s_v12 = new b2Vec2();
      function b2CollidePolygons(manifold, polyA, xfA, polyB, xfB) {
        manifold.pointCount = 0;
        var totalRadius = polyA.m_radius + polyB.m_radius;
        var edgeA = b2CollidePolygons_s_edgeA;
        edgeA[0] = 0;
        var separationA = b2FindMaxSeparation(edgeA, polyA, xfA, polyB, xfB);
        if (separationA > totalRadius) return;
        var edgeB = b2CollidePolygons_s_edgeB;
        edgeB[0] = 0;
        var separationB = b2FindMaxSeparation(edgeB, polyB, xfB, polyA, xfA);
        if (separationB > totalRadius) return;
        var poly1;
        var poly2;
        var xf1, xf2;
        var edge1 = 0;
        var flip = 0;
        var k_relativeTol = .98;
        var k_absoluteTol = .001;
        if (separationB > k_relativeTol * separationA + k_absoluteTol) {
          poly1 = polyB;
          poly2 = polyA;
          xf1 = xfB;
          xf2 = xfA;
          edge1 = edgeB[0];
          manifold.type = exports.b2ManifoldType.e_faceB;
          flip = 1;
        } else {
          poly1 = polyA;
          poly2 = polyB;
          xf1 = xfA;
          xf2 = xfB;
          edge1 = edgeA[0];
          manifold.type = exports.b2ManifoldType.e_faceA;
          flip = 0;
        }
        var incidentEdge = b2CollidePolygons_s_incidentEdge;
        b2FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
        var count1 = poly1.m_count;
        var vertices1 = poly1.m_vertices;
        var iv1 = edge1;
        var iv2 = (edge1 + 1) % count1;
        var local_v11 = vertices1[iv1];
        var local_v12 = vertices1[iv2];
        var localTangent = b2Vec2.SubVV(local_v12, local_v11, b2CollidePolygons_s_localTangent);
        localTangent.Normalize();
        var localNormal = b2Vec2.CrossVOne(localTangent, b2CollidePolygons_s_localNormal);
        var planePoint = b2Vec2.MidVV(local_v11, local_v12, b2CollidePolygons_s_planePoint);
        var tangent = b2Rot.MulRV(xf1.q, localTangent, b2CollidePolygons_s_tangent);
        var normal = b2Vec2.CrossVOne(tangent, b2CollidePolygons_s_normal);
        var v11 = b2Transform.MulXV(xf1, local_v11, b2CollidePolygons_s_v11);
        var v12 = b2Transform.MulXV(xf1, local_v12, b2CollidePolygons_s_v12);
        var frontOffset = b2Vec2.DotVV(normal, v11);
        var sideOffset1 = -b2Vec2.DotVV(tangent, v11) + totalRadius;
        var sideOffset2 = b2Vec2.DotVV(tangent, v12) + totalRadius;
        var clipPoints1 = b2CollidePolygons_s_clipPoints1;
        var clipPoints2 = b2CollidePolygons_s_clipPoints2;
        var np;
        var ntangent = b2Vec2.NegV(tangent, b2CollidePolygons_s_ntangent);
        np = b2ClipSegmentToLine(clipPoints1, incidentEdge, ntangent, sideOffset1, iv1);
        if (np < 2) return;
        np = b2ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);
        if (np < 2) return;
        manifold.localNormal.Copy(localNormal);
        manifold.localPoint.Copy(planePoint);
        var pointCount = 0;
        for (var i = 0; i < b2_maxManifoldPoints; ++i) {
          var cv = clipPoints2[i];
          var separation = b2Vec2.DotVV(normal, cv.v) - frontOffset;
          if (separation <= totalRadius) {
            var cp = manifold.points[pointCount];
            b2Transform.MulTXV(xf2, cv.v, cp.localPoint);
            cp.id.Copy(cv.id);
            if (flip) {
              var cf = cp.id.cf;
              cp.id.cf.indexA = cf.indexB;
              cp.id.cf.indexB = cf.indexA;
              cp.id.cf.typeA = cf.typeB;
              cp.id.cf.typeB = cf.typeA;
            }
            ++pointCount;
          }
        }
        manifold.pointCount = pointCount;
      }
      var b2CollideEdgeAndCircle_s_Q = new b2Vec2();
      var b2CollideEdgeAndCircle_s_e = new b2Vec2();
      var b2CollideEdgeAndCircle_s_d = new b2Vec2();
      var b2CollideEdgeAndCircle_s_e1 = new b2Vec2();
      var b2CollideEdgeAndCircle_s_e2 = new b2Vec2();
      var b2CollideEdgeAndCircle_s_P = new b2Vec2();
      var b2CollideEdgeAndCircle_s_n = new b2Vec2();
      var b2CollideEdgeAndCircle_s_id = new b2ContactID();
      function b2CollideEdgeAndCircle(manifold, edgeA, xfA, circleB, xfB) {
        manifold.pointCount = 0;
        var Q = b2Transform.MulTXV(xfA, b2Transform.MulXV(xfB, circleB.m_p, b2Vec2.s_t0), b2CollideEdgeAndCircle_s_Q);
        var A = edgeA.m_vertex1;
        var B = edgeA.m_vertex2;
        var e = b2Vec2.SubVV(B, A, b2CollideEdgeAndCircle_s_e);
        var u = b2Vec2.DotVV(e, b2Vec2.SubVV(B, Q, b2Vec2.s_t0));
        var v = b2Vec2.DotVV(e, b2Vec2.SubVV(Q, A, b2Vec2.s_t0));
        var radius = edgeA.m_radius + circleB.m_radius;
        var id = b2CollideEdgeAndCircle_s_id;
        id.cf.indexB = 0;
        id.cf.typeB = exports.b2ContactFeatureType.e_vertex;
        if (v <= 0) {
          var P_1 = A;
          var d_1 = b2Vec2.SubVV(Q, P_1, b2CollideEdgeAndCircle_s_d);
          var dd_1 = b2Vec2.DotVV(d_1, d_1);
          if (dd_1 > radius * radius) return;
          if (edgeA.m_hasVertex0) {
            var A1 = edgeA.m_vertex0;
            var B1 = A;
            var e1 = b2Vec2.SubVV(B1, A1, b2CollideEdgeAndCircle_s_e1);
            var u1 = b2Vec2.DotVV(e1, b2Vec2.SubVV(B1, Q, b2Vec2.s_t0));
            if (u1 > 0) return;
          }
          id.cf.indexA = 0;
          id.cf.typeA = exports.b2ContactFeatureType.e_vertex;
          manifold.pointCount = 1;
          manifold.type = exports.b2ManifoldType.e_circles;
          manifold.localNormal.SetZero();
          manifold.localPoint.Copy(P_1);
          manifold.points[0].id.Copy(id);
          manifold.points[0].localPoint.Copy(circleB.m_p);
          return;
        }
        if (u <= 0) {
          var P_2 = B;
          var d_2 = b2Vec2.SubVV(Q, P_2, b2CollideEdgeAndCircle_s_d);
          var dd_2 = b2Vec2.DotVV(d_2, d_2);
          if (dd_2 > radius * radius) return;
          if (edgeA.m_hasVertex3) {
            var B2 = edgeA.m_vertex3;
            var A2 = B;
            var e2 = b2Vec2.SubVV(B2, A2, b2CollideEdgeAndCircle_s_e2);
            var v2 = b2Vec2.DotVV(e2, b2Vec2.SubVV(Q, A2, b2Vec2.s_t0));
            if (v2 > 0) return;
          }
          id.cf.indexA = 1;
          id.cf.typeA = exports.b2ContactFeatureType.e_vertex;
          manifold.pointCount = 1;
          manifold.type = exports.b2ManifoldType.e_circles;
          manifold.localNormal.SetZero();
          manifold.localPoint.Copy(P_2);
          manifold.points[0].id.Copy(id);
          manifold.points[0].localPoint.Copy(circleB.m_p);
          return;
        }
        var den = b2Vec2.DotVV(e, e);
        var P = b2CollideEdgeAndCircle_s_P;
        P.x = 1 / den * (u * A.x + v * B.x);
        P.y = 1 / den * (u * A.y + v * B.y);
        var d = b2Vec2.SubVV(Q, P, b2CollideEdgeAndCircle_s_d);
        var dd = b2Vec2.DotVV(d, d);
        if (dd > radius * radius) return;
        var n = b2CollideEdgeAndCircle_s_n.Set(-e.y, e.x);
        b2Vec2.DotVV(n, b2Vec2.SubVV(Q, A, b2Vec2.s_t0)) < 0 && n.Set(-n.x, -n.y);
        n.Normalize();
        id.cf.indexA = 0;
        id.cf.typeA = exports.b2ContactFeatureType.e_face;
        manifold.pointCount = 1;
        manifold.type = exports.b2ManifoldType.e_faceA;
        manifold.localNormal.Copy(n);
        manifold.localPoint.Copy(A);
        manifold.points[0].id.Copy(id);
        manifold.points[0].localPoint.Copy(circleB.m_p);
      }
      var b2EPAxis = (function() {
        function b2EPAxis() {
          this.type = 0;
          this.index = 0;
          this.separation = 0;
        }
        return b2EPAxis;
      })();
      var b2TempPolygon = (function() {
        function b2TempPolygon() {
          this.vertices = b2Vec2.MakeArray(b2_maxPolygonVertices);
          this.normals = b2Vec2.MakeArray(b2_maxPolygonVertices);
          this.count = 0;
        }
        return b2TempPolygon;
      })();
      var b2ReferenceFace = (function() {
        function b2ReferenceFace() {
          this.i1 = 0;
          this.i2 = 0;
          this.v1 = new b2Vec2();
          this.v2 = new b2Vec2();
          this.normal = new b2Vec2();
          this.sideNormal1 = new b2Vec2();
          this.sideOffset1 = 0;
          this.sideNormal2 = new b2Vec2();
          this.sideOffset2 = 0;
        }
        return b2ReferenceFace;
      })();
      var b2EPCollider = (function() {
        function b2EPCollider() {
          this.m_polygonB = new b2TempPolygon();
          this.m_xf = new b2Transform();
          this.m_centroidB = new b2Vec2();
          this.m_v0 = new b2Vec2();
          this.m_v1 = new b2Vec2();
          this.m_v2 = new b2Vec2();
          this.m_v3 = new b2Vec2();
          this.m_normal0 = new b2Vec2();
          this.m_normal1 = new b2Vec2();
          this.m_normal2 = new b2Vec2();
          this.m_normal = new b2Vec2();
          this.m_type1 = 0;
          this.m_type2 = 0;
          this.m_lowerLimit = new b2Vec2();
          this.m_upperLimit = new b2Vec2();
          this.m_radius = 0;
          this.m_front = false;
        }
        b2EPCollider.prototype.Collide = function(manifold, edgeA, xfA, polygonB, xfB) {
          b2Transform.MulTXX(xfA, xfB, this.m_xf);
          b2Transform.MulXV(this.m_xf, polygonB.m_centroid, this.m_centroidB);
          this.m_v0.Copy(edgeA.m_vertex0);
          this.m_v1.Copy(edgeA.m_vertex1);
          this.m_v2.Copy(edgeA.m_vertex2);
          this.m_v3.Copy(edgeA.m_vertex3);
          var hasVertex0 = edgeA.m_hasVertex0;
          var hasVertex3 = edgeA.m_hasVertex3;
          var edge1 = b2Vec2.SubVV(this.m_v2, this.m_v1, b2EPCollider.s_edge1);
          edge1.Normalize();
          this.m_normal1.Set(edge1.y, -edge1.x);
          var offset1 = b2Vec2.DotVV(this.m_normal1, b2Vec2.SubVV(this.m_centroidB, this.m_v1, b2Vec2.s_t0));
          var offset0 = 0;
          var offset2 = 0;
          var convex1 = false;
          var convex2 = false;
          if (hasVertex0) {
            var edge0 = b2Vec2.SubVV(this.m_v1, this.m_v0, b2EPCollider.s_edge0);
            edge0.Normalize();
            this.m_normal0.Set(edge0.y, -edge0.x);
            convex1 = b2Vec2.CrossVV(edge0, edge1) >= 0;
            offset0 = b2Vec2.DotVV(this.m_normal0, b2Vec2.SubVV(this.m_centroidB, this.m_v0, b2Vec2.s_t0));
          }
          if (hasVertex3) {
            var edge2 = b2Vec2.SubVV(this.m_v3, this.m_v2, b2EPCollider.s_edge2);
            edge2.Normalize();
            this.m_normal2.Set(edge2.y, -edge2.x);
            convex2 = b2Vec2.CrossVV(edge1, edge2) > 0;
            offset2 = b2Vec2.DotVV(this.m_normal2, b2Vec2.SubVV(this.m_centroidB, this.m_v2, b2Vec2.s_t0));
          }
          if (hasVertex0 && hasVertex3) if (convex1 && convex2) {
            this.m_front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;
            if (this.m_front) {
              this.m_normal.Copy(this.m_normal1);
              this.m_lowerLimit.Copy(this.m_normal0);
              this.m_upperLimit.Copy(this.m_normal2);
            } else {
              this.m_normal.Copy(this.m_normal1).SelfNeg();
              this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();
              this.m_upperLimit.Copy(this.m_normal1).SelfNeg();
            }
          } else if (convex1) {
            this.m_front = offset0 >= 0 || offset1 >= 0 && offset2 >= 0;
            if (this.m_front) {
              this.m_normal.Copy(this.m_normal1);
              this.m_lowerLimit.Copy(this.m_normal0);
              this.m_upperLimit.Copy(this.m_normal1);
            } else {
              this.m_normal.Copy(this.m_normal1).SelfNeg();
              this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();
              this.m_upperLimit.Copy(this.m_normal1).SelfNeg();
            }
          } else if (convex2) {
            this.m_front = offset2 >= 0 || offset0 >= 0 && offset1 >= 0;
            if (this.m_front) {
              this.m_normal.Copy(this.m_normal1);
              this.m_lowerLimit.Copy(this.m_normal1);
              this.m_upperLimit.Copy(this.m_normal2);
            } else {
              this.m_normal.Copy(this.m_normal1).SelfNeg();
              this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();
              this.m_upperLimit.Copy(this.m_normal0).SelfNeg();
            }
          } else {
            this.m_front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;
            if (this.m_front) {
              this.m_normal.Copy(this.m_normal1);
              this.m_lowerLimit.Copy(this.m_normal1);
              this.m_upperLimit.Copy(this.m_normal1);
            } else {
              this.m_normal.Copy(this.m_normal1).SelfNeg();
              this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();
              this.m_upperLimit.Copy(this.m_normal0).SelfNeg();
            }
          } else if (hasVertex0) if (convex1) {
            this.m_front = offset0 >= 0 || offset1 >= 0;
            if (this.m_front) {
              this.m_normal.Copy(this.m_normal1);
              this.m_lowerLimit.Copy(this.m_normal0);
              this.m_upperLimit.Copy(this.m_normal1).SelfNeg();
            } else {
              this.m_normal.Copy(this.m_normal1).SelfNeg();
              this.m_lowerLimit.Copy(this.m_normal1);
              this.m_upperLimit.Copy(this.m_normal1).SelfNeg();
            }
          } else {
            this.m_front = offset0 >= 0 && offset1 >= 0;
            if (this.m_front) {
              this.m_normal.Copy(this.m_normal1);
              this.m_lowerLimit.Copy(this.m_normal1);
              this.m_upperLimit.Copy(this.m_normal1).SelfNeg();
            } else {
              this.m_normal.Copy(this.m_normal1).SelfNeg();
              this.m_lowerLimit.Copy(this.m_normal1);
              this.m_upperLimit.Copy(this.m_normal0).SelfNeg();
            }
          } else if (hasVertex3) if (convex2) {
            this.m_front = offset1 >= 0 || offset2 >= 0;
            if (this.m_front) {
              this.m_normal.Copy(this.m_normal1);
              this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();
              this.m_upperLimit.Copy(this.m_normal2);
            } else {
              this.m_normal.Copy(this.m_normal1).SelfNeg();
              this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();
              this.m_upperLimit.Copy(this.m_normal1);
            }
          } else {
            this.m_front = offset1 >= 0 && offset2 >= 0;
            if (this.m_front) {
              this.m_normal.Copy(this.m_normal1);
              this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();
              this.m_upperLimit.Copy(this.m_normal1);
            } else {
              this.m_normal.Copy(this.m_normal1).SelfNeg();
              this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();
              this.m_upperLimit.Copy(this.m_normal1);
            }
          } else {
            this.m_front = offset1 >= 0;
            if (this.m_front) {
              this.m_normal.Copy(this.m_normal1);
              this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();
              this.m_upperLimit.Copy(this.m_normal1).SelfNeg();
            } else {
              this.m_normal.Copy(this.m_normal1).SelfNeg();
              this.m_lowerLimit.Copy(this.m_normal1);
              this.m_upperLimit.Copy(this.m_normal1);
            }
          }
          this.m_polygonB.count = polygonB.m_count;
          for (var i = 0; i < polygonB.m_count; ++i) {
            b2Transform.MulXV(this.m_xf, polygonB.m_vertices[i], this.m_polygonB.vertices[i]);
            b2Rot.MulRV(this.m_xf.q, polygonB.m_normals[i], this.m_polygonB.normals[i]);
          }
          this.m_radius = polygonB.m_radius + edgeA.m_radius;
          manifold.pointCount = 0;
          var edgeAxis = this.ComputeEdgeSeparation(b2EPCollider.s_edgeAxis);
          if (0 === edgeAxis.type) return;
          if (edgeAxis.separation > this.m_radius) return;
          var polygonAxis = this.ComputePolygonSeparation(b2EPCollider.s_polygonAxis);
          if (0 !== polygonAxis.type && polygonAxis.separation > this.m_radius) return;
          var k_relativeTol = .98;
          var k_absoluteTol = .001;
          var primaryAxis;
          primaryAxis = 0 === polygonAxis.type ? edgeAxis : polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol ? polygonAxis : edgeAxis;
          var ie = b2EPCollider.s_ie;
          var rf = b2EPCollider.s_rf;
          if (1 === primaryAxis.type) {
            manifold.type = exports.b2ManifoldType.e_faceA;
            var bestIndex = 0;
            var bestValue = b2Vec2.DotVV(this.m_normal, this.m_polygonB.normals[0]);
            for (var i = 1; i < this.m_polygonB.count; ++i) {
              var value = b2Vec2.DotVV(this.m_normal, this.m_polygonB.normals[i]);
              if (value < bestValue) {
                bestValue = value;
                bestIndex = i;
              }
            }
            var i1 = bestIndex;
            var i2 = (i1 + 1) % this.m_polygonB.count;
            var ie0 = ie[0];
            ie0.v.Copy(this.m_polygonB.vertices[i1]);
            ie0.id.cf.indexA = 0;
            ie0.id.cf.indexB = i1;
            ie0.id.cf.typeA = exports.b2ContactFeatureType.e_face;
            ie0.id.cf.typeB = exports.b2ContactFeatureType.e_vertex;
            var ie1 = ie[1];
            ie1.v.Copy(this.m_polygonB.vertices[i2]);
            ie1.id.cf.indexA = 0;
            ie1.id.cf.indexB = i2;
            ie1.id.cf.typeA = exports.b2ContactFeatureType.e_face;
            ie1.id.cf.typeB = exports.b2ContactFeatureType.e_vertex;
            if (this.m_front) {
              rf.i1 = 0;
              rf.i2 = 1;
              rf.v1.Copy(this.m_v1);
              rf.v2.Copy(this.m_v2);
              rf.normal.Copy(this.m_normal1);
            } else {
              rf.i1 = 1;
              rf.i2 = 0;
              rf.v1.Copy(this.m_v2);
              rf.v2.Copy(this.m_v1);
              rf.normal.Copy(this.m_normal1).SelfNeg();
            }
          } else {
            manifold.type = exports.b2ManifoldType.e_faceB;
            var ie0 = ie[0];
            ie0.v.Copy(this.m_v1);
            ie0.id.cf.indexA = 0;
            ie0.id.cf.indexB = primaryAxis.index;
            ie0.id.cf.typeA = exports.b2ContactFeatureType.e_vertex;
            ie0.id.cf.typeB = exports.b2ContactFeatureType.e_face;
            var ie1 = ie[1];
            ie1.v.Copy(this.m_v2);
            ie1.id.cf.indexA = 0;
            ie1.id.cf.indexB = primaryAxis.index;
            ie1.id.cf.typeA = exports.b2ContactFeatureType.e_vertex;
            ie1.id.cf.typeB = exports.b2ContactFeatureType.e_face;
            rf.i1 = primaryAxis.index;
            rf.i2 = (rf.i1 + 1) % this.m_polygonB.count;
            rf.v1.Copy(this.m_polygonB.vertices[rf.i1]);
            rf.v2.Copy(this.m_polygonB.vertices[rf.i2]);
            rf.normal.Copy(this.m_polygonB.normals[rf.i1]);
          }
          rf.sideNormal1.Set(rf.normal.y, -rf.normal.x);
          rf.sideNormal2.Copy(rf.sideNormal1).SelfNeg();
          rf.sideOffset1 = b2Vec2.DotVV(rf.sideNormal1, rf.v1);
          rf.sideOffset2 = b2Vec2.DotVV(rf.sideNormal2, rf.v2);
          var clipPoints1 = b2EPCollider.s_clipPoints1;
          var clipPoints2 = b2EPCollider.s_clipPoints2;
          var np = 0;
          np = b2ClipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);
          if (np < b2_maxManifoldPoints) return;
          np = b2ClipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);
          if (np < b2_maxManifoldPoints) return;
          if (1 === primaryAxis.type) {
            manifold.localNormal.Copy(rf.normal);
            manifold.localPoint.Copy(rf.v1);
          } else {
            manifold.localNormal.Copy(polygonB.m_normals[rf.i1]);
            manifold.localPoint.Copy(polygonB.m_vertices[rf.i1]);
          }
          var pointCount = 0;
          for (var i = 0; i < b2_maxManifoldPoints; ++i) {
            var separation = void 0;
            separation = b2Vec2.DotVV(rf.normal, b2Vec2.SubVV(clipPoints2[i].v, rf.v1, b2Vec2.s_t0));
            if (separation <= this.m_radius) {
              var cp = manifold.points[pointCount];
              if (1 === primaryAxis.type) {
                b2Transform.MulTXV(this.m_xf, clipPoints2[i].v, cp.localPoint);
                cp.id = clipPoints2[i].id;
              } else {
                cp.localPoint.Copy(clipPoints2[i].v);
                cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;
                cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;
                cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;
                cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;
              }
              ++pointCount;
            }
          }
          manifold.pointCount = pointCount;
        };
        b2EPCollider.prototype.ComputeEdgeSeparation = function(out) {
          var axis = out;
          axis.type = 1;
          axis.index = this.m_front ? 0 : 1;
          axis.separation = b2_maxFloat;
          for (var i = 0; i < this.m_polygonB.count; ++i) {
            var s = b2Vec2.DotVV(this.m_normal, b2Vec2.SubVV(this.m_polygonB.vertices[i], this.m_v1, b2Vec2.s_t0));
            s < axis.separation && (axis.separation = s);
          }
          return axis;
        };
        b2EPCollider.prototype.ComputePolygonSeparation = function(out) {
          var axis = out;
          axis.type = 0;
          axis.index = -1;
          axis.separation = -b2_maxFloat;
          var perp = b2EPCollider.s_perp.Set(-this.m_normal.y, this.m_normal.x);
          for (var i = 0; i < this.m_polygonB.count; ++i) {
            var n = b2Vec2.NegV(this.m_polygonB.normals[i], b2EPCollider.s_n);
            var s1 = b2Vec2.DotVV(n, b2Vec2.SubVV(this.m_polygonB.vertices[i], this.m_v1, b2Vec2.s_t0));
            var s2 = b2Vec2.DotVV(n, b2Vec2.SubVV(this.m_polygonB.vertices[i], this.m_v2, b2Vec2.s_t0));
            var s = b2Min(s1, s2);
            if (s > this.m_radius) {
              axis.type = 2;
              axis.index = i;
              axis.separation = s;
              return axis;
            }
            if (b2Vec2.DotVV(n, perp) >= 0) {
              if (b2Vec2.DotVV(b2Vec2.SubVV(n, this.m_upperLimit, b2Vec2.s_t0), this.m_normal) < -b2_angularSlop) continue;
            } else if (b2Vec2.DotVV(b2Vec2.SubVV(n, this.m_lowerLimit, b2Vec2.s_t0), this.m_normal) < -b2_angularSlop) continue;
            if (s > axis.separation) {
              axis.type = 2;
              axis.index = i;
              axis.separation = s;
            }
          }
          return axis;
        };
        b2EPCollider.s_edge1 = new b2Vec2();
        b2EPCollider.s_edge0 = new b2Vec2();
        b2EPCollider.s_edge2 = new b2Vec2();
        b2EPCollider.s_ie = b2ClipVertex.MakeArray(2);
        b2EPCollider.s_rf = new b2ReferenceFace();
        b2EPCollider.s_clipPoints1 = b2ClipVertex.MakeArray(2);
        b2EPCollider.s_clipPoints2 = b2ClipVertex.MakeArray(2);
        b2EPCollider.s_edgeAxis = new b2EPAxis();
        b2EPCollider.s_polygonAxis = new b2EPAxis();
        b2EPCollider.s_n = new b2Vec2();
        b2EPCollider.s_perp = new b2Vec2();
        return b2EPCollider;
      })();
      var b2CollideEdgeAndPolygon_s_collider = new b2EPCollider();
      function b2CollideEdgeAndPolygon(manifold, edgeA, xfA, polygonB, xfB) {
        var collider = b2CollideEdgeAndPolygon_s_collider;
        collider.Collide(manifold, edgeA, xfA, polygonB, xfB);
      }
      var b2MassData = (function() {
        function b2MassData() {
          this.mass = 0;
          this.center = new b2Vec2(0, 0);
          this.I = 0;
        }
        return b2MassData;
      })();
      (function(b2ShapeType) {
        b2ShapeType[b2ShapeType["e_unknown"] = -1] = "e_unknown";
        b2ShapeType[b2ShapeType["e_circleShape"] = 0] = "e_circleShape";
        b2ShapeType[b2ShapeType["e_edgeShape"] = 1] = "e_edgeShape";
        b2ShapeType[b2ShapeType["e_polygonShape"] = 2] = "e_polygonShape";
        b2ShapeType[b2ShapeType["e_chainShape"] = 3] = "e_chainShape";
        b2ShapeType[b2ShapeType["e_shapeTypeCount"] = 4] = "e_shapeTypeCount";
      })(exports.b2ShapeType || (exports.b2ShapeType = {}));
      var b2Shape = (function() {
        function b2Shape(type, radius) {
          this.m_type = exports.b2ShapeType.e_unknown;
          this.m_radius = 0;
          this.m_type = type;
          this.m_radius = radius;
        }
        b2Shape.prototype.Copy = function(other) {
          this.m_radius = other.m_radius;
          return this;
        };
        b2Shape.prototype.GetType = function() {
          return this.m_type;
        };
        return b2Shape;
      })();
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
      };
      function __extends(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var b2CircleShape = (function(_super) {
        __extends(b2CircleShape, _super);
        function b2CircleShape(radius) {
          void 0 === radius && (radius = 0);
          var _this = _super.call(this, exports.b2ShapeType.e_circleShape, radius) || this;
          _this.m_p = new b2Vec2();
          return _this;
        }
        b2CircleShape.prototype.Set = function(position, radius) {
          void 0 === radius && (radius = this.m_radius);
          this.m_p.Copy(position);
          this.m_radius = radius;
          return this;
        };
        b2CircleShape.prototype.Clone = function() {
          return new b2CircleShape().Copy(this);
        };
        b2CircleShape.prototype.Copy = function(other) {
          _super.prototype.Copy.call(this, other);
          this.m_p.Copy(other.m_p);
          return this;
        };
        b2CircleShape.prototype.GetChildCount = function() {
          return 1;
        };
        b2CircleShape.prototype.TestPoint = function(transform, p) {
          var center = b2Transform.MulXV(transform, this.m_p, b2CircleShape.TestPoint_s_center);
          var d = b2Vec2.SubVV(p, center, b2CircleShape.TestPoint_s_d);
          return b2Vec2.DotVV(d, d) <= b2Sq(this.m_radius);
        };
        b2CircleShape.prototype.ComputeDistance = function(xf, p, normal, childIndex) {
          var center = b2Transform.MulXV(xf, this.m_p, b2CircleShape.ComputeDistance_s_center);
          b2Vec2.SubVV(p, center, normal);
          return normal.Normalize() - this.m_radius;
        };
        b2CircleShape.prototype.RayCast = function(output, input, transform, childIndex) {
          var position = b2Transform.MulXV(transform, this.m_p, b2CircleShape.RayCast_s_position);
          var s = b2Vec2.SubVV(input.p1, position, b2CircleShape.RayCast_s_s);
          var b = b2Vec2.DotVV(s, s) - b2Sq(this.m_radius);
          var r = b2Vec2.SubVV(input.p2, input.p1, b2CircleShape.RayCast_s_r);
          var c = b2Vec2.DotVV(s, r);
          var rr = b2Vec2.DotVV(r, r);
          var sigma = c * c - rr * b;
          if (sigma < 0 || rr < b2_epsilon) return false;
          var a = -(c + b2Sqrt(sigma));
          if (0 <= a && a <= input.maxFraction * rr) {
            a /= rr;
            output.fraction = a;
            b2Vec2.AddVMulSV(s, a, r, output.normal).SelfNormalize();
            return true;
          }
          return false;
        };
        b2CircleShape.prototype.ComputeAABB = function(aabb, transform, childIndex) {
          var p = b2Transform.MulXV(transform, this.m_p, b2CircleShape.ComputeAABB_s_p);
          aabb.lowerBound.Set(p.x - this.m_radius, p.y - this.m_radius);
          aabb.upperBound.Set(p.x + this.m_radius, p.y + this.m_radius);
        };
        b2CircleShape.prototype.ComputeMass = function(massData, density) {
          var radius_sq = b2Sq(this.m_radius);
          massData.mass = density * b2_pi * radius_sq;
          massData.center.Copy(this.m_p);
          massData.I = massData.mass * (.5 * radius_sq + b2Vec2.DotVV(this.m_p, this.m_p));
        };
        b2CircleShape.prototype.SetupDistanceProxy = function(proxy, index) {
          proxy.m_vertices = proxy.m_buffer;
          proxy.m_vertices[0].Copy(this.m_p);
          proxy.m_count = 1;
          proxy.m_radius = this.m_radius;
        };
        b2CircleShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
          var p = b2Transform.MulXV(xf, this.m_p, new b2Vec2());
          var l = -(b2Vec2.DotVV(normal, p) - offset);
          if (l < -this.m_radius + b2_epsilon) return 0;
          if (l > this.m_radius) {
            c.Copy(p);
            return b2_pi * this.m_radius * this.m_radius;
          }
          var r2 = this.m_radius * this.m_radius;
          var l2 = l * l;
          var area = r2 * (b2Asin(l / this.m_radius) + b2_pi / 2) + l * b2Sqrt(r2 - l2);
          var com = -2 / 3 * b2Pow(r2 - l2, 1.5) / area;
          c.x = p.x + normal.x * com;
          c.y = p.y + normal.y * com;
          return area;
        };
        b2CircleShape.prototype.Dump = function(log) {
          log("    const shape: b2CircleShape = new b2CircleShape();\n");
          log("    shape.m_radius = %.15f;\n", this.m_radius);
          log("    shape.m_p.Set(%.15f, %.15f);\n", this.m_p.x, this.m_p.y);
        };
        b2CircleShape.TestPoint_s_center = new b2Vec2();
        b2CircleShape.TestPoint_s_d = new b2Vec2();
        b2CircleShape.ComputeDistance_s_center = new b2Vec2();
        b2CircleShape.RayCast_s_position = new b2Vec2();
        b2CircleShape.RayCast_s_s = new b2Vec2();
        b2CircleShape.RayCast_s_r = new b2Vec2();
        b2CircleShape.ComputeAABB_s_p = new b2Vec2();
        return b2CircleShape;
      })(b2Shape);
      var b2PolygonShape = (function(_super) {
        __extends(b2PolygonShape, _super);
        function b2PolygonShape() {
          var _this = _super.call(this, exports.b2ShapeType.e_polygonShape, b2_polygonRadius) || this;
          _this.m_centroid = new b2Vec2(0, 0);
          _this.m_vertices = [];
          _this.m_normals = [];
          _this.m_count = 0;
          return _this;
        }
        b2PolygonShape.prototype.Clone = function() {
          return new b2PolygonShape().Copy(this);
        };
        b2PolygonShape.prototype.Copy = function(other) {
          _super.prototype.Copy.call(this, other);
          this.m_centroid.Copy(other.m_centroid);
          this.m_count = other.m_count;
          this.m_vertices = b2Vec2.MakeArray(this.m_count);
          this.m_normals = b2Vec2.MakeArray(this.m_count);
          for (var i = 0; i < this.m_count; ++i) {
            this.m_vertices[i].Copy(other.m_vertices[i]);
            this.m_normals[i].Copy(other.m_normals[i]);
          }
          return this;
        };
        b2PolygonShape.prototype.GetChildCount = function() {
          return 1;
        };
        b2PolygonShape.prototype.Set = function(vertices, count, start) {
          void 0 === count && (count = vertices.length);
          void 0 === start && (start = 0);
          if (count < 3) return this.SetAsBox(1, 1);
          var n = b2Min(count, b2_maxPolygonVertices);
          var ps = b2PolygonShape.Set_s_ps;
          var tempCount = 0;
          for (var i = 0; i < n; ++i) {
            var v = vertices[start + i];
            var unique = true;
            for (var j = 0; j < tempCount; ++j) if (b2Vec2.DistanceSquaredVV(v, ps[j]) < .5 * b2_linearSlop * (.5 * b2_linearSlop)) {
              unique = false;
              break;
            }
            unique && ps[tempCount++].Copy(v);
          }
          n = tempCount;
          if (n < 3) return this.SetAsBox(1, 1);
          var i0 = 0;
          var x0 = ps[0].x;
          for (var i = 1; i < n; ++i) {
            var x = ps[i].x;
            if (x > x0 || x === x0 && ps[i].y < ps[i0].y) {
              i0 = i;
              x0 = x;
            }
          }
          var hull = b2PolygonShape.Set_s_hull;
          var m = 0;
          var ih = i0;
          for (;;) {
            hull[m] = ih;
            var ie = 0;
            for (var j = 1; j < n; ++j) {
              if (ie === ih) {
                ie = j;
                continue;
              }
              var r = b2Vec2.SubVV(ps[ie], ps[hull[m]], b2PolygonShape.Set_s_r);
              var v = b2Vec2.SubVV(ps[j], ps[hull[m]], b2PolygonShape.Set_s_v);
              var c = b2Vec2.CrossVV(r, v);
              c < 0 && (ie = j);
              0 === c && v.LengthSquared() > r.LengthSquared() && (ie = j);
            }
            ++m;
            ih = ie;
            if (ie === i0) break;
          }
          this.m_count = m;
          this.m_vertices = b2Vec2.MakeArray(this.m_count);
          this.m_normals = b2Vec2.MakeArray(this.m_count);
          for (var i = 0; i < m; ++i) this.m_vertices[i].Copy(ps[hull[i]]);
          for (var i = 0; i < m; ++i) {
            var vertexi1 = this.m_vertices[i];
            var vertexi2 = this.m_vertices[(i + 1) % m];
            var edge = b2Vec2.SubVV(vertexi2, vertexi1, b2Vec2.s_t0);
            b2Vec2.CrossVOne(edge, this.m_normals[i]).SelfNormalize();
          }
          b2PolygonShape.ComputeCentroid(this.m_vertices, m, this.m_centroid);
          return this;
        };
        b2PolygonShape.prototype.SetAsArray = function(vertices, count) {
          void 0 === count && (count = vertices.length);
          return this.Set(vertices, count);
        };
        b2PolygonShape.prototype.SetAsBox = function(hx, hy, center, angle) {
          void 0 === angle && (angle = 0);
          this.m_count = 4;
          this.m_vertices = b2Vec2.MakeArray(this.m_count);
          this.m_normals = b2Vec2.MakeArray(this.m_count);
          this.m_vertices[0].Set(-hx, -hy);
          this.m_vertices[1].Set(hx, -hy);
          this.m_vertices[2].Set(hx, hy);
          this.m_vertices[3].Set(-hx, hy);
          this.m_normals[0].Set(0, -1);
          this.m_normals[1].Set(1, 0);
          this.m_normals[2].Set(0, 1);
          this.m_normals[3].Set(-1, 0);
          this.m_centroid.SetZero();
          if (center) {
            this.m_centroid.Copy(center);
            var xf = new b2Transform();
            xf.SetPosition(center);
            xf.SetRotationAngle(angle);
            for (var i = 0; i < this.m_count; ++i) {
              b2Transform.MulXV(xf, this.m_vertices[i], this.m_vertices[i]);
              b2Rot.MulRV(xf.q, this.m_normals[i], this.m_normals[i]);
            }
          }
          return this;
        };
        b2PolygonShape.prototype.TestPoint = function(xf, p) {
          var pLocal = b2Transform.MulTXV(xf, p, b2PolygonShape.TestPoint_s_pLocal);
          for (var i = 0; i < this.m_count; ++i) {
            var dot = b2Vec2.DotVV(this.m_normals[i], b2Vec2.SubVV(pLocal, this.m_vertices[i], b2Vec2.s_t0));
            if (dot > 0) return false;
          }
          return true;
        };
        b2PolygonShape.prototype.ComputeDistance = function(xf, p, normal, childIndex) {
          var pLocal = b2Transform.MulTXV(xf, p, b2PolygonShape.ComputeDistance_s_pLocal);
          var maxDistance = -b2_maxFloat;
          var normalForMaxDistance = b2PolygonShape.ComputeDistance_s_normalForMaxDistance.Copy(pLocal);
          for (var i = 0; i < this.m_count; ++i) {
            var dot = b2Vec2.DotVV(this.m_normals[i], b2Vec2.SubVV(pLocal, this.m_vertices[i], b2Vec2.s_t0));
            if (dot > maxDistance) {
              maxDistance = dot;
              normalForMaxDistance.Copy(this.m_normals[i]);
            }
          }
          if (maxDistance > 0) {
            var minDistance = b2PolygonShape.ComputeDistance_s_minDistance.Copy(normalForMaxDistance);
            var minDistance2 = maxDistance * maxDistance;
            for (var i = 0; i < this.m_count; ++i) {
              var distance = b2Vec2.SubVV(pLocal, this.m_vertices[i], b2PolygonShape.ComputeDistance_s_distance);
              var distance2 = distance.LengthSquared();
              if (minDistance2 > distance2) {
                minDistance.Copy(distance);
                minDistance2 = distance2;
              }
            }
            b2Rot.MulRV(xf.q, minDistance, normal);
            normal.Normalize();
            return Math.sqrt(minDistance2);
          }
          b2Rot.MulRV(xf.q, normalForMaxDistance, normal);
          return maxDistance;
        };
        b2PolygonShape.prototype.RayCast = function(output, input, xf, childIndex) {
          var p1 = b2Transform.MulTXV(xf, input.p1, b2PolygonShape.RayCast_s_p1);
          var p2 = b2Transform.MulTXV(xf, input.p2, b2PolygonShape.RayCast_s_p2);
          var d = b2Vec2.SubVV(p2, p1, b2PolygonShape.RayCast_s_d);
          var lower = 0, upper = input.maxFraction;
          var index = -1;
          for (var i = 0; i < this.m_count; ++i) {
            var numerator = b2Vec2.DotVV(this.m_normals[i], b2Vec2.SubVV(this.m_vertices[i], p1, b2Vec2.s_t0));
            var denominator = b2Vec2.DotVV(this.m_normals[i], d);
            if (0 === denominator) {
              if (numerator < 0) return false;
            } else if (denominator < 0 && numerator < lower * denominator) {
              lower = numerator / denominator;
              index = i;
            } else denominator > 0 && numerator < upper * denominator && (upper = numerator / denominator);
            if (upper < lower) return false;
          }
          if (index >= 0) {
            output.fraction = lower;
            b2Rot.MulRV(xf.q, this.m_normals[index], output.normal);
            return true;
          }
          return false;
        };
        b2PolygonShape.prototype.ComputeAABB = function(aabb, xf, childIndex) {
          var lower = b2Transform.MulXV(xf, this.m_vertices[0], aabb.lowerBound);
          var upper = aabb.upperBound.Copy(lower);
          for (var i = 0; i < this.m_count; ++i) {
            var v = b2Transform.MulXV(xf, this.m_vertices[i], b2PolygonShape.ComputeAABB_s_v);
            b2Vec2.MinV(v, lower, lower);
            b2Vec2.MaxV(v, upper, upper);
          }
          var r = this.m_radius;
          lower.SelfSubXY(r, r);
          upper.SelfAddXY(r, r);
        };
        b2PolygonShape.prototype.ComputeMass = function(massData, density) {
          var center = b2PolygonShape.ComputeMass_s_center.SetZero();
          var area = 0;
          var I = 0;
          var s = b2PolygonShape.ComputeMass_s_s.SetZero();
          for (var i = 0; i < this.m_count; ++i) s.SelfAdd(this.m_vertices[i]);
          s.SelfMul(1 / this.m_count);
          var k_inv3 = 1 / 3;
          for (var i = 0; i < this.m_count; ++i) {
            var e1 = b2Vec2.SubVV(this.m_vertices[i], s, b2PolygonShape.ComputeMass_s_e1);
            var e2 = b2Vec2.SubVV(this.m_vertices[(i + 1) % this.m_count], s, b2PolygonShape.ComputeMass_s_e2);
            var D = b2Vec2.CrossVV(e1, e2);
            var triangleArea = .5 * D;
            area += triangleArea;
            center.SelfAdd(b2Vec2.MulSV(triangleArea * k_inv3, b2Vec2.AddVV(e1, e2, b2Vec2.s_t0), b2Vec2.s_t1));
            var ex1 = e1.x;
            var ey1 = e1.y;
            var ex2 = e2.x;
            var ey2 = e2.y;
            var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;
            var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;
            I += .25 * k_inv3 * D * (intx2 + inty2);
          }
          massData.mass = density * area;
          center.SelfMul(1 / area);
          b2Vec2.AddVV(center, s, massData.center);
          massData.I = density * I;
          massData.I += massData.mass * (b2Vec2.DotVV(massData.center, massData.center) - b2Vec2.DotVV(center, center));
        };
        b2PolygonShape.prototype.Validate = function() {
          for (var i = 0; i < this.m_count; ++i) {
            var i1 = i;
            var i2 = (i + 1) % this.m_count;
            var p = this.m_vertices[i1];
            var e = b2Vec2.SubVV(this.m_vertices[i2], p, b2PolygonShape.Validate_s_e);
            for (var j = 0; j < this.m_count; ++j) {
              if (j === i1 || j === i2) continue;
              var v = b2Vec2.SubVV(this.m_vertices[j], p, b2PolygonShape.Validate_s_v);
              var c = b2Vec2.CrossVV(e, v);
              if (c < 0) return false;
            }
          }
          return true;
        };
        b2PolygonShape.prototype.SetupDistanceProxy = function(proxy, index) {
          proxy.m_vertices = this.m_vertices;
          proxy.m_count = this.m_count;
          proxy.m_radius = this.m_radius;
        };
        b2PolygonShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
          var normalL = b2Rot.MulTRV(xf.q, normal, b2PolygonShape.ComputeSubmergedArea_s_normalL);
          var offsetL = offset - b2Vec2.DotVV(normal, xf.p);
          var depths = b2PolygonShape.ComputeSubmergedArea_s_depths;
          var diveCount = 0;
          var intoIndex = -1;
          var outoIndex = -1;
          var lastSubmerged = false;
          for (var i_1 = 0; i_1 < this.m_count; ++i_1) {
            depths[i_1] = b2Vec2.DotVV(normalL, this.m_vertices[i_1]) - offsetL;
            var isSubmerged = depths[i_1] < -b2_epsilon;
            if (i_1 > 0) if (isSubmerged) {
              if (!lastSubmerged) {
                intoIndex = i_1 - 1;
                diveCount++;
              }
            } else if (lastSubmerged) {
              outoIndex = i_1 - 1;
              diveCount++;
            }
            lastSubmerged = isSubmerged;
          }
          switch (diveCount) {
           case 0:
            if (lastSubmerged) {
              var md = b2PolygonShape.ComputeSubmergedArea_s_md;
              this.ComputeMass(md, 1);
              b2Transform.MulXV(xf, md.center, c);
              return md.mass;
            }
            return 0;

           case 1:
            -1 === intoIndex ? intoIndex = this.m_count - 1 : outoIndex = this.m_count - 1;
          }
          var intoIndex2 = (intoIndex + 1) % this.m_count;
          var outoIndex2 = (outoIndex + 1) % this.m_count;
          var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
          var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
          var intoVec = b2PolygonShape.ComputeSubmergedArea_s_intoVec.Set(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
          var outoVec = b2PolygonShape.ComputeSubmergedArea_s_outoVec.Set(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
          var area = 0;
          var center = b2PolygonShape.ComputeSubmergedArea_s_center.SetZero();
          var p2 = this.m_vertices[intoIndex2];
          var p3;
          var i = intoIndex2;
          while (i !== outoIndex2) {
            i = (i + 1) % this.m_count;
            p3 = i === outoIndex2 ? outoVec : this.m_vertices[i];
            var triangleArea = .5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
            area += triangleArea;
            center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
            center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
            p2 = p3;
          }
          center.SelfMul(1 / area);
          b2Transform.MulXV(xf, center, c);
          return area;
        };
        b2PolygonShape.prototype.Dump = function(log) {
          log("    const shape: b2PolygonShape = new b2PolygonShape();\n");
          log("    const vs: b2Vec2[] = b2Vec2.MakeArray(%d);\n", b2_maxPolygonVertices);
          for (var i = 0; i < this.m_count; ++i) log("    vs[%d].Set(%.15f, %.15f);\n", i, this.m_vertices[i].x, this.m_vertices[i].y);
          log("    shape.Set(vs, %d);\n", this.m_count);
        };
        b2PolygonShape.ComputeCentroid = function(vs, count, out) {
          var c = out;
          c.SetZero();
          var area = 0;
          var pRef = b2PolygonShape.ComputeCentroid_s_pRef.SetZero();
          var inv3 = 1 / 3;
          for (var i = 0; i < count; ++i) {
            var p1 = pRef;
            var p2 = vs[i];
            var p3 = vs[(i + 1) % count];
            var e1 = b2Vec2.SubVV(p2, p1, b2PolygonShape.ComputeCentroid_s_e1);
            var e2 = b2Vec2.SubVV(p3, p1, b2PolygonShape.ComputeCentroid_s_e2);
            var D = b2Vec2.CrossVV(e1, e2);
            var triangleArea = .5 * D;
            area += triangleArea;
            c.x += triangleArea * inv3 * (p1.x + p2.x + p3.x);
            c.y += triangleArea * inv3 * (p1.y + p2.y + p3.y);
          }
          c.SelfMul(1 / area);
          return c;
        };
        b2PolygonShape.Set_s_ps = b2Vec2.MakeArray(b2_maxPolygonVertices);
        b2PolygonShape.Set_s_hull = b2MakeNumberArray(b2_maxPolygonVertices);
        b2PolygonShape.Set_s_r = new b2Vec2();
        b2PolygonShape.Set_s_v = new b2Vec2();
        b2PolygonShape.TestPoint_s_pLocal = new b2Vec2();
        b2PolygonShape.ComputeDistance_s_pLocal = new b2Vec2();
        b2PolygonShape.ComputeDistance_s_normalForMaxDistance = new b2Vec2();
        b2PolygonShape.ComputeDistance_s_minDistance = new b2Vec2();
        b2PolygonShape.ComputeDistance_s_distance = new b2Vec2();
        b2PolygonShape.RayCast_s_p1 = new b2Vec2();
        b2PolygonShape.RayCast_s_p2 = new b2Vec2();
        b2PolygonShape.RayCast_s_d = new b2Vec2();
        b2PolygonShape.ComputeAABB_s_v = new b2Vec2();
        b2PolygonShape.ComputeMass_s_center = new b2Vec2();
        b2PolygonShape.ComputeMass_s_s = new b2Vec2();
        b2PolygonShape.ComputeMass_s_e1 = new b2Vec2();
        b2PolygonShape.ComputeMass_s_e2 = new b2Vec2();
        b2PolygonShape.Validate_s_e = new b2Vec2();
        b2PolygonShape.Validate_s_v = new b2Vec2();
        b2PolygonShape.ComputeSubmergedArea_s_normalL = new b2Vec2();
        b2PolygonShape.ComputeSubmergedArea_s_depths = b2MakeNumberArray(b2_maxPolygonVertices);
        b2PolygonShape.ComputeSubmergedArea_s_md = new b2MassData();
        b2PolygonShape.ComputeSubmergedArea_s_intoVec = new b2Vec2();
        b2PolygonShape.ComputeSubmergedArea_s_outoVec = new b2Vec2();
        b2PolygonShape.ComputeSubmergedArea_s_center = new b2Vec2();
        b2PolygonShape.ComputeCentroid_s_pRef = new b2Vec2();
        b2PolygonShape.ComputeCentroid_s_e1 = new b2Vec2();
        b2PolygonShape.ComputeCentroid_s_e2 = new b2Vec2();
        return b2PolygonShape;
      })(b2Shape);
      var b2EdgeShape = (function(_super) {
        __extends(b2EdgeShape, _super);
        function b2EdgeShape() {
          var _this = _super.call(this, exports.b2ShapeType.e_edgeShape, b2_polygonRadius) || this;
          _this.m_vertex1 = new b2Vec2();
          _this.m_vertex2 = new b2Vec2();
          _this.m_vertex0 = new b2Vec2();
          _this.m_vertex3 = new b2Vec2();
          _this.m_hasVertex0 = false;
          _this.m_hasVertex3 = false;
          return _this;
        }
        b2EdgeShape.prototype.Set = function(v1, v2) {
          this.m_vertex1.Copy(v1);
          this.m_vertex2.Copy(v2);
          this.m_hasVertex0 = false;
          this.m_hasVertex3 = false;
          return this;
        };
        b2EdgeShape.prototype.Clone = function() {
          return new b2EdgeShape().Copy(this);
        };
        b2EdgeShape.prototype.Copy = function(other) {
          _super.prototype.Copy.call(this, other);
          this.m_vertex1.Copy(other.m_vertex1);
          this.m_vertex2.Copy(other.m_vertex2);
          this.m_vertex0.Copy(other.m_vertex0);
          this.m_vertex3.Copy(other.m_vertex3);
          this.m_hasVertex0 = other.m_hasVertex0;
          this.m_hasVertex3 = other.m_hasVertex3;
          return this;
        };
        b2EdgeShape.prototype.GetChildCount = function() {
          return 1;
        };
        b2EdgeShape.prototype.TestPoint = function(xf, p) {
          return false;
        };
        b2EdgeShape.prototype.ComputeDistance = function(xf, p, normal, childIndex) {
          var v1 = b2Transform.MulXV(xf, this.m_vertex1, b2EdgeShape.ComputeDistance_s_v1);
          var v2 = b2Transform.MulXV(xf, this.m_vertex2, b2EdgeShape.ComputeDistance_s_v2);
          var d = b2Vec2.SubVV(p, v1, b2EdgeShape.ComputeDistance_s_d);
          var s = b2Vec2.SubVV(v2, v1, b2EdgeShape.ComputeDistance_s_s);
          var ds = b2Vec2.DotVV(d, s);
          if (ds > 0) {
            var s2 = b2Vec2.DotVV(s, s);
            ds > s2 ? b2Vec2.SubVV(p, v2, d) : d.SelfMulSub(ds / s2, s);
          }
          normal.Copy(d);
          return normal.Normalize();
        };
        b2EdgeShape.prototype.RayCast = function(output, input, xf, childIndex) {
          var p1 = b2Transform.MulTXV(xf, input.p1, b2EdgeShape.RayCast_s_p1);
          var p2 = b2Transform.MulTXV(xf, input.p2, b2EdgeShape.RayCast_s_p2);
          var d = b2Vec2.SubVV(p2, p1, b2EdgeShape.RayCast_s_d);
          var v1 = this.m_vertex1;
          var v2 = this.m_vertex2;
          var e = b2Vec2.SubVV(v2, v1, b2EdgeShape.RayCast_s_e);
          var normal = output.normal.Set(e.y, -e.x).SelfNormalize();
          var numerator = b2Vec2.DotVV(normal, b2Vec2.SubVV(v1, p1, b2Vec2.s_t0));
          var denominator = b2Vec2.DotVV(normal, d);
          if (0 === denominator) return false;
          var t = numerator / denominator;
          if (t < 0 || input.maxFraction < t) return false;
          var q = b2Vec2.AddVMulSV(p1, t, d, b2EdgeShape.RayCast_s_q);
          var r = b2Vec2.SubVV(v2, v1, b2EdgeShape.RayCast_s_r);
          var rr = b2Vec2.DotVV(r, r);
          if (0 === rr) return false;
          var s = b2Vec2.DotVV(b2Vec2.SubVV(q, v1, b2Vec2.s_t0), r) / rr;
          if (s < 0 || 1 < s) return false;
          output.fraction = t;
          b2Rot.MulRV(xf.q, output.normal, output.normal);
          numerator > 0 && output.normal.SelfNeg();
          return true;
        };
        b2EdgeShape.prototype.ComputeAABB = function(aabb, xf, childIndex) {
          var v1 = b2Transform.MulXV(xf, this.m_vertex1, b2EdgeShape.ComputeAABB_s_v1);
          var v2 = b2Transform.MulXV(xf, this.m_vertex2, b2EdgeShape.ComputeAABB_s_v2);
          b2Vec2.MinV(v1, v2, aabb.lowerBound);
          b2Vec2.MaxV(v1, v2, aabb.upperBound);
          var r = this.m_radius;
          aabb.lowerBound.SelfSubXY(r, r);
          aabb.upperBound.SelfAddXY(r, r);
        };
        b2EdgeShape.prototype.ComputeMass = function(massData, density) {
          massData.mass = 0;
          b2Vec2.MidVV(this.m_vertex1, this.m_vertex2, massData.center);
          massData.I = 0;
        };
        b2EdgeShape.prototype.SetupDistanceProxy = function(proxy, index) {
          proxy.m_vertices = proxy.m_buffer;
          proxy.m_vertices[0].Copy(this.m_vertex1);
          proxy.m_vertices[1].Copy(this.m_vertex2);
          proxy.m_count = 2;
          proxy.m_radius = this.m_radius;
        };
        b2EdgeShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
          c.SetZero();
          return 0;
        };
        b2EdgeShape.prototype.Dump = function(log) {
          log("    const shape: b2EdgeShape = new b2EdgeShape();\n");
          log("    shape.m_radius = %.15f;\n", this.m_radius);
          log("    shape.m_vertex0.Set(%.15f, %.15f);\n", this.m_vertex0.x, this.m_vertex0.y);
          log("    shape.m_vertex1.Set(%.15f, %.15f);\n", this.m_vertex1.x, this.m_vertex1.y);
          log("    shape.m_vertex2.Set(%.15f, %.15f);\n", this.m_vertex2.x, this.m_vertex2.y);
          log("    shape.m_vertex3.Set(%.15f, %.15f);\n", this.m_vertex3.x, this.m_vertex3.y);
          log("    shape.m_hasVertex0 = %s;\n", this.m_hasVertex0);
          log("    shape.m_hasVertex3 = %s;\n", this.m_hasVertex3);
        };
        b2EdgeShape.ComputeDistance_s_v1 = new b2Vec2();
        b2EdgeShape.ComputeDistance_s_v2 = new b2Vec2();
        b2EdgeShape.ComputeDistance_s_d = new b2Vec2();
        b2EdgeShape.ComputeDistance_s_s = new b2Vec2();
        b2EdgeShape.RayCast_s_p1 = new b2Vec2();
        b2EdgeShape.RayCast_s_p2 = new b2Vec2();
        b2EdgeShape.RayCast_s_d = new b2Vec2();
        b2EdgeShape.RayCast_s_e = new b2Vec2();
        b2EdgeShape.RayCast_s_q = new b2Vec2();
        b2EdgeShape.RayCast_s_r = new b2Vec2();
        b2EdgeShape.ComputeAABB_s_v1 = new b2Vec2();
        b2EdgeShape.ComputeAABB_s_v2 = new b2Vec2();
        return b2EdgeShape;
      })(b2Shape);
      var b2ChainShape = (function(_super) {
        __extends(b2ChainShape, _super);
        function b2ChainShape() {
          var _this = _super.call(this, exports.b2ShapeType.e_chainShape, b2_polygonRadius) || this;
          _this.m_vertices = [];
          _this.m_count = 0;
          _this.m_prevVertex = new b2Vec2();
          _this.m_nextVertex = new b2Vec2();
          _this.m_hasPrevVertex = false;
          _this.m_hasNextVertex = false;
          return _this;
        }
        b2ChainShape.prototype.CreateLoop = function(vertices, count, start) {
          void 0 === count && (count = vertices.length);
          void 0 === start && (start = 0);
          if (count < 3) return this;
          this.m_count = count + 1;
          this.m_vertices = b2Vec2.MakeArray(this.m_count);
          for (var i = 0; i < count; ++i) this.m_vertices[i].Copy(vertices[start + i]);
          this.m_vertices[count].Copy(this.m_vertices[0]);
          this.m_prevVertex.Copy(this.m_vertices[this.m_count - 2]);
          this.m_nextVertex.Copy(this.m_vertices[1]);
          this.m_hasPrevVertex = true;
          this.m_hasNextVertex = true;
          return this;
        };
        b2ChainShape.prototype.CreateChain = function(vertices, count, start) {
          void 0 === count && (count = vertices.length);
          void 0 === start && (start = 0);
          this.m_count = count;
          this.m_vertices = b2Vec2.MakeArray(count);
          for (var i = 0; i < count; ++i) this.m_vertices[i].Copy(vertices[start + i]);
          this.m_hasPrevVertex = false;
          this.m_hasNextVertex = false;
          this.m_prevVertex.SetZero();
          this.m_nextVertex.SetZero();
          return this;
        };
        b2ChainShape.prototype.SetPrevVertex = function(prevVertex) {
          this.m_prevVertex.Copy(prevVertex);
          this.m_hasPrevVertex = true;
          return this;
        };
        b2ChainShape.prototype.SetNextVertex = function(nextVertex) {
          this.m_nextVertex.Copy(nextVertex);
          this.m_hasNextVertex = true;
          return this;
        };
        b2ChainShape.prototype.Clone = function() {
          return new b2ChainShape().Copy(this);
        };
        b2ChainShape.prototype.Copy = function(other) {
          _super.prototype.Copy.call(this, other);
          this.CreateChain(other.m_vertices, other.m_count);
          this.m_prevVertex.Copy(other.m_prevVertex);
          this.m_nextVertex.Copy(other.m_nextVertex);
          this.m_hasPrevVertex = other.m_hasPrevVertex;
          this.m_hasNextVertex = other.m_hasNextVertex;
          return this;
        };
        b2ChainShape.prototype.GetChildCount = function() {
          return this.m_count - 1;
        };
        b2ChainShape.prototype.GetChildEdge = function(edge, index) {
          edge.m_type = exports.b2ShapeType.e_edgeShape;
          edge.m_radius = this.m_radius;
          edge.m_vertex1.Copy(this.m_vertices[index]);
          edge.m_vertex2.Copy(this.m_vertices[index + 1]);
          if (index > 0) {
            edge.m_vertex0.Copy(this.m_vertices[index - 1]);
            edge.m_hasVertex0 = true;
          } else {
            edge.m_vertex0.Copy(this.m_prevVertex);
            edge.m_hasVertex0 = this.m_hasPrevVertex;
          }
          if (index < this.m_count - 2) {
            edge.m_vertex3.Copy(this.m_vertices[index + 2]);
            edge.m_hasVertex3 = true;
          } else {
            edge.m_vertex3.Copy(this.m_nextVertex);
            edge.m_hasVertex3 = this.m_hasNextVertex;
          }
        };
        b2ChainShape.prototype.TestPoint = function(xf, p) {
          return false;
        };
        b2ChainShape.prototype.ComputeDistance = function(xf, p, normal, childIndex) {
          var edge = b2ChainShape.ComputeDistance_s_edgeShape;
          this.GetChildEdge(edge, childIndex);
          return edge.ComputeDistance(xf, p, normal, 0);
        };
        b2ChainShape.prototype.RayCast = function(output, input, xf, childIndex) {
          var edgeShape = b2ChainShape.RayCast_s_edgeShape;
          edgeShape.m_vertex1.Copy(this.m_vertices[childIndex]);
          edgeShape.m_vertex2.Copy(this.m_vertices[(childIndex + 1) % this.m_count]);
          return edgeShape.RayCast(output, input, xf, 0);
        };
        b2ChainShape.prototype.ComputeAABB = function(aabb, xf, childIndex) {
          var vertexi1 = this.m_vertices[childIndex];
          var vertexi2 = this.m_vertices[(childIndex + 1) % this.m_count];
          var v1 = b2Transform.MulXV(xf, vertexi1, b2ChainShape.ComputeAABB_s_v1);
          var v2 = b2Transform.MulXV(xf, vertexi2, b2ChainShape.ComputeAABB_s_v2);
          b2Vec2.MinV(v1, v2, aabb.lowerBound);
          b2Vec2.MaxV(v1, v2, aabb.upperBound);
        };
        b2ChainShape.prototype.ComputeMass = function(massData, density) {
          massData.mass = 0;
          massData.center.SetZero();
          massData.I = 0;
        };
        b2ChainShape.prototype.SetupDistanceProxy = function(proxy, index) {
          proxy.m_vertices = proxy.m_buffer;
          proxy.m_vertices[0].Copy(this.m_vertices[index]);
          index + 1 < this.m_count ? proxy.m_vertices[1].Copy(this.m_vertices[index + 1]) : proxy.m_vertices[1].Copy(this.m_vertices[0]);
          proxy.m_count = 2;
          proxy.m_radius = this.m_radius;
        };
        b2ChainShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
          c.SetZero();
          return 0;
        };
        b2ChainShape.prototype.Dump = function(log) {
          log("    const shape: b2ChainShape = new b2ChainShape();\n");
          log("    const vs: b2Vec2[] = b2Vec2.MakeArray(%d);\n", b2_maxPolygonVertices);
          for (var i = 0; i < this.m_count; ++i) log("    vs[%d].Set(%.15f, %.15f);\n", i, this.m_vertices[i].x, this.m_vertices[i].y);
          log("    shape.CreateChain(vs, %d);\n", this.m_count);
          log("    shape.m_prevVertex.Set(%.15f, %.15f);\n", this.m_prevVertex.x, this.m_prevVertex.y);
          log("    shape.m_nextVertex.Set(%.15f, %.15f);\n", this.m_nextVertex.x, this.m_nextVertex.y);
          log("    shape.m_hasPrevVertex = %s;\n", this.m_hasPrevVertex ? "true" : "false");
          log("    shape.m_hasNextVertex = %s;\n", this.m_hasNextVertex ? "true" : "false");
        };
        b2ChainShape.ComputeDistance_s_edgeShape = new b2EdgeShape();
        b2ChainShape.RayCast_s_edgeShape = new b2EdgeShape();
        b2ChainShape.ComputeAABB_s_v1 = new b2Vec2();
        b2ChainShape.ComputeAABB_s_v2 = new b2Vec2();
        return b2ChainShape;
      })(b2Shape);
      var b2Filter = (function() {
        function b2Filter() {
          this.categoryBits = 1;
          this.maskBits = 65535;
          this.groupIndex = 0;
        }
        b2Filter.prototype.Clone = function() {
          return new b2Filter().Copy(this);
        };
        b2Filter.prototype.Copy = function(other) {
          this.categoryBits = other.categoryBits;
          this.maskBits = other.maskBits;
          this.groupIndex = other.groupIndex || 0;
          return this;
        };
        b2Filter.DEFAULT = new b2Filter();
        return b2Filter;
      })();
      var b2FixtureDef = (function() {
        function b2FixtureDef() {
          this.userData = null;
          this.friction = .2;
          this.restitution = 0;
          this.density = 0;
          this.isSensor = false;
          this.filter = new b2Filter();
        }
        return b2FixtureDef;
      })();
      var b2FixtureProxy = (function() {
        function b2FixtureProxy(fixture) {
          this.aabb = new b2AABB();
          this.childIndex = 0;
          this.fixture = fixture;
        }
        return b2FixtureProxy;
      })();
      var b2Fixture = (function() {
        function b2Fixture(def, body) {
          this.m_density = 0;
          this.m_next = null;
          this.m_friction = 0;
          this.m_restitution = 0;
          this.m_proxies = [];
          this.m_proxyCount = 0;
          this.m_filter = new b2Filter();
          this.m_isSensor = false;
          this.m_userData = null;
          this.m_body = body;
          this.m_shape = def.shape.Clone();
        }
        b2Fixture.prototype.GetType = function() {
          return this.m_shape.GetType();
        };
        b2Fixture.prototype.GetShape = function() {
          return this.m_shape;
        };
        b2Fixture.prototype.SetSensor = function(sensor) {
          if (sensor !== this.m_isSensor) {
            this.m_body.SetAwake(true);
            this.m_isSensor = sensor;
          }
        };
        b2Fixture.prototype.IsSensor = function() {
          return this.m_isSensor;
        };
        b2Fixture.prototype.SetFilterData = function(filter) {
          this.m_filter.Copy(filter);
          this.Refilter();
        };
        b2Fixture.prototype.GetFilterData = function() {
          return this.m_filter;
        };
        b2Fixture.prototype.Refilter = function() {
          var edge = this.m_body.GetContactList();
          while (edge) {
            var contact = edge.contact;
            var fixtureA = contact.GetFixtureA();
            var fixtureB = contact.GetFixtureB();
            fixtureA !== this && fixtureB !== this || contact.FlagForFiltering();
            edge = edge.next;
          }
          var world = this.m_body.GetWorld();
          if (null === world) return;
          var broadPhase = world.m_contactManager.m_broadPhase;
          for (var i = 0; i < this.m_proxyCount; ++i) broadPhase.TouchProxy(this.m_proxies[i].treeNode);
        };
        b2Fixture.prototype.GetBody = function() {
          return this.m_body;
        };
        b2Fixture.prototype.GetNext = function() {
          return this.m_next;
        };
        b2Fixture.prototype.GetUserData = function() {
          return this.m_userData;
        };
        b2Fixture.prototype.SetUserData = function(data) {
          this.m_userData = data;
        };
        b2Fixture.prototype.TestPoint = function(p) {
          return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
        };
        b2Fixture.prototype.ComputeDistance = function(p, normal, childIndex) {
          return this.m_shape.ComputeDistance(this.m_body.GetTransform(), p, normal, childIndex);
        };
        b2Fixture.prototype.RayCast = function(output, input, childIndex) {
          return this.m_shape.RayCast(output, input, this.m_body.GetTransform(), childIndex);
        };
        b2Fixture.prototype.GetMassData = function(massData) {
          void 0 === massData && (massData = new b2MassData());
          this.m_shape.ComputeMass(massData, this.m_density);
          return massData;
        };
        b2Fixture.prototype.SetDensity = function(density) {
          this.m_density = density;
        };
        b2Fixture.prototype.GetDensity = function() {
          return this.m_density;
        };
        b2Fixture.prototype.GetFriction = function() {
          return this.m_friction;
        };
        b2Fixture.prototype.SetFriction = function(friction) {
          this.m_friction = friction;
        };
        b2Fixture.prototype.GetRestitution = function() {
          return this.m_restitution;
        };
        b2Fixture.prototype.SetRestitution = function(restitution) {
          this.m_restitution = restitution;
        };
        b2Fixture.prototype.GetAABB = function(childIndex) {
          return this.m_proxies[childIndex].aabb;
        };
        b2Fixture.prototype.Dump = function(log, bodyIndex) {
          log("    const fd: b2FixtureDef = new b2FixtureDef();\n");
          log("    fd.friction = %.15f;\n", this.m_friction);
          log("    fd.restitution = %.15f;\n", this.m_restitution);
          log("    fd.density = %.15f;\n", this.m_density);
          log("    fd.isSensor = %s;\n", this.m_isSensor ? "true" : "false");
          log("    fd.filter.categoryBits = %d;\n", this.m_filter.categoryBits);
          log("    fd.filter.maskBits = %d;\n", this.m_filter.maskBits);
          log("    fd.filter.groupIndex = %d;\n", this.m_filter.groupIndex);
          this.m_shape.Dump(log);
          log("\n");
          log("    fd.shape = shape;\n");
          log("\n");
          log("    bodies[%d].CreateFixture(fd);\n", bodyIndex);
        };
        b2Fixture.prototype.Create = function(def) {
          var _this = this;
          this.m_userData = def.userData;
          this.m_friction = b2Maybe(def.friction, .2);
          this.m_restitution = b2Maybe(def.restitution, 0);
          this.m_next = null;
          this.m_filter.Copy(b2Maybe(def.filter, b2Filter.DEFAULT));
          this.m_isSensor = b2Maybe(def.isSensor, false);
          this.m_proxies = b2MakeArray(this.m_shape.GetChildCount(), (function(i) {
            return new b2FixtureProxy(_this);
          }));
          this.m_proxyCount = 0;
          this.m_density = b2Maybe(def.density, 0);
        };
        b2Fixture.prototype.Destroy = function() {};
        b2Fixture.prototype.CreateProxies = function(xf) {
          var broadPhase = this.m_body.m_world.m_contactManager.m_broadPhase;
          this.m_proxyCount = this.m_shape.GetChildCount();
          for (var i = 0; i < this.m_proxyCount; ++i) {
            var proxy = this.m_proxies[i] = new b2FixtureProxy(this);
            this.m_shape.ComputeAABB(proxy.aabb, xf, i);
            proxy.treeNode = broadPhase.CreateProxy(proxy.aabb, proxy);
            proxy.childIndex = i;
          }
        };
        b2Fixture.prototype.DestroyProxies = function() {
          var broadPhase = this.m_body.m_world.m_contactManager.m_broadPhase;
          for (var i = 0; i < this.m_proxyCount; ++i) {
            var proxy = this.m_proxies[i];
            delete proxy.treeNode.userData;
            broadPhase.DestroyProxy(proxy.treeNode);
            delete proxy.treeNode;
          }
          this.m_proxyCount = 0;
        };
        b2Fixture.prototype.TouchProxies = function() {
          var broadPhase = this.m_body.m_world.m_contactManager.m_broadPhase;
          var proxyCount = this.m_proxyCount;
          for (var i = 0; i < proxyCount; ++i) broadPhase.TouchProxy(this.m_proxies[i].treeNode);
        };
        b2Fixture.prototype.Synchronize = function(transform1, transform2) {
          if (0 === this.m_proxyCount) return;
          var broadPhase = this.m_body.m_world.m_contactManager.m_broadPhase;
          for (var i = 0; i < this.m_proxyCount; ++i) {
            var proxy = this.m_proxies[i];
            var aabb1 = b2Fixture.Synchronize_s_aabb1;
            var aabb2 = b2Fixture.Synchronize_s_aabb2;
            this.m_shape.ComputeAABB(aabb1, transform1, i);
            this.m_shape.ComputeAABB(aabb2, transform2, i);
            proxy.aabb.Combine2(aabb1, aabb2);
            var displacement = b2Vec2.SubVV(transform2.p, transform1.p, b2Fixture.Synchronize_s_displacement);
            broadPhase.MoveProxy(proxy.treeNode, proxy.aabb, displacement);
          }
        };
        b2Fixture.Synchronize_s_aabb1 = new b2AABB();
        b2Fixture.Synchronize_s_aabb2 = new b2AABB();
        b2Fixture.Synchronize_s_displacement = new b2Vec2();
        return b2Fixture;
      })();
      (function(b2BodyType) {
        b2BodyType[b2BodyType["b2_unknown"] = -1] = "b2_unknown";
        b2BodyType[b2BodyType["b2_staticBody"] = 0] = "b2_staticBody";
        b2BodyType[b2BodyType["b2_kinematicBody"] = 1] = "b2_kinematicBody";
        b2BodyType[b2BodyType["b2_dynamicBody"] = 2] = "b2_dynamicBody";
      })(exports.b2BodyType || (exports.b2BodyType = {}));
      var b2BodyDef = (function() {
        function b2BodyDef() {
          this.type = exports.b2BodyType.b2_staticBody;
          this.position = new b2Vec2(0, 0);
          this.angle = 0;
          this.linearVelocity = new b2Vec2(0, 0);
          this.angularVelocity = 0;
          this.linearDamping = 0;
          this.angularDamping = 0;
          this.allowSleep = true;
          this.awake = true;
          this.fixedRotation = false;
          this.bullet = false;
          this.active = true;
          this.userData = null;
          this.gravityScale = 1;
        }
        return b2BodyDef;
      })();
      var b2Body = (function() {
        function b2Body(bd, world) {
          this.m_type = exports.b2BodyType.b2_staticBody;
          this.m_islandFlag = false;
          this.m_awakeFlag = false;
          this.m_autoSleepFlag = false;
          this.m_bulletFlag = false;
          this.m_fixedRotationFlag = false;
          this.m_activeFlag = false;
          this.m_toiFlag = false;
          this.m_islandIndex = 0;
          this.m_xf = new b2Transform();
          this.m_xf0 = new b2Transform();
          this.m_sweep = new b2Sweep();
          this.m_linearVelocity = new b2Vec2();
          this.m_angularVelocity = 0;
          this.m_force = new b2Vec2();
          this.m_torque = 0;
          this.m_prev = null;
          this.m_next = null;
          this.m_fixtureList = null;
          this.m_fixtureCount = 0;
          this.m_jointList = null;
          this.m_contactList = null;
          this.m_mass = 1;
          this.m_invMass = 1;
          this.m_I = 0;
          this.m_invI = 0;
          this.m_linearDamping = 0;
          this.m_angularDamping = 0;
          this.m_gravityScale = 1;
          this.m_sleepTime = 0;
          this.m_userData = null;
          this.m_controllerList = null;
          this.m_controllerCount = 0;
          this.m_bulletFlag = b2Maybe(bd.bullet, false);
          this.m_fixedRotationFlag = b2Maybe(bd.fixedRotation, false);
          this.m_autoSleepFlag = b2Maybe(bd.allowSleep, true);
          this.m_awakeFlag = b2Maybe(bd.awake, true);
          this.m_activeFlag = b2Maybe(bd.active, true);
          this.m_world = world;
          this.m_xf.p.Copy(b2Maybe(bd.position, b2Vec2.ZERO));
          this.m_xf.q.SetAngle(b2Maybe(bd.angle, 0));
          this.m_xf0.Copy(this.m_xf);
          this.m_sweep.localCenter.SetZero();
          this.m_sweep.c0.Copy(this.m_xf.p);
          this.m_sweep.c.Copy(this.m_xf.p);
          this.m_sweep.a0 = this.m_sweep.a = this.m_xf.q.GetAngle();
          this.m_sweep.alpha0 = 0;
          this.m_linearVelocity.Copy(b2Maybe(bd.linearVelocity, b2Vec2.ZERO));
          this.m_angularVelocity = b2Maybe(bd.angularVelocity, 0);
          this.m_linearDamping = b2Maybe(bd.linearDamping, 0);
          this.m_angularDamping = b2Maybe(bd.angularDamping, 0);
          this.m_gravityScale = b2Maybe(bd.gravityScale, 1);
          this.m_force.SetZero();
          this.m_torque = 0;
          this.m_sleepTime = 0;
          this.m_type = b2Maybe(bd.type, exports.b2BodyType.b2_staticBody);
          if (bd.type === exports.b2BodyType.b2_dynamicBody) {
            this.m_mass = 1;
            this.m_invMass = 1;
          } else {
            this.m_mass = 0;
            this.m_invMass = 0;
          }
          this.m_I = 0;
          this.m_invI = 0;
          this.m_userData = bd.userData;
          this.m_fixtureList = null;
          this.m_fixtureCount = 0;
          this.m_controllerList = null;
          this.m_controllerCount = 0;
        }
        b2Body.prototype.CreateFixture = function(a, b) {
          void 0 === b && (b = 0);
          return a instanceof b2Shape ? this.CreateFixtureShapeDensity(a, b) : this.CreateFixtureDef(a);
        };
        b2Body.prototype.CreateFixtureDef = function(def) {
          if (this.m_world.IsLocked()) throw new Error();
          var fixture = new b2Fixture(def, this);
          fixture.Create(def);
          this.m_activeFlag && fixture.CreateProxies(this.m_xf);
          fixture.m_next = this.m_fixtureList;
          this.m_fixtureList = fixture;
          ++this.m_fixtureCount;
          fixture.m_density > 0 && this.ResetMassData();
          this.m_world.m_newFixture = true;
          return fixture;
        };
        b2Body.prototype.CreateFixtureShapeDensity = function(shape, density) {
          void 0 === density && (density = 0);
          var def = b2Body.CreateFixtureShapeDensity_s_def;
          def.shape = shape;
          def.density = density;
          return this.CreateFixtureDef(def);
        };
        b2Body.prototype.DestroyFixture = function(fixture) {
          if (this.m_world.IsLocked()) throw new Error();
          var node = this.m_fixtureList;
          var ppF = null;
          while (null !== node) {
            if (node === fixture) {
              ppF ? ppF.m_next = fixture.m_next : this.m_fixtureList = fixture.m_next;
              break;
            }
            ppF = node;
            node = node.m_next;
          }
          var edge = this.m_contactList;
          while (edge) {
            var c = edge.contact;
            edge = edge.next;
            var fixtureA = c.GetFixtureA();
            var fixtureB = c.GetFixtureB();
            fixture !== fixtureA && fixture !== fixtureB || this.m_world.m_contactManager.Destroy(c);
          }
          this.m_activeFlag && fixture.DestroyProxies();
          fixture.m_next = null;
          fixture.Destroy();
          --this.m_fixtureCount;
          this.ResetMassData();
        };
        b2Body.prototype.SetTransformVec = function(position, angle) {
          this.SetTransformXY(position.x, position.y, angle);
        };
        b2Body.prototype.SetTransformXY = function(x, y, angle) {
          if (this.m_world.IsLocked()) throw new Error();
          this.m_xf.q.SetAngle(angle);
          this.m_xf.p.Set(x, y);
          this.m_xf0.Copy(this.m_xf);
          b2Transform.MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
          this.m_sweep.a = angle;
          this.m_sweep.c0.Copy(this.m_sweep.c);
          this.m_sweep.a0 = angle;
          for (var f = this.m_fixtureList; f; f = f.m_next) f.Synchronize(this.m_xf, this.m_xf);
          this.m_world.m_contactManager.FindNewContacts();
        };
        b2Body.prototype.SetTransform = function(xf) {
          this.SetTransformVec(xf.p, xf.GetAngle());
        };
        b2Body.prototype.GetTransform = function() {
          return this.m_xf;
        };
        b2Body.prototype.GetPosition = function() {
          return this.m_xf.p;
        };
        b2Body.prototype.SetPosition = function(position) {
          this.SetTransformVec(position, this.GetAngle());
        };
        b2Body.prototype.SetPositionXY = function(x, y) {
          this.SetTransformXY(x, y, this.GetAngle());
        };
        b2Body.prototype.GetAngle = function() {
          return this.m_sweep.a;
        };
        b2Body.prototype.SetAngle = function(angle) {
          this.SetTransformVec(this.GetPosition(), angle);
        };
        b2Body.prototype.GetWorldCenter = function() {
          return this.m_sweep.c;
        };
        b2Body.prototype.GetLocalCenter = function() {
          return this.m_sweep.localCenter;
        };
        b2Body.prototype.SetLinearVelocity = function(v) {
          if (this.m_type === exports.b2BodyType.b2_staticBody) return;
          b2Vec2.DotVV(v, v) > 0 && this.SetAwake(true);
          this.m_linearVelocity.Copy(v);
        };
        b2Body.prototype.GetLinearVelocity = function() {
          return this.m_linearVelocity;
        };
        b2Body.prototype.SetAngularVelocity = function(w) {
          if (this.m_type === exports.b2BodyType.b2_staticBody) return;
          w * w > 0 && this.SetAwake(true);
          this.m_angularVelocity = w;
        };
        b2Body.prototype.GetAngularVelocity = function() {
          return this.m_angularVelocity;
        };
        b2Body.prototype.GetDefinition = function(bd) {
          bd.type = this.GetType();
          bd.allowSleep = this.m_autoSleepFlag;
          bd.angle = this.GetAngle();
          bd.angularDamping = this.m_angularDamping;
          bd.gravityScale = this.m_gravityScale;
          bd.angularVelocity = this.m_angularVelocity;
          bd.fixedRotation = this.m_fixedRotationFlag;
          bd.bullet = this.m_bulletFlag;
          bd.awake = this.m_awakeFlag;
          bd.linearDamping = this.m_linearDamping;
          bd.linearVelocity.Copy(this.GetLinearVelocity());
          bd.position.Copy(this.GetPosition());
          bd.userData = this.GetUserData();
          return bd;
        };
        b2Body.prototype.ApplyForce = function(force, point, wake) {
          void 0 === wake && (wake = true);
          if (this.m_type !== exports.b2BodyType.b2_dynamicBody) return;
          wake && !this.m_awakeFlag && this.SetAwake(true);
          if (this.m_awakeFlag) {
            this.m_force.x += force.x;
            this.m_force.y += force.y;
            this.m_torque += (point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x;
          }
        };
        b2Body.prototype.ApplyForceToCenter = function(force, wake) {
          void 0 === wake && (wake = true);
          if (this.m_type !== exports.b2BodyType.b2_dynamicBody) return;
          wake && !this.m_awakeFlag && this.SetAwake(true);
          if (this.m_awakeFlag) {
            this.m_force.x += force.x;
            this.m_force.y += force.y;
          }
        };
        b2Body.prototype.ApplyTorque = function(torque, wake) {
          void 0 === wake && (wake = true);
          if (this.m_type !== exports.b2BodyType.b2_dynamicBody) return;
          wake && !this.m_awakeFlag && this.SetAwake(true);
          this.m_awakeFlag && (this.m_torque += torque);
        };
        b2Body.prototype.ApplyLinearImpulse = function(impulse, point, wake) {
          void 0 === wake && (wake = true);
          if (this.m_type !== exports.b2BodyType.b2_dynamicBody) return;
          wake && !this.m_awakeFlag && this.SetAwake(true);
          if (this.m_awakeFlag) {
            this.m_linearVelocity.x += this.m_invMass * impulse.x;
            this.m_linearVelocity.y += this.m_invMass * impulse.y;
            this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
          }
        };
        b2Body.prototype.ApplyLinearImpulseToCenter = function(impulse, wake) {
          void 0 === wake && (wake = true);
          if (this.m_type !== exports.b2BodyType.b2_dynamicBody) return;
          wake && !this.m_awakeFlag && this.SetAwake(true);
          if (this.m_awakeFlag) {
            this.m_linearVelocity.x += this.m_invMass * impulse.x;
            this.m_linearVelocity.y += this.m_invMass * impulse.y;
          }
        };
        b2Body.prototype.ApplyAngularImpulse = function(impulse, wake) {
          void 0 === wake && (wake = true);
          if (this.m_type !== exports.b2BodyType.b2_dynamicBody) return;
          wake && !this.m_awakeFlag && this.SetAwake(true);
          this.m_awakeFlag && (this.m_angularVelocity += this.m_invI * impulse);
        };
        b2Body.prototype.GetMass = function() {
          return this.m_mass;
        };
        b2Body.prototype.GetInertia = function() {
          return this.m_I + this.m_mass * b2Vec2.DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);
        };
        b2Body.prototype.GetMassData = function(data) {
          data.mass = this.m_mass;
          data.I = this.m_I + this.m_mass * b2Vec2.DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);
          data.center.Copy(this.m_sweep.localCenter);
          return data;
        };
        b2Body.prototype.SetMassData = function(massData) {
          if (this.m_world.IsLocked()) throw new Error();
          if (this.m_type !== exports.b2BodyType.b2_dynamicBody) return;
          this.m_invMass = 0;
          this.m_I = 0;
          this.m_invI = 0;
          this.m_mass = massData.mass;
          this.m_mass <= 0 && (this.m_mass = 1);
          this.m_invMass = 1 / this.m_mass;
          if (massData.I > 0 && !this.m_fixedRotationFlag) {
            this.m_I = massData.I - this.m_mass * b2Vec2.DotVV(massData.center, massData.center);
            this.m_invI = 1 / this.m_I;
          }
          var oldCenter = b2Body.SetMassData_s_oldCenter.Copy(this.m_sweep.c);
          this.m_sweep.localCenter.Copy(massData.center);
          b2Transform.MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
          this.m_sweep.c0.Copy(this.m_sweep.c);
          b2Vec2.AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, b2Vec2.SubVV(this.m_sweep.c, oldCenter, b2Vec2.s_t0), this.m_linearVelocity);
        };
        b2Body.prototype.ResetMassData = function() {
          this.m_mass = 0;
          this.m_invMass = 0;
          this.m_I = 0;
          this.m_invI = 0;
          this.m_sweep.localCenter.SetZero();
          if (this.m_type === exports.b2BodyType.b2_staticBody || this.m_type === exports.b2BodyType.b2_kinematicBody) {
            this.m_sweep.c0.Copy(this.m_xf.p);
            this.m_sweep.c.Copy(this.m_xf.p);
            this.m_sweep.a0 = this.m_sweep.a;
            return;
          }
          var localCenter = b2Body.ResetMassData_s_localCenter.SetZero();
          for (var f = this.m_fixtureList; f; f = f.m_next) {
            if (0 === f.m_density) continue;
            var massData = f.GetMassData(b2Body.ResetMassData_s_massData);
            this.m_mass += massData.mass;
            localCenter.x += massData.center.x * massData.mass;
            localCenter.y += massData.center.y * massData.mass;
            this.m_I += massData.I;
          }
          if (this.m_mass > 0) {
            this.m_invMass = 1 / this.m_mass;
            localCenter.x *= this.m_invMass;
            localCenter.y *= this.m_invMass;
          } else {
            this.m_mass = 1;
            this.m_invMass = 1;
          }
          if (this.m_I > 0 && !this.m_fixedRotationFlag) {
            this.m_I -= this.m_mass * b2Vec2.DotVV(localCenter, localCenter);
            this.m_invI = 1 / this.m_I;
          } else {
            this.m_I = 0;
            this.m_invI = 0;
          }
          var oldCenter = b2Body.ResetMassData_s_oldCenter.Copy(this.m_sweep.c);
          this.m_sweep.localCenter.Copy(localCenter);
          b2Transform.MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);
          this.m_sweep.c0.Copy(this.m_sweep.c);
          b2Vec2.AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, b2Vec2.SubVV(this.m_sweep.c, oldCenter, b2Vec2.s_t0), this.m_linearVelocity);
        };
        b2Body.prototype.GetWorldPoint = function(localPoint, out) {
          return b2Transform.MulXV(this.m_xf, localPoint, out);
        };
        b2Body.prototype.GetWorldVector = function(localVector, out) {
          return b2Rot.MulRV(this.m_xf.q, localVector, out);
        };
        b2Body.prototype.GetLocalPoint = function(worldPoint, out) {
          return b2Transform.MulTXV(this.m_xf, worldPoint, out);
        };
        b2Body.prototype.GetLocalVector = function(worldVector, out) {
          return b2Rot.MulTRV(this.m_xf.q, worldVector, out);
        };
        b2Body.prototype.GetLinearVelocityFromWorldPoint = function(worldPoint, out) {
          return b2Vec2.AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, b2Vec2.SubVV(worldPoint, this.m_sweep.c, b2Vec2.s_t0), out);
        };
        b2Body.prototype.GetLinearVelocityFromLocalPoint = function(localPoint, out) {
          return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(localPoint, out), out);
        };
        b2Body.prototype.GetLinearDamping = function() {
          return this.m_linearDamping;
        };
        b2Body.prototype.SetLinearDamping = function(linearDamping) {
          this.m_linearDamping = linearDamping;
        };
        b2Body.prototype.GetAngularDamping = function() {
          return this.m_angularDamping;
        };
        b2Body.prototype.SetAngularDamping = function(angularDamping) {
          this.m_angularDamping = angularDamping;
        };
        b2Body.prototype.GetGravityScale = function() {
          return this.m_gravityScale;
        };
        b2Body.prototype.SetGravityScale = function(scale) {
          this.m_gravityScale = scale;
        };
        b2Body.prototype.SetType = function(type) {
          if (this.m_world.IsLocked()) throw new Error();
          if (this.m_type === type) return;
          this.m_type = type;
          this.ResetMassData();
          if (this.m_type === exports.b2BodyType.b2_staticBody) {
            this.m_linearVelocity.SetZero();
            this.m_angularVelocity = 0;
            this.m_sweep.a0 = this.m_sweep.a;
            this.m_sweep.c0.Copy(this.m_sweep.c);
            this.SynchronizeFixtures();
          }
          this.SetAwake(true);
          this.m_force.SetZero();
          this.m_torque = 0;
          var ce = this.m_contactList;
          while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_world.m_contactManager.Destroy(ce0.contact);
          }
          this.m_contactList = null;
          for (var f = this.m_fixtureList; f; f = f.m_next) f.TouchProxies();
        };
        b2Body.prototype.GetType = function() {
          return this.m_type;
        };
        b2Body.prototype.SetBullet = function(flag) {
          this.m_bulletFlag = flag;
        };
        b2Body.prototype.IsBullet = function() {
          return this.m_bulletFlag;
        };
        b2Body.prototype.SetSleepingAllowed = function(flag) {
          this.m_autoSleepFlag = flag;
          flag || this.SetAwake(true);
        };
        b2Body.prototype.IsSleepingAllowed = function() {
          return this.m_autoSleepFlag;
        };
        b2Body.prototype.SetAwake = function(flag) {
          if (flag) {
            this.m_awakeFlag = true;
            this.m_sleepTime = 0;
          } else {
            this.m_awakeFlag = false;
            this.m_sleepTime = 0;
            this.m_linearVelocity.SetZero();
            this.m_angularVelocity = 0;
            this.m_force.SetZero();
            this.m_torque = 0;
          }
        };
        b2Body.prototype.IsAwake = function() {
          return this.m_awakeFlag;
        };
        b2Body.prototype.SetActive = function(flag) {
          if (this.m_world.IsLocked()) throw new Error();
          if (flag === this.IsActive()) return;
          this.m_activeFlag = flag;
          if (flag) for (var f = this.m_fixtureList; f; f = f.m_next) f.CreateProxies(this.m_xf); else {
            for (var f = this.m_fixtureList; f; f = f.m_next) f.DestroyProxies();
            var ce = this.m_contactList;
            while (ce) {
              var ce0 = ce;
              ce = ce.next;
              this.m_world.m_contactManager.Destroy(ce0.contact);
            }
            this.m_contactList = null;
          }
        };
        b2Body.prototype.IsActive = function() {
          return this.m_activeFlag;
        };
        b2Body.prototype.SetFixedRotation = function(flag) {
          if (this.m_fixedRotationFlag === flag) return;
          this.m_fixedRotationFlag = flag;
          this.m_angularVelocity = 0;
          this.ResetMassData();
        };
        b2Body.prototype.IsFixedRotation = function() {
          return this.m_fixedRotationFlag;
        };
        b2Body.prototype.GetFixtureList = function() {
          return this.m_fixtureList;
        };
        b2Body.prototype.GetJointList = function() {
          return this.m_jointList;
        };
        b2Body.prototype.GetContactList = function() {
          return this.m_contactList;
        };
        b2Body.prototype.GetNext = function() {
          return this.m_next;
        };
        b2Body.prototype.GetUserData = function() {
          return this.m_userData;
        };
        b2Body.prototype.SetUserData = function(data) {
          this.m_userData = data;
        };
        b2Body.prototype.GetWorld = function() {
          return this.m_world;
        };
        b2Body.prototype.Dump = function(log) {
          var bodyIndex = this.m_islandIndex;
          log("{\n");
          log("  const bd: b2BodyDef = new b2BodyDef();\n");
          var type_str = "";
          switch (this.m_type) {
           case exports.b2BodyType.b2_staticBody:
            type_str = "b2BodyType.b2_staticBody";
            break;

           case exports.b2BodyType.b2_kinematicBody:
            type_str = "b2BodyType.b2_kinematicBody";
            break;

           case exports.b2BodyType.b2_dynamicBody:
            type_str = "b2BodyType.b2_dynamicBody";
          }
          log("  bd.type = %s;\n", type_str);
          log("  bd.position.Set(%.15f, %.15f);\n", this.m_xf.p.x, this.m_xf.p.y);
          log("  bd.angle = %.15f;\n", this.m_sweep.a);
          log("  bd.linearVelocity.Set(%.15f, %.15f);\n", this.m_linearVelocity.x, this.m_linearVelocity.y);
          log("  bd.angularVelocity = %.15f;\n", this.m_angularVelocity);
          log("  bd.linearDamping = %.15f;\n", this.m_linearDamping);
          log("  bd.angularDamping = %.15f;\n", this.m_angularDamping);
          log("  bd.allowSleep = %s;\n", this.m_autoSleepFlag ? "true" : "false");
          log("  bd.awake = %s;\n", this.m_awakeFlag ? "true" : "false");
          log("  bd.fixedRotation = %s;\n", this.m_fixedRotationFlag ? "true" : "false");
          log("  bd.bullet = %s;\n", this.m_bulletFlag ? "true" : "false");
          log("  bd.active = %s;\n", this.m_activeFlag ? "true" : "false");
          log("  bd.gravityScale = %.15f;\n", this.m_gravityScale);
          log("\n");
          log("  bodies[%d] = this.m_world.CreateBody(bd);\n", this.m_islandIndex);
          log("\n");
          for (var f = this.m_fixtureList; f; f = f.m_next) {
            log("  {\n");
            f.Dump(log, bodyIndex);
            log("  }\n");
          }
          log("}\n");
        };
        b2Body.prototype.SynchronizeFixtures = function() {
          var xf1 = b2Body.SynchronizeFixtures_s_xf1;
          xf1.q.SetAngle(this.m_sweep.a0);
          b2Rot.MulRV(xf1.q, this.m_sweep.localCenter, xf1.p);
          b2Vec2.SubVV(this.m_sweep.c0, xf1.p, xf1.p);
          for (var f = this.m_fixtureList; f; f = f.m_next) f.Synchronize(xf1, this.m_xf);
        };
        b2Body.prototype.SynchronizeTransform = function() {
          this.m_xf.q.SetAngle(this.m_sweep.a);
          b2Rot.MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
          b2Vec2.SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p);
        };
        b2Body.prototype.ShouldCollide = function(other) {
          if (this.m_type === exports.b2BodyType.b2_staticBody && other.m_type === exports.b2BodyType.b2_staticBody) return false;
          return this.ShouldCollideConnected(other);
        };
        b2Body.prototype.ShouldCollideConnected = function(other) {
          for (var jn = this.m_jointList; jn; jn = jn.next) if (jn.other === other && !jn.joint.m_collideConnected) return false;
          return true;
        };
        b2Body.prototype.Advance = function(alpha) {
          this.m_sweep.Advance(alpha);
          this.m_sweep.c.Copy(this.m_sweep.c0);
          this.m_sweep.a = this.m_sweep.a0;
          this.m_xf.q.SetAngle(this.m_sweep.a);
          b2Rot.MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);
          b2Vec2.SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p);
        };
        b2Body.prototype.GetControllerList = function() {
          return this.m_controllerList;
        };
        b2Body.prototype.GetControllerCount = function() {
          return this.m_controllerCount;
        };
        b2Body.CreateFixtureShapeDensity_s_def = new b2FixtureDef();
        b2Body.SetMassData_s_oldCenter = new b2Vec2();
        b2Body.ResetMassData_s_localCenter = new b2Vec2();
        b2Body.ResetMassData_s_oldCenter = new b2Vec2();
        b2Body.ResetMassData_s_massData = new b2MassData();
        b2Body.SynchronizeFixtures_s_xf1 = new b2Transform();
        return b2Body;
      })();
      (function(b2JointType) {
        b2JointType[b2JointType["e_unknownJoint"] = 0] = "e_unknownJoint";
        b2JointType[b2JointType["e_revoluteJoint"] = 1] = "e_revoluteJoint";
        b2JointType[b2JointType["e_prismaticJoint"] = 2] = "e_prismaticJoint";
        b2JointType[b2JointType["e_distanceJoint"] = 3] = "e_distanceJoint";
        b2JointType[b2JointType["e_pulleyJoint"] = 4] = "e_pulleyJoint";
        b2JointType[b2JointType["e_mouseJoint"] = 5] = "e_mouseJoint";
        b2JointType[b2JointType["e_gearJoint"] = 6] = "e_gearJoint";
        b2JointType[b2JointType["e_wheelJoint"] = 7] = "e_wheelJoint";
        b2JointType[b2JointType["e_weldJoint"] = 8] = "e_weldJoint";
        b2JointType[b2JointType["e_frictionJoint"] = 9] = "e_frictionJoint";
        b2JointType[b2JointType["e_ropeJoint"] = 10] = "e_ropeJoint";
        b2JointType[b2JointType["e_motorJoint"] = 11] = "e_motorJoint";
        b2JointType[b2JointType["e_areaJoint"] = 12] = "e_areaJoint";
      })(exports.b2JointType || (exports.b2JointType = {}));
      (function(b2LimitState) {
        b2LimitState[b2LimitState["e_inactiveLimit"] = 0] = "e_inactiveLimit";
        b2LimitState[b2LimitState["e_atLowerLimit"] = 1] = "e_atLowerLimit";
        b2LimitState[b2LimitState["e_atUpperLimit"] = 2] = "e_atUpperLimit";
        b2LimitState[b2LimitState["e_equalLimits"] = 3] = "e_equalLimits";
      })(exports.b2LimitState || (exports.b2LimitState = {}));
      var b2Jacobian = (function() {
        function b2Jacobian() {
          this.linear = new b2Vec2();
          this.angularA = 0;
          this.angularB = 0;
        }
        b2Jacobian.prototype.SetZero = function() {
          this.linear.SetZero();
          this.angularA = 0;
          this.angularB = 0;
          return this;
        };
        b2Jacobian.prototype.Set = function(x, a1, a2) {
          this.linear.Copy(x);
          this.angularA = a1;
          this.angularB = a2;
          return this;
        };
        return b2Jacobian;
      })();
      var b2JointEdge = (function() {
        function b2JointEdge(joint, other) {
          this.prev = null;
          this.next = null;
          this.joint = joint;
          this.other = other;
        }
        return b2JointEdge;
      })();
      var b2JointDef = (function() {
        function b2JointDef(type) {
          this.type = exports.b2JointType.e_unknownJoint;
          this.userData = null;
          this.collideConnected = false;
          this.type = type;
        }
        return b2JointDef;
      })();
      var b2Joint = (function() {
        function b2Joint(def) {
          this.m_type = exports.b2JointType.e_unknownJoint;
          this.m_prev = null;
          this.m_next = null;
          this.m_index = 0;
          this.m_islandFlag = false;
          this.m_collideConnected = false;
          this.m_userData = null;
          this.m_type = def.type;
          this.m_edgeA = new b2JointEdge(this, def.bodyB);
          this.m_edgeB = new b2JointEdge(this, def.bodyA);
          this.m_bodyA = def.bodyA;
          this.m_bodyB = def.bodyB;
          this.m_collideConnected = b2Maybe(def.collideConnected, false);
          this.m_userData = def.userData;
        }
        b2Joint.prototype.GetType = function() {
          return this.m_type;
        };
        b2Joint.prototype.GetBodyA = function() {
          return this.m_bodyA;
        };
        b2Joint.prototype.GetBodyB = function() {
          return this.m_bodyB;
        };
        b2Joint.prototype.GetNext = function() {
          return this.m_next;
        };
        b2Joint.prototype.GetUserData = function() {
          return this.m_userData;
        };
        b2Joint.prototype.SetUserData = function(data) {
          this.m_userData = data;
        };
        b2Joint.prototype.IsActive = function() {
          return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
        };
        b2Joint.prototype.GetCollideConnected = function() {
          return this.m_collideConnected;
        };
        b2Joint.prototype.Dump = function(log) {
          log("// Dump is not supported for this joint type.\n");
        };
        b2Joint.prototype.ShiftOrigin = function(newOrigin) {};
        return b2Joint;
      })();
      var b2DistanceJointDef = (function(_super) {
        __extends(b2DistanceJointDef, _super);
        function b2DistanceJointDef() {
          var _this = _super.call(this, exports.b2JointType.e_distanceJoint) || this;
          _this.localAnchorA = new b2Vec2();
          _this.localAnchorB = new b2Vec2();
          _this.length = 1;
          _this.frequencyHz = 0;
          _this.dampingRatio = 0;
          return _this;
        }
        b2DistanceJointDef.prototype.Initialize = function(b1, b2, anchor1, anchor2) {
          this.bodyA = b1;
          this.bodyB = b2;
          this.bodyA.GetLocalPoint(anchor1, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchor2, this.localAnchorB);
          this.length = b2Vec2.DistanceVV(anchor1, anchor2);
          this.frequencyHz = 0;
          this.dampingRatio = 0;
        };
        return b2DistanceJointDef;
      })(b2JointDef);
      var b2DistanceJoint = (function(_super) {
        __extends(b2DistanceJoint, _super);
        function b2DistanceJoint(def) {
          var _this = _super.call(this, def) || this;
          _this.m_frequencyHz = 0;
          _this.m_dampingRatio = 0;
          _this.m_bias = 0;
          _this.m_localAnchorA = new b2Vec2();
          _this.m_localAnchorB = new b2Vec2();
          _this.m_gamma = 0;
          _this.m_impulse = 0;
          _this.m_length = 0;
          _this.m_indexA = 0;
          _this.m_indexB = 0;
          _this.m_u = new b2Vec2();
          _this.m_rA = new b2Vec2();
          _this.m_rB = new b2Vec2();
          _this.m_localCenterA = new b2Vec2();
          _this.m_localCenterB = new b2Vec2();
          _this.m_invMassA = 0;
          _this.m_invMassB = 0;
          _this.m_invIA = 0;
          _this.m_invIB = 0;
          _this.m_mass = 0;
          _this.m_qA = new b2Rot();
          _this.m_qB = new b2Rot();
          _this.m_lalcA = new b2Vec2();
          _this.m_lalcB = new b2Vec2();
          _this.m_frequencyHz = b2Maybe(def.frequencyHz, 0);
          _this.m_dampingRatio = b2Maybe(def.dampingRatio, 0);
          _this.m_localAnchorA.Copy(def.localAnchorA);
          _this.m_localAnchorB.Copy(def.localAnchorB);
          _this.m_length = def.length;
          return _this;
        }
        b2DistanceJoint.prototype.GetAnchorA = function(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
        };
        b2DistanceJoint.prototype.GetAnchorB = function(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
        };
        b2DistanceJoint.prototype.GetReactionForce = function(inv_dt, out) {
          out.x = inv_dt * this.m_impulse * this.m_u.x;
          out.y = inv_dt * this.m_impulse * this.m_u.y;
          return out;
        };
        b2DistanceJoint.prototype.GetReactionTorque = function(inv_dt) {
          return 0;
        };
        b2DistanceJoint.prototype.GetLocalAnchorA = function() {
          return this.m_localAnchorA;
        };
        b2DistanceJoint.prototype.GetLocalAnchorB = function() {
          return this.m_localAnchorB;
        };
        b2DistanceJoint.prototype.SetLength = function(length) {
          this.m_length = length;
        };
        b2DistanceJoint.prototype.Length = function() {
          return this.m_length;
        };
        b2DistanceJoint.prototype.SetFrequency = function(hz) {
          this.m_frequencyHz = hz;
        };
        b2DistanceJoint.prototype.GetFrequency = function() {
          return this.m_frequencyHz;
        };
        b2DistanceJoint.prototype.SetDampingRatio = function(ratio) {
          this.m_dampingRatio = ratio;
        };
        b2DistanceJoint.prototype.GetDampingRatio = function() {
          return this.m_dampingRatio;
        };
        b2DistanceJoint.prototype.Dump = function(log) {
          var indexA = this.m_bodyA.m_islandIndex;
          var indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2DistanceJointDef = new b2DistanceJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.length = %.15f;\n", this.m_length);
          log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
          log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
        };
        b2DistanceJoint.prototype.InitVelocityConstraints = function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          this.m_u.x = cB.x + this.m_rB.x - cA.x - this.m_rA.x;
          this.m_u.y = cB.y + this.m_rB.y - cA.y - this.m_rA.y;
          var length = this.m_u.Length();
          length > b2_linearSlop ? this.m_u.SelfMul(1 / length) : this.m_u.SetZero();
          var crAu = b2Vec2.CrossVV(this.m_rA, this.m_u);
          var crBu = b2Vec2.CrossVV(this.m_rB, this.m_u);
          var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;
          this.m_mass = 0 !== invMass ? 1 / invMass : 0;
          if (this.m_frequencyHz > 0) {
            var C = length - this.m_length;
            var omega = 2 * b2_pi * this.m_frequencyHz;
            var d = 2 * this.m_mass * this.m_dampingRatio * omega;
            var k = this.m_mass * omega * omega;
            var h = data.step.dt;
            this.m_gamma = h * (d + h * k);
            this.m_gamma = 0 !== this.m_gamma ? 1 / this.m_gamma : 0;
            this.m_bias = C * h * k * this.m_gamma;
            invMass += this.m_gamma;
            this.m_mass = 0 !== invMass ? 1 / invMass : 0;
          } else {
            this.m_gamma = 0;
            this.m_bias = 0;
          }
          if (data.step.warmStarting) {
            this.m_impulse *= data.step.dtRatio;
            var P = b2Vec2.MulSV(this.m_impulse, this.m_u, b2DistanceJoint.InitVelocityConstraints_s_P);
            vA.SelfMulSub(this.m_invMassA, P);
            wA -= this.m_invIA * b2Vec2.CrossVV(this.m_rA, P);
            vB.SelfMulAdd(this.m_invMassB, P);
            wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, P);
          } else this.m_impulse = 0;
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2DistanceJoint.prototype.SolveVelocityConstraints = function(data) {
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var vpA = b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2DistanceJoint.SolveVelocityConstraints_s_vpA);
          var vpB = b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2DistanceJoint.SolveVelocityConstraints_s_vpB);
          var Cdot = b2Vec2.DotVV(this.m_u, b2Vec2.SubVV(vpB, vpA, b2Vec2.s_t0));
          var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
          this.m_impulse += impulse;
          var P = b2Vec2.MulSV(impulse, this.m_u, b2DistanceJoint.SolveVelocityConstraints_s_P);
          vA.SelfMulSub(this.m_invMassA, P);
          wA -= this.m_invIA * b2Vec2.CrossVV(this.m_rA, P);
          vB.SelfMulAdd(this.m_invMassB, P);
          wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, P);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2DistanceJoint.prototype.SolvePositionConstraints = function(data) {
          if (this.m_frequencyHz > 0) return true;
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          var rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          var rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var u = this.m_u;
          u.x = cB.x + rB.x - cA.x - rA.x;
          u.y = cB.y + rB.y - cA.y - rA.y;
          var length = this.m_u.Normalize();
          var C = length - this.m_length;
          C = b2Clamp(C, -b2_maxLinearCorrection, b2_maxLinearCorrection);
          var impulse = -this.m_mass * C;
          var P = b2Vec2.MulSV(impulse, u, b2DistanceJoint.SolvePositionConstraints_s_P);
          cA.SelfMulSub(this.m_invMassA, P);
          aA -= this.m_invIA * b2Vec2.CrossVV(rA, P);
          cB.SelfMulAdd(this.m_invMassB, P);
          aB += this.m_invIB * b2Vec2.CrossVV(rB, P);
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].a = aB;
          return b2Abs(C) < b2_linearSlop;
        };
        b2DistanceJoint.InitVelocityConstraints_s_P = new b2Vec2();
        b2DistanceJoint.SolveVelocityConstraints_s_vpA = new b2Vec2();
        b2DistanceJoint.SolveVelocityConstraints_s_vpB = new b2Vec2();
        b2DistanceJoint.SolveVelocityConstraints_s_P = new b2Vec2();
        b2DistanceJoint.SolvePositionConstraints_s_P = new b2Vec2();
        return b2DistanceJoint;
      })(b2Joint);
      var b2AreaJointDef = (function(_super) {
        __extends(b2AreaJointDef, _super);
        function b2AreaJointDef() {
          var _this = _super.call(this, exports.b2JointType.e_areaJoint) || this;
          _this.bodies = [];
          _this.frequencyHz = 0;
          _this.dampingRatio = 0;
          return _this;
        }
        b2AreaJointDef.prototype.AddBody = function(body) {
          this.bodies.push(body);
          1 === this.bodies.length ? this.bodyA = body : 2 === this.bodies.length && (this.bodyB = body);
        };
        return b2AreaJointDef;
      })(b2JointDef);
      var b2AreaJoint = (function(_super) {
        __extends(b2AreaJoint, _super);
        function b2AreaJoint(def) {
          var _this = _super.call(this, def) || this;
          _this.m_frequencyHz = 0;
          _this.m_dampingRatio = 0;
          _this.m_impulse = 0;
          _this.m_targetArea = 0;
          _this.m_bodies = def.bodies;
          _this.m_frequencyHz = b2Maybe(def.frequencyHz, 0);
          _this.m_dampingRatio = b2Maybe(def.dampingRatio, 0);
          _this.m_targetLengths = b2MakeNumberArray(def.bodies.length);
          _this.m_normals = b2Vec2.MakeArray(def.bodies.length);
          _this.m_joints = [];
          _this.m_deltas = b2Vec2.MakeArray(def.bodies.length);
          _this.m_delta = new b2Vec2();
          var djd = new b2DistanceJointDef();
          djd.frequencyHz = _this.m_frequencyHz;
          djd.dampingRatio = _this.m_dampingRatio;
          _this.m_targetArea = 0;
          for (var i = 0; i < _this.m_bodies.length; ++i) {
            var body = _this.m_bodies[i];
            var next = _this.m_bodies[(i + 1) % _this.m_bodies.length];
            var body_c = body.GetWorldCenter();
            var next_c = next.GetWorldCenter();
            _this.m_targetLengths[i] = b2Vec2.DistanceVV(body_c, next_c);
            _this.m_targetArea += b2Vec2.CrossVV(body_c, next_c);
            djd.Initialize(body, next, body_c, next_c);
            _this.m_joints[i] = body.GetWorld().CreateJoint(djd);
          }
          _this.m_targetArea *= .5;
          return _this;
        }
        b2AreaJoint.prototype.GetAnchorA = function(out) {
          return out;
        };
        b2AreaJoint.prototype.GetAnchorB = function(out) {
          return out;
        };
        b2AreaJoint.prototype.GetReactionForce = function(inv_dt, out) {
          return out;
        };
        b2AreaJoint.prototype.GetReactionTorque = function(inv_dt) {
          return 0;
        };
        b2AreaJoint.prototype.SetFrequency = function(hz) {
          this.m_frequencyHz = hz;
          for (var i = 0; i < this.m_joints.length; ++i) this.m_joints[i].SetFrequency(hz);
        };
        b2AreaJoint.prototype.GetFrequency = function() {
          return this.m_frequencyHz;
        };
        b2AreaJoint.prototype.SetDampingRatio = function(ratio) {
          this.m_dampingRatio = ratio;
          for (var i = 0; i < this.m_joints.length; ++i) this.m_joints[i].SetDampingRatio(ratio);
        };
        b2AreaJoint.prototype.GetDampingRatio = function() {
          return this.m_dampingRatio;
        };
        b2AreaJoint.prototype.Dump = function(log) {
          log("Area joint dumping is not supported.\n");
        };
        b2AreaJoint.prototype.InitVelocityConstraints = function(data) {
          for (var i = 0; i < this.m_bodies.length; ++i) {
            var prev = this.m_bodies[(i + this.m_bodies.length - 1) % this.m_bodies.length];
            var next = this.m_bodies[(i + 1) % this.m_bodies.length];
            var prev_c = data.positions[prev.m_islandIndex].c;
            var next_c = data.positions[next.m_islandIndex].c;
            var delta = this.m_deltas[i];
            b2Vec2.SubVV(next_c, prev_c, delta);
          }
          if (data.step.warmStarting) {
            this.m_impulse *= data.step.dtRatio;
            for (var i = 0; i < this.m_bodies.length; ++i) {
              var body = this.m_bodies[i];
              var body_v = data.velocities[body.m_islandIndex].v;
              var delta = this.m_deltas[i];
              body_v.x += body.m_invMass * delta.y * .5 * this.m_impulse;
              body_v.y += body.m_invMass * -delta.x * .5 * this.m_impulse;
            }
          } else this.m_impulse = 0;
        };
        b2AreaJoint.prototype.SolveVelocityConstraints = function(data) {
          var dotMassSum = 0;
          var crossMassSum = 0;
          for (var i = 0; i < this.m_bodies.length; ++i) {
            var body = this.m_bodies[i];
            var body_v = data.velocities[body.m_islandIndex].v;
            var delta = this.m_deltas[i];
            dotMassSum += delta.LengthSquared() / body.GetMass();
            crossMassSum += b2Vec2.CrossVV(body_v, delta);
          }
          var lambda = -2 * crossMassSum / dotMassSum;
          this.m_impulse += lambda;
          for (var i = 0; i < this.m_bodies.length; ++i) {
            var body = this.m_bodies[i];
            var body_v = data.velocities[body.m_islandIndex].v;
            var delta = this.m_deltas[i];
            body_v.x += body.m_invMass * delta.y * .5 * lambda;
            body_v.y += body.m_invMass * -delta.x * .5 * lambda;
          }
        };
        b2AreaJoint.prototype.SolvePositionConstraints = function(data) {
          var perimeter = 0;
          var area = 0;
          for (var i = 0; i < this.m_bodies.length; ++i) {
            var body = this.m_bodies[i];
            var next = this.m_bodies[(i + 1) % this.m_bodies.length];
            var body_c = data.positions[body.m_islandIndex].c;
            var next_c = data.positions[next.m_islandIndex].c;
            var delta = b2Vec2.SubVV(next_c, body_c, this.m_delta);
            var dist = delta.Length();
            dist < b2_epsilon && (dist = 1);
            this.m_normals[i].x = delta.y / dist;
            this.m_normals[i].y = -delta.x / dist;
            perimeter += dist;
            area += b2Vec2.CrossVV(body_c, next_c);
          }
          area *= .5;
          var deltaArea = this.m_targetArea - area;
          var toExtrude = .5 * deltaArea / perimeter;
          var done = true;
          for (var i = 0; i < this.m_bodies.length; ++i) {
            var body = this.m_bodies[i];
            var body_c = data.positions[body.m_islandIndex].c;
            var next_i = (i + 1) % this.m_bodies.length;
            var delta = b2Vec2.AddVV(this.m_normals[i], this.m_normals[next_i], this.m_delta);
            delta.SelfMul(toExtrude);
            var norm_sq = delta.LengthSquared();
            norm_sq > b2Sq(b2_maxLinearCorrection) && delta.SelfMul(b2_maxLinearCorrection / b2Sqrt(norm_sq));
            norm_sq > b2Sq(b2_linearSlop) && (done = false);
            body_c.x += delta.x;
            body_c.y += delta.y;
          }
          return done;
        };
        return b2AreaJoint;
      })(b2Joint);
      var b2FrictionJointDef = (function(_super) {
        __extends(b2FrictionJointDef, _super);
        function b2FrictionJointDef() {
          var _this = _super.call(this, exports.b2JointType.e_frictionJoint) || this;
          _this.localAnchorA = new b2Vec2();
          _this.localAnchorB = new b2Vec2();
          _this.maxForce = 0;
          _this.maxTorque = 0;
          return _this;
        }
        b2FrictionJointDef.prototype.Initialize = function(bA, bB, anchor) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
        };
        return b2FrictionJointDef;
      })(b2JointDef);
      var b2FrictionJoint = (function(_super) {
        __extends(b2FrictionJoint, _super);
        function b2FrictionJoint(def) {
          var _this = _super.call(this, def) || this;
          _this.m_localAnchorA = new b2Vec2();
          _this.m_localAnchorB = new b2Vec2();
          _this.m_linearImpulse = new b2Vec2();
          _this.m_angularImpulse = 0;
          _this.m_maxForce = 0;
          _this.m_maxTorque = 0;
          _this.m_indexA = 0;
          _this.m_indexB = 0;
          _this.m_rA = new b2Vec2();
          _this.m_rB = new b2Vec2();
          _this.m_localCenterA = new b2Vec2();
          _this.m_localCenterB = new b2Vec2();
          _this.m_invMassA = 0;
          _this.m_invMassB = 0;
          _this.m_invIA = 0;
          _this.m_invIB = 0;
          _this.m_linearMass = new b2Mat22();
          _this.m_angularMass = 0;
          _this.m_qA = new b2Rot();
          _this.m_qB = new b2Rot();
          _this.m_lalcA = new b2Vec2();
          _this.m_lalcB = new b2Vec2();
          _this.m_K = new b2Mat22();
          _this.m_localAnchorA.Copy(def.localAnchorA);
          _this.m_localAnchorB.Copy(def.localAnchorB);
          _this.m_linearImpulse.SetZero();
          _this.m_maxForce = b2Maybe(def.maxForce, 0);
          _this.m_maxTorque = b2Maybe(def.maxTorque, 0);
          _this.m_linearMass.SetZero();
          return _this;
        }
        b2FrictionJoint.prototype.InitVelocityConstraints = function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          var rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          var rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var K = this.m_K;
          K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
          K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
          K.ey.x = K.ex.y;
          K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
          K.GetInverse(this.m_linearMass);
          this.m_angularMass = iA + iB;
          this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass);
          if (data.step.warmStarting) {
            this.m_linearImpulse.SelfMul(data.step.dtRatio);
            this.m_angularImpulse *= data.step.dtRatio;
            var P = this.m_linearImpulse;
            vA.SelfMulSub(mA, P);
            wA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + this.m_angularImpulse);
            vB.SelfMulAdd(mB, P);
            wB += iB * (b2Vec2.CrossVV(this.m_rB, P) + this.m_angularImpulse);
          } else {
            this.m_linearImpulse.SetZero();
            this.m_angularImpulse = 0;
          }
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2FrictionJoint.prototype.SolveVelocityConstraints = function(data) {
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var h = data.step.dt;
          var Cdot = wB - wA;
          var impulse = -this.m_angularMass * Cdot;
          var oldImpulse = this.m_angularImpulse;
          var maxImpulse = h * this.m_maxTorque;
          this.m_angularImpulse = b2Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
          impulse = this.m_angularImpulse - oldImpulse;
          wA -= iA * impulse;
          wB += iB * impulse;
          var Cdot_v2 = b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Vec2.s_t1), b2FrictionJoint.SolveVelocityConstraints_s_Cdot_v2);
          var impulseV = b2Mat22.MulMV(this.m_linearMass, Cdot_v2, b2FrictionJoint.SolveVelocityConstraints_s_impulseV).SelfNeg();
          var oldImpulseV = b2FrictionJoint.SolveVelocityConstraints_s_oldImpulseV.Copy(this.m_linearImpulse);
          this.m_linearImpulse.SelfAdd(impulseV);
          var maxImpulse = h * this.m_maxForce;
          if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_linearImpulse.Normalize();
            this.m_linearImpulse.SelfMul(maxImpulse);
          }
          b2Vec2.SubVV(this.m_linearImpulse, oldImpulseV, impulseV);
          vA.SelfMulSub(mA, impulseV);
          wA -= iA * b2Vec2.CrossVV(this.m_rA, impulseV);
          vB.SelfMulAdd(mB, impulseV);
          wB += iB * b2Vec2.CrossVV(this.m_rB, impulseV);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2FrictionJoint.prototype.SolvePositionConstraints = function(data) {
          return true;
        };
        b2FrictionJoint.prototype.GetAnchorA = function(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
        };
        b2FrictionJoint.prototype.GetAnchorB = function(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
        };
        b2FrictionJoint.prototype.GetReactionForce = function(inv_dt, out) {
          out.x = inv_dt * this.m_linearImpulse.x;
          out.y = inv_dt * this.m_linearImpulse.y;
          return out;
        };
        b2FrictionJoint.prototype.GetReactionTorque = function(inv_dt) {
          return inv_dt * this.m_angularImpulse;
        };
        b2FrictionJoint.prototype.GetLocalAnchorA = function() {
          return this.m_localAnchorA;
        };
        b2FrictionJoint.prototype.GetLocalAnchorB = function() {
          return this.m_localAnchorB;
        };
        b2FrictionJoint.prototype.SetMaxForce = function(force) {
          this.m_maxForce = force;
        };
        b2FrictionJoint.prototype.GetMaxForce = function() {
          return this.m_maxForce;
        };
        b2FrictionJoint.prototype.SetMaxTorque = function(torque) {
          this.m_maxTorque = torque;
        };
        b2FrictionJoint.prototype.GetMaxTorque = function() {
          return this.m_maxTorque;
        };
        b2FrictionJoint.prototype.Dump = function(log) {
          var indexA = this.m_bodyA.m_islandIndex;
          var indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2FrictionJointDef = new b2FrictionJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.maxForce = %.15f;\n", this.m_maxForce);
          log("  jd.maxTorque = %.15f;\n", this.m_maxTorque);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
        };
        b2FrictionJoint.SolveVelocityConstraints_s_Cdot_v2 = new b2Vec2();
        b2FrictionJoint.SolveVelocityConstraints_s_impulseV = new b2Vec2();
        b2FrictionJoint.SolveVelocityConstraints_s_oldImpulseV = new b2Vec2();
        return b2FrictionJoint;
      })(b2Joint);
      var b2GearJointDef = (function(_super) {
        __extends(b2GearJointDef, _super);
        function b2GearJointDef() {
          var _this = _super.call(this, exports.b2JointType.e_gearJoint) || this;
          _this.ratio = 1;
          return _this;
        }
        return b2GearJointDef;
      })(b2JointDef);
      var b2GearJoint = (function(_super) {
        __extends(b2GearJoint, _super);
        function b2GearJoint(def) {
          var _this = _super.call(this, def) || this;
          _this.m_typeA = exports.b2JointType.e_unknownJoint;
          _this.m_typeB = exports.b2JointType.e_unknownJoint;
          _this.m_localAnchorA = new b2Vec2();
          _this.m_localAnchorB = new b2Vec2();
          _this.m_localAnchorC = new b2Vec2();
          _this.m_localAnchorD = new b2Vec2();
          _this.m_localAxisC = new b2Vec2();
          _this.m_localAxisD = new b2Vec2();
          _this.m_referenceAngleA = 0;
          _this.m_referenceAngleB = 0;
          _this.m_constant = 0;
          _this.m_ratio = 0;
          _this.m_impulse = 0;
          _this.m_indexA = 0;
          _this.m_indexB = 0;
          _this.m_indexC = 0;
          _this.m_indexD = 0;
          _this.m_lcA = new b2Vec2();
          _this.m_lcB = new b2Vec2();
          _this.m_lcC = new b2Vec2();
          _this.m_lcD = new b2Vec2();
          _this.m_mA = 0;
          _this.m_mB = 0;
          _this.m_mC = 0;
          _this.m_mD = 0;
          _this.m_iA = 0;
          _this.m_iB = 0;
          _this.m_iC = 0;
          _this.m_iD = 0;
          _this.m_JvAC = new b2Vec2();
          _this.m_JvBD = new b2Vec2();
          _this.m_JwA = 0;
          _this.m_JwB = 0;
          _this.m_JwC = 0;
          _this.m_JwD = 0;
          _this.m_mass = 0;
          _this.m_qA = new b2Rot();
          _this.m_qB = new b2Rot();
          _this.m_qC = new b2Rot();
          _this.m_qD = new b2Rot();
          _this.m_lalcA = new b2Vec2();
          _this.m_lalcB = new b2Vec2();
          _this.m_lalcC = new b2Vec2();
          _this.m_lalcD = new b2Vec2();
          _this.m_joint1 = def.joint1;
          _this.m_joint2 = def.joint2;
          _this.m_typeA = _this.m_joint1.GetType();
          _this.m_typeB = _this.m_joint2.GetType();
          var coordinateA, coordinateB;
          _this.m_bodyC = _this.m_joint1.GetBodyA();
          _this.m_bodyA = _this.m_joint1.GetBodyB();
          var xfA = _this.m_bodyA.m_xf;
          var aA = _this.m_bodyA.m_sweep.a;
          var xfC = _this.m_bodyC.m_xf;
          var aC = _this.m_bodyC.m_sweep.a;
          if (_this.m_typeA === exports.b2JointType.e_revoluteJoint) {
            var revolute = def.joint1;
            _this.m_localAnchorC.Copy(revolute.m_localAnchorA);
            _this.m_localAnchorA.Copy(revolute.m_localAnchorB);
            _this.m_referenceAngleA = revolute.m_referenceAngle;
            _this.m_localAxisC.SetZero();
            coordinateA = aA - aC - _this.m_referenceAngleA;
          } else {
            var prismatic = def.joint1;
            _this.m_localAnchorC.Copy(prismatic.m_localAnchorA);
            _this.m_localAnchorA.Copy(prismatic.m_localAnchorB);
            _this.m_referenceAngleA = prismatic.m_referenceAngle;
            _this.m_localAxisC.Copy(prismatic.m_localXAxisA);
            var pC = _this.m_localAnchorC;
            var pA = b2Rot.MulTRV(xfC.q, b2Vec2.AddVV(b2Rot.MulRV(xfA.q, _this.m_localAnchorA, b2Vec2.s_t0), b2Vec2.SubVV(xfA.p, xfC.p, b2Vec2.s_t1), b2Vec2.s_t0), b2Vec2.s_t0);
            coordinateA = b2Vec2.DotVV(b2Vec2.SubVV(pA, pC, b2Vec2.s_t0), _this.m_localAxisC);
          }
          _this.m_bodyD = _this.m_joint2.GetBodyA();
          _this.m_bodyB = _this.m_joint2.GetBodyB();
          var xfB = _this.m_bodyB.m_xf;
          var aB = _this.m_bodyB.m_sweep.a;
          var xfD = _this.m_bodyD.m_xf;
          var aD = _this.m_bodyD.m_sweep.a;
          if (_this.m_typeB === exports.b2JointType.e_revoluteJoint) {
            var revolute = def.joint2;
            _this.m_localAnchorD.Copy(revolute.m_localAnchorA);
            _this.m_localAnchorB.Copy(revolute.m_localAnchorB);
            _this.m_referenceAngleB = revolute.m_referenceAngle;
            _this.m_localAxisD.SetZero();
            coordinateB = aB - aD - _this.m_referenceAngleB;
          } else {
            var prismatic = def.joint2;
            _this.m_localAnchorD.Copy(prismatic.m_localAnchorA);
            _this.m_localAnchorB.Copy(prismatic.m_localAnchorB);
            _this.m_referenceAngleB = prismatic.m_referenceAngle;
            _this.m_localAxisD.Copy(prismatic.m_localXAxisA);
            var pD = _this.m_localAnchorD;
            var pB = b2Rot.MulTRV(xfD.q, b2Vec2.AddVV(b2Rot.MulRV(xfB.q, _this.m_localAnchorB, b2Vec2.s_t0), b2Vec2.SubVV(xfB.p, xfD.p, b2Vec2.s_t1), b2Vec2.s_t0), b2Vec2.s_t0);
            coordinateB = b2Vec2.DotVV(b2Vec2.SubVV(pB, pD, b2Vec2.s_t0), _this.m_localAxisD);
          }
          _this.m_ratio = b2Maybe(def.ratio, 1);
          _this.m_constant = coordinateA + _this.m_ratio * coordinateB;
          _this.m_impulse = 0;
          return _this;
        }
        b2GearJoint.prototype.InitVelocityConstraints = function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_indexC = this.m_bodyC.m_islandIndex;
          this.m_indexD = this.m_bodyD.m_islandIndex;
          this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter);
          this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter);
          this.m_mA = this.m_bodyA.m_invMass;
          this.m_mB = this.m_bodyB.m_invMass;
          this.m_mC = this.m_bodyC.m_invMass;
          this.m_mD = this.m_bodyD.m_invMass;
          this.m_iA = this.m_bodyA.m_invI;
          this.m_iB = this.m_bodyB.m_invI;
          this.m_iC = this.m_bodyC.m_invI;
          this.m_iD = this.m_bodyD.m_invI;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var aC = data.positions[this.m_indexC].a;
          var vC = data.velocities[this.m_indexC].v;
          var wC = data.velocities[this.m_indexC].w;
          var aD = data.positions[this.m_indexD].a;
          var vD = data.velocities[this.m_indexD].v;
          var wD = data.velocities[this.m_indexD].w;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB), qC = this.m_qC.SetAngle(aC), qD = this.m_qD.SetAngle(aD);
          this.m_mass = 0;
          if (this.m_typeA === exports.b2JointType.e_revoluteJoint) {
            this.m_JvAC.SetZero();
            this.m_JwA = 1;
            this.m_JwC = 1;
            this.m_mass += this.m_iA + this.m_iC;
          } else {
            var u = b2Rot.MulRV(qC, this.m_localAxisC, b2GearJoint.InitVelocityConstraints_s_u);
            b2Vec2.SubVV(this.m_localAnchorC, this.m_lcC, this.m_lalcC);
            var rC = b2Rot.MulRV(qC, this.m_lalcC, b2GearJoint.InitVelocityConstraints_s_rC);
            b2Vec2.SubVV(this.m_localAnchorA, this.m_lcA, this.m_lalcA);
            var rA = b2Rot.MulRV(qA, this.m_lalcA, b2GearJoint.InitVelocityConstraints_s_rA);
            this.m_JvAC.Copy(u);
            this.m_JwC = b2Vec2.CrossVV(rC, u);
            this.m_JwA = b2Vec2.CrossVV(rA, u);
            this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
          }
          if (this.m_typeB === exports.b2JointType.e_revoluteJoint) {
            this.m_JvBD.SetZero();
            this.m_JwB = this.m_ratio;
            this.m_JwD = this.m_ratio;
            this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
          } else {
            var u = b2Rot.MulRV(qD, this.m_localAxisD, b2GearJoint.InitVelocityConstraints_s_u);
            b2Vec2.SubVV(this.m_localAnchorD, this.m_lcD, this.m_lalcD);
            var rD = b2Rot.MulRV(qD, this.m_lalcD, b2GearJoint.InitVelocityConstraints_s_rD);
            b2Vec2.SubVV(this.m_localAnchorB, this.m_lcB, this.m_lalcB);
            var rB = b2Rot.MulRV(qB, this.m_lalcB, b2GearJoint.InitVelocityConstraints_s_rB);
            b2Vec2.MulSV(this.m_ratio, u, this.m_JvBD);
            this.m_JwD = this.m_ratio * b2Vec2.CrossVV(rD, u);
            this.m_JwB = this.m_ratio * b2Vec2.CrossVV(rB, u);
            this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
          }
          this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0;
          if (data.step.warmStarting) {
            vA.SelfMulAdd(this.m_mA * this.m_impulse, this.m_JvAC);
            wA += this.m_iA * this.m_impulse * this.m_JwA;
            vB.SelfMulAdd(this.m_mB * this.m_impulse, this.m_JvBD);
            wB += this.m_iB * this.m_impulse * this.m_JwB;
            vC.SelfMulSub(this.m_mC * this.m_impulse, this.m_JvAC);
            wC -= this.m_iC * this.m_impulse * this.m_JwC;
            vD.SelfMulSub(this.m_mD * this.m_impulse, this.m_JvBD);
            wD -= this.m_iD * this.m_impulse * this.m_JwD;
          } else this.m_impulse = 0;
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
          data.velocities[this.m_indexC].w = wC;
          data.velocities[this.m_indexD].w = wD;
        };
        b2GearJoint.prototype.SolveVelocityConstraints = function(data) {
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var vC = data.velocities[this.m_indexC].v;
          var wC = data.velocities[this.m_indexC].w;
          var vD = data.velocities[this.m_indexD].v;
          var wD = data.velocities[this.m_indexD].w;
          var Cdot = b2Vec2.DotVV(this.m_JvAC, b2Vec2.SubVV(vA, vC, b2Vec2.s_t0)) + b2Vec2.DotVV(this.m_JvBD, b2Vec2.SubVV(vB, vD, b2Vec2.s_t0));
          Cdot += this.m_JwA * wA - this.m_JwC * wC + (this.m_JwB * wB - this.m_JwD * wD);
          var impulse = -this.m_mass * Cdot;
          this.m_impulse += impulse;
          vA.SelfMulAdd(this.m_mA * impulse, this.m_JvAC);
          wA += this.m_iA * impulse * this.m_JwA;
          vB.SelfMulAdd(this.m_mB * impulse, this.m_JvBD);
          wB += this.m_iB * impulse * this.m_JwB;
          vC.SelfMulSub(this.m_mC * impulse, this.m_JvAC);
          wC -= this.m_iC * impulse * this.m_JwC;
          vD.SelfMulSub(this.m_mD * impulse, this.m_JvBD);
          wD -= this.m_iD * impulse * this.m_JwD;
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
          data.velocities[this.m_indexC].w = wC;
          data.velocities[this.m_indexD].w = wD;
        };
        b2GearJoint.prototype.SolvePositionConstraints = function(data) {
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var cC = data.positions[this.m_indexC].c;
          var aC = data.positions[this.m_indexC].a;
          var cD = data.positions[this.m_indexD].c;
          var aD = data.positions[this.m_indexD].a;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB), qC = this.m_qC.SetAngle(aC), qD = this.m_qD.SetAngle(aD);
          var linearError = 0;
          var coordinateA, coordinateB;
          var JvAC = this.m_JvAC, JvBD = this.m_JvBD;
          var JwA, JwB, JwC, JwD;
          var mass = 0;
          if (this.m_typeA === exports.b2JointType.e_revoluteJoint) {
            JvAC.SetZero();
            JwA = 1;
            JwC = 1;
            mass += this.m_iA + this.m_iC;
            coordinateA = aA - aC - this.m_referenceAngleA;
          } else {
            var u = b2Rot.MulRV(qC, this.m_localAxisC, b2GearJoint.SolvePositionConstraints_s_u);
            var rC = b2Rot.MulRV(qC, this.m_lalcC, b2GearJoint.SolvePositionConstraints_s_rC);
            var rA = b2Rot.MulRV(qA, this.m_lalcA, b2GearJoint.SolvePositionConstraints_s_rA);
            JvAC.Copy(u);
            JwC = b2Vec2.CrossVV(rC, u);
            JwA = b2Vec2.CrossVV(rA, u);
            mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;
            var pC = this.m_lalcC;
            var pA = b2Rot.MulTRV(qC, b2Vec2.AddVV(rA, b2Vec2.SubVV(cA, cC, b2Vec2.s_t0), b2Vec2.s_t0), b2Vec2.s_t0);
            coordinateA = b2Vec2.DotVV(b2Vec2.SubVV(pA, pC, b2Vec2.s_t0), this.m_localAxisC);
          }
          if (this.m_typeB === exports.b2JointType.e_revoluteJoint) {
            JvBD.SetZero();
            JwB = this.m_ratio;
            JwD = this.m_ratio;
            mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
            coordinateB = aB - aD - this.m_referenceAngleB;
          } else {
            var u = b2Rot.MulRV(qD, this.m_localAxisD, b2GearJoint.SolvePositionConstraints_s_u);
            var rD = b2Rot.MulRV(qD, this.m_lalcD, b2GearJoint.SolvePositionConstraints_s_rD);
            var rB = b2Rot.MulRV(qB, this.m_lalcB, b2GearJoint.SolvePositionConstraints_s_rB);
            b2Vec2.MulSV(this.m_ratio, u, JvBD);
            JwD = this.m_ratio * b2Vec2.CrossVV(rD, u);
            JwB = this.m_ratio * b2Vec2.CrossVV(rB, u);
            mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;
            var pD = this.m_lalcD;
            var pB = b2Rot.MulTRV(qD, b2Vec2.AddVV(rB, b2Vec2.SubVV(cB, cD, b2Vec2.s_t0), b2Vec2.s_t0), b2Vec2.s_t0);
            coordinateB = b2Vec2.DotVV(b2Vec2.SubVV(pB, pD, b2Vec2.s_t0), this.m_localAxisD);
          }
          var C = coordinateA + this.m_ratio * coordinateB - this.m_constant;
          var impulse = 0;
          mass > 0 && (impulse = -C / mass);
          cA.SelfMulAdd(this.m_mA * impulse, JvAC);
          aA += this.m_iA * impulse * JwA;
          cB.SelfMulAdd(this.m_mB * impulse, JvBD);
          aB += this.m_iB * impulse * JwB;
          cC.SelfMulSub(this.m_mC * impulse, JvAC);
          aC -= this.m_iC * impulse * JwC;
          cD.SelfMulSub(this.m_mD * impulse, JvBD);
          aD -= this.m_iD * impulse * JwD;
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].a = aB;
          data.positions[this.m_indexC].a = aC;
          data.positions[this.m_indexD].a = aD;
          return linearError < b2_linearSlop;
        };
        b2GearJoint.prototype.GetAnchorA = function(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
        };
        b2GearJoint.prototype.GetAnchorB = function(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
        };
        b2GearJoint.prototype.GetReactionForce = function(inv_dt, out) {
          return b2Vec2.MulSV(inv_dt * this.m_impulse, this.m_JvAC, out);
        };
        b2GearJoint.prototype.GetReactionTorque = function(inv_dt) {
          return inv_dt * this.m_impulse * this.m_JwA;
        };
        b2GearJoint.prototype.GetJoint1 = function() {
          return this.m_joint1;
        };
        b2GearJoint.prototype.GetJoint2 = function() {
          return this.m_joint2;
        };
        b2GearJoint.prototype.GetRatio = function() {
          return this.m_ratio;
        };
        b2GearJoint.prototype.SetRatio = function(ratio) {
          this.m_ratio = ratio;
        };
        b2GearJoint.prototype.Dump = function(log) {
          var indexA = this.m_bodyA.m_islandIndex;
          var indexB = this.m_bodyB.m_islandIndex;
          var index1 = this.m_joint1.m_index;
          var index2 = this.m_joint2.m_index;
          log("  const jd: b2GearJointDef = new b2GearJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
          log("  jd.joint1 = joints[%d];\n", index1);
          log("  jd.joint2 = joints[%d];\n", index2);
          log("  jd.ratio = %.15f;\n", this.m_ratio);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
        };
        b2GearJoint.InitVelocityConstraints_s_u = new b2Vec2();
        b2GearJoint.InitVelocityConstraints_s_rA = new b2Vec2();
        b2GearJoint.InitVelocityConstraints_s_rB = new b2Vec2();
        b2GearJoint.InitVelocityConstraints_s_rC = new b2Vec2();
        b2GearJoint.InitVelocityConstraints_s_rD = new b2Vec2();
        b2GearJoint.SolvePositionConstraints_s_u = new b2Vec2();
        b2GearJoint.SolvePositionConstraints_s_rA = new b2Vec2();
        b2GearJoint.SolvePositionConstraints_s_rB = new b2Vec2();
        b2GearJoint.SolvePositionConstraints_s_rC = new b2Vec2();
        b2GearJoint.SolvePositionConstraints_s_rD = new b2Vec2();
        return b2GearJoint;
      })(b2Joint);
      var b2MotorJointDef = (function(_super) {
        __extends(b2MotorJointDef, _super);
        function b2MotorJointDef() {
          var _this = _super.call(this, exports.b2JointType.e_motorJoint) || this;
          _this.linearOffset = new b2Vec2(0, 0);
          _this.angularOffset = 0;
          _this.maxForce = 1;
          _this.maxTorque = 1;
          _this.correctionFactor = .3;
          return _this;
        }
        b2MotorJointDef.prototype.Initialize = function(bA, bB) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.bodyA.GetLocalPoint(this.bodyB.GetPosition(), this.linearOffset);
          var angleA = this.bodyA.GetAngle();
          var angleB = this.bodyB.GetAngle();
          this.angularOffset = angleB - angleA;
        };
        return b2MotorJointDef;
      })(b2JointDef);
      var b2MotorJoint = (function(_super) {
        __extends(b2MotorJoint, _super);
        function b2MotorJoint(def) {
          var _this = _super.call(this, def) || this;
          _this.m_linearOffset = new b2Vec2();
          _this.m_angularOffset = 0;
          _this.m_linearImpulse = new b2Vec2();
          _this.m_angularImpulse = 0;
          _this.m_maxForce = 0;
          _this.m_maxTorque = 0;
          _this.m_correctionFactor = .3;
          _this.m_indexA = 0;
          _this.m_indexB = 0;
          _this.m_rA = new b2Vec2();
          _this.m_rB = new b2Vec2();
          _this.m_localCenterA = new b2Vec2();
          _this.m_localCenterB = new b2Vec2();
          _this.m_linearError = new b2Vec2();
          _this.m_angularError = 0;
          _this.m_invMassA = 0;
          _this.m_invMassB = 0;
          _this.m_invIA = 0;
          _this.m_invIB = 0;
          _this.m_linearMass = new b2Mat22();
          _this.m_angularMass = 0;
          _this.m_qA = new b2Rot();
          _this.m_qB = new b2Rot();
          _this.m_K = new b2Mat22();
          _this.m_linearOffset.Copy(b2Maybe(def.linearOffset, b2Vec2.ZERO));
          _this.m_linearImpulse.SetZero();
          _this.m_maxForce = b2Maybe(def.maxForce, 0);
          _this.m_maxTorque = b2Maybe(def.maxTorque, 0);
          _this.m_correctionFactor = b2Maybe(def.correctionFactor, .3);
          return _this;
        }
        b2MotorJoint.prototype.GetAnchorA = function(out) {
          var pos = this.m_bodyA.GetPosition();
          out.x = pos.x;
          out.y = pos.y;
          return out;
        };
        b2MotorJoint.prototype.GetAnchorB = function(out) {
          var pos = this.m_bodyB.GetPosition();
          out.x = pos.x;
          out.y = pos.y;
          return out;
        };
        b2MotorJoint.prototype.GetReactionForce = function(inv_dt, out) {
          return b2Vec2.MulSV(inv_dt, this.m_linearImpulse, out);
        };
        b2MotorJoint.prototype.GetReactionTorque = function(inv_dt) {
          return inv_dt * this.m_angularImpulse;
        };
        b2MotorJoint.prototype.SetLinearOffset = function(linearOffset) {
          if (!b2Vec2.IsEqualToV(linearOffset, this.m_linearOffset)) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_linearOffset.Copy(linearOffset);
          }
        };
        b2MotorJoint.prototype.GetLinearOffset = function() {
          return this.m_linearOffset;
        };
        b2MotorJoint.prototype.SetAngularOffset = function(angularOffset) {
          if (angularOffset !== this.m_angularOffset) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_angularOffset = angularOffset;
          }
        };
        b2MotorJoint.prototype.GetAngularOffset = function() {
          return this.m_angularOffset;
        };
        b2MotorJoint.prototype.SetMaxForce = function(force) {
          this.m_maxForce = force;
        };
        b2MotorJoint.prototype.GetMaxForce = function() {
          return this.m_maxForce;
        };
        b2MotorJoint.prototype.SetMaxTorque = function(torque) {
          this.m_maxTorque = torque;
        };
        b2MotorJoint.prototype.GetMaxTorque = function() {
          return this.m_maxTorque;
        };
        b2MotorJoint.prototype.InitVelocityConstraints = function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          var rA = b2Rot.MulRV(qA, b2Vec2.SubVV(this.m_linearOffset, this.m_localCenterA, b2Vec2.s_t0), this.m_rA);
          var rB = b2Rot.MulRV(qB, b2Vec2.NegV(this.m_localCenterB, b2Vec2.s_t0), this.m_rB);
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var K = this.m_K;
          K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
          K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
          K.ey.x = K.ex.y;
          K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
          K.GetInverse(this.m_linearMass);
          this.m_angularMass = iA + iB;
          this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass);
          b2Vec2.SubVV(b2Vec2.AddVV(cB, rB, b2Vec2.s_t0), b2Vec2.AddVV(cA, rA, b2Vec2.s_t1), this.m_linearError);
          this.m_angularError = aB - aA - this.m_angularOffset;
          if (data.step.warmStarting) {
            this.m_linearImpulse.SelfMul(data.step.dtRatio);
            this.m_angularImpulse *= data.step.dtRatio;
            var P = this.m_linearImpulse;
            vA.SelfMulSub(mA, P);
            wA -= iA * (b2Vec2.CrossVV(rA, P) + this.m_angularImpulse);
            vB.SelfMulAdd(mB, P);
            wB += iB * (b2Vec2.CrossVV(rB, P) + this.m_angularImpulse);
          } else {
            this.m_linearImpulse.SetZero();
            this.m_angularImpulse = 0;
          }
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2MotorJoint.prototype.SolveVelocityConstraints = function(data) {
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var h = data.step.dt;
          var inv_h = data.step.inv_dt;
          var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;
          var impulse = -this.m_angularMass * Cdot;
          var oldImpulse = this.m_angularImpulse;
          var maxImpulse = h * this.m_maxTorque;
          this.m_angularImpulse = b2Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
          impulse = this.m_angularImpulse - oldImpulse;
          wA -= iA * impulse;
          wB += iB * impulse;
          var rA = this.m_rA;
          var rB = this.m_rB;
          var Cdot_v2 = b2Vec2.AddVV(b2Vec2.SubVV(b2Vec2.AddVV(vB, b2Vec2.CrossSV(wB, rB, b2Vec2.s_t0), b2Vec2.s_t0), b2Vec2.AddVV(vA, b2Vec2.CrossSV(wA, rA, b2Vec2.s_t1), b2Vec2.s_t1), b2Vec2.s_t2), b2Vec2.MulSV(inv_h * this.m_correctionFactor, this.m_linearError, b2Vec2.s_t3), b2MotorJoint.SolveVelocityConstraints_s_Cdot_v2);
          var impulse_v2 = b2Mat22.MulMV(this.m_linearMass, Cdot_v2, b2MotorJoint.SolveVelocityConstraints_s_impulse_v2).SelfNeg();
          var oldImpulse_v2 = b2MotorJoint.SolveVelocityConstraints_s_oldImpulse_v2.Copy(this.m_linearImpulse);
          this.m_linearImpulse.SelfAdd(impulse_v2);
          var maxImpulse = h * this.m_maxForce;
          if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
            this.m_linearImpulse.Normalize();
            this.m_linearImpulse.SelfMul(maxImpulse);
          }
          b2Vec2.SubVV(this.m_linearImpulse, oldImpulse_v2, impulse_v2);
          vA.SelfMulSub(mA, impulse_v2);
          wA -= iA * b2Vec2.CrossVV(rA, impulse_v2);
          vB.SelfMulAdd(mB, impulse_v2);
          wB += iB * b2Vec2.CrossVV(rB, impulse_v2);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2MotorJoint.prototype.SolvePositionConstraints = function(data) {
          return true;
        };
        b2MotorJoint.prototype.Dump = function(log) {
          var indexA = this.m_bodyA.m_islandIndex;
          var indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2MotorJointDef = new b2MotorJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
          log("  jd.linearOffset.Set(%.15f, %.15f);\n", this.m_linearOffset.x, this.m_linearOffset.y);
          log("  jd.angularOffset = %.15f;\n", this.m_angularOffset);
          log("  jd.maxForce = %.15f;\n", this.m_maxForce);
          log("  jd.maxTorque = %.15f;\n", this.m_maxTorque);
          log("  jd.correctionFactor = %.15f;\n", this.m_correctionFactor);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
        };
        b2MotorJoint.SolveVelocityConstraints_s_Cdot_v2 = new b2Vec2();
        b2MotorJoint.SolveVelocityConstraints_s_impulse_v2 = new b2Vec2();
        b2MotorJoint.SolveVelocityConstraints_s_oldImpulse_v2 = new b2Vec2();
        return b2MotorJoint;
      })(b2Joint);
      var b2MouseJointDef = (function(_super) {
        __extends(b2MouseJointDef, _super);
        function b2MouseJointDef() {
          var _this = _super.call(this, exports.b2JointType.e_mouseJoint) || this;
          _this.target = new b2Vec2();
          _this.maxForce = 0;
          _this.frequencyHz = 5;
          _this.dampingRatio = .7;
          return _this;
        }
        return b2MouseJointDef;
      })(b2JointDef);
      var b2MouseJoint = (function(_super) {
        __extends(b2MouseJoint, _super);
        function b2MouseJoint(def) {
          var _this = _super.call(this, def) || this;
          _this.m_localAnchorB = new b2Vec2();
          _this.m_targetA = new b2Vec2();
          _this.m_frequencyHz = 0;
          _this.m_dampingRatio = 0;
          _this.m_beta = 0;
          _this.m_impulse = new b2Vec2();
          _this.m_maxForce = 0;
          _this.m_gamma = 0;
          _this.m_indexA = 0;
          _this.m_indexB = 0;
          _this.m_rB = new b2Vec2();
          _this.m_localCenterB = new b2Vec2();
          _this.m_invMassB = 0;
          _this.m_invIB = 0;
          _this.m_mass = new b2Mat22();
          _this.m_C = new b2Vec2();
          _this.m_qB = new b2Rot();
          _this.m_lalcB = new b2Vec2();
          _this.m_K = new b2Mat22();
          _this.m_targetA.Copy(b2Maybe(def.target, b2Vec2.ZERO));
          b2Transform.MulTXV(_this.m_bodyB.GetTransform(), _this.m_targetA, _this.m_localAnchorB);
          _this.m_maxForce = b2Maybe(def.maxForce, 0);
          _this.m_impulse.SetZero();
          _this.m_frequencyHz = b2Maybe(def.frequencyHz, 0);
          _this.m_dampingRatio = b2Maybe(def.dampingRatio, 0);
          _this.m_beta = 0;
          _this.m_gamma = 0;
          return _this;
        }
        b2MouseJoint.prototype.SetTarget = function(target) {
          this.m_bodyB.IsAwake() || this.m_bodyB.SetAwake(true);
          this.m_targetA.Copy(target);
        };
        b2MouseJoint.prototype.GetTarget = function() {
          return this.m_targetA;
        };
        b2MouseJoint.prototype.SetMaxForce = function(maxForce) {
          this.m_maxForce = maxForce;
        };
        b2MouseJoint.prototype.GetMaxForce = function() {
          return this.m_maxForce;
        };
        b2MouseJoint.prototype.SetFrequency = function(hz) {
          this.m_frequencyHz = hz;
        };
        b2MouseJoint.prototype.GetFrequency = function() {
          return this.m_frequencyHz;
        };
        b2MouseJoint.prototype.SetDampingRatio = function(ratio) {
          this.m_dampingRatio = ratio;
        };
        b2MouseJoint.prototype.GetDampingRatio = function() {
          return this.m_dampingRatio;
        };
        b2MouseJoint.prototype.InitVelocityConstraints = function(data) {
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIB = this.m_bodyB.m_invI;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var qB = this.m_qB.SetAngle(aB);
          var mass = this.m_bodyB.GetMass();
          var omega = 2 * b2_pi * this.m_frequencyHz;
          var d = 2 * mass * this.m_dampingRatio * omega;
          var k = mass * (omega * omega);
          var h = data.step.dt;
          this.m_gamma = h * (d + h * k);
          0 !== this.m_gamma && (this.m_gamma = 1 / this.m_gamma);
          this.m_beta = h * k * this.m_gamma;
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var K = this.m_K;
          K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;
          K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
          K.ey.x = K.ex.y;
          K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;
          K.GetInverse(this.m_mass);
          this.m_C.x = cB.x + this.m_rB.x - this.m_targetA.x;
          this.m_C.y = cB.y + this.m_rB.y - this.m_targetA.y;
          this.m_C.SelfMul(this.m_beta);
          wB *= .98;
          if (data.step.warmStarting) {
            this.m_impulse.SelfMul(data.step.dtRatio);
            vB.x += this.m_invMassB * this.m_impulse.x;
            vB.y += this.m_invMassB * this.m_impulse.y;
            wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, this.m_impulse);
          } else this.m_impulse.SetZero();
          data.velocities[this.m_indexB].w = wB;
        };
        b2MouseJoint.prototype.SolveVelocityConstraints = function(data) {
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var Cdot = b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2MouseJoint.SolveVelocityConstraints_s_Cdot);
          var impulse = b2Mat22.MulMV(this.m_mass, b2Vec2.AddVV(Cdot, b2Vec2.AddVV(this.m_C, b2Vec2.MulSV(this.m_gamma, this.m_impulse, b2Vec2.s_t0), b2Vec2.s_t0), b2Vec2.s_t0).SelfNeg(), b2MouseJoint.SolveVelocityConstraints_s_impulse);
          var oldImpulse = b2MouseJoint.SolveVelocityConstraints_s_oldImpulse.Copy(this.m_impulse);
          this.m_impulse.SelfAdd(impulse);
          var maxImpulse = data.step.dt * this.m_maxForce;
          this.m_impulse.LengthSquared() > maxImpulse * maxImpulse && this.m_impulse.SelfMul(maxImpulse / this.m_impulse.Length());
          b2Vec2.SubVV(this.m_impulse, oldImpulse, impulse);
          vB.SelfMulAdd(this.m_invMassB, impulse);
          wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, impulse);
          data.velocities[this.m_indexB].w = wB;
        };
        b2MouseJoint.prototype.SolvePositionConstraints = function(data) {
          return true;
        };
        b2MouseJoint.prototype.GetAnchorA = function(out) {
          out.x = this.m_targetA.x;
          out.y = this.m_targetA.y;
          return out;
        };
        b2MouseJoint.prototype.GetAnchorB = function(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
        };
        b2MouseJoint.prototype.GetReactionForce = function(inv_dt, out) {
          return b2Vec2.MulSV(inv_dt, this.m_impulse, out);
        };
        b2MouseJoint.prototype.GetReactionTorque = function(inv_dt) {
          return 0;
        };
        b2MouseJoint.prototype.Dump = function(log) {
          log("Mouse joint dumping is not supported.\n");
        };
        b2MouseJoint.prototype.ShiftOrigin = function(newOrigin) {
          this.m_targetA.SelfSub(newOrigin);
        };
        b2MouseJoint.SolveVelocityConstraints_s_Cdot = new b2Vec2();
        b2MouseJoint.SolveVelocityConstraints_s_impulse = new b2Vec2();
        b2MouseJoint.SolveVelocityConstraints_s_oldImpulse = new b2Vec2();
        return b2MouseJoint;
      })(b2Joint);
      var b2PrismaticJointDef = (function(_super) {
        __extends(b2PrismaticJointDef, _super);
        function b2PrismaticJointDef() {
          var _this = _super.call(this, exports.b2JointType.e_prismaticJoint) || this;
          _this.localAnchorA = new b2Vec2();
          _this.localAnchorB = new b2Vec2();
          _this.localAxisA = new b2Vec2(1, 0);
          _this.referenceAngle = 0;
          _this.enableLimit = false;
          _this.lowerTranslation = 0;
          _this.upperTranslation = 0;
          _this.enableMotor = false;
          _this.maxMotorForce = 0;
          _this.motorSpeed = 0;
          return _this;
        }
        b2PrismaticJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
          this.bodyA.GetLocalVector(axis, this.localAxisA);
          this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
        };
        return b2PrismaticJointDef;
      })(b2JointDef);
      var b2PrismaticJoint = (function(_super) {
        __extends(b2PrismaticJoint, _super);
        function b2PrismaticJoint(def) {
          var _this = _super.call(this, def) || this;
          _this.m_localAnchorA = new b2Vec2();
          _this.m_localAnchorB = new b2Vec2();
          _this.m_localXAxisA = new b2Vec2();
          _this.m_localYAxisA = new b2Vec2();
          _this.m_referenceAngle = 0;
          _this.m_impulse = new b2Vec3(0, 0, 0);
          _this.m_motorImpulse = 0;
          _this.m_lowerTranslation = 0;
          _this.m_upperTranslation = 0;
          _this.m_maxMotorForce = 0;
          _this.m_motorSpeed = 0;
          _this.m_enableLimit = false;
          _this.m_enableMotor = false;
          _this.m_limitState = exports.b2LimitState.e_inactiveLimit;
          _this.m_indexA = 0;
          _this.m_indexB = 0;
          _this.m_localCenterA = new b2Vec2();
          _this.m_localCenterB = new b2Vec2();
          _this.m_invMassA = 0;
          _this.m_invMassB = 0;
          _this.m_invIA = 0;
          _this.m_invIB = 0;
          _this.m_axis = new b2Vec2(0, 0);
          _this.m_perp = new b2Vec2(0, 0);
          _this.m_s1 = 0;
          _this.m_s2 = 0;
          _this.m_a1 = 0;
          _this.m_a2 = 0;
          _this.m_K = new b2Mat33();
          _this.m_K3 = new b2Mat33();
          _this.m_K2 = new b2Mat22();
          _this.m_motorMass = 0;
          _this.m_qA = new b2Rot();
          _this.m_qB = new b2Rot();
          _this.m_lalcA = new b2Vec2();
          _this.m_lalcB = new b2Vec2();
          _this.m_rA = new b2Vec2();
          _this.m_rB = new b2Vec2();
          _this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, b2Vec2.ZERO));
          _this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, b2Vec2.ZERO));
          _this.m_localXAxisA.Copy(b2Maybe(def.localAxisA, new b2Vec2(1, 0))).SelfNormalize();
          b2Vec2.CrossOneV(_this.m_localXAxisA, _this.m_localYAxisA);
          _this.m_referenceAngle = b2Maybe(def.referenceAngle, 0);
          _this.m_lowerTranslation = b2Maybe(def.lowerTranslation, 0);
          _this.m_upperTranslation = b2Maybe(def.upperTranslation, 0);
          _this.m_maxMotorForce = b2Maybe(def.maxMotorForce, 0);
          _this.m_motorSpeed = b2Maybe(def.motorSpeed, 0);
          _this.m_enableLimit = b2Maybe(def.enableLimit, false);
          _this.m_enableMotor = b2Maybe(def.enableMotor, false);
          return _this;
        }
        b2PrismaticJoint.prototype.InitVelocityConstraints = function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          var rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          var rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var d = b2Vec2.AddVV(b2Vec2.SubVV(cB, cA, b2Vec2.s_t0), b2Vec2.SubVV(rB, rA, b2Vec2.s_t1), b2PrismaticJoint.InitVelocityConstraints_s_d);
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          b2Rot.MulRV(qA, this.m_localXAxisA, this.m_axis);
          this.m_a1 = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), this.m_axis);
          this.m_a2 = b2Vec2.CrossVV(rB, this.m_axis);
          this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
          this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass);
          b2Rot.MulRV(qA, this.m_localYAxisA, this.m_perp);
          this.m_s1 = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), this.m_perp);
          this.m_s2 = b2Vec2.CrossVV(rB, this.m_perp);
          this.m_K.ex.x = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;
          this.m_K.ex.y = iA * this.m_s1 + iB * this.m_s2;
          this.m_K.ex.z = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;
          this.m_K.ey.x = this.m_K.ex.y;
          this.m_K.ey.y = iA + iB;
          0 === this.m_K.ey.y && (this.m_K.ey.y = 1);
          this.m_K.ey.z = iA * this.m_a1 + iB * this.m_a2;
          this.m_K.ez.x = this.m_K.ex.z;
          this.m_K.ez.y = this.m_K.ey.z;
          this.m_K.ez.z = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;
          if (this.m_enableLimit) {
            var jointTranslation = b2Vec2.DotVV(this.m_axis, d);
            if (b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2_linearSlop) this.m_limitState = exports.b2LimitState.e_equalLimits; else if (jointTranslation <= this.m_lowerTranslation) {
              if (this.m_limitState !== exports.b2LimitState.e_atLowerLimit) {
                this.m_limitState = exports.b2LimitState.e_atLowerLimit;
                this.m_impulse.z = 0;
              }
            } else if (jointTranslation >= this.m_upperTranslation) {
              if (this.m_limitState !== exports.b2LimitState.e_atUpperLimit) {
                this.m_limitState = exports.b2LimitState.e_atUpperLimit;
                this.m_impulse.z = 0;
              }
            } else {
              this.m_limitState = exports.b2LimitState.e_inactiveLimit;
              this.m_impulse.z = 0;
            }
          } else {
            this.m_limitState = exports.b2LimitState.e_inactiveLimit;
            this.m_impulse.z = 0;
          }
          this.m_enableMotor || (this.m_motorImpulse = 0);
          if (data.step.warmStarting) {
            this.m_impulse.SelfMul(data.step.dtRatio);
            this.m_motorImpulse *= data.step.dtRatio;
            var P = b2Vec2.AddVV(b2Vec2.MulSV(this.m_impulse.x, this.m_perp, b2Vec2.s_t0), b2Vec2.MulSV(this.m_motorImpulse + this.m_impulse.z, this.m_axis, b2Vec2.s_t1), b2PrismaticJoint.InitVelocityConstraints_s_P);
            var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
            var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
            vA.SelfMulSub(mA, P);
            wA -= iA * LA;
            vB.SelfMulAdd(mB, P);
            wB += iB * LB;
          } else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0;
          }
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2PrismaticJoint.prototype.SolveVelocityConstraints = function(data) {
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          if (this.m_enableMotor && this.m_limitState !== exports.b2LimitState.e_equalLimits) {
            var Cdot = b2Vec2.DotVV(this.m_axis, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_a2 * wB - this.m_a1 * wA;
            var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = data.step.dt * this.m_maxMotorForce;
            this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            var P = b2Vec2.MulSV(impulse, this.m_axis, b2PrismaticJoint.SolveVelocityConstraints_s_P);
            var LA = impulse * this.m_a1;
            var LB = impulse * this.m_a2;
            vA.SelfMulSub(mA, P);
            wA -= iA * LA;
            vB.SelfMulAdd(mB, P);
            wB += iB * LB;
          }
          var Cdot1_x = b2Vec2.DotVV(this.m_perp, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_s2 * wB - this.m_s1 * wA;
          var Cdot1_y = wB - wA;
          if (this.m_enableLimit && this.m_limitState !== exports.b2LimitState.e_inactiveLimit) {
            var Cdot2 = b2Vec2.DotVV(this.m_axis, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_a2 * wB - this.m_a1 * wA;
            var f1 = b2PrismaticJoint.SolveVelocityConstraints_s_f1.Copy(this.m_impulse);
            var df3 = this.m_K.Solve33(-Cdot1_x, -Cdot1_y, -Cdot2, b2PrismaticJoint.SolveVelocityConstraints_s_df3);
            this.m_impulse.SelfAdd(df3);
            this.m_limitState === exports.b2LimitState.e_atLowerLimit ? this.m_impulse.z = b2Max(this.m_impulse.z, 0) : this.m_limitState === exports.b2LimitState.e_atUpperLimit && (this.m_impulse.z = b2Min(this.m_impulse.z, 0));
            var b_x = -Cdot1_x - (this.m_impulse.z - f1.z) * this.m_K.ez.x;
            var b_y = -Cdot1_y - (this.m_impulse.z - f1.z) * this.m_K.ez.y;
            var f2r = this.m_K.Solve22(b_x, b_y, b2PrismaticJoint.SolveVelocityConstraints_s_f2r);
            f2r.x += f1.x;
            f2r.y += f1.y;
            this.m_impulse.x = f2r.x;
            this.m_impulse.y = f2r.y;
            df3.x = this.m_impulse.x - f1.x;
            df3.y = this.m_impulse.y - f1.y;
            df3.z = this.m_impulse.z - f1.z;
            var P = b2Vec2.AddVV(b2Vec2.MulSV(df3.x, this.m_perp, b2Vec2.s_t0), b2Vec2.MulSV(df3.z, this.m_axis, b2Vec2.s_t1), b2PrismaticJoint.SolveVelocityConstraints_s_P);
            var LA = df3.x * this.m_s1 + df3.y + df3.z * this.m_a1;
            var LB = df3.x * this.m_s2 + df3.y + df3.z * this.m_a2;
            vA.SelfMulSub(mA, P);
            wA -= iA * LA;
            vB.SelfMulAdd(mB, P);
            wB += iB * LB;
          } else {
            var df2 = this.m_K.Solve22(-Cdot1_x, -Cdot1_y, b2PrismaticJoint.SolveVelocityConstraints_s_df2);
            this.m_impulse.x += df2.x;
            this.m_impulse.y += df2.y;
            var P = b2Vec2.MulSV(df2.x, this.m_perp, b2PrismaticJoint.SolveVelocityConstraints_s_P);
            var LA = df2.x * this.m_s1 + df2.y;
            var LB = df2.x * this.m_s2 + df2.y;
            vA.SelfMulSub(mA, P);
            wA -= iA * LA;
            vB.SelfMulAdd(mB, P);
            wB += iB * LB;
          }
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2PrismaticJoint.prototype.SolvePositionConstraints = function(data) {
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          var rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var d = b2Vec2.SubVV(b2Vec2.AddVV(cB, rB, b2Vec2.s_t0), b2Vec2.AddVV(cA, rA, b2Vec2.s_t1), b2PrismaticJoint.SolvePositionConstraints_s_d);
          var axis = b2Rot.MulRV(qA, this.m_localXAxisA, this.m_axis);
          var a1 = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), axis);
          var a2 = b2Vec2.CrossVV(rB, axis);
          var perp = b2Rot.MulRV(qA, this.m_localYAxisA, this.m_perp);
          var s1 = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), perp);
          var s2 = b2Vec2.CrossVV(rB, perp);
          var impulse = b2PrismaticJoint.SolvePositionConstraints_s_impulse;
          var C1_x = b2Vec2.DotVV(perp, d);
          var C1_y = aB - aA - this.m_referenceAngle;
          var linearError = b2Abs(C1_x);
          var angularError = b2Abs(C1_y);
          var active = false;
          var C2 = 0;
          if (this.m_enableLimit) {
            var translation = b2Vec2.DotVV(axis, d);
            if (b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2_linearSlop) {
              C2 = b2Clamp(translation, -b2_maxLinearCorrection, b2_maxLinearCorrection);
              linearError = b2Max(linearError, b2Abs(translation));
              active = true;
            } else if (translation <= this.m_lowerTranslation) {
              C2 = b2Clamp(translation - this.m_lowerTranslation + b2_linearSlop, -b2_maxLinearCorrection, 0);
              linearError = b2Max(linearError, this.m_lowerTranslation - translation);
              active = true;
            } else if (translation >= this.m_upperTranslation) {
              C2 = b2Clamp(translation - this.m_upperTranslation - b2_linearSlop, 0, b2_maxLinearCorrection);
              linearError = b2Max(linearError, translation - this.m_upperTranslation);
              active = true;
            }
          }
          if (active) {
            var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
            var k12 = iA * s1 + iB * s2;
            var k13 = iA * s1 * a1 + iB * s2 * a2;
            var k22 = iA + iB;
            0 === k22 && (k22 = 1);
            var k23 = iA * a1 + iB * a2;
            var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;
            var K = this.m_K3;
            K.ex.SetXYZ(k11, k12, k13);
            K.ey.SetXYZ(k12, k22, k23);
            K.ez.SetXYZ(k13, k23, k33);
            impulse = K.Solve33(-C1_x, -C1_y, -C2, impulse);
          } else {
            var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;
            var k12 = iA * s1 + iB * s2;
            var k22 = iA + iB;
            0 === k22 && (k22 = 1);
            var K2 = this.m_K2;
            K2.ex.Set(k11, k12);
            K2.ey.Set(k12, k22);
            var impulse1 = K2.Solve(-C1_x, -C1_y, b2PrismaticJoint.SolvePositionConstraints_s_impulse1);
            impulse.x = impulse1.x;
            impulse.y = impulse1.y;
            impulse.z = 0;
          }
          var P = b2Vec2.AddVV(b2Vec2.MulSV(impulse.x, perp, b2Vec2.s_t0), b2Vec2.MulSV(impulse.z, axis, b2Vec2.s_t1), b2PrismaticJoint.SolvePositionConstraints_s_P);
          var LA = impulse.x * s1 + impulse.y + impulse.z * a1;
          var LB = impulse.x * s2 + impulse.y + impulse.z * a2;
          cA.SelfMulSub(mA, P);
          aA -= iA * LA;
          cB.SelfMulAdd(mB, P);
          aB += iB * LB;
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].a = aB;
          return linearError <= b2_linearSlop && angularError <= b2_angularSlop;
        };
        b2PrismaticJoint.prototype.GetAnchorA = function(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
        };
        b2PrismaticJoint.prototype.GetAnchorB = function(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
        };
        b2PrismaticJoint.prototype.GetReactionForce = function(inv_dt, out) {
          out.x = inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x);
          out.y = inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y);
          return out;
        };
        b2PrismaticJoint.prototype.GetReactionTorque = function(inv_dt) {
          return inv_dt * this.m_impulse.y;
        };
        b2PrismaticJoint.prototype.GetLocalAnchorA = function() {
          return this.m_localAnchorA;
        };
        b2PrismaticJoint.prototype.GetLocalAnchorB = function() {
          return this.m_localAnchorB;
        };
        b2PrismaticJoint.prototype.GetLocalAxisA = function() {
          return this.m_localXAxisA;
        };
        b2PrismaticJoint.prototype.GetReferenceAngle = function() {
          return this.m_referenceAngle;
        };
        b2PrismaticJoint.prototype.GetJointTranslation = function() {
          var pA = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, b2PrismaticJoint.GetJointTranslation_s_pA);
          var pB = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, b2PrismaticJoint.GetJointTranslation_s_pB);
          var d = b2Vec2.SubVV(pB, pA, b2PrismaticJoint.GetJointTranslation_s_d);
          var axis = this.m_bodyA.GetWorldVector(this.m_localXAxisA, b2PrismaticJoint.GetJointTranslation_s_axis);
          var translation = b2Vec2.DotVV(d, axis);
          return translation;
        };
        b2PrismaticJoint.prototype.GetJointSpeed = function() {
          var bA = this.m_bodyA;
          var bB = this.m_bodyB;
          b2Vec2.SubVV(this.m_localAnchorA, bA.m_sweep.localCenter, this.m_lalcA);
          var rA = b2Rot.MulRV(bA.m_xf.q, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, bB.m_sweep.localCenter, this.m_lalcB);
          var rB = b2Rot.MulRV(bB.m_xf.q, this.m_lalcB, this.m_rB);
          var pA = b2Vec2.AddVV(bA.m_sweep.c, rA, b2Vec2.s_t0);
          var pB = b2Vec2.AddVV(bB.m_sweep.c, rB, b2Vec2.s_t1);
          var d = b2Vec2.SubVV(pB, pA, b2Vec2.s_t2);
          var axis = bA.GetWorldVector(this.m_localXAxisA, this.m_axis);
          var vA = bA.m_linearVelocity;
          var vB = bB.m_linearVelocity;
          var wA = bA.m_angularVelocity;
          var wB = bB.m_angularVelocity;
          var speed = b2Vec2.DotVV(d, b2Vec2.CrossSV(wA, axis, b2Vec2.s_t0)) + b2Vec2.DotVV(axis, b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, rA, b2Vec2.s_t1), b2Vec2.s_t0));
          return speed;
        };
        b2PrismaticJoint.prototype.IsLimitEnabled = function() {
          return this.m_enableLimit;
        };
        b2PrismaticJoint.prototype.EnableLimit = function(flag) {
          if (flag !== this.m_enableLimit) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_enableLimit = flag;
            this.m_impulse.z = 0;
          }
        };
        b2PrismaticJoint.prototype.GetLowerLimit = function() {
          return this.m_lowerTranslation;
        };
        b2PrismaticJoint.prototype.GetUpperLimit = function() {
          return this.m_upperTranslation;
        };
        b2PrismaticJoint.prototype.SetLimits = function(lower, upper) {
          if (lower !== this.m_lowerTranslation || upper !== this.m_upperTranslation) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_lowerTranslation = lower;
            this.m_upperTranslation = upper;
            this.m_impulse.z = 0;
          }
        };
        b2PrismaticJoint.prototype.IsMotorEnabled = function() {
          return this.m_enableMotor;
        };
        b2PrismaticJoint.prototype.EnableMotor = function(flag) {
          if (flag !== this.m_enableMotor) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_enableMotor = flag;
          }
        };
        b2PrismaticJoint.prototype.SetMotorSpeed = function(speed) {
          if (speed !== this.m_motorSpeed) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_motorSpeed = speed;
          }
        };
        b2PrismaticJoint.prototype.GetMotorSpeed = function() {
          return this.m_motorSpeed;
        };
        b2PrismaticJoint.prototype.SetMaxMotorForce = function(force) {
          if (force !== this.m_maxMotorForce) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_maxMotorForce = force;
          }
        };
        b2PrismaticJoint.prototype.GetMaxMotorForce = function() {
          return this.m_maxMotorForce;
        };
        b2PrismaticJoint.prototype.GetMotorForce = function(inv_dt) {
          return inv_dt * this.m_motorImpulse;
        };
        b2PrismaticJoint.prototype.Dump = function(log) {
          var indexA = this.m_bodyA.m_islandIndex;
          var indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2PrismaticJointDef = new b2PrismaticJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.localAxisA.Set(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y);
          log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
          log("  jd.enableLimit = %s;\n", this.m_enableLimit ? "true" : "false");
          log("  jd.lowerTranslation = %.15f;\n", this.m_lowerTranslation);
          log("  jd.upperTranslation = %.15f;\n", this.m_upperTranslation);
          log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false");
          log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
          log("  jd.maxMotorForce = %.15f;\n", this.m_maxMotorForce);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
        };
        b2PrismaticJoint.InitVelocityConstraints_s_d = new b2Vec2();
        b2PrismaticJoint.InitVelocityConstraints_s_P = new b2Vec2();
        b2PrismaticJoint.SolveVelocityConstraints_s_P = new b2Vec2();
        b2PrismaticJoint.SolveVelocityConstraints_s_f2r = new b2Vec2();
        b2PrismaticJoint.SolveVelocityConstraints_s_f1 = new b2Vec3();
        b2PrismaticJoint.SolveVelocityConstraints_s_df3 = new b2Vec3();
        b2PrismaticJoint.SolveVelocityConstraints_s_df2 = new b2Vec2();
        b2PrismaticJoint.SolvePositionConstraints_s_d = new b2Vec2();
        b2PrismaticJoint.SolvePositionConstraints_s_impulse = new b2Vec3();
        b2PrismaticJoint.SolvePositionConstraints_s_impulse1 = new b2Vec2();
        b2PrismaticJoint.SolvePositionConstraints_s_P = new b2Vec2();
        b2PrismaticJoint.GetJointTranslation_s_pA = new b2Vec2();
        b2PrismaticJoint.GetJointTranslation_s_pB = new b2Vec2();
        b2PrismaticJoint.GetJointTranslation_s_d = new b2Vec2();
        b2PrismaticJoint.GetJointTranslation_s_axis = new b2Vec2();
        return b2PrismaticJoint;
      })(b2Joint);
      var b2_minPulleyLength = 2;
      var b2PulleyJointDef = (function(_super) {
        __extends(b2PulleyJointDef, _super);
        function b2PulleyJointDef() {
          var _this = _super.call(this, exports.b2JointType.e_pulleyJoint) || this;
          _this.groundAnchorA = new b2Vec2(-1, 1);
          _this.groundAnchorB = new b2Vec2(1, 1);
          _this.localAnchorA = new b2Vec2(-1, 0);
          _this.localAnchorB = new b2Vec2(1, 0);
          _this.lengthA = 0;
          _this.lengthB = 0;
          _this.ratio = 1;
          _this.collideConnected = true;
          return _this;
        }
        b2PulleyJointDef.prototype.Initialize = function(bA, bB, groundA, groundB, anchorA, anchorB, r) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.groundAnchorA.Copy(groundA);
          this.groundAnchorB.Copy(groundB);
          this.bodyA.GetLocalPoint(anchorA, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchorB, this.localAnchorB);
          this.lengthA = b2Vec2.DistanceVV(anchorA, groundA);
          this.lengthB = b2Vec2.DistanceVV(anchorB, groundB);
          this.ratio = r;
        };
        return b2PulleyJointDef;
      })(b2JointDef);
      var b2PulleyJoint = (function(_super) {
        __extends(b2PulleyJoint, _super);
        function b2PulleyJoint(def) {
          var _this = _super.call(this, def) || this;
          _this.m_groundAnchorA = new b2Vec2();
          _this.m_groundAnchorB = new b2Vec2();
          _this.m_lengthA = 0;
          _this.m_lengthB = 0;
          _this.m_localAnchorA = new b2Vec2();
          _this.m_localAnchorB = new b2Vec2();
          _this.m_constant = 0;
          _this.m_ratio = 0;
          _this.m_impulse = 0;
          _this.m_indexA = 0;
          _this.m_indexB = 0;
          _this.m_uA = new b2Vec2();
          _this.m_uB = new b2Vec2();
          _this.m_rA = new b2Vec2();
          _this.m_rB = new b2Vec2();
          _this.m_localCenterA = new b2Vec2();
          _this.m_localCenterB = new b2Vec2();
          _this.m_invMassA = 0;
          _this.m_invMassB = 0;
          _this.m_invIA = 0;
          _this.m_invIB = 0;
          _this.m_mass = 0;
          _this.m_qA = new b2Rot();
          _this.m_qB = new b2Rot();
          _this.m_lalcA = new b2Vec2();
          _this.m_lalcB = new b2Vec2();
          _this.m_groundAnchorA.Copy(b2Maybe(def.groundAnchorA, new b2Vec2(-1, 1)));
          _this.m_groundAnchorB.Copy(b2Maybe(def.groundAnchorB, new b2Vec2(1, 0)));
          _this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, new b2Vec2(-1, 0)));
          _this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, new b2Vec2(1, 0)));
          _this.m_lengthA = b2Maybe(def.lengthA, 0);
          _this.m_lengthB = b2Maybe(def.lengthB, 0);
          _this.m_ratio = b2Maybe(def.ratio, 1);
          _this.m_constant = b2Maybe(def.lengthA, 0) + _this.m_ratio * b2Maybe(def.lengthB, 0);
          _this.m_impulse = 0;
          return _this;
        }
        b2PulleyJoint.prototype.InitVelocityConstraints = function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          this.m_uA.Copy(cA).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA);
          this.m_uB.Copy(cB).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB);
          var lengthA = this.m_uA.Length();
          var lengthB = this.m_uB.Length();
          lengthA > 10 * b2_linearSlop ? this.m_uA.SelfMul(1 / lengthA) : this.m_uA.SetZero();
          lengthB > 10 * b2_linearSlop ? this.m_uB.SelfMul(1 / lengthB) : this.m_uB.SetZero();
          var ruA = b2Vec2.CrossVV(this.m_rA, this.m_uA);
          var ruB = b2Vec2.CrossVV(this.m_rB, this.m_uB);
          var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
          var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
          this.m_mass = mA + this.m_ratio * this.m_ratio * mB;
          this.m_mass > 0 && (this.m_mass = 1 / this.m_mass);
          if (data.step.warmStarting) {
            this.m_impulse *= data.step.dtRatio;
            var PA = b2Vec2.MulSV(-this.m_impulse, this.m_uA, b2PulleyJoint.InitVelocityConstraints_s_PA);
            var PB = b2Vec2.MulSV(-this.m_ratio * this.m_impulse, this.m_uB, b2PulleyJoint.InitVelocityConstraints_s_PB);
            vA.SelfMulAdd(this.m_invMassA, PA);
            wA += this.m_invIA * b2Vec2.CrossVV(this.m_rA, PA);
            vB.SelfMulAdd(this.m_invMassB, PB);
            wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, PB);
          } else this.m_impulse = 0;
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2PulleyJoint.prototype.SolveVelocityConstraints = function(data) {
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var vpA = b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2PulleyJoint.SolveVelocityConstraints_s_vpA);
          var vpB = b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2PulleyJoint.SolveVelocityConstraints_s_vpB);
          var Cdot = -b2Vec2.DotVV(this.m_uA, vpA) - this.m_ratio * b2Vec2.DotVV(this.m_uB, vpB);
          var impulse = -this.m_mass * Cdot;
          this.m_impulse += impulse;
          var PA = b2Vec2.MulSV(-impulse, this.m_uA, b2PulleyJoint.SolveVelocityConstraints_s_PA);
          var PB = b2Vec2.MulSV(-this.m_ratio * impulse, this.m_uB, b2PulleyJoint.SolveVelocityConstraints_s_PB);
          vA.SelfMulAdd(this.m_invMassA, PA);
          wA += this.m_invIA * b2Vec2.CrossVV(this.m_rA, PA);
          vB.SelfMulAdd(this.m_invMassB, PB);
          wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, PB);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2PulleyJoint.prototype.SolvePositionConstraints = function(data) {
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          var rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          var rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var uA = this.m_uA.Copy(cA).SelfAdd(rA).SelfSub(this.m_groundAnchorA);
          var uB = this.m_uB.Copy(cB).SelfAdd(rB).SelfSub(this.m_groundAnchorB);
          var lengthA = uA.Length();
          var lengthB = uB.Length();
          lengthA > 10 * b2_linearSlop ? uA.SelfMul(1 / lengthA) : uA.SetZero();
          lengthB > 10 * b2_linearSlop ? uB.SelfMul(1 / lengthB) : uB.SetZero();
          var ruA = b2Vec2.CrossVV(rA, uA);
          var ruB = b2Vec2.CrossVV(rB, uB);
          var mA = this.m_invMassA + this.m_invIA * ruA * ruA;
          var mB = this.m_invMassB + this.m_invIB * ruB * ruB;
          var mass = mA + this.m_ratio * this.m_ratio * mB;
          mass > 0 && (mass = 1 / mass);
          var C = this.m_constant - lengthA - this.m_ratio * lengthB;
          var linearError = b2Abs(C);
          var impulse = -mass * C;
          var PA = b2Vec2.MulSV(-impulse, uA, b2PulleyJoint.SolvePositionConstraints_s_PA);
          var PB = b2Vec2.MulSV(-this.m_ratio * impulse, uB, b2PulleyJoint.SolvePositionConstraints_s_PB);
          cA.SelfMulAdd(this.m_invMassA, PA);
          aA += this.m_invIA * b2Vec2.CrossVV(rA, PA);
          cB.SelfMulAdd(this.m_invMassB, PB);
          aB += this.m_invIB * b2Vec2.CrossVV(rB, PB);
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].a = aB;
          return linearError < b2_linearSlop;
        };
        b2PulleyJoint.prototype.GetAnchorA = function(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
        };
        b2PulleyJoint.prototype.GetAnchorB = function(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
        };
        b2PulleyJoint.prototype.GetReactionForce = function(inv_dt, out) {
          out.x = inv_dt * this.m_impulse * this.m_uB.x;
          out.y = inv_dt * this.m_impulse * this.m_uB.y;
          return out;
        };
        b2PulleyJoint.prototype.GetReactionTorque = function(inv_dt) {
          return 0;
        };
        b2PulleyJoint.prototype.GetGroundAnchorA = function() {
          return this.m_groundAnchorA;
        };
        b2PulleyJoint.prototype.GetGroundAnchorB = function() {
          return this.m_groundAnchorB;
        };
        b2PulleyJoint.prototype.GetLengthA = function() {
          return this.m_lengthA;
        };
        b2PulleyJoint.prototype.GetLengthB = function() {
          return this.m_lengthB;
        };
        b2PulleyJoint.prototype.GetRatio = function() {
          return this.m_ratio;
        };
        b2PulleyJoint.prototype.GetCurrentLengthA = function() {
          var p = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, b2PulleyJoint.GetCurrentLengthA_s_p);
          var s = this.m_groundAnchorA;
          return b2Vec2.DistanceVV(p, s);
        };
        b2PulleyJoint.prototype.GetCurrentLengthB = function() {
          var p = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, b2PulleyJoint.GetCurrentLengthB_s_p);
          var s = this.m_groundAnchorB;
          return b2Vec2.DistanceVV(p, s);
        };
        b2PulleyJoint.prototype.Dump = function(log) {
          var indexA = this.m_bodyA.m_islandIndex;
          var indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2PulleyJointDef = new b2PulleyJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
          log("  jd.groundAnchorA.Set(%.15f, %.15f);\n", this.m_groundAnchorA.x, this.m_groundAnchorA.y);
          log("  jd.groundAnchorB.Set(%.15f, %.15f);\n", this.m_groundAnchorB.x, this.m_groundAnchorB.y);
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.lengthA = %.15f;\n", this.m_lengthA);
          log("  jd.lengthB = %.15f;\n", this.m_lengthB);
          log("  jd.ratio = %.15f;\n", this.m_ratio);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
        };
        b2PulleyJoint.prototype.ShiftOrigin = function(newOrigin) {
          this.m_groundAnchorA.SelfSub(newOrigin);
          this.m_groundAnchorB.SelfSub(newOrigin);
        };
        b2PulleyJoint.InitVelocityConstraints_s_PA = new b2Vec2();
        b2PulleyJoint.InitVelocityConstraints_s_PB = new b2Vec2();
        b2PulleyJoint.SolveVelocityConstraints_s_vpA = new b2Vec2();
        b2PulleyJoint.SolveVelocityConstraints_s_vpB = new b2Vec2();
        b2PulleyJoint.SolveVelocityConstraints_s_PA = new b2Vec2();
        b2PulleyJoint.SolveVelocityConstraints_s_PB = new b2Vec2();
        b2PulleyJoint.SolvePositionConstraints_s_PA = new b2Vec2();
        b2PulleyJoint.SolvePositionConstraints_s_PB = new b2Vec2();
        b2PulleyJoint.GetCurrentLengthA_s_p = new b2Vec2();
        b2PulleyJoint.GetCurrentLengthB_s_p = new b2Vec2();
        return b2PulleyJoint;
      })(b2Joint);
      var b2RevoluteJointDef = (function(_super) {
        __extends(b2RevoluteJointDef, _super);
        function b2RevoluteJointDef() {
          var _this = _super.call(this, exports.b2JointType.e_revoluteJoint) || this;
          _this.localAnchorA = new b2Vec2(0, 0);
          _this.localAnchorB = new b2Vec2(0, 0);
          _this.referenceAngle = 0;
          _this.enableLimit = false;
          _this.lowerAngle = 0;
          _this.upperAngle = 0;
          _this.enableMotor = false;
          _this.motorSpeed = 0;
          _this.maxMotorTorque = 0;
          return _this;
        }
        b2RevoluteJointDef.prototype.Initialize = function(bA, bB, anchor) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
          this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
        };
        return b2RevoluteJointDef;
      })(b2JointDef);
      var b2RevoluteJoint = (function(_super) {
        __extends(b2RevoluteJoint, _super);
        function b2RevoluteJoint(def) {
          var _this = _super.call(this, def) || this;
          _this.m_localAnchorA = new b2Vec2();
          _this.m_localAnchorB = new b2Vec2();
          _this.m_impulse = new b2Vec3();
          _this.m_motorImpulse = 0;
          _this.m_enableMotor = false;
          _this.m_maxMotorTorque = 0;
          _this.m_motorSpeed = 0;
          _this.m_enableLimit = false;
          _this.m_referenceAngle = 0;
          _this.m_lowerAngle = 0;
          _this.m_upperAngle = 0;
          _this.m_indexA = 0;
          _this.m_indexB = 0;
          _this.m_rA = new b2Vec2();
          _this.m_rB = new b2Vec2();
          _this.m_localCenterA = new b2Vec2();
          _this.m_localCenterB = new b2Vec2();
          _this.m_invMassA = 0;
          _this.m_invMassB = 0;
          _this.m_invIA = 0;
          _this.m_invIB = 0;
          _this.m_mass = new b2Mat33();
          _this.m_motorMass = 0;
          _this.m_limitState = exports.b2LimitState.e_inactiveLimit;
          _this.m_qA = new b2Rot();
          _this.m_qB = new b2Rot();
          _this.m_lalcA = new b2Vec2();
          _this.m_lalcB = new b2Vec2();
          _this.m_K = new b2Mat22();
          _this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, b2Vec2.ZERO));
          _this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, b2Vec2.ZERO));
          _this.m_referenceAngle = b2Maybe(def.referenceAngle, 0);
          _this.m_impulse.SetZero();
          _this.m_motorImpulse = 0;
          _this.m_lowerAngle = b2Maybe(def.lowerAngle, 0);
          _this.m_upperAngle = b2Maybe(def.upperAngle, 0);
          _this.m_maxMotorTorque = b2Maybe(def.maxMotorTorque, 0);
          _this.m_motorSpeed = b2Maybe(def.motorSpeed, 0);
          _this.m_enableLimit = b2Maybe(def.enableLimit, false);
          _this.m_enableMotor = b2Maybe(def.enableMotor, false);
          _this.m_limitState = exports.b2LimitState.e_inactiveLimit;
          return _this;
        }
        b2RevoluteJoint.prototype.InitVelocityConstraints = function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var fixedRotation = iA + iB === 0;
          this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
          this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
          this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
          this.m_mass.ex.y = this.m_mass.ey.x;
          this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
          this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
          this.m_mass.ex.z = this.m_mass.ez.x;
          this.m_mass.ey.z = this.m_mass.ez.y;
          this.m_mass.ez.z = iA + iB;
          this.m_motorMass = iA + iB;
          this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass);
          this.m_enableMotor && !fixedRotation || (this.m_motorImpulse = 0);
          if (this.m_enableLimit && !fixedRotation) {
            var jointAngle = aB - aA - this.m_referenceAngle;
            if (b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b2_angularSlop) this.m_limitState = exports.b2LimitState.e_equalLimits; else if (jointAngle <= this.m_lowerAngle) {
              this.m_limitState !== exports.b2LimitState.e_atLowerLimit && (this.m_impulse.z = 0);
              this.m_limitState = exports.b2LimitState.e_atLowerLimit;
            } else if (jointAngle >= this.m_upperAngle) {
              this.m_limitState !== exports.b2LimitState.e_atUpperLimit && (this.m_impulse.z = 0);
              this.m_limitState = exports.b2LimitState.e_atUpperLimit;
            } else {
              this.m_limitState = exports.b2LimitState.e_inactiveLimit;
              this.m_impulse.z = 0;
            }
          } else this.m_limitState = exports.b2LimitState.e_inactiveLimit;
          if (data.step.warmStarting) {
            this.m_impulse.SelfMul(data.step.dtRatio);
            this.m_motorImpulse *= data.step.dtRatio;
            var P = b2RevoluteJoint.InitVelocityConstraints_s_P.Set(this.m_impulse.x, this.m_impulse.y);
            vA.SelfMulSub(mA, P);
            wA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);
            vB.SelfMulAdd(mB, P);
            wB += iB * (b2Vec2.CrossVV(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);
          } else {
            this.m_impulse.SetZero();
            this.m_motorImpulse = 0;
          }
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2RevoluteJoint.prototype.SolveVelocityConstraints = function(data) {
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var fixedRotation = iA + iB === 0;
          if (this.m_enableMotor && this.m_limitState !== exports.b2LimitState.e_equalLimits && !fixedRotation) {
            var Cdot = wB - wA - this.m_motorSpeed;
            var impulse = -this.m_motorMass * Cdot;
            var oldImpulse = this.m_motorImpulse;
            var maxImpulse = data.step.dt * this.m_maxMotorTorque;
            this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
            impulse = this.m_motorImpulse - oldImpulse;
            wA -= iA * impulse;
            wB += iB * impulse;
          }
          if (this.m_enableLimit && this.m_limitState !== exports.b2LimitState.e_inactiveLimit && !fixedRotation) {
            var Cdot1 = b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Vec2.s_t1), b2RevoluteJoint.SolveVelocityConstraints_s_Cdot1);
            var Cdot2 = wB - wA;
            var impulse_v3 = this.m_mass.Solve33(Cdot1.x, Cdot1.y, Cdot2, b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v3).SelfNeg();
            if (this.m_limitState === exports.b2LimitState.e_equalLimits) this.m_impulse.SelfAdd(impulse_v3); else if (this.m_limitState === exports.b2LimitState.e_atLowerLimit) {
              var newImpulse = this.m_impulse.z + impulse_v3.z;
              if (newImpulse < 0) {
                var rhs_x = -Cdot1.x + this.m_impulse.z * this.m_mass.ez.x;
                var rhs_y = -Cdot1.y + this.m_impulse.z * this.m_mass.ez.y;
                var reduced_v2 = this.m_mass.Solve22(rhs_x, rhs_y, b2RevoluteJoint.SolveVelocityConstraints_s_reduced_v2);
                impulse_v3.x = reduced_v2.x;
                impulse_v3.y = reduced_v2.y;
                impulse_v3.z = -this.m_impulse.z;
                this.m_impulse.x += reduced_v2.x;
                this.m_impulse.y += reduced_v2.y;
                this.m_impulse.z = 0;
              } else this.m_impulse.SelfAdd(impulse_v3);
            } else if (this.m_limitState === exports.b2LimitState.e_atUpperLimit) {
              var newImpulse = this.m_impulse.z + impulse_v3.z;
              if (newImpulse > 0) {
                var rhs_x = -Cdot1.x + this.m_impulse.z * this.m_mass.ez.x;
                var rhs_y = -Cdot1.y + this.m_impulse.z * this.m_mass.ez.y;
                var reduced_v2 = this.m_mass.Solve22(rhs_x, rhs_y, b2RevoluteJoint.SolveVelocityConstraints_s_reduced_v2);
                impulse_v3.x = reduced_v2.x;
                impulse_v3.y = reduced_v2.y;
                impulse_v3.z = -this.m_impulse.z;
                this.m_impulse.x += reduced_v2.x;
                this.m_impulse.y += reduced_v2.y;
                this.m_impulse.z = 0;
              } else this.m_impulse.SelfAdd(impulse_v3);
            }
            var P = b2RevoluteJoint.SolveVelocityConstraints_s_P.Set(impulse_v3.x, impulse_v3.y);
            vA.SelfMulSub(mA, P);
            wA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + impulse_v3.z);
            vB.SelfMulAdd(mB, P);
            wB += iB * (b2Vec2.CrossVV(this.m_rB, P) + impulse_v3.z);
          } else {
            var Cdot_v2 = b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Vec2.s_t1), b2RevoluteJoint.SolveVelocityConstraints_s_Cdot_v2);
            var impulse_v2 = this.m_mass.Solve22(-Cdot_v2.x, -Cdot_v2.y, b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v2);
            this.m_impulse.x += impulse_v2.x;
            this.m_impulse.y += impulse_v2.y;
            vA.SelfMulSub(mA, impulse_v2);
            wA -= iA * b2Vec2.CrossVV(this.m_rA, impulse_v2);
            vB.SelfMulAdd(mB, impulse_v2);
            wB += iB * b2Vec2.CrossVV(this.m_rB, impulse_v2);
          }
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2RevoluteJoint.prototype.SolvePositionConstraints = function(data) {
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          var angularError = 0;
          var positionError = 0;
          var fixedRotation = this.m_invIA + this.m_invIB === 0;
          if (this.m_enableLimit && this.m_limitState !== exports.b2LimitState.e_inactiveLimit && !fixedRotation) {
            var angle = aB - aA - this.m_referenceAngle;
            var limitImpulse = 0;
            if (this.m_limitState === exports.b2LimitState.e_equalLimits) {
              var C = b2Clamp(angle - this.m_lowerAngle, -b2_maxAngularCorrection, b2_maxAngularCorrection);
              limitImpulse = -this.m_motorMass * C;
              angularError = b2Abs(C);
            } else if (this.m_limitState === exports.b2LimitState.e_atLowerLimit) {
              var C = angle - this.m_lowerAngle;
              angularError = -C;
              C = b2Clamp(C + b2_angularSlop, -b2_maxAngularCorrection, 0);
              limitImpulse = -this.m_motorMass * C;
            } else if (this.m_limitState === exports.b2LimitState.e_atUpperLimit) {
              var C = angle - this.m_upperAngle;
              angularError = C;
              C = b2Clamp(C - b2_angularSlop, 0, b2_maxAngularCorrection);
              limitImpulse = -this.m_motorMass * C;
            }
            aA -= this.m_invIA * limitImpulse;
            aB += this.m_invIB * limitImpulse;
          }
          qA.SetAngle(aA);
          qB.SetAngle(aB);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          var rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          var rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var C_v2 = b2Vec2.SubVV(b2Vec2.AddVV(cB, rB, b2Vec2.s_t0), b2Vec2.AddVV(cA, rA, b2Vec2.s_t1), b2RevoluteJoint.SolvePositionConstraints_s_C_v2);
          positionError = C_v2.Length();
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var K = this.m_K;
          K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
          K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
          K.ey.x = K.ex.y;
          K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;
          var impulse = K.Solve(C_v2.x, C_v2.y, b2RevoluteJoint.SolvePositionConstraints_s_impulse).SelfNeg();
          cA.SelfMulSub(mA, impulse);
          aA -= iA * b2Vec2.CrossVV(rA, impulse);
          cB.SelfMulAdd(mB, impulse);
          aB += iB * b2Vec2.CrossVV(rB, impulse);
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].a = aB;
          return positionError <= b2_linearSlop && angularError <= b2_angularSlop;
        };
        b2RevoluteJoint.prototype.GetAnchorA = function(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
        };
        b2RevoluteJoint.prototype.GetAnchorB = function(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
        };
        b2RevoluteJoint.prototype.GetReactionForce = function(inv_dt, out) {
          out.x = inv_dt * this.m_impulse.x;
          out.y = inv_dt * this.m_impulse.y;
          return out;
        };
        b2RevoluteJoint.prototype.GetReactionTorque = function(inv_dt) {
          return inv_dt * this.m_impulse.z;
        };
        b2RevoluteJoint.prototype.GetLocalAnchorA = function() {
          return this.m_localAnchorA;
        };
        b2RevoluteJoint.prototype.GetLocalAnchorB = function() {
          return this.m_localAnchorB;
        };
        b2RevoluteJoint.prototype.GetReferenceAngle = function() {
          return this.m_referenceAngle;
        };
        b2RevoluteJoint.prototype.GetJointAngle = function() {
          return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
        };
        b2RevoluteJoint.prototype.GetJointSpeed = function() {
          return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
        };
        b2RevoluteJoint.prototype.IsMotorEnabled = function() {
          return this.m_enableMotor;
        };
        b2RevoluteJoint.prototype.EnableMotor = function(flag) {
          if (flag !== this.m_enableMotor) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_enableMotor = flag;
          }
        };
        b2RevoluteJoint.prototype.GetMotorTorque = function(inv_dt) {
          return inv_dt * this.m_motorImpulse;
        };
        b2RevoluteJoint.prototype.GetMotorSpeed = function() {
          return this.m_motorSpeed;
        };
        b2RevoluteJoint.prototype.SetMaxMotorTorque = function(torque) {
          if (torque !== this.m_maxMotorTorque) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_maxMotorTorque = torque;
          }
        };
        b2RevoluteJoint.prototype.GetMaxMotorTorque = function() {
          return this.m_maxMotorTorque;
        };
        b2RevoluteJoint.prototype.IsLimitEnabled = function() {
          return this.m_enableLimit;
        };
        b2RevoluteJoint.prototype.EnableLimit = function(flag) {
          if (flag !== this.m_enableLimit) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_enableLimit = flag;
            this.m_impulse.z = 0;
          }
        };
        b2RevoluteJoint.prototype.GetLowerLimit = function() {
          return this.m_lowerAngle;
        };
        b2RevoluteJoint.prototype.GetUpperLimit = function() {
          return this.m_upperAngle;
        };
        b2RevoluteJoint.prototype.SetLimits = function(lower, upper) {
          if (lower !== this.m_lowerAngle || upper !== this.m_upperAngle) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_impulse.z = 0;
            this.m_lowerAngle = lower;
            this.m_upperAngle = upper;
          }
        };
        b2RevoluteJoint.prototype.SetMotorSpeed = function(speed) {
          if (speed !== this.m_motorSpeed) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_motorSpeed = speed;
          }
        };
        b2RevoluteJoint.prototype.Dump = function(log) {
          var indexA = this.m_bodyA.m_islandIndex;
          var indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2RevoluteJointDef = new b2RevoluteJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
          log("  jd.enableLimit = %s;\n", this.m_enableLimit ? "true" : "false");
          log("  jd.lowerAngle = %.15f;\n", this.m_lowerAngle);
          log("  jd.upperAngle = %.15f;\n", this.m_upperAngle);
          log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false");
          log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
          log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
        };
        b2RevoluteJoint.InitVelocityConstraints_s_P = new b2Vec2();
        b2RevoluteJoint.SolveVelocityConstraints_s_P = new b2Vec2();
        b2RevoluteJoint.SolveVelocityConstraints_s_Cdot_v2 = new b2Vec2();
        b2RevoluteJoint.SolveVelocityConstraints_s_Cdot1 = new b2Vec2();
        b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v3 = new b2Vec3();
        b2RevoluteJoint.SolveVelocityConstraints_s_reduced_v2 = new b2Vec2();
        b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v2 = new b2Vec2();
        b2RevoluteJoint.SolvePositionConstraints_s_C_v2 = new b2Vec2();
        b2RevoluteJoint.SolvePositionConstraints_s_impulse = new b2Vec2();
        return b2RevoluteJoint;
      })(b2Joint);
      var b2RopeJointDef = (function(_super) {
        __extends(b2RopeJointDef, _super);
        function b2RopeJointDef() {
          var _this = _super.call(this, exports.b2JointType.e_ropeJoint) || this;
          _this.localAnchorA = new b2Vec2(-1, 0);
          _this.localAnchorB = new b2Vec2(1, 0);
          _this.maxLength = 0;
          return _this;
        }
        return b2RopeJointDef;
      })(b2JointDef);
      var b2RopeJoint = (function(_super) {
        __extends(b2RopeJoint, _super);
        function b2RopeJoint(def) {
          var _this = _super.call(this, def) || this;
          _this.m_localAnchorA = new b2Vec2();
          _this.m_localAnchorB = new b2Vec2();
          _this.m_maxLength = 0;
          _this.m_length = 0;
          _this.m_impulse = 0;
          _this.m_indexA = 0;
          _this.m_indexB = 0;
          _this.m_u = new b2Vec2();
          _this.m_rA = new b2Vec2();
          _this.m_rB = new b2Vec2();
          _this.m_localCenterA = new b2Vec2();
          _this.m_localCenterB = new b2Vec2();
          _this.m_invMassA = 0;
          _this.m_invMassB = 0;
          _this.m_invIA = 0;
          _this.m_invIB = 0;
          _this.m_mass = 0;
          _this.m_state = exports.b2LimitState.e_inactiveLimit;
          _this.m_qA = new b2Rot();
          _this.m_qB = new b2Rot();
          _this.m_lalcA = new b2Vec2();
          _this.m_lalcB = new b2Vec2();
          _this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, new b2Vec2(-1, 0)));
          _this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, new b2Vec2(1, 0)));
          _this.m_maxLength = b2Maybe(def.maxLength, 0);
          return _this;
        }
        b2RopeJoint.prototype.InitVelocityConstraints = function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          this.m_u.Copy(cB).SelfAdd(this.m_rB).SelfSub(cA).SelfSub(this.m_rA);
          this.m_length = this.m_u.Length();
          var C = this.m_length - this.m_maxLength;
          this.m_state = C > 0 ? exports.b2LimitState.e_atUpperLimit : exports.b2LimitState.e_inactiveLimit;
          if (!(this.m_length > b2_linearSlop)) {
            this.m_u.SetZero();
            this.m_mass = 0;
            this.m_impulse = 0;
            return;
          }
          this.m_u.SelfMul(1 / this.m_length);
          var crA = b2Vec2.CrossVV(this.m_rA, this.m_u);
          var crB = b2Vec2.CrossVV(this.m_rB, this.m_u);
          var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB;
          this.m_mass = 0 !== invMass ? 1 / invMass : 0;
          if (data.step.warmStarting) {
            this.m_impulse *= data.step.dtRatio;
            var P = b2Vec2.MulSV(this.m_impulse, this.m_u, b2RopeJoint.InitVelocityConstraints_s_P);
            vA.SelfMulSub(this.m_invMassA, P);
            wA -= this.m_invIA * b2Vec2.CrossVV(this.m_rA, P);
            vB.SelfMulAdd(this.m_invMassB, P);
            wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, P);
          } else this.m_impulse = 0;
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2RopeJoint.prototype.SolveVelocityConstraints = function(data) {
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var vpA = b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2RopeJoint.SolveVelocityConstraints_s_vpA);
          var vpB = b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2RopeJoint.SolveVelocityConstraints_s_vpB);
          var C = this.m_length - this.m_maxLength;
          var Cdot = b2Vec2.DotVV(this.m_u, b2Vec2.SubVV(vpB, vpA, b2Vec2.s_t0));
          C < 0 && (Cdot += data.step.inv_dt * C);
          var impulse = -this.m_mass * Cdot;
          var oldImpulse = this.m_impulse;
          this.m_impulse = b2Min(0, this.m_impulse + impulse);
          impulse = this.m_impulse - oldImpulse;
          var P = b2Vec2.MulSV(impulse, this.m_u, b2RopeJoint.SolveVelocityConstraints_s_P);
          vA.SelfMulSub(this.m_invMassA, P);
          wA -= this.m_invIA * b2Vec2.CrossVV(this.m_rA, P);
          vB.SelfMulAdd(this.m_invMassB, P);
          wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, P);
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2RopeJoint.prototype.SolvePositionConstraints = function(data) {
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          var rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          var rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var u = this.m_u.Copy(cB).SelfAdd(rB).SelfSub(cA).SelfSub(rA);
          var length = u.Normalize();
          var C = length - this.m_maxLength;
          C = b2Clamp(C, 0, b2_maxLinearCorrection);
          var impulse = -this.m_mass * C;
          var P = b2Vec2.MulSV(impulse, u, b2RopeJoint.SolvePositionConstraints_s_P);
          cA.SelfMulSub(this.m_invMassA, P);
          aA -= this.m_invIA * b2Vec2.CrossVV(rA, P);
          cB.SelfMulAdd(this.m_invMassB, P);
          aB += this.m_invIB * b2Vec2.CrossVV(rB, P);
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].a = aB;
          return length - this.m_maxLength < b2_linearSlop;
        };
        b2RopeJoint.prototype.GetAnchorA = function(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
        };
        b2RopeJoint.prototype.GetAnchorB = function(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
        };
        b2RopeJoint.prototype.GetReactionForce = function(inv_dt, out) {
          return b2Vec2.MulSV(inv_dt * this.m_impulse, this.m_u, out);
        };
        b2RopeJoint.prototype.GetReactionTorque = function(inv_dt) {
          return 0;
        };
        b2RopeJoint.prototype.GetLocalAnchorA = function() {
          return this.m_localAnchorA;
        };
        b2RopeJoint.prototype.GetLocalAnchorB = function() {
          return this.m_localAnchorB;
        };
        b2RopeJoint.prototype.SetMaxLength = function(length) {
          this.m_maxLength = length;
        };
        b2RopeJoint.prototype.GetMaxLength = function() {
          return this.m_maxLength;
        };
        b2RopeJoint.prototype.GetLimitState = function() {
          return this.m_state;
        };
        b2RopeJoint.prototype.Dump = function(log) {
          var indexA = this.m_bodyA.m_islandIndex;
          var indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2RopeJointDef = new b2RopeJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.maxLength = %.15f;\n", this.m_maxLength);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
        };
        b2RopeJoint.InitVelocityConstraints_s_P = new b2Vec2();
        b2RopeJoint.SolveVelocityConstraints_s_vpA = new b2Vec2();
        b2RopeJoint.SolveVelocityConstraints_s_vpB = new b2Vec2();
        b2RopeJoint.SolveVelocityConstraints_s_P = new b2Vec2();
        b2RopeJoint.SolvePositionConstraints_s_P = new b2Vec2();
        return b2RopeJoint;
      })(b2Joint);
      var b2WeldJointDef = (function(_super) {
        __extends(b2WeldJointDef, _super);
        function b2WeldJointDef() {
          var _this = _super.call(this, exports.b2JointType.e_weldJoint) || this;
          _this.localAnchorA = new b2Vec2();
          _this.localAnchorB = new b2Vec2();
          _this.referenceAngle = 0;
          _this.frequencyHz = 0;
          _this.dampingRatio = 0;
          return _this;
        }
        b2WeldJointDef.prototype.Initialize = function(bA, bB, anchor) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
          this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
        };
        return b2WeldJointDef;
      })(b2JointDef);
      var b2WeldJoint = (function(_super) {
        __extends(b2WeldJoint, _super);
        function b2WeldJoint(def) {
          var _this = _super.call(this, def) || this;
          _this.m_frequencyHz = 0;
          _this.m_dampingRatio = 0;
          _this.m_bias = 0;
          _this.m_localAnchorA = new b2Vec2();
          _this.m_localAnchorB = new b2Vec2();
          _this.m_referenceAngle = 0;
          _this.m_gamma = 0;
          _this.m_impulse = new b2Vec3(0, 0, 0);
          _this.m_indexA = 0;
          _this.m_indexB = 0;
          _this.m_rA = new b2Vec2();
          _this.m_rB = new b2Vec2();
          _this.m_localCenterA = new b2Vec2();
          _this.m_localCenterB = new b2Vec2();
          _this.m_invMassA = 0;
          _this.m_invMassB = 0;
          _this.m_invIA = 0;
          _this.m_invIB = 0;
          _this.m_mass = new b2Mat33();
          _this.m_qA = new b2Rot();
          _this.m_qB = new b2Rot();
          _this.m_lalcA = new b2Vec2();
          _this.m_lalcB = new b2Vec2();
          _this.m_K = new b2Mat33();
          _this.m_frequencyHz = b2Maybe(def.frequencyHz, 0);
          _this.m_dampingRatio = b2Maybe(def.dampingRatio, 0);
          _this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, b2Vec2.ZERO));
          _this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, b2Vec2.ZERO));
          _this.m_referenceAngle = b2Maybe(def.referenceAngle, 0);
          _this.m_impulse.SetZero();
          return _this;
        }
        b2WeldJoint.prototype.InitVelocityConstraints = function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var K = this.m_K;
          K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;
          K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
          K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
          K.ex.y = K.ey.x;
          K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;
          K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
          K.ex.z = K.ez.x;
          K.ey.z = K.ez.y;
          K.ez.z = iA + iB;
          if (this.m_frequencyHz > 0) {
            K.GetInverse22(this.m_mass);
            var invM = iA + iB;
            var m = invM > 0 ? 1 / invM : 0;
            var C = aB - aA - this.m_referenceAngle;
            var omega = 2 * b2_pi * this.m_frequencyHz;
            var d = 2 * m * this.m_dampingRatio * omega;
            var k = m * omega * omega;
            var h = data.step.dt;
            this.m_gamma = h * (d + h * k);
            this.m_gamma = 0 !== this.m_gamma ? 1 / this.m_gamma : 0;
            this.m_bias = C * h * k * this.m_gamma;
            invM += this.m_gamma;
            this.m_mass.ez.z = 0 !== invM ? 1 / invM : 0;
          } else {
            K.GetSymInverse33(this.m_mass);
            this.m_gamma = 0;
            this.m_bias = 0;
          }
          if (data.step.warmStarting) {
            this.m_impulse.SelfMul(data.step.dtRatio);
            var P = b2WeldJoint.InitVelocityConstraints_s_P.Set(this.m_impulse.x, this.m_impulse.y);
            vA.SelfMulSub(mA, P);
            wA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + this.m_impulse.z);
            vB.SelfMulAdd(mB, P);
            wB += iB * (b2Vec2.CrossVV(this.m_rB, P) + this.m_impulse.z);
          } else this.m_impulse.SetZero();
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2WeldJoint.prototype.SolveVelocityConstraints = function(data) {
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          if (this.m_frequencyHz > 0) {
            var Cdot2 = wB - wA;
            var impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);
            this.m_impulse.z += impulse2;
            wA -= iA * impulse2;
            wB += iB * impulse2;
            var Cdot1 = b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Vec2.s_t1), b2WeldJoint.SolveVelocityConstraints_s_Cdot1);
            var impulse1 = b2Mat33.MulM33XY(this.m_mass, Cdot1.x, Cdot1.y, b2WeldJoint.SolveVelocityConstraints_s_impulse1).SelfNeg();
            this.m_impulse.x += impulse1.x;
            this.m_impulse.y += impulse1.y;
            var P = impulse1;
            vA.SelfMulSub(mA, P);
            wA -= iA * b2Vec2.CrossVV(this.m_rA, P);
            vB.SelfMulAdd(mB, P);
            wB += iB * b2Vec2.CrossVV(this.m_rB, P);
          } else {
            var Cdot1 = b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Vec2.s_t1), b2WeldJoint.SolveVelocityConstraints_s_Cdot1);
            var Cdot2 = wB - wA;
            var impulse = b2Mat33.MulM33XYZ(this.m_mass, Cdot1.x, Cdot1.y, Cdot2, b2WeldJoint.SolveVelocityConstraints_s_impulse).SelfNeg();
            this.m_impulse.SelfAdd(impulse);
            var P = b2WeldJoint.SolveVelocityConstraints_s_P.Set(impulse.x, impulse.y);
            vA.SelfMulSub(mA, P);
            wA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + impulse.z);
            vB.SelfMulAdd(mB, P);
            wB += iB * (b2Vec2.CrossVV(this.m_rB, P) + impulse.z);
          }
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2WeldJoint.prototype.SolvePositionConstraints = function(data) {
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          var rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          var rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var positionError, angularError;
          var K = this.m_K;
          K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;
          K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;
          K.ez.x = -rA.y * iA - rB.y * iB;
          K.ex.y = K.ey.x;
          K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;
          K.ez.y = rA.x * iA + rB.x * iB;
          K.ex.z = K.ez.x;
          K.ey.z = K.ez.y;
          K.ez.z = iA + iB;
          if (this.m_frequencyHz > 0) {
            var C1 = b2Vec2.SubVV(b2Vec2.AddVV(cB, rB, b2Vec2.s_t0), b2Vec2.AddVV(cA, rA, b2Vec2.s_t1), b2WeldJoint.SolvePositionConstraints_s_C1);
            positionError = C1.Length();
            angularError = 0;
            var P = K.Solve22(C1.x, C1.y, b2WeldJoint.SolvePositionConstraints_s_P).SelfNeg();
            cA.SelfMulSub(mA, P);
            aA -= iA * b2Vec2.CrossVV(rA, P);
            cB.SelfMulAdd(mB, P);
            aB += iB * b2Vec2.CrossVV(rB, P);
          } else {
            var C1 = b2Vec2.SubVV(b2Vec2.AddVV(cB, rB, b2Vec2.s_t0), b2Vec2.AddVV(cA, rA, b2Vec2.s_t1), b2WeldJoint.SolvePositionConstraints_s_C1);
            var C2 = aB - aA - this.m_referenceAngle;
            positionError = C1.Length();
            angularError = b2Abs(C2);
            var impulse = K.Solve33(C1.x, C1.y, C2, b2WeldJoint.SolvePositionConstraints_s_impulse).SelfNeg();
            var P = b2WeldJoint.SolvePositionConstraints_s_P.Set(impulse.x, impulse.y);
            cA.SelfMulSub(mA, P);
            aA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + impulse.z);
            cB.SelfMulAdd(mB, P);
            aB += iB * (b2Vec2.CrossVV(this.m_rB, P) + impulse.z);
          }
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].a = aB;
          return positionError <= b2_linearSlop && angularError <= b2_angularSlop;
        };
        b2WeldJoint.prototype.GetAnchorA = function(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
        };
        b2WeldJoint.prototype.GetAnchorB = function(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
        };
        b2WeldJoint.prototype.GetReactionForce = function(inv_dt, out) {
          out.x = inv_dt * this.m_impulse.x;
          out.y = inv_dt * this.m_impulse.y;
          return out;
        };
        b2WeldJoint.prototype.GetReactionTorque = function(inv_dt) {
          return inv_dt * this.m_impulse.z;
        };
        b2WeldJoint.prototype.GetLocalAnchorA = function() {
          return this.m_localAnchorA;
        };
        b2WeldJoint.prototype.GetLocalAnchorB = function() {
          return this.m_localAnchorB;
        };
        b2WeldJoint.prototype.GetReferenceAngle = function() {
          return this.m_referenceAngle;
        };
        b2WeldJoint.prototype.SetFrequency = function(hz) {
          this.m_frequencyHz = hz;
        };
        b2WeldJoint.prototype.GetFrequency = function() {
          return this.m_frequencyHz;
        };
        b2WeldJoint.prototype.SetDampingRatio = function(ratio) {
          this.m_dampingRatio = ratio;
        };
        b2WeldJoint.prototype.GetDampingRatio = function() {
          return this.m_dampingRatio;
        };
        b2WeldJoint.prototype.Dump = function(log) {
          var indexA = this.m_bodyA.m_islandIndex;
          var indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2WeldJointDef = new b2WeldJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle);
          log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
          log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
        };
        b2WeldJoint.InitVelocityConstraints_s_P = new b2Vec2();
        b2WeldJoint.SolveVelocityConstraints_s_Cdot1 = new b2Vec2();
        b2WeldJoint.SolveVelocityConstraints_s_impulse1 = new b2Vec2();
        b2WeldJoint.SolveVelocityConstraints_s_impulse = new b2Vec3();
        b2WeldJoint.SolveVelocityConstraints_s_P = new b2Vec2();
        b2WeldJoint.SolvePositionConstraints_s_C1 = new b2Vec2();
        b2WeldJoint.SolvePositionConstraints_s_P = new b2Vec2();
        b2WeldJoint.SolvePositionConstraints_s_impulse = new b2Vec3();
        return b2WeldJoint;
      })(b2Joint);
      var b2WheelJointDef = (function(_super) {
        __extends(b2WheelJointDef, _super);
        function b2WheelJointDef() {
          var _this = _super.call(this, exports.b2JointType.e_wheelJoint) || this;
          _this.localAnchorA = new b2Vec2(0, 0);
          _this.localAnchorB = new b2Vec2(0, 0);
          _this.localAxisA = new b2Vec2(1, 0);
          _this.enableMotor = false;
          _this.maxMotorTorque = 0;
          _this.motorSpeed = 0;
          _this.frequencyHz = 2;
          _this.dampingRatio = .7;
          return _this;
        }
        b2WheelJointDef.prototype.Initialize = function(bA, bB, anchor, axis) {
          this.bodyA = bA;
          this.bodyB = bB;
          this.bodyA.GetLocalPoint(anchor, this.localAnchorA);
          this.bodyB.GetLocalPoint(anchor, this.localAnchorB);
          this.bodyA.GetLocalVector(axis, this.localAxisA);
        };
        return b2WheelJointDef;
      })(b2JointDef);
      var b2WheelJoint = (function(_super) {
        __extends(b2WheelJoint, _super);
        function b2WheelJoint(def) {
          var _this = _super.call(this, def) || this;
          _this.m_frequencyHz = 0;
          _this.m_dampingRatio = 0;
          _this.m_localAnchorA = new b2Vec2();
          _this.m_localAnchorB = new b2Vec2();
          _this.m_localXAxisA = new b2Vec2();
          _this.m_localYAxisA = new b2Vec2();
          _this.m_impulse = 0;
          _this.m_motorImpulse = 0;
          _this.m_springImpulse = 0;
          _this.m_maxMotorTorque = 0;
          _this.m_motorSpeed = 0;
          _this.m_enableMotor = false;
          _this.m_indexA = 0;
          _this.m_indexB = 0;
          _this.m_localCenterA = new b2Vec2();
          _this.m_localCenterB = new b2Vec2();
          _this.m_invMassA = 0;
          _this.m_invMassB = 0;
          _this.m_invIA = 0;
          _this.m_invIB = 0;
          _this.m_ax = new b2Vec2();
          _this.m_ay = new b2Vec2();
          _this.m_sAx = 0;
          _this.m_sBx = 0;
          _this.m_sAy = 0;
          _this.m_sBy = 0;
          _this.m_mass = 0;
          _this.m_motorMass = 0;
          _this.m_springMass = 0;
          _this.m_bias = 0;
          _this.m_gamma = 0;
          _this.m_qA = new b2Rot();
          _this.m_qB = new b2Rot();
          _this.m_lalcA = new b2Vec2();
          _this.m_lalcB = new b2Vec2();
          _this.m_rA = new b2Vec2();
          _this.m_rB = new b2Vec2();
          _this.m_frequencyHz = b2Maybe(def.frequencyHz, 2);
          _this.m_dampingRatio = b2Maybe(def.dampingRatio, .7);
          _this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, b2Vec2.ZERO));
          _this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, b2Vec2.ZERO));
          _this.m_localXAxisA.Copy(b2Maybe(def.localAxisA, b2Vec2.UNITX));
          b2Vec2.CrossOneV(_this.m_localXAxisA, _this.m_localYAxisA);
          _this.m_maxMotorTorque = b2Maybe(def.maxMotorTorque, 0);
          _this.m_motorSpeed = b2Maybe(def.motorSpeed, 0);
          _this.m_enableMotor = b2Maybe(def.enableMotor, false);
          _this.m_ax.SetZero();
          _this.m_ay.SetZero();
          return _this;
        }
        b2WheelJoint.prototype.GetMotorSpeed = function() {
          return this.m_motorSpeed;
        };
        b2WheelJoint.prototype.GetMaxMotorTorque = function() {
          return this.m_maxMotorTorque;
        };
        b2WheelJoint.prototype.SetSpringFrequencyHz = function(hz) {
          this.m_frequencyHz = hz;
        };
        b2WheelJoint.prototype.GetSpringFrequencyHz = function() {
          return this.m_frequencyHz;
        };
        b2WheelJoint.prototype.SetSpringDampingRatio = function(ratio) {
          this.m_dampingRatio = ratio;
        };
        b2WheelJoint.prototype.GetSpringDampingRatio = function() {
          return this.m_dampingRatio;
        };
        b2WheelJoint.prototype.InitVelocityConstraints = function(data) {
          this.m_indexA = this.m_bodyA.m_islandIndex;
          this.m_indexB = this.m_bodyB.m_islandIndex;
          this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);
          this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);
          this.m_invMassA = this.m_bodyA.m_invMass;
          this.m_invMassB = this.m_bodyB.m_invMass;
          this.m_invIA = this.m_bodyA.m_invI;
          this.m_invIB = this.m_bodyB.m_invI;
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          var rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          var rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var d = b2Vec2.SubVV(b2Vec2.AddVV(cB, rB, b2Vec2.s_t0), b2Vec2.AddVV(cA, rA, b2Vec2.s_t1), b2WheelJoint.InitVelocityConstraints_s_d);
          b2Rot.MulRV(qA, this.m_localYAxisA, this.m_ay);
          this.m_sAy = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), this.m_ay);
          this.m_sBy = b2Vec2.CrossVV(rB, this.m_ay);
          this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy * this.m_sBy;
          this.m_mass > 0 && (this.m_mass = 1 / this.m_mass);
          this.m_springMass = 0;
          this.m_bias = 0;
          this.m_gamma = 0;
          if (this.m_frequencyHz > 0) {
            b2Rot.MulRV(qA, this.m_localXAxisA, this.m_ax);
            this.m_sAx = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), this.m_ax);
            this.m_sBx = b2Vec2.CrossVV(rB, this.m_ax);
            var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx * this.m_sBx;
            if (invMass > 0) {
              this.m_springMass = 1 / invMass;
              var C = b2Vec2.DotVV(d, this.m_ax);
              var omega = 2 * b2_pi * this.m_frequencyHz;
              var damp = 2 * this.m_springMass * this.m_dampingRatio * omega;
              var k = this.m_springMass * omega * omega;
              var h = data.step.dt;
              this.m_gamma = h * (damp + h * k);
              this.m_gamma > 0 && (this.m_gamma = 1 / this.m_gamma);
              this.m_bias = C * h * k * this.m_gamma;
              this.m_springMass = invMass + this.m_gamma;
              this.m_springMass > 0 && (this.m_springMass = 1 / this.m_springMass);
            }
          } else this.m_springImpulse = 0;
          if (this.m_enableMotor) {
            this.m_motorMass = iA + iB;
            this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass);
          } else {
            this.m_motorMass = 0;
            this.m_motorImpulse = 0;
          }
          if (data.step.warmStarting) {
            this.m_impulse *= data.step.dtRatio;
            this.m_springImpulse *= data.step.dtRatio;
            this.m_motorImpulse *= data.step.dtRatio;
            var P = b2Vec2.AddVV(b2Vec2.MulSV(this.m_impulse, this.m_ay, b2Vec2.s_t0), b2Vec2.MulSV(this.m_springImpulse, this.m_ax, b2Vec2.s_t1), b2WheelJoint.InitVelocityConstraints_s_P);
            var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;
            var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;
            vA.SelfMulSub(this.m_invMassA, P);
            wA -= this.m_invIA * LA;
            vB.SelfMulAdd(this.m_invMassB, P);
            wB += this.m_invIB * LB;
          } else {
            this.m_impulse = 0;
            this.m_springImpulse = 0;
            this.m_motorImpulse = 0;
          }
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2WheelJoint.prototype.SolveVelocityConstraints = function(data) {
          var mA = this.m_invMassA, mB = this.m_invMassB;
          var iA = this.m_invIA, iB = this.m_invIB;
          var vA = data.velocities[this.m_indexA].v;
          var wA = data.velocities[this.m_indexA].w;
          var vB = data.velocities[this.m_indexB].v;
          var wB = data.velocities[this.m_indexB].w;
          var Cdot = b2Vec2.DotVV(this.m_ax, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_sBx * wB - this.m_sAx * wA;
          var impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);
          this.m_springImpulse += impulse;
          var P = b2Vec2.MulSV(impulse, this.m_ax, b2WheelJoint.SolveVelocityConstraints_s_P);
          var LA = impulse * this.m_sAx;
          var LB = impulse * this.m_sBx;
          vA.SelfMulSub(mA, P);
          wA -= iA * LA;
          vB.SelfMulAdd(mB, P);
          wB += iB * LB;
          var Cdot = wB - wA - this.m_motorSpeed;
          var impulse = -this.m_motorMass * Cdot;
          var oldImpulse = this.m_motorImpulse;
          var maxImpulse = data.step.dt * this.m_maxMotorTorque;
          this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
          impulse = this.m_motorImpulse - oldImpulse;
          wA -= iA * impulse;
          wB += iB * impulse;
          var Cdot = b2Vec2.DotVV(this.m_ay, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_sBy * wB - this.m_sAy * wA;
          var impulse = -this.m_mass * Cdot;
          this.m_impulse += impulse;
          var P = b2Vec2.MulSV(impulse, this.m_ay, b2WheelJoint.SolveVelocityConstraints_s_P);
          var LA = impulse * this.m_sAy;
          var LB = impulse * this.m_sBy;
          vA.SelfMulSub(mA, P);
          wA -= iA * LA;
          vB.SelfMulAdd(mB, P);
          wB += iB * LB;
          data.velocities[this.m_indexA].w = wA;
          data.velocities[this.m_indexB].w = wB;
        };
        b2WheelJoint.prototype.SolvePositionConstraints = function(data) {
          var cA = data.positions[this.m_indexA].c;
          var aA = data.positions[this.m_indexA].a;
          var cB = data.positions[this.m_indexB].c;
          var aB = data.positions[this.m_indexB].a;
          var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);
          b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);
          var rA = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);
          var rB = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);
          var d = b2Vec2.AddVV(b2Vec2.SubVV(cB, cA, b2Vec2.s_t0), b2Vec2.SubVV(rB, rA, b2Vec2.s_t1), b2WheelJoint.SolvePositionConstraints_s_d);
          var ay = b2Rot.MulRV(qA, this.m_localYAxisA, this.m_ay);
          var sAy = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), ay);
          var sBy = b2Vec2.CrossVV(rB, ay);
          var C = b2Vec2.DotVV(d, this.m_ay);
          var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
          var impulse;
          impulse = 0 !== k ? -C / k : 0;
          var P = b2Vec2.MulSV(impulse, ay, b2WheelJoint.SolvePositionConstraints_s_P);
          var LA = impulse * sAy;
          var LB = impulse * sBy;
          cA.SelfMulSub(this.m_invMassA, P);
          aA -= this.m_invIA * LA;
          cB.SelfMulAdd(this.m_invMassB, P);
          aB += this.m_invIB * LB;
          data.positions[this.m_indexA].a = aA;
          data.positions[this.m_indexB].a = aB;
          return b2Abs(C) <= b2_linearSlop;
        };
        b2WheelJoint.prototype.GetDefinition = function(def) {
          return def;
        };
        b2WheelJoint.prototype.GetAnchorA = function(out) {
          return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);
        };
        b2WheelJoint.prototype.GetAnchorB = function(out) {
          return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);
        };
        b2WheelJoint.prototype.GetReactionForce = function(inv_dt, out) {
          out.x = inv_dt * (this.m_impulse * this.m_ay.x + this.m_springImpulse * this.m_ax.x);
          out.y = inv_dt * (this.m_impulse * this.m_ay.y + this.m_springImpulse * this.m_ax.y);
          return out;
        };
        b2WheelJoint.prototype.GetReactionTorque = function(inv_dt) {
          return inv_dt * this.m_motorImpulse;
        };
        b2WheelJoint.prototype.GetLocalAnchorA = function() {
          return this.m_localAnchorA;
        };
        b2WheelJoint.prototype.GetLocalAnchorB = function() {
          return this.m_localAnchorB;
        };
        b2WheelJoint.prototype.GetLocalAxisA = function() {
          return this.m_localXAxisA;
        };
        b2WheelJoint.prototype.GetJointTranslation = function() {
          return this.GetPrismaticJointTranslation();
        };
        b2WheelJoint.prototype.GetJointLinearSpeed = function() {
          return this.GetPrismaticJointSpeed();
        };
        b2WheelJoint.prototype.GetJointAngle = function() {
          return this.GetRevoluteJointAngle();
        };
        b2WheelJoint.prototype.GetJointAngularSpeed = function() {
          return this.GetRevoluteJointSpeed();
        };
        b2WheelJoint.prototype.GetPrismaticJointTranslation = function() {
          var bA = this.m_bodyA;
          var bB = this.m_bodyB;
          var pA = bA.GetWorldPoint(this.m_localAnchorA, new b2Vec2());
          var pB = bB.GetWorldPoint(this.m_localAnchorB, new b2Vec2());
          var d = b2Vec2.SubVV(pB, pA, new b2Vec2());
          var axis = bA.GetWorldVector(this.m_localXAxisA, new b2Vec2());
          var translation = b2Vec2.DotVV(d, axis);
          return translation;
        };
        b2WheelJoint.prototype.GetPrismaticJointSpeed = function() {
          var bA = this.m_bodyA;
          var bB = this.m_bodyB;
          b2Vec2.SubVV(this.m_localAnchorA, bA.m_sweep.localCenter, this.m_lalcA);
          var rA = b2Rot.MulRV(bA.m_xf.q, this.m_lalcA, this.m_rA);
          b2Vec2.SubVV(this.m_localAnchorB, bB.m_sweep.localCenter, this.m_lalcB);
          var rB = b2Rot.MulRV(bB.m_xf.q, this.m_lalcB, this.m_rB);
          var pA = b2Vec2.AddVV(bA.m_sweep.c, rA, b2Vec2.s_t0);
          var pB = b2Vec2.AddVV(bB.m_sweep.c, rB, b2Vec2.s_t1);
          var d = b2Vec2.SubVV(pB, pA, b2Vec2.s_t2);
          var axis = bA.GetWorldVector(this.m_localXAxisA, new b2Vec2());
          var vA = bA.m_linearVelocity;
          var vB = bB.m_linearVelocity;
          var wA = bA.m_angularVelocity;
          var wB = bB.m_angularVelocity;
          var speed = b2Vec2.DotVV(d, b2Vec2.CrossSV(wA, axis, b2Vec2.s_t0)) + b2Vec2.DotVV(axis, b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, rA, b2Vec2.s_t1), b2Vec2.s_t0));
          return speed;
        };
        b2WheelJoint.prototype.GetRevoluteJointAngle = function() {
          return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a;
        };
        b2WheelJoint.prototype.GetRevoluteJointSpeed = function() {
          var wA = this.m_bodyA.m_angularVelocity;
          var wB = this.m_bodyB.m_angularVelocity;
          return wB - wA;
        };
        b2WheelJoint.prototype.IsMotorEnabled = function() {
          return this.m_enableMotor;
        };
        b2WheelJoint.prototype.EnableMotor = function(flag) {
          if (flag !== this.m_enableMotor) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_enableMotor = flag;
          }
        };
        b2WheelJoint.prototype.SetMotorSpeed = function(speed) {
          if (speed !== this.m_motorSpeed) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_motorSpeed = speed;
          }
        };
        b2WheelJoint.prototype.SetMaxMotorTorque = function(force) {
          if (force !== this.m_maxMotorTorque) {
            this.m_bodyA.SetAwake(true);
            this.m_bodyB.SetAwake(true);
            this.m_maxMotorTorque = force;
          }
        };
        b2WheelJoint.prototype.GetMotorTorque = function(inv_dt) {
          return inv_dt * this.m_motorImpulse;
        };
        b2WheelJoint.prototype.Dump = function(log) {
          var indexA = this.m_bodyA.m_islandIndex;
          var indexB = this.m_bodyB.m_islandIndex;
          log("  const jd: b2WheelJointDef = new b2WheelJointDef();\n");
          log("  jd.bodyA = bodies[%d];\n", indexA);
          log("  jd.bodyB = bodies[%d];\n", indexB);
          log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false");
          log("  jd.localAnchorA.Set(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y);
          log("  jd.localAnchorB.Set(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y);
          log("  jd.localAxisA.Set(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y);
          log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false");
          log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed);
          log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque);
          log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz);
          log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio);
          log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index);
        };
        b2WheelJoint.InitVelocityConstraints_s_d = new b2Vec2();
        b2WheelJoint.InitVelocityConstraints_s_P = new b2Vec2();
        b2WheelJoint.SolveVelocityConstraints_s_P = new b2Vec2();
        b2WheelJoint.SolvePositionConstraints_s_d = new b2Vec2();
        b2WheelJoint.SolvePositionConstraints_s_P = new b2Vec2();
        return b2WheelJoint;
      })(b2Joint);
      function b2MixFriction(friction1, friction2) {
        return b2Sqrt(friction1 * friction2);
      }
      function b2MixRestitution(restitution1, restitution2) {
        return restitution1 > restitution2 ? restitution1 : restitution2;
      }
      var b2ContactEdge = (function() {
        function b2ContactEdge(contact) {
          this.prev = null;
          this.next = null;
          this.contact = contact;
        }
        return b2ContactEdge;
      })();
      var b2Contact = (function() {
        function b2Contact() {
          this.m_islandFlag = false;
          this.m_touchingFlag = false;
          this.m_enabledFlag = false;
          this.m_filterFlag = false;
          this.m_bulletHitFlag = false;
          this.m_toiFlag = false;
          this.m_prev = null;
          this.m_next = null;
          this.m_indexA = 0;
          this.m_indexB = 0;
          this.m_manifold = new b2Manifold();
          this.m_toiCount = 0;
          this.m_toi = 0;
          this.m_friction = 0;
          this.m_restitution = 0;
          this.m_tangentSpeed = 0;
          this.m_oldManifold = new b2Manifold();
          this.m_nodeA = new b2ContactEdge(this);
          this.m_nodeB = new b2ContactEdge(this);
        }
        b2Contact.prototype.GetManifold = function() {
          return this.m_manifold;
        };
        b2Contact.prototype.GetWorldManifold = function(worldManifold) {
          var bodyA = this.m_fixtureA.GetBody();
          var bodyB = this.m_fixtureB.GetBody();
          var shapeA = this.m_fixtureA.GetShape();
          var shapeB = this.m_fixtureB.GetShape();
          worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
        };
        b2Contact.prototype.IsTouching = function() {
          return this.m_touchingFlag;
        };
        b2Contact.prototype.SetEnabled = function(flag) {
          this.m_enabledFlag = flag;
        };
        b2Contact.prototype.IsEnabled = function() {
          return this.m_enabledFlag;
        };
        b2Contact.prototype.GetNext = function() {
          return this.m_next;
        };
        b2Contact.prototype.GetFixtureA = function() {
          return this.m_fixtureA;
        };
        b2Contact.prototype.GetChildIndexA = function() {
          return this.m_indexA;
        };
        b2Contact.prototype.GetFixtureB = function() {
          return this.m_fixtureB;
        };
        b2Contact.prototype.GetChildIndexB = function() {
          return this.m_indexB;
        };
        b2Contact.prototype.FlagForFiltering = function() {
          this.m_filterFlag = true;
        };
        b2Contact.prototype.SetFriction = function(friction) {
          this.m_friction = friction;
        };
        b2Contact.prototype.GetFriction = function() {
          return this.m_friction;
        };
        b2Contact.prototype.ResetFriction = function() {
          this.m_friction = b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
        };
        b2Contact.prototype.SetRestitution = function(restitution) {
          this.m_restitution = restitution;
        };
        b2Contact.prototype.GetRestitution = function() {
          return this.m_restitution;
        };
        b2Contact.prototype.ResetRestitution = function() {
          this.m_restitution = b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
        };
        b2Contact.prototype.SetTangentSpeed = function(speed) {
          this.m_tangentSpeed = speed;
        };
        b2Contact.prototype.GetTangentSpeed = function() {
          return this.m_tangentSpeed;
        };
        b2Contact.prototype.Reset = function(fixtureA, indexA, fixtureB, indexB) {
          this.m_islandFlag = false;
          this.m_touchingFlag = false;
          this.m_enabledFlag = true;
          this.m_filterFlag = false;
          this.m_bulletHitFlag = false;
          this.m_toiFlag = false;
          this.m_fixtureA = fixtureA;
          this.m_fixtureB = fixtureB;
          this.m_indexA = indexA;
          this.m_indexB = indexB;
          this.m_manifold.pointCount = 0;
          this.m_prev = null;
          this.m_next = null;
          delete this.m_nodeA.contact;
          this.m_nodeA.prev = null;
          this.m_nodeA.next = null;
          delete this.m_nodeA.other;
          delete this.m_nodeB.contact;
          this.m_nodeB.prev = null;
          this.m_nodeB.next = null;
          delete this.m_nodeB.other;
          this.m_toiCount = 0;
          this.m_friction = b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);
          this.m_restitution = b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);
        };
        b2Contact.prototype.Update = function(listener) {
          var tManifold = this.m_oldManifold;
          this.m_oldManifold = this.m_manifold;
          this.m_manifold = tManifold;
          this.m_enabledFlag = true;
          var touching = false;
          var wasTouching = this.m_touchingFlag;
          var sensorA = this.m_fixtureA.IsSensor();
          var sensorB = this.m_fixtureB.IsSensor();
          var sensor = sensorA || sensorB;
          var bodyA = this.m_fixtureA.GetBody();
          var bodyB = this.m_fixtureB.GetBody();
          var xfA = bodyA.GetTransform();
          var xfB = bodyB.GetTransform();
          if (sensor) {
            var shapeA = this.m_fixtureA.GetShape();
            var shapeB = this.m_fixtureB.GetShape();
            touching = b2TestOverlapShape(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);
            this.m_manifold.pointCount = 0;
          } else {
            this.Evaluate(this.m_manifold, xfA, xfB);
            touching = this.m_manifold.pointCount > 0;
            for (var i = 0; i < this.m_manifold.pointCount; ++i) {
              var mp2 = this.m_manifold.points[i];
              mp2.normalImpulse = 0;
              mp2.tangentImpulse = 0;
              var id2 = mp2.id;
              for (var j = 0; j < this.m_oldManifold.pointCount; ++j) {
                var mp1 = this.m_oldManifold.points[j];
                if (mp1.id.key === id2.key) {
                  mp2.normalImpulse = mp1.normalImpulse;
                  mp2.tangentImpulse = mp1.tangentImpulse;
                  break;
                }
              }
            }
            if (touching !== wasTouching) {
              bodyA.SetAwake(true);
              bodyB.SetAwake(true);
            }
          }
          this.m_touchingFlag = touching;
          !wasTouching && touching && listener && listener.BeginContact(this);
          wasTouching && !touching && listener && listener.EndContact(this);
          !sensor && touching && listener && listener.PreSolve(this, this.m_oldManifold);
        };
        b2Contact.prototype.ComputeTOI = function(sweepA, sweepB) {
          var input = b2Contact.ComputeTOI_s_input;
          input.proxyA.SetShape(this.m_fixtureA.GetShape(), this.m_indexA);
          input.proxyB.SetShape(this.m_fixtureB.GetShape(), this.m_indexB);
          input.sweepA.Copy(sweepA);
          input.sweepB.Copy(sweepB);
          input.tMax = b2_linearSlop;
          var output = b2Contact.ComputeTOI_s_output;
          b2TimeOfImpact(output, input);
          return output.t;
        };
        b2Contact.ComputeTOI_s_input = new b2TOIInput();
        b2Contact.ComputeTOI_s_output = new b2TOIOutput();
        return b2Contact;
      })();
      var b2CircleContact = (function(_super) {
        __extends(b2CircleContact, _super);
        function b2CircleContact() {
          return _super.call(this) || this;
        }
        b2CircleContact.Create = function(allocator) {
          return new b2CircleContact();
        };
        b2CircleContact.Destroy = function(contact, allocator) {};
        b2CircleContact.prototype.Reset = function(fixtureA, indexA, fixtureB, indexB) {
          _super.prototype.Reset.call(this, fixtureA, indexA, fixtureB, indexB);
        };
        b2CircleContact.prototype.Evaluate = function(manifold, xfA, xfB) {
          var shapeA = this.m_fixtureA.GetShape();
          var shapeB = this.m_fixtureB.GetShape();
          b2CollideCircles(manifold, shapeA, xfA, shapeB, xfB);
        };
        return b2CircleContact;
      })(b2Contact);
      var b2PolygonContact = (function(_super) {
        __extends(b2PolygonContact, _super);
        function b2PolygonContact() {
          return _super.call(this) || this;
        }
        b2PolygonContact.Create = function(allocator) {
          return new b2PolygonContact();
        };
        b2PolygonContact.Destroy = function(contact, allocator) {};
        b2PolygonContact.prototype.Reset = function(fixtureA, indexA, fixtureB, indexB) {
          _super.prototype.Reset.call(this, fixtureA, indexA, fixtureB, indexB);
        };
        b2PolygonContact.prototype.Evaluate = function(manifold, xfA, xfB) {
          var shapeA = this.m_fixtureA.GetShape();
          var shapeB = this.m_fixtureB.GetShape();
          b2CollidePolygons(manifold, shapeA, xfA, shapeB, xfB);
        };
        return b2PolygonContact;
      })(b2Contact);
      var b2PolygonAndCircleContact = (function(_super) {
        __extends(b2PolygonAndCircleContact, _super);
        function b2PolygonAndCircleContact() {
          return _super.call(this) || this;
        }
        b2PolygonAndCircleContact.Create = function(allocator) {
          return new b2PolygonAndCircleContact();
        };
        b2PolygonAndCircleContact.Destroy = function(contact, allocator) {};
        b2PolygonAndCircleContact.prototype.Reset = function(fixtureA, indexA, fixtureB, indexB) {
          _super.prototype.Reset.call(this, fixtureA, indexA, fixtureB, indexB);
        };
        b2PolygonAndCircleContact.prototype.Evaluate = function(manifold, xfA, xfB) {
          var shapeA = this.m_fixtureA.GetShape();
          var shapeB = this.m_fixtureB.GetShape();
          b2CollidePolygonAndCircle(manifold, shapeA, xfA, shapeB, xfB);
        };
        return b2PolygonAndCircleContact;
      })(b2Contact);
      var b2EdgeAndCircleContact = (function(_super) {
        __extends(b2EdgeAndCircleContact, _super);
        function b2EdgeAndCircleContact() {
          return _super.call(this) || this;
        }
        b2EdgeAndCircleContact.Create = function(allocator) {
          return new b2EdgeAndCircleContact();
        };
        b2EdgeAndCircleContact.Destroy = function(contact, allocator) {};
        b2EdgeAndCircleContact.prototype.Reset = function(fixtureA, indexA, fixtureB, indexB) {
          _super.prototype.Reset.call(this, fixtureA, indexA, fixtureB, indexB);
        };
        b2EdgeAndCircleContact.prototype.Evaluate = function(manifold, xfA, xfB) {
          var shapeA = this.m_fixtureA.GetShape();
          var shapeB = this.m_fixtureB.GetShape();
          b2CollideEdgeAndCircle(manifold, shapeA, xfA, shapeB, xfB);
        };
        return b2EdgeAndCircleContact;
      })(b2Contact);
      var b2EdgeAndPolygonContact = (function(_super) {
        __extends(b2EdgeAndPolygonContact, _super);
        function b2EdgeAndPolygonContact() {
          return _super.call(this) || this;
        }
        b2EdgeAndPolygonContact.Create = function(allocator) {
          return new b2EdgeAndPolygonContact();
        };
        b2EdgeAndPolygonContact.Destroy = function(contact, allocator) {};
        b2EdgeAndPolygonContact.prototype.Reset = function(fixtureA, indexA, fixtureB, indexB) {
          _super.prototype.Reset.call(this, fixtureA, indexA, fixtureB, indexB);
        };
        b2EdgeAndPolygonContact.prototype.Evaluate = function(manifold, xfA, xfB) {
          var shapeA = this.m_fixtureA.GetShape();
          var shapeB = this.m_fixtureB.GetShape();
          b2CollideEdgeAndPolygon(manifold, shapeA, xfA, shapeB, xfB);
        };
        return b2EdgeAndPolygonContact;
      })(b2Contact);
      var b2ChainAndCircleContact = (function(_super) {
        __extends(b2ChainAndCircleContact, _super);
        function b2ChainAndCircleContact() {
          return _super.call(this) || this;
        }
        b2ChainAndCircleContact.Create = function(allocator) {
          return new b2ChainAndCircleContact();
        };
        b2ChainAndCircleContact.Destroy = function(contact, allocator) {};
        b2ChainAndCircleContact.prototype.Reset = function(fixtureA, indexA, fixtureB, indexB) {
          _super.prototype.Reset.call(this, fixtureA, indexA, fixtureB, indexB);
        };
        b2ChainAndCircleContact.prototype.Evaluate = function(manifold, xfA, xfB) {
          var shapeA = this.m_fixtureA.GetShape();
          var shapeB = this.m_fixtureB.GetShape();
          var chain = shapeA;
          var edge = b2ChainAndCircleContact.Evaluate_s_edge;
          chain.GetChildEdge(edge, this.m_indexA);
          b2CollideEdgeAndCircle(manifold, edge, xfA, shapeB, xfB);
        };
        b2ChainAndCircleContact.Evaluate_s_edge = new b2EdgeShape();
        return b2ChainAndCircleContact;
      })(b2Contact);
      var b2ChainAndPolygonContact = (function(_super) {
        __extends(b2ChainAndPolygonContact, _super);
        function b2ChainAndPolygonContact() {
          return _super.call(this) || this;
        }
        b2ChainAndPolygonContact.Create = function(allocator) {
          return new b2ChainAndPolygonContact();
        };
        b2ChainAndPolygonContact.Destroy = function(contact, allocator) {};
        b2ChainAndPolygonContact.prototype.Reset = function(fixtureA, indexA, fixtureB, indexB) {
          _super.prototype.Reset.call(this, fixtureA, indexA, fixtureB, indexB);
        };
        b2ChainAndPolygonContact.prototype.Evaluate = function(manifold, xfA, xfB) {
          var shapeA = this.m_fixtureA.GetShape();
          var shapeB = this.m_fixtureB.GetShape();
          var chain = shapeA;
          var edge = b2ChainAndPolygonContact.Evaluate_s_edge;
          chain.GetChildEdge(edge, this.m_indexA);
          b2CollideEdgeAndPolygon(manifold, edge, xfA, shapeB, xfB);
        };
        b2ChainAndPolygonContact.Evaluate_s_edge = new b2EdgeShape();
        return b2ChainAndPolygonContact;
      })(b2Contact);
      var b2ContactRegister = (function() {
        function b2ContactRegister() {
          this.createFcn = null;
          this.destroyFcn = null;
          this.primary = false;
        }
        return b2ContactRegister;
      })();
      var b2ContactFactory = (function() {
        function b2ContactFactory(allocator) {
          this.m_allocator = null;
          this.m_allocator = allocator;
          this.InitializeRegisters();
        }
        b2ContactFactory.prototype.AddType = function(createFcn, destroyFcn, type1, type2) {
          var _this = this;
          var pool = b2MakeArray(256, (function(i) {
            return createFcn(_this.m_allocator);
          }));
          function poolCreateFcn(allocator) {
            return pool.pop() || createFcn(allocator);
          }
          function poolDestroyFcn(contact, allocator) {
            pool.push(contact);
          }
          this.m_registers[type1][type2].createFcn = poolCreateFcn;
          this.m_registers[type1][type2].destroyFcn = poolDestroyFcn;
          this.m_registers[type1][type2].primary = true;
          if (type1 !== type2) {
            this.m_registers[type2][type1].createFcn = poolCreateFcn;
            this.m_registers[type2][type1].destroyFcn = poolDestroyFcn;
            this.m_registers[type2][type1].primary = false;
          }
        };
        b2ContactFactory.prototype.InitializeRegisters = function() {
          this.m_registers = [];
          for (var i = 0; i < exports.b2ShapeType.e_shapeTypeCount; i++) {
            this.m_registers[i] = [];
            for (var j = 0; j < exports.b2ShapeType.e_shapeTypeCount; j++) this.m_registers[i][j] = new b2ContactRegister();
          }
          this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, exports.b2ShapeType.e_circleShape, exports.b2ShapeType.e_circleShape);
          this.AddType(b2PolygonAndCircleContact.Create, b2PolygonAndCircleContact.Destroy, exports.b2ShapeType.e_polygonShape, exports.b2ShapeType.e_circleShape);
          this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, exports.b2ShapeType.e_polygonShape, exports.b2ShapeType.e_polygonShape);
          this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, exports.b2ShapeType.e_edgeShape, exports.b2ShapeType.e_circleShape);
          this.AddType(b2EdgeAndPolygonContact.Create, b2EdgeAndPolygonContact.Destroy, exports.b2ShapeType.e_edgeShape, exports.b2ShapeType.e_polygonShape);
          this.AddType(b2ChainAndCircleContact.Create, b2ChainAndCircleContact.Destroy, exports.b2ShapeType.e_chainShape, exports.b2ShapeType.e_circleShape);
          this.AddType(b2ChainAndPolygonContact.Create, b2ChainAndPolygonContact.Destroy, exports.b2ShapeType.e_chainShape, exports.b2ShapeType.e_polygonShape);
        };
        b2ContactFactory.prototype.Create = function(fixtureA, indexA, fixtureB, indexB) {
          var type1 = fixtureA.GetType();
          var type2 = fixtureB.GetType();
          var reg = this.m_registers[type1][type2];
          if (reg.createFcn) {
            var c = reg.createFcn(this.m_allocator);
            reg.primary ? c.Reset(fixtureA, indexA, fixtureB, indexB) : c.Reset(fixtureB, indexB, fixtureA, indexA);
            return c;
          }
          return null;
        };
        b2ContactFactory.prototype.Destroy = function(contact) {
          var fixtureA = contact.m_fixtureA;
          var fixtureB = contact.m_fixtureB;
          if (contact.m_manifold.pointCount > 0 && !fixtureA.IsSensor() && !fixtureB.IsSensor()) {
            fixtureA.GetBody().SetAwake(true);
            fixtureB.GetBody().SetAwake(true);
          }
          var typeA = fixtureA.GetType();
          var typeB = fixtureB.GetType();
          var reg = this.m_registers[typeA][typeB];
          reg.destroyFcn && reg.destroyFcn(contact, this.m_allocator);
        };
        return b2ContactFactory;
      })();
      var b2DestructionListener = (function() {
        function b2DestructionListener() {}
        b2DestructionListener.prototype.SayGoodbyeJoint = function(joint) {};
        b2DestructionListener.prototype.SayGoodbyeFixture = function(fixture) {};
        b2DestructionListener.prototype.SayGoodbyeParticleGroup = function(group) {};
        b2DestructionListener.prototype.SayGoodbyeParticle = function(system, index) {};
        return b2DestructionListener;
      })();
      var b2ContactFilter = (function() {
        function b2ContactFilter() {}
        b2ContactFilter.prototype.ShouldCollide = function(fixtureA, fixtureB) {
          var bodyA = fixtureA.GetBody();
          var bodyB = fixtureB.GetBody();
          if (bodyB.GetType() === exports.b2BodyType.b2_staticBody && bodyA.GetType() === exports.b2BodyType.b2_staticBody) return false;
          if (!bodyB.ShouldCollideConnected(bodyA)) return false;
          var filter1 = fixtureA.GetFilterData();
          var filter2 = fixtureB.GetFilterData();
          if (filter1.groupIndex === filter2.groupIndex && 0 !== filter1.groupIndex) return filter1.groupIndex > 0;
          var collide = 0 !== (filter1.maskBits & filter2.categoryBits) && 0 !== (filter1.categoryBits & filter2.maskBits);
          return collide;
        };
        b2ContactFilter.prototype.ShouldCollideFixtureParticle = function(fixture, system, index) {
          return true;
        };
        b2ContactFilter.prototype.ShouldCollideParticleParticle = function(system, indexA, indexB) {
          return true;
        };
        b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
        return b2ContactFilter;
      })();
      var b2ContactImpulse = (function() {
        function b2ContactImpulse() {
          this.normalImpulses = b2MakeNumberArray(b2_maxManifoldPoints);
          this.tangentImpulses = b2MakeNumberArray(b2_maxManifoldPoints);
          this.count = 0;
        }
        return b2ContactImpulse;
      })();
      var b2ContactListener = (function() {
        function b2ContactListener() {}
        b2ContactListener.prototype.BeginContact = function(contact) {};
        b2ContactListener.prototype.EndContact = function(contact) {};
        b2ContactListener.prototype.BeginContactFixtureParticle = function(system, contact) {};
        b2ContactListener.prototype.EndContactFixtureParticle = function(system, contact) {};
        b2ContactListener.prototype.BeginContactParticleParticle = function(system, contact) {};
        b2ContactListener.prototype.EndContactParticleParticle = function(system, contact) {};
        b2ContactListener.prototype.PreSolve = function(contact, oldManifold) {};
        b2ContactListener.prototype.PostSolve = function(contact, impulse) {};
        b2ContactListener.b2_defaultListener = new b2ContactListener();
        return b2ContactListener;
      })();
      var b2QueryCallback = (function() {
        function b2QueryCallback() {}
        b2QueryCallback.prototype.ReportFixture = function(fixture) {
          return true;
        };
        b2QueryCallback.prototype.ReportParticle = function(system, index) {
          return false;
        };
        b2QueryCallback.prototype.ShouldQueryParticleSystem = function(system) {
          return true;
        };
        return b2QueryCallback;
      })();
      var b2RayCastCallback = (function() {
        function b2RayCastCallback() {}
        b2RayCastCallback.prototype.ReportFixture = function(fixture, point, normal, fraction) {
          return fraction;
        };
        b2RayCastCallback.prototype.ReportParticle = function(system, index, point, normal, fraction) {
          return 0;
        };
        b2RayCastCallback.prototype.ShouldQueryParticleSystem = function(system) {
          return true;
        };
        return b2RayCastCallback;
      })();
      var b2ContactManager = (function() {
        function b2ContactManager() {
          this.m_broadPhase = new b2BroadPhase();
          this.m_contactList = null;
          this.m_contactCount = 0;
          this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
          this.m_contactListener = b2ContactListener.b2_defaultListener;
          this.m_allocator = null;
          this.m_contactFactory = new b2ContactFactory(this.m_allocator);
        }
        b2ContactManager.prototype.AddPair = function(proxyA, proxyB) {
          var fixtureA = proxyA.fixture;
          var fixtureB = proxyB.fixture;
          var indexA = proxyA.childIndex;
          var indexB = proxyB.childIndex;
          var bodyA = fixtureA.GetBody();
          var bodyB = fixtureB.GetBody();
          if (bodyA === bodyB) return;
          var edge = bodyB.GetContactList();
          while (edge) {
            if (edge.other === bodyA) {
              var fA = edge.contact.GetFixtureA();
              var fB = edge.contact.GetFixtureB();
              var iA = edge.contact.GetChildIndexA();
              var iB = edge.contact.GetChildIndexB();
              if (fA === fixtureA && fB === fixtureB && iA === indexA && iB === indexB) return;
              if (fA === fixtureB && fB === fixtureA && iA === indexB && iB === indexA) return;
            }
            edge = edge.next;
          }
          if (this.m_contactFilter && !this.m_contactFilter.ShouldCollide(fixtureA, fixtureB)) return;
          var c = this.m_contactFactory.Create(fixtureA, indexA, fixtureB, indexB);
          if (null === c) return;
          fixtureA = c.GetFixtureA();
          fixtureB = c.GetFixtureB();
          indexA = c.GetChildIndexA();
          indexB = c.GetChildIndexB();
          bodyA = fixtureA.m_body;
          bodyB = fixtureB.m_body;
          c.m_prev = null;
          c.m_next = this.m_contactList;
          null !== this.m_contactList && (this.m_contactList.m_prev = c);
          this.m_contactList = c;
          c.m_nodeA.contact = c;
          c.m_nodeA.other = bodyB;
          c.m_nodeA.prev = null;
          c.m_nodeA.next = bodyA.m_contactList;
          null !== bodyA.m_contactList && (bodyA.m_contactList.prev = c.m_nodeA);
          bodyA.m_contactList = c.m_nodeA;
          c.m_nodeB.contact = c;
          c.m_nodeB.other = bodyA;
          c.m_nodeB.prev = null;
          c.m_nodeB.next = bodyB.m_contactList;
          null !== bodyB.m_contactList && (bodyB.m_contactList.prev = c.m_nodeB);
          bodyB.m_contactList = c.m_nodeB;
          if (!fixtureA.IsSensor() && !fixtureB.IsSensor()) {
            bodyA.SetAwake(true);
            bodyB.SetAwake(true);
          }
          ++this.m_contactCount;
        };
        b2ContactManager.prototype.FindNewContacts = function() {
          var _this = this;
          this.m_broadPhase.UpdatePairs((function(proxyA, proxyB) {
            _this.AddPair(proxyA, proxyB);
          }));
        };
        b2ContactManager.prototype.Destroy = function(c) {
          var fixtureA = c.GetFixtureA();
          var fixtureB = c.GetFixtureB();
          var bodyA = fixtureA.GetBody();
          var bodyB = fixtureB.GetBody();
          this.m_contactListener && c.IsTouching() && this.m_contactListener.EndContact(c);
          c.m_prev && (c.m_prev.m_next = c.m_next);
          c.m_next && (c.m_next.m_prev = c.m_prev);
          c === this.m_contactList && (this.m_contactList = c.m_next);
          c.m_nodeA.prev && (c.m_nodeA.prev.next = c.m_nodeA.next);
          c.m_nodeA.next && (c.m_nodeA.next.prev = c.m_nodeA.prev);
          c.m_nodeA === bodyA.m_contactList && (bodyA.m_contactList = c.m_nodeA.next);
          c.m_nodeB.prev && (c.m_nodeB.prev.next = c.m_nodeB.next);
          c.m_nodeB.next && (c.m_nodeB.next.prev = c.m_nodeB.prev);
          c.m_nodeB === bodyB.m_contactList && (bodyB.m_contactList = c.m_nodeB.next);
          this.m_contactFactory.Destroy(c);
          --this.m_contactCount;
        };
        b2ContactManager.prototype.Collide = function() {
          var c = this.m_contactList;
          while (c) {
            var fixtureA = c.GetFixtureA();
            var fixtureB = c.GetFixtureB();
            var indexA = c.GetChildIndexA();
            var indexB = c.GetChildIndexB();
            var bodyA = fixtureA.GetBody();
            var bodyB = fixtureB.GetBody();
            if (c.m_filterFlag) {
              if (this.m_contactFilter && !this.m_contactFilter.ShouldCollide(fixtureA, fixtureB)) {
                var cNuke = c;
                c = cNuke.m_next;
                this.Destroy(cNuke);
                continue;
              }
              c.m_filterFlag = false;
            }
            var activeA = bodyA.IsAwake() && bodyA.m_type !== exports.b2BodyType.b2_staticBody;
            var activeB = bodyB.IsAwake() && bodyB.m_type !== exports.b2BodyType.b2_staticBody;
            if (!activeA && !activeB) {
              c = c.m_next;
              continue;
            }
            var proxyA = fixtureA.m_proxies[indexA].treeNode;
            var proxyB = fixtureB.m_proxies[indexB].treeNode;
            var overlap = b2TestOverlapAABB(proxyA.aabb, proxyB.aabb);
            if (!overlap) {
              var cNuke = c;
              c = cNuke.m_next;
              this.Destroy(cNuke);
              continue;
            }
            c.Update(this.m_contactListener);
            c = c.m_next;
          }
        };
        return b2ContactManager;
      })();
      var b2Profile = (function() {
        function b2Profile() {
          this.step = 0;
          this.collide = 0;
          this.solve = 0;
          this.solveInit = 0;
          this.solveVelocity = 0;
          this.solvePosition = 0;
          this.broadphase = 0;
          this.solveTOI = 0;
        }
        b2Profile.prototype.Reset = function() {
          this.step = 0;
          this.collide = 0;
          this.solve = 0;
          this.solveInit = 0;
          this.solveVelocity = 0;
          this.solvePosition = 0;
          this.broadphase = 0;
          this.solveTOI = 0;
          return this;
        };
        return b2Profile;
      })();
      var b2TimeStep = (function() {
        function b2TimeStep() {
          this.dt = 0;
          this.inv_dt = 0;
          this.dtRatio = 0;
          this.velocityIterations = 0;
          this.positionIterations = 0;
          this.particleIterations = 0;
          this.warmStarting = false;
        }
        b2TimeStep.prototype.Copy = function(step) {
          this.dt = step.dt;
          this.inv_dt = step.inv_dt;
          this.dtRatio = step.dtRatio;
          this.positionIterations = step.positionIterations;
          this.velocityIterations = step.velocityIterations;
          this.particleIterations = step.particleIterations;
          this.warmStarting = step.warmStarting;
          return this;
        };
        return b2TimeStep;
      })();
      var b2Position = (function() {
        function b2Position() {
          this.c = new b2Vec2();
          this.a = 0;
        }
        b2Position.MakeArray = function(length) {
          return b2MakeArray(length, (function(i) {
            return new b2Position();
          }));
        };
        return b2Position;
      })();
      var b2Velocity = (function() {
        function b2Velocity() {
          this.v = new b2Vec2();
          this.w = 0;
        }
        b2Velocity.MakeArray = function(length) {
          return b2MakeArray(length, (function(i) {
            return new b2Velocity();
          }));
        };
        return b2Velocity;
      })();
      var b2SolverData = (function() {
        function b2SolverData() {
          this.step = new b2TimeStep();
        }
        return b2SolverData;
      })();
      var g_blockSolve = false;
      var b2VelocityConstraintPoint = (function() {
        function b2VelocityConstraintPoint() {
          this.rA = new b2Vec2();
          this.rB = new b2Vec2();
          this.normalImpulse = 0;
          this.tangentImpulse = 0;
          this.normalMass = 0;
          this.tangentMass = 0;
          this.velocityBias = 0;
        }
        b2VelocityConstraintPoint.MakeArray = function(length) {
          return b2MakeArray(length, (function(i) {
            return new b2VelocityConstraintPoint();
          }));
        };
        return b2VelocityConstraintPoint;
      })();
      var b2ContactVelocityConstraint = (function() {
        function b2ContactVelocityConstraint() {
          this.points = b2VelocityConstraintPoint.MakeArray(b2_maxManifoldPoints);
          this.normal = new b2Vec2();
          this.tangent = new b2Vec2();
          this.normalMass = new b2Mat22();
          this.K = new b2Mat22();
          this.indexA = 0;
          this.indexB = 0;
          this.invMassA = 0;
          this.invMassB = 0;
          this.invIA = 0;
          this.invIB = 0;
          this.friction = 0;
          this.restitution = 0;
          this.tangentSpeed = 0;
          this.pointCount = 0;
          this.contactIndex = 0;
        }
        b2ContactVelocityConstraint.MakeArray = function(length) {
          return b2MakeArray(length, (function(i) {
            return new b2ContactVelocityConstraint();
          }));
        };
        return b2ContactVelocityConstraint;
      })();
      var b2ContactPositionConstraint = (function() {
        function b2ContactPositionConstraint() {
          this.localPoints = b2Vec2.MakeArray(b2_maxManifoldPoints);
          this.localNormal = new b2Vec2();
          this.localPoint = new b2Vec2();
          this.indexA = 0;
          this.indexB = 0;
          this.invMassA = 0;
          this.invMassB = 0;
          this.localCenterA = new b2Vec2();
          this.localCenterB = new b2Vec2();
          this.invIA = 0;
          this.invIB = 0;
          this.type = exports.b2ManifoldType.e_unknown;
          this.radiusA = 0;
          this.radiusB = 0;
          this.pointCount = 0;
        }
        b2ContactPositionConstraint.MakeArray = function(length) {
          return b2MakeArray(length, (function(i) {
            return new b2ContactPositionConstraint();
          }));
        };
        return b2ContactPositionConstraint;
      })();
      var b2ContactSolverDef = (function() {
        function b2ContactSolverDef() {
          this.step = new b2TimeStep();
          this.count = 0;
          this.allocator = null;
        }
        return b2ContactSolverDef;
      })();
      var b2PositionSolverManifold = (function() {
        function b2PositionSolverManifold() {
          this.normal = new b2Vec2();
          this.point = new b2Vec2();
          this.separation = 0;
        }
        b2PositionSolverManifold.prototype.Initialize = function(pc, xfA, xfB, index) {
          var pointA = b2PositionSolverManifold.Initialize_s_pointA;
          var pointB = b2PositionSolverManifold.Initialize_s_pointB;
          var planePoint = b2PositionSolverManifold.Initialize_s_planePoint;
          var clipPoint = b2PositionSolverManifold.Initialize_s_clipPoint;
          switch (pc.type) {
           case exports.b2ManifoldType.e_circles:
            b2Transform.MulXV(xfA, pc.localPoint, pointA);
            b2Transform.MulXV(xfB, pc.localPoints[0], pointB);
            b2Vec2.SubVV(pointB, pointA, this.normal).SelfNormalize();
            b2Vec2.MidVV(pointA, pointB, this.point);
            this.separation = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;
            break;

           case exports.b2ManifoldType.e_faceA:
            b2Rot.MulRV(xfA.q, pc.localNormal, this.normal);
            b2Transform.MulXV(xfA, pc.localPoint, planePoint);
            b2Transform.MulXV(xfB, pc.localPoints[index], clipPoint);
            this.separation = b2Vec2.DotVV(b2Vec2.SubVV(clipPoint, planePoint, b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;
            this.point.Copy(clipPoint);
            break;

           case exports.b2ManifoldType.e_faceB:
            b2Rot.MulRV(xfB.q, pc.localNormal, this.normal);
            b2Transform.MulXV(xfB, pc.localPoint, planePoint);
            b2Transform.MulXV(xfA, pc.localPoints[index], clipPoint);
            this.separation = b2Vec2.DotVV(b2Vec2.SubVV(clipPoint, planePoint, b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;
            this.point.Copy(clipPoint);
            this.normal.SelfNeg();
          }
        };
        b2PositionSolverManifold.Initialize_s_pointA = new b2Vec2();
        b2PositionSolverManifold.Initialize_s_pointB = new b2Vec2();
        b2PositionSolverManifold.Initialize_s_planePoint = new b2Vec2();
        b2PositionSolverManifold.Initialize_s_clipPoint = new b2Vec2();
        return b2PositionSolverManifold;
      })();
      var b2ContactSolver = (function() {
        function b2ContactSolver() {
          this.m_step = new b2TimeStep();
          this.m_allocator = null;
          this.m_positionConstraints = b2ContactPositionConstraint.MakeArray(1024);
          this.m_velocityConstraints = b2ContactVelocityConstraint.MakeArray(1024);
          this.m_count = 0;
        }
        b2ContactSolver.prototype.Initialize = function(def) {
          this.m_step.Copy(def.step);
          this.m_allocator = def.allocator;
          this.m_count = def.count;
          if (this.m_positionConstraints.length < this.m_count) {
            var new_length = b2Max(2 * this.m_positionConstraints.length, this.m_count);
            while (this.m_positionConstraints.length < new_length) this.m_positionConstraints[this.m_positionConstraints.length] = new b2ContactPositionConstraint();
          }
          if (this.m_velocityConstraints.length < this.m_count) {
            var new_length = b2Max(2 * this.m_velocityConstraints.length, this.m_count);
            while (this.m_velocityConstraints.length < new_length) this.m_velocityConstraints[this.m_velocityConstraints.length] = new b2ContactVelocityConstraint();
          }
          this.m_positions = def.positions;
          this.m_velocities = def.velocities;
          this.m_contacts = def.contacts;
          for (var i = 0; i < this.m_count; ++i) {
            var contact = this.m_contacts[i];
            var fixtureA = contact.m_fixtureA;
            var fixtureB = contact.m_fixtureB;
            var shapeA = fixtureA.GetShape();
            var shapeB = fixtureB.GetShape();
            var radiusA = shapeA.m_radius;
            var radiusB = shapeB.m_radius;
            var bodyA = fixtureA.GetBody();
            var bodyB = fixtureB.GetBody();
            var manifold = contact.GetManifold();
            var pointCount = manifold.pointCount;
            var vc = this.m_velocityConstraints[i];
            vc.friction = contact.m_friction;
            vc.restitution = contact.m_restitution;
            vc.tangentSpeed = contact.m_tangentSpeed;
            vc.indexA = bodyA.m_islandIndex;
            vc.indexB = bodyB.m_islandIndex;
            vc.invMassA = bodyA.m_invMass;
            vc.invMassB = bodyB.m_invMass;
            vc.invIA = bodyA.m_invI;
            vc.invIB = bodyB.m_invI;
            vc.contactIndex = i;
            vc.pointCount = pointCount;
            vc.K.SetZero();
            vc.normalMass.SetZero();
            var pc = this.m_positionConstraints[i];
            pc.indexA = bodyA.m_islandIndex;
            pc.indexB = bodyB.m_islandIndex;
            pc.invMassA = bodyA.m_invMass;
            pc.invMassB = bodyB.m_invMass;
            pc.localCenterA.Copy(bodyA.m_sweep.localCenter);
            pc.localCenterB.Copy(bodyB.m_sweep.localCenter);
            pc.invIA = bodyA.m_invI;
            pc.invIB = bodyB.m_invI;
            pc.localNormal.Copy(manifold.localNormal);
            pc.localPoint.Copy(manifold.localPoint);
            pc.pointCount = pointCount;
            pc.radiusA = radiusA;
            pc.radiusB = radiusB;
            pc.type = manifold.type;
            for (var j = 0; j < pointCount; ++j) {
              var cp = manifold.points[j];
              var vcp = vc.points[j];
              if (this.m_step.warmStarting) {
                vcp.normalImpulse = this.m_step.dtRatio * cp.normalImpulse;
                vcp.tangentImpulse = this.m_step.dtRatio * cp.tangentImpulse;
              } else {
                vcp.normalImpulse = 0;
                vcp.tangentImpulse = 0;
              }
              vcp.rA.SetZero();
              vcp.rB.SetZero();
              vcp.normalMass = 0;
              vcp.tangentMass = 0;
              vcp.velocityBias = 0;
              pc.localPoints[j].Copy(cp.localPoint);
            }
          }
          return this;
        };
        b2ContactSolver.prototype.InitializeVelocityConstraints = function() {
          var xfA = b2ContactSolver.InitializeVelocityConstraints_s_xfA;
          var xfB = b2ContactSolver.InitializeVelocityConstraints_s_xfB;
          var worldManifold = b2ContactSolver.InitializeVelocityConstraints_s_worldManifold;
          var k_maxConditionNumber = 1e3;
          for (var i = 0; i < this.m_count; ++i) {
            var vc = this.m_velocityConstraints[i];
            var pc = this.m_positionConstraints[i];
            var radiusA = pc.radiusA;
            var radiusB = pc.radiusB;
            var manifold = this.m_contacts[vc.contactIndex].GetManifold();
            var indexA = vc.indexA;
            var indexB = vc.indexB;
            var mA = vc.invMassA;
            var mB = vc.invMassB;
            var iA = vc.invIA;
            var iB = vc.invIB;
            var localCenterA = pc.localCenterA;
            var localCenterB = pc.localCenterB;
            var cA = this.m_positions[indexA].c;
            var aA = this.m_positions[indexA].a;
            var vA = this.m_velocities[indexA].v;
            var wA = this.m_velocities[indexA].w;
            var cB = this.m_positions[indexB].c;
            var aB = this.m_positions[indexB].a;
            var vB = this.m_velocities[indexB].v;
            var wB = this.m_velocities[indexB].w;
            xfA.q.SetAngle(aA);
            xfB.q.SetAngle(aB);
            b2Vec2.SubVV(cA, b2Rot.MulRV(xfA.q, localCenterA, b2Vec2.s_t0), xfA.p);
            b2Vec2.SubVV(cB, b2Rot.MulRV(xfB.q, localCenterB, b2Vec2.s_t0), xfB.p);
            worldManifold.Initialize(manifold, xfA, radiusA, xfB, radiusB);
            vc.normal.Copy(worldManifold.normal);
            b2Vec2.CrossVOne(vc.normal, vc.tangent);
            var pointCount = vc.pointCount;
            for (var j = 0; j < pointCount; ++j) {
              var vcp = vc.points[j];
              b2Vec2.SubVV(worldManifold.points[j], cA, vcp.rA);
              b2Vec2.SubVV(worldManifold.points[j], cB, vcp.rB);
              var rnA = b2Vec2.CrossVV(vcp.rA, vc.normal);
              var rnB = b2Vec2.CrossVV(vcp.rB, vc.normal);
              var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
              vcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;
              var tangent = vc.tangent;
              var rtA = b2Vec2.CrossVV(vcp.rA, tangent);
              var rtB = b2Vec2.CrossVV(vcp.rB, tangent);
              var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;
              vcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;
              vcp.velocityBias = 0;
              var vRel = b2Vec2.DotVV(vc.normal, b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, vcp.rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, vcp.rA, b2Vec2.s_t1), b2Vec2.s_t0));
              vRel < -b2_velocityThreshold && (vcp.velocityBias += -vc.restitution * vRel);
            }
            if (2 === vc.pointCount && g_blockSolve) {
              var vcp1 = vc.points[0];
              var vcp2 = vc.points[1];
              var rn1A = b2Vec2.CrossVV(vcp1.rA, vc.normal);
              var rn1B = b2Vec2.CrossVV(vcp1.rB, vc.normal);
              var rn2A = b2Vec2.CrossVV(vcp2.rA, vc.normal);
              var rn2B = b2Vec2.CrossVV(vcp2.rB, vc.normal);
              var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
              var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
              var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;
              if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
                vc.K.ex.Set(k11, k12);
                vc.K.ey.Set(k12, k22);
                vc.K.GetInverse(vc.normalMass);
              } else vc.pointCount = 1;
            }
          }
        };
        b2ContactSolver.prototype.WarmStart = function() {
          var P = b2ContactSolver.WarmStart_s_P;
          for (var i = 0; i < this.m_count; ++i) {
            var vc = this.m_velocityConstraints[i];
            var indexA = vc.indexA;
            var indexB = vc.indexB;
            var mA = vc.invMassA;
            var iA = vc.invIA;
            var mB = vc.invMassB;
            var iB = vc.invIB;
            var pointCount = vc.pointCount;
            var vA = this.m_velocities[indexA].v;
            var wA = this.m_velocities[indexA].w;
            var vB = this.m_velocities[indexB].v;
            var wB = this.m_velocities[indexB].w;
            var normal = vc.normal;
            var tangent = vc.tangent;
            for (var j = 0; j < pointCount; ++j) {
              var vcp = vc.points[j];
              b2Vec2.AddVV(b2Vec2.MulSV(vcp.normalImpulse, normal, b2Vec2.s_t0), b2Vec2.MulSV(vcp.tangentImpulse, tangent, b2Vec2.s_t1), P);
              wA -= iA * b2Vec2.CrossVV(vcp.rA, P);
              vA.SelfMulSub(mA, P);
              wB += iB * b2Vec2.CrossVV(vcp.rB, P);
              vB.SelfMulAdd(mB, P);
            }
            this.m_velocities[indexA].w = wA;
            this.m_velocities[indexB].w = wB;
          }
        };
        b2ContactSolver.prototype.SolveVelocityConstraints = function() {
          var dv = b2ContactSolver.SolveVelocityConstraints_s_dv;
          var dv1 = b2ContactSolver.SolveVelocityConstraints_s_dv1;
          var dv2 = b2ContactSolver.SolveVelocityConstraints_s_dv2;
          var P = b2ContactSolver.SolveVelocityConstraints_s_P;
          var a = b2ContactSolver.SolveVelocityConstraints_s_a;
          var b = b2ContactSolver.SolveVelocityConstraints_s_b;
          var x = b2ContactSolver.SolveVelocityConstraints_s_x;
          var d = b2ContactSolver.SolveVelocityConstraints_s_d;
          var P1 = b2ContactSolver.SolveVelocityConstraints_s_P1;
          var P2 = b2ContactSolver.SolveVelocityConstraints_s_P2;
          var P1P2 = b2ContactSolver.SolveVelocityConstraints_s_P1P2;
          for (var i = 0; i < this.m_count; ++i) {
            var vc = this.m_velocityConstraints[i];
            var indexA = vc.indexA;
            var indexB = vc.indexB;
            var mA = vc.invMassA;
            var iA = vc.invIA;
            var mB = vc.invMassB;
            var iB = vc.invIB;
            var pointCount = vc.pointCount;
            var vA = this.m_velocities[indexA].v;
            var wA = this.m_velocities[indexA].w;
            var vB = this.m_velocities[indexB].v;
            var wB = this.m_velocities[indexB].w;
            var normal = vc.normal;
            var tangent = vc.tangent;
            var friction = vc.friction;
            for (var j = 0; j < pointCount; ++j) {
              var vcp = vc.points[j];
              b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, vcp.rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, vcp.rA, b2Vec2.s_t1), dv);
              var vt = b2Vec2.DotVV(dv, tangent) - vc.tangentSpeed;
              var lambda = vcp.tangentMass * -vt;
              var maxFriction = friction * vcp.normalImpulse;
              var newImpulse = b2Clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);
              lambda = newImpulse - vcp.tangentImpulse;
              vcp.tangentImpulse = newImpulse;
              b2Vec2.MulSV(lambda, tangent, P);
              vA.SelfMulSub(mA, P);
              wA -= iA * b2Vec2.CrossVV(vcp.rA, P);
              vB.SelfMulAdd(mB, P);
              wB += iB * b2Vec2.CrossVV(vcp.rB, P);
            }
            if (1 === vc.pointCount || false === g_blockSolve) for (var j = 0; j < pointCount; ++j) {
              var vcp = vc.points[j];
              b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, vcp.rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, vcp.rA, b2Vec2.s_t1), dv);
              var vn = b2Vec2.DotVV(dv, normal);
              var lambda = -vcp.normalMass * (vn - vcp.velocityBias);
              var newImpulse = b2Max(vcp.normalImpulse + lambda, 0);
              lambda = newImpulse - vcp.normalImpulse;
              vcp.normalImpulse = newImpulse;
              b2Vec2.MulSV(lambda, normal, P);
              vA.SelfMulSub(mA, P);
              wA -= iA * b2Vec2.CrossVV(vcp.rA, P);
              vB.SelfMulAdd(mB, P);
              wB += iB * b2Vec2.CrossVV(vcp.rB, P);
            } else {
              var cp1 = vc.points[0];
              var cp2 = vc.points[1];
              a.Set(cp1.normalImpulse, cp2.normalImpulse);
              b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, cp1.rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, cp1.rA, b2Vec2.s_t1), dv1);
              b2Vec2.SubVV(b2Vec2.AddVCrossSV(vB, wB, cp2.rB, b2Vec2.s_t0), b2Vec2.AddVCrossSV(vA, wA, cp2.rA, b2Vec2.s_t1), dv2);
              var vn1 = b2Vec2.DotVV(dv1, normal);
              var vn2 = b2Vec2.DotVV(dv2, normal);
              b.x = vn1 - cp1.velocityBias;
              b.y = vn2 - cp2.velocityBias;
              b.SelfSub(b2Mat22.MulMV(vc.K, a, b2Vec2.s_t0));
              for (;;) {
                b2Mat22.MulMV(vc.normalMass, b, x).SelfNeg();
                if (x.x >= 0 && x.y >= 0) {
                  b2Vec2.SubVV(x, a, d);
                  b2Vec2.MulSV(d.x, normal, P1);
                  b2Vec2.MulSV(d.y, normal, P2);
                  b2Vec2.AddVV(P1, P2, P1P2);
                  vA.SelfMulSub(mA, P1P2);
                  wA -= iA * (b2Vec2.CrossVV(cp1.rA, P1) + b2Vec2.CrossVV(cp2.rA, P2));
                  vB.SelfMulAdd(mB, P1P2);
                  wB += iB * (b2Vec2.CrossVV(cp1.rB, P1) + b2Vec2.CrossVV(cp2.rB, P2));
                  cp1.normalImpulse = x.x;
                  cp2.normalImpulse = x.y;
                  break;
                }
                x.x = -cp1.normalMass * b.x;
                x.y = 0;
                vn1 = 0;
                vn2 = vc.K.ex.y * x.x + b.y;
                if (x.x >= 0 && vn2 >= 0) {
                  b2Vec2.SubVV(x, a, d);
                  b2Vec2.MulSV(d.x, normal, P1);
                  b2Vec2.MulSV(d.y, normal, P2);
                  b2Vec2.AddVV(P1, P2, P1P2);
                  vA.SelfMulSub(mA, P1P2);
                  wA -= iA * (b2Vec2.CrossVV(cp1.rA, P1) + b2Vec2.CrossVV(cp2.rA, P2));
                  vB.SelfMulAdd(mB, P1P2);
                  wB += iB * (b2Vec2.CrossVV(cp1.rB, P1) + b2Vec2.CrossVV(cp2.rB, P2));
                  cp1.normalImpulse = x.x;
                  cp2.normalImpulse = x.y;
                  break;
                }
                x.x = 0;
                x.y = -cp2.normalMass * b.y;
                vn1 = vc.K.ey.x * x.y + b.x;
                vn2 = 0;
                if (x.y >= 0 && vn1 >= 0) {
                  b2Vec2.SubVV(x, a, d);
                  b2Vec2.MulSV(d.x, normal, P1);
                  b2Vec2.MulSV(d.y, normal, P2);
                  b2Vec2.AddVV(P1, P2, P1P2);
                  vA.SelfMulSub(mA, P1P2);
                  wA -= iA * (b2Vec2.CrossVV(cp1.rA, P1) + b2Vec2.CrossVV(cp2.rA, P2));
                  vB.SelfMulAdd(mB, P1P2);
                  wB += iB * (b2Vec2.CrossVV(cp1.rB, P1) + b2Vec2.CrossVV(cp2.rB, P2));
                  cp1.normalImpulse = x.x;
                  cp2.normalImpulse = x.y;
                  break;
                }
                x.x = 0;
                x.y = 0;
                vn1 = b.x;
                vn2 = b.y;
                if (vn1 >= 0 && vn2 >= 0) {
                  b2Vec2.SubVV(x, a, d);
                  b2Vec2.MulSV(d.x, normal, P1);
                  b2Vec2.MulSV(d.y, normal, P2);
                  b2Vec2.AddVV(P1, P2, P1P2);
                  vA.SelfMulSub(mA, P1P2);
                  wA -= iA * (b2Vec2.CrossVV(cp1.rA, P1) + b2Vec2.CrossVV(cp2.rA, P2));
                  vB.SelfMulAdd(mB, P1P2);
                  wB += iB * (b2Vec2.CrossVV(cp1.rB, P1) + b2Vec2.CrossVV(cp2.rB, P2));
                  cp1.normalImpulse = x.x;
                  cp2.normalImpulse = x.y;
                  break;
                }
                break;
              }
            }
            this.m_velocities[indexA].w = wA;
            this.m_velocities[indexB].w = wB;
          }
        };
        b2ContactSolver.prototype.StoreImpulses = function() {
          for (var i = 0; i < this.m_count; ++i) {
            var vc = this.m_velocityConstraints[i];
            var manifold = this.m_contacts[vc.contactIndex].GetManifold();
            for (var j = 0; j < vc.pointCount; ++j) {
              manifold.points[j].normalImpulse = vc.points[j].normalImpulse;
              manifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;
            }
          }
        };
        b2ContactSolver.prototype.SolvePositionConstraints = function() {
          var xfA = b2ContactSolver.SolvePositionConstraints_s_xfA;
          var xfB = b2ContactSolver.SolvePositionConstraints_s_xfB;
          var psm = b2ContactSolver.SolvePositionConstraints_s_psm;
          var rA = b2ContactSolver.SolvePositionConstraints_s_rA;
          var rB = b2ContactSolver.SolvePositionConstraints_s_rB;
          var P = b2ContactSolver.SolvePositionConstraints_s_P;
          var minSeparation = 0;
          for (var i = 0; i < this.m_count; ++i) {
            var pc = this.m_positionConstraints[i];
            var indexA = pc.indexA;
            var indexB = pc.indexB;
            var localCenterA = pc.localCenterA;
            var mA = pc.invMassA;
            var iA = pc.invIA;
            var localCenterB = pc.localCenterB;
            var mB = pc.invMassB;
            var iB = pc.invIB;
            var pointCount = pc.pointCount;
            var cA = this.m_positions[indexA].c;
            var aA = this.m_positions[indexA].a;
            var cB = this.m_positions[indexB].c;
            var aB = this.m_positions[indexB].a;
            for (var j = 0; j < pointCount; ++j) {
              xfA.q.SetAngle(aA);
              xfB.q.SetAngle(aB);
              b2Vec2.SubVV(cA, b2Rot.MulRV(xfA.q, localCenterA, b2Vec2.s_t0), xfA.p);
              b2Vec2.SubVV(cB, b2Rot.MulRV(xfB.q, localCenterB, b2Vec2.s_t0), xfB.p);
              psm.Initialize(pc, xfA, xfB, j);
              var normal = psm.normal;
              var point = psm.point;
              var separation = psm.separation;
              b2Vec2.SubVV(point, cA, rA);
              b2Vec2.SubVV(point, cB, rB);
              minSeparation = b2Min(minSeparation, separation);
              var C = b2Clamp(b2_baumgarte * (separation + b2_linearSlop), -b2_maxLinearCorrection, 0);
              var rnA = b2Vec2.CrossVV(rA, normal);
              var rnB = b2Vec2.CrossVV(rB, normal);
              var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
              var impulse = K > 0 ? -C / K : 0;
              b2Vec2.MulSV(impulse, normal, P);
              cA.SelfMulSub(mA, P);
              aA -= iA * b2Vec2.CrossVV(rA, P);
              cB.SelfMulAdd(mB, P);
              aB += iB * b2Vec2.CrossVV(rB, P);
            }
            this.m_positions[indexA].a = aA;
            this.m_positions[indexB].a = aB;
          }
          return minSeparation > -3 * b2_linearSlop;
        };
        b2ContactSolver.prototype.SolveTOIPositionConstraints = function(toiIndexA, toiIndexB) {
          var xfA = b2ContactSolver.SolveTOIPositionConstraints_s_xfA;
          var xfB = b2ContactSolver.SolveTOIPositionConstraints_s_xfB;
          var psm = b2ContactSolver.SolveTOIPositionConstraints_s_psm;
          var rA = b2ContactSolver.SolveTOIPositionConstraints_s_rA;
          var rB = b2ContactSolver.SolveTOIPositionConstraints_s_rB;
          var P = b2ContactSolver.SolveTOIPositionConstraints_s_P;
          var minSeparation = 0;
          for (var i = 0; i < this.m_count; ++i) {
            var pc = this.m_positionConstraints[i];
            var indexA = pc.indexA;
            var indexB = pc.indexB;
            var localCenterA = pc.localCenterA;
            var localCenterB = pc.localCenterB;
            var pointCount = pc.pointCount;
            var mA = 0;
            var iA = 0;
            if (indexA === toiIndexA || indexA === toiIndexB) {
              mA = pc.invMassA;
              iA = pc.invIA;
            }
            var mB = 0;
            var iB = 0;
            if (indexB === toiIndexA || indexB === toiIndexB) {
              mB = pc.invMassB;
              iB = pc.invIB;
            }
            var cA = this.m_positions[indexA].c;
            var aA = this.m_positions[indexA].a;
            var cB = this.m_positions[indexB].c;
            var aB = this.m_positions[indexB].a;
            for (var j = 0; j < pointCount; ++j) {
              xfA.q.SetAngle(aA);
              xfB.q.SetAngle(aB);
              b2Vec2.SubVV(cA, b2Rot.MulRV(xfA.q, localCenterA, b2Vec2.s_t0), xfA.p);
              b2Vec2.SubVV(cB, b2Rot.MulRV(xfB.q, localCenterB, b2Vec2.s_t0), xfB.p);
              psm.Initialize(pc, xfA, xfB, j);
              var normal = psm.normal;
              var point = psm.point;
              var separation = psm.separation;
              b2Vec2.SubVV(point, cA, rA);
              b2Vec2.SubVV(point, cB, rB);
              minSeparation = b2Min(minSeparation, separation);
              var C = b2Clamp(b2_toiBaumgarte * (separation + b2_linearSlop), -b2_maxLinearCorrection, 0);
              var rnA = b2Vec2.CrossVV(rA, normal);
              var rnB = b2Vec2.CrossVV(rB, normal);
              var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;
              var impulse = K > 0 ? -C / K : 0;
              b2Vec2.MulSV(impulse, normal, P);
              cA.SelfMulSub(mA, P);
              aA -= iA * b2Vec2.CrossVV(rA, P);
              cB.SelfMulAdd(mB, P);
              aB += iB * b2Vec2.CrossVV(rB, P);
            }
            this.m_positions[indexA].a = aA;
            this.m_positions[indexB].a = aB;
          }
          return minSeparation >= -1.5 * b2_linearSlop;
        };
        b2ContactSolver.InitializeVelocityConstraints_s_xfA = new b2Transform();
        b2ContactSolver.InitializeVelocityConstraints_s_xfB = new b2Transform();
        b2ContactSolver.InitializeVelocityConstraints_s_worldManifold = new b2WorldManifold();
        b2ContactSolver.WarmStart_s_P = new b2Vec2();
        b2ContactSolver.SolveVelocityConstraints_s_dv = new b2Vec2();
        b2ContactSolver.SolveVelocityConstraints_s_dv1 = new b2Vec2();
        b2ContactSolver.SolveVelocityConstraints_s_dv2 = new b2Vec2();
        b2ContactSolver.SolveVelocityConstraints_s_P = new b2Vec2();
        b2ContactSolver.SolveVelocityConstraints_s_a = new b2Vec2();
        b2ContactSolver.SolveVelocityConstraints_s_b = new b2Vec2();
        b2ContactSolver.SolveVelocityConstraints_s_x = new b2Vec2();
        b2ContactSolver.SolveVelocityConstraints_s_d = new b2Vec2();
        b2ContactSolver.SolveVelocityConstraints_s_P1 = new b2Vec2();
        b2ContactSolver.SolveVelocityConstraints_s_P2 = new b2Vec2();
        b2ContactSolver.SolveVelocityConstraints_s_P1P2 = new b2Vec2();
        b2ContactSolver.SolvePositionConstraints_s_xfA = new b2Transform();
        b2ContactSolver.SolvePositionConstraints_s_xfB = new b2Transform();
        b2ContactSolver.SolvePositionConstraints_s_psm = new b2PositionSolverManifold();
        b2ContactSolver.SolvePositionConstraints_s_rA = new b2Vec2();
        b2ContactSolver.SolvePositionConstraints_s_rB = new b2Vec2();
        b2ContactSolver.SolvePositionConstraints_s_P = new b2Vec2();
        b2ContactSolver.SolveTOIPositionConstraints_s_xfA = new b2Transform();
        b2ContactSolver.SolveTOIPositionConstraints_s_xfB = new b2Transform();
        b2ContactSolver.SolveTOIPositionConstraints_s_psm = new b2PositionSolverManifold();
        b2ContactSolver.SolveTOIPositionConstraints_s_rA = new b2Vec2();
        b2ContactSolver.SolveTOIPositionConstraints_s_rB = new b2Vec2();
        b2ContactSolver.SolveTOIPositionConstraints_s_P = new b2Vec2();
        return b2ContactSolver;
      })();
      var b2Island = (function() {
        function b2Island() {
          this.m_allocator = null;
          this.m_bodies = [];
          this.m_contacts = [];
          this.m_joints = [];
          this.m_positions = b2Position.MakeArray(1024);
          this.m_velocities = b2Velocity.MakeArray(1024);
          this.m_bodyCount = 0;
          this.m_jointCount = 0;
          this.m_contactCount = 0;
          this.m_bodyCapacity = 0;
          this.m_contactCapacity = 0;
          this.m_jointCapacity = 0;
        }
        b2Island.prototype.Initialize = function(bodyCapacity, contactCapacity, jointCapacity, allocator, listener) {
          this.m_bodyCapacity = bodyCapacity;
          this.m_contactCapacity = contactCapacity;
          this.m_jointCapacity = jointCapacity;
          this.m_bodyCount = 0;
          this.m_contactCount = 0;
          this.m_jointCount = 0;
          this.m_allocator = allocator;
          this.m_listener = listener;
          if (this.m_positions.length < bodyCapacity) {
            var new_length = b2Max(2 * this.m_positions.length, bodyCapacity);
            while (this.m_positions.length < new_length) this.m_positions[this.m_positions.length] = new b2Position();
          }
          if (this.m_velocities.length < bodyCapacity) {
            var new_length = b2Max(2 * this.m_velocities.length, bodyCapacity);
            while (this.m_velocities.length < new_length) this.m_velocities[this.m_velocities.length] = new b2Velocity();
          }
        };
        b2Island.prototype.Clear = function() {
          this.m_bodyCount = 0;
          this.m_contactCount = 0;
          this.m_jointCount = 0;
        };
        b2Island.prototype.AddBody = function(body) {
          body.m_islandIndex = this.m_bodyCount;
          this.m_bodies[this.m_bodyCount++] = body;
        };
        b2Island.prototype.AddContact = function(contact) {
          this.m_contacts[this.m_contactCount++] = contact;
        };
        b2Island.prototype.AddJoint = function(joint) {
          this.m_joints[this.m_jointCount++] = joint;
        };
        b2Island.prototype.Solve = function(profile, step, gravity, allowSleep) {
          var timer = b2Island.s_timer.Reset();
          var h = step.dt;
          for (var i = 0; i < this.m_bodyCount; ++i) {
            var b = this.m_bodies[i];
            this.m_positions[i].c.Copy(b.m_sweep.c);
            var a = b.m_sweep.a;
            var v = this.m_velocities[i].v.Copy(b.m_linearVelocity);
            var w = b.m_angularVelocity;
            b.m_sweep.c0.Copy(b.m_sweep.c);
            b.m_sweep.a0 = b.m_sweep.a;
            if (b.m_type === exports.b2BodyType.b2_dynamicBody) {
              v.x += h * (b.m_gravityScale * gravity.x + b.m_invMass * b.m_force.x);
              v.y += h * (b.m_gravityScale * gravity.y + b.m_invMass * b.m_force.y);
              w += h * b.m_invI * b.m_torque;
              v.SelfMul(1 / (1 + h * b.m_linearDamping));
              w *= 1 / (1 + h * b.m_angularDamping);
            }
            this.m_positions[i].a = a;
            this.m_velocities[i].w = w;
          }
          timer.Reset();
          var solverData = b2Island.s_solverData;
          solverData.step.Copy(step);
          solverData.positions = this.m_positions;
          solverData.velocities = this.m_velocities;
          var contactSolverDef = b2Island.s_contactSolverDef;
          contactSolverDef.step.Copy(step);
          contactSolverDef.contacts = this.m_contacts;
          contactSolverDef.count = this.m_contactCount;
          contactSolverDef.positions = this.m_positions;
          contactSolverDef.velocities = this.m_velocities;
          contactSolverDef.allocator = this.m_allocator;
          var contactSolver = b2Island.s_contactSolver.Initialize(contactSolverDef);
          contactSolver.InitializeVelocityConstraints();
          step.warmStarting && contactSolver.WarmStart();
          for (var i = 0; i < this.m_jointCount; ++i) this.m_joints[i].InitVelocityConstraints(solverData);
          profile.solveInit = timer.GetMilliseconds();
          timer.Reset();
          for (var i = 0; i < step.velocityIterations; ++i) {
            for (var j = 0; j < this.m_jointCount; ++j) this.m_joints[j].SolveVelocityConstraints(solverData);
            contactSolver.SolveVelocityConstraints();
          }
          contactSolver.StoreImpulses();
          profile.solveVelocity = timer.GetMilliseconds();
          for (var i = 0; i < this.m_bodyCount; ++i) {
            var c = this.m_positions[i].c;
            var a = this.m_positions[i].a;
            var v = this.m_velocities[i].v;
            var w = this.m_velocities[i].w;
            var translation = b2Vec2.MulSV(h, v, b2Island.s_translation);
            if (b2Vec2.DotVV(translation, translation) > b2_maxTranslationSquared) {
              var ratio = b2_maxTranslation / translation.Length();
              v.SelfMul(ratio);
            }
            var rotation = h * w;
            if (rotation * rotation > b2_maxRotationSquared) {
              var ratio = b2_maxRotation / b2Abs(rotation);
              w *= ratio;
            }
            c.x += h * v.x;
            c.y += h * v.y;
            a += h * w;
            this.m_positions[i].a = a;
            this.m_velocities[i].w = w;
          }
          timer.Reset();
          var positionSolved = false;
          for (var i = 0; i < step.positionIterations; ++i) {
            var contactsOkay = contactSolver.SolvePositionConstraints();
            var jointsOkay = true;
            for (var j = 0; j < this.m_jointCount; ++j) {
              var jointOkay = this.m_joints[j].SolvePositionConstraints(solverData);
              jointsOkay = jointsOkay && jointOkay;
            }
            if (contactsOkay && jointsOkay) {
              positionSolved = true;
              break;
            }
          }
          for (var i = 0; i < this.m_bodyCount; ++i) {
            var body = this.m_bodies[i];
            body.m_sweep.c.Copy(this.m_positions[i].c);
            body.m_sweep.a = this.m_positions[i].a;
            body.m_linearVelocity.Copy(this.m_velocities[i].v);
            body.m_angularVelocity = this.m_velocities[i].w;
            body.SynchronizeTransform();
          }
          profile.solvePosition = timer.GetMilliseconds();
          this.Report(contactSolver.m_velocityConstraints);
          if (allowSleep) {
            var minSleepTime = b2_maxFloat;
            var linTolSqr = b2_linearSleepTolerance * b2_linearSleepTolerance;
            var angTolSqr = b2_angularSleepTolerance * b2_angularSleepTolerance;
            for (var i = 0; i < this.m_bodyCount; ++i) {
              var b = this.m_bodies[i];
              if (b.GetType() === exports.b2BodyType.b2_staticBody) continue;
              if (!b.m_autoSleepFlag || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Vec2.DotVV(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
                b.m_sleepTime = 0;
                minSleepTime = 0;
              } else {
                b.m_sleepTime += h;
                minSleepTime = b2Min(minSleepTime, b.m_sleepTime);
              }
            }
            if (minSleepTime >= b2_timeToSleep && positionSolved) for (var i = 0; i < this.m_bodyCount; ++i) {
              var b = this.m_bodies[i];
              b.SetAwake(false);
            }
          }
        };
        b2Island.prototype.SolveTOI = function(subStep, toiIndexA, toiIndexB) {
          for (var i = 0; i < this.m_bodyCount; ++i) {
            var b = this.m_bodies[i];
            this.m_positions[i].c.Copy(b.m_sweep.c);
            this.m_positions[i].a = b.m_sweep.a;
            this.m_velocities[i].v.Copy(b.m_linearVelocity);
            this.m_velocities[i].w = b.m_angularVelocity;
          }
          var contactSolverDef = b2Island.s_contactSolverDef;
          contactSolverDef.contacts = this.m_contacts;
          contactSolverDef.count = this.m_contactCount;
          contactSolverDef.allocator = this.m_allocator;
          contactSolverDef.step.Copy(subStep);
          contactSolverDef.positions = this.m_positions;
          contactSolverDef.velocities = this.m_velocities;
          var contactSolver = b2Island.s_contactSolver.Initialize(contactSolverDef);
          for (var i = 0; i < subStep.positionIterations; ++i) {
            var contactsOkay = contactSolver.SolveTOIPositionConstraints(toiIndexA, toiIndexB);
            if (contactsOkay) break;
          }
          this.m_bodies[toiIndexA].m_sweep.c0.Copy(this.m_positions[toiIndexA].c);
          this.m_bodies[toiIndexA].m_sweep.a0 = this.m_positions[toiIndexA].a;
          this.m_bodies[toiIndexB].m_sweep.c0.Copy(this.m_positions[toiIndexB].c);
          this.m_bodies[toiIndexB].m_sweep.a0 = this.m_positions[toiIndexB].a;
          contactSolver.InitializeVelocityConstraints();
          for (var i = 0; i < subStep.velocityIterations; ++i) contactSolver.SolveVelocityConstraints();
          var h = subStep.dt;
          for (var i = 0; i < this.m_bodyCount; ++i) {
            var c = this.m_positions[i].c;
            var a = this.m_positions[i].a;
            var v = this.m_velocities[i].v;
            var w = this.m_velocities[i].w;
            var translation = b2Vec2.MulSV(h, v, b2Island.s_translation);
            if (b2Vec2.DotVV(translation, translation) > b2_maxTranslationSquared) {
              var ratio = b2_maxTranslation / translation.Length();
              v.SelfMul(ratio);
            }
            var rotation = h * w;
            if (rotation * rotation > b2_maxRotationSquared) {
              var ratio = b2_maxRotation / b2Abs(rotation);
              w *= ratio;
            }
            c.SelfMulAdd(h, v);
            a += h * w;
            this.m_positions[i].a = a;
            this.m_velocities[i].w = w;
            var body = this.m_bodies[i];
            body.m_sweep.c.Copy(c);
            body.m_sweep.a = a;
            body.m_linearVelocity.Copy(v);
            body.m_angularVelocity = w;
            body.SynchronizeTransform();
          }
          this.Report(contactSolver.m_velocityConstraints);
        };
        b2Island.prototype.Report = function(constraints) {
          if (null === this.m_listener) return;
          for (var i = 0; i < this.m_contactCount; ++i) {
            var c = this.m_contacts[i];
            if (!c) continue;
            var vc = constraints[i];
            var impulse = b2Island.s_impulse;
            impulse.count = vc.pointCount;
            for (var j = 0; j < vc.pointCount; ++j) {
              impulse.normalImpulses[j] = vc.points[j].normalImpulse;
              impulse.tangentImpulses[j] = vc.points[j].tangentImpulse;
            }
            this.m_listener.PostSolve(c, impulse);
          }
        };
        b2Island.s_timer = new b2Timer();
        b2Island.s_solverData = new b2SolverData();
        b2Island.s_contactSolverDef = new b2ContactSolverDef();
        b2Island.s_contactSolver = new b2ContactSolver();
        b2Island.s_translation = new b2Vec2();
        b2Island.s_impulse = new b2ContactImpulse();
        return b2Island;
      })();
      (function(b2ParticleFlag) {
        b2ParticleFlag[b2ParticleFlag["b2_waterParticle"] = 0] = "b2_waterParticle";
        b2ParticleFlag[b2ParticleFlag["b2_zombieParticle"] = 2] = "b2_zombieParticle";
        b2ParticleFlag[b2ParticleFlag["b2_wallParticle"] = 4] = "b2_wallParticle";
        b2ParticleFlag[b2ParticleFlag["b2_springParticle"] = 8] = "b2_springParticle";
        b2ParticleFlag[b2ParticleFlag["b2_elasticParticle"] = 16] = "b2_elasticParticle";
        b2ParticleFlag[b2ParticleFlag["b2_viscousParticle"] = 32] = "b2_viscousParticle";
        b2ParticleFlag[b2ParticleFlag["b2_powderParticle"] = 64] = "b2_powderParticle";
        b2ParticleFlag[b2ParticleFlag["b2_tensileParticle"] = 128] = "b2_tensileParticle";
        b2ParticleFlag[b2ParticleFlag["b2_colorMixingParticle"] = 256] = "b2_colorMixingParticle";
        b2ParticleFlag[b2ParticleFlag["b2_destructionListenerParticle"] = 512] = "b2_destructionListenerParticle";
        b2ParticleFlag[b2ParticleFlag["b2_barrierParticle"] = 1024] = "b2_barrierParticle";
        b2ParticleFlag[b2ParticleFlag["b2_staticPressureParticle"] = 2048] = "b2_staticPressureParticle";
        b2ParticleFlag[b2ParticleFlag["b2_reactiveParticle"] = 4096] = "b2_reactiveParticle";
        b2ParticleFlag[b2ParticleFlag["b2_repulsiveParticle"] = 8192] = "b2_repulsiveParticle";
        b2ParticleFlag[b2ParticleFlag["b2_fixtureContactListenerParticle"] = 16384] = "b2_fixtureContactListenerParticle";
        b2ParticleFlag[b2ParticleFlag["b2_particleContactListenerParticle"] = 32768] = "b2_particleContactListenerParticle";
        b2ParticleFlag[b2ParticleFlag["b2_fixtureContactFilterParticle"] = 65536] = "b2_fixtureContactFilterParticle";
        b2ParticleFlag[b2ParticleFlag["b2_particleContactFilterParticle"] = 131072] = "b2_particleContactFilterParticle";
      })(exports.b2ParticleFlag || (exports.b2ParticleFlag = {}));
      var b2ParticleDef = (function() {
        function b2ParticleDef() {
          this.flags = 0;
          this.position = new b2Vec2();
          this.velocity = new b2Vec2();
          this.color = new b2Color(0, 0, 0, 0);
          this.lifetime = 0;
          this.userData = null;
          this.group = null;
        }
        return b2ParticleDef;
      })();
      function b2CalculateParticleIterations(gravity, radius, timeStep) {
        var B2_MAX_RECOMMENDED_PARTICLE_ITERATIONS = 8;
        var B2_RADIUS_THRESHOLD = .01;
        var iterations = Math.ceil(Math.sqrt(gravity / (B2_RADIUS_THRESHOLD * radius)) * timeStep);
        return b2Clamp(iterations, 1, B2_MAX_RECOMMENDED_PARTICLE_ITERATIONS);
      }
      var b2ParticleHandle = (function() {
        function b2ParticleHandle() {
          this.m_index = b2_invalidParticleIndex;
        }
        b2ParticleHandle.prototype.GetIndex = function() {
          return this.m_index;
        };
        b2ParticleHandle.prototype.SetIndex = function(index) {
          this.m_index = index;
        };
        return b2ParticleHandle;
      })();
      (function(b2ParticleGroupFlag) {
        b2ParticleGroupFlag[b2ParticleGroupFlag["b2_solidParticleGroup"] = 1] = "b2_solidParticleGroup";
        b2ParticleGroupFlag[b2ParticleGroupFlag["b2_rigidParticleGroup"] = 2] = "b2_rigidParticleGroup";
        b2ParticleGroupFlag[b2ParticleGroupFlag["b2_particleGroupCanBeEmpty"] = 4] = "b2_particleGroupCanBeEmpty";
        b2ParticleGroupFlag[b2ParticleGroupFlag["b2_particleGroupWillBeDestroyed"] = 8] = "b2_particleGroupWillBeDestroyed";
        b2ParticleGroupFlag[b2ParticleGroupFlag["b2_particleGroupNeedsUpdateDepth"] = 16] = "b2_particleGroupNeedsUpdateDepth";
        b2ParticleGroupFlag[b2ParticleGroupFlag["b2_particleGroupInternalMask"] = 24] = "b2_particleGroupInternalMask";
      })(exports.b2ParticleGroupFlag || (exports.b2ParticleGroupFlag = {}));
      var b2ParticleGroupDef = (function() {
        function b2ParticleGroupDef() {
          this.flags = 0;
          this.groupFlags = 0;
          this.position = new b2Vec2();
          this.angle = 0;
          this.linearVelocity = new b2Vec2();
          this.angularVelocity = 0;
          this.color = new b2Color();
          this.strength = 1;
          this.shapeCount = 0;
          this.stride = 0;
          this.particleCount = 0;
          this.lifetime = 0;
          this.userData = null;
          this.group = null;
        }
        return b2ParticleGroupDef;
      })();
      var b2ParticleGroup = (function() {
        function b2ParticleGroup(system) {
          this.m_firstIndex = 0;
          this.m_lastIndex = 0;
          this.m_groupFlags = 0;
          this.m_strength = 1;
          this.m_prev = null;
          this.m_next = null;
          this.m_timestamp = -1;
          this.m_mass = 0;
          this.m_inertia = 0;
          this.m_center = new b2Vec2();
          this.m_linearVelocity = new b2Vec2();
          this.m_angularVelocity = 0;
          this.m_transform = new b2Transform();
          this.m_userData = null;
          this.m_system = system;
        }
        b2ParticleGroup.prototype.GetNext = function() {
          return this.m_next;
        };
        b2ParticleGroup.prototype.GetParticleSystem = function() {
          return this.m_system;
        };
        b2ParticleGroup.prototype.GetParticleCount = function() {
          return this.m_lastIndex - this.m_firstIndex;
        };
        b2ParticleGroup.prototype.GetBufferIndex = function() {
          return this.m_firstIndex;
        };
        b2ParticleGroup.prototype.ContainsParticle = function(index) {
          return this.m_firstIndex <= index && index < this.m_lastIndex;
        };
        b2ParticleGroup.prototype.GetAllParticleFlags = function() {
          if (!this.m_system.m_flagsBuffer.data) throw new Error();
          var flags = 0;
          for (var i = this.m_firstIndex; i < this.m_lastIndex; i++) flags |= this.m_system.m_flagsBuffer.data[i];
          return flags;
        };
        b2ParticleGroup.prototype.GetGroupFlags = function() {
          return this.m_groupFlags;
        };
        b2ParticleGroup.prototype.SetGroupFlags = function(flags) {
          flags |= this.m_groupFlags & exports.b2ParticleGroupFlag.b2_particleGroupInternalMask;
          this.m_system.SetGroupFlags(this, flags);
        };
        b2ParticleGroup.prototype.GetMass = function() {
          this.UpdateStatistics();
          return this.m_mass;
        };
        b2ParticleGroup.prototype.GetInertia = function() {
          this.UpdateStatistics();
          return this.m_inertia;
        };
        b2ParticleGroup.prototype.GetCenter = function() {
          this.UpdateStatistics();
          return this.m_center;
        };
        b2ParticleGroup.prototype.GetLinearVelocity = function() {
          this.UpdateStatistics();
          return this.m_linearVelocity;
        };
        b2ParticleGroup.prototype.GetAngularVelocity = function() {
          this.UpdateStatistics();
          return this.m_angularVelocity;
        };
        b2ParticleGroup.prototype.GetTransform = function() {
          return this.m_transform;
        };
        b2ParticleGroup.prototype.GetPosition = function() {
          return this.m_transform.p;
        };
        b2ParticleGroup.prototype.GetAngle = function() {
          return this.m_transform.q.GetAngle();
        };
        b2ParticleGroup.prototype.GetLinearVelocityFromWorldPoint = function(worldPoint, out) {
          var s_t0 = b2ParticleGroup.GetLinearVelocityFromWorldPoint_s_t0;
          this.UpdateStatistics();
          return b2Vec2.AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, b2Vec2.SubVV(worldPoint, this.m_center, s_t0), out);
        };
        b2ParticleGroup.prototype.GetUserData = function() {
          return this.m_userData;
        };
        b2ParticleGroup.prototype.SetUserData = function(data) {
          this.m_userData = data;
        };
        b2ParticleGroup.prototype.ApplyForce = function(force) {
          this.m_system.ApplyForce(this.m_firstIndex, this.m_lastIndex, force);
        };
        b2ParticleGroup.prototype.ApplyLinearImpulse = function(impulse) {
          this.m_system.ApplyLinearImpulse(this.m_firstIndex, this.m_lastIndex, impulse);
        };
        b2ParticleGroup.prototype.DestroyParticles = function(callDestructionListener) {
          if (this.m_system.m_world.IsLocked()) throw new Error();
          for (var i = this.m_firstIndex; i < this.m_lastIndex; i++) this.m_system.DestroyParticle(i, callDestructionListener);
        };
        b2ParticleGroup.prototype.UpdateStatistics = function() {
          if (!this.m_system.m_positionBuffer.data) throw new Error();
          if (!this.m_system.m_velocityBuffer.data) throw new Error();
          var p = new b2Vec2();
          var v = new b2Vec2();
          if (this.m_timestamp !== this.m_system.m_timestamp) {
            var m = this.m_system.GetParticleMass();
            this.m_mass = m * (this.m_lastIndex - this.m_firstIndex);
            this.m_center.SetZero();
            this.m_linearVelocity.SetZero();
            for (var i = this.m_firstIndex; i < this.m_lastIndex; i++) {
              this.m_center.SelfMulAdd(m, this.m_system.m_positionBuffer.data[i]);
              this.m_linearVelocity.SelfMulAdd(m, this.m_system.m_velocityBuffer.data[i]);
            }
            if (this.m_mass > 0) {
              var inv_mass = 1 / this.m_mass;
              this.m_center.SelfMul(inv_mass);
              this.m_linearVelocity.SelfMul(inv_mass);
            }
            this.m_inertia = 0;
            this.m_angularVelocity = 0;
            for (var i = this.m_firstIndex; i < this.m_lastIndex; i++) {
              b2Vec2.SubVV(this.m_system.m_positionBuffer.data[i], this.m_center, p);
              b2Vec2.SubVV(this.m_system.m_velocityBuffer.data[i], this.m_linearVelocity, v);
              this.m_inertia += m * b2Vec2.DotVV(p, p);
              this.m_angularVelocity += m * b2Vec2.CrossVV(p, v);
            }
            this.m_inertia > 0 && (this.m_angularVelocity *= 1 / this.m_inertia);
            this.m_timestamp = this.m_system.m_timestamp;
          }
        };
        b2ParticleGroup.GetLinearVelocityFromWorldPoint_s_t0 = new b2Vec2();
        return b2ParticleGroup;
      })();
      var b2StackQueue = (function() {
        function b2StackQueue(capacity) {
          this.m_front = 0;
          this.m_back = 0;
          this.m_capacity = 0;
          this.m_buffer = b2MakeArray(capacity, (function(index) {
            return null;
          }));
          this.m_capacity = capacity;
        }
        b2StackQueue.prototype.Push = function(item) {
          if (this.m_back >= this.m_capacity) {
            for (var i = this.m_front; i < this.m_back; i++) this.m_buffer[i - this.m_front] = this.m_buffer[i];
            this.m_back -= this.m_front;
            this.m_front = 0;
            if (this.m_back >= this.m_capacity) if (this.m_capacity > 0) {
              this.m_buffer.concat(b2MakeArray(this.m_capacity, (function(index) {
                return null;
              })));
              this.m_capacity *= 2;
            } else {
              this.m_buffer.concat(b2MakeArray(1, (function(index) {
                return null;
              })));
              this.m_capacity = 1;
            }
          }
          this.m_buffer[this.m_back] = item;
          this.m_back++;
        };
        b2StackQueue.prototype.Pop = function() {
          this.m_buffer[this.m_front] = null;
          this.m_front++;
        };
        b2StackQueue.prototype.Empty = function() {
          return this.m_front === this.m_back;
        };
        b2StackQueue.prototype.Front = function() {
          var item = this.m_buffer[this.m_front];
          if (!item) throw new Error();
          return item;
        };
        return b2StackQueue;
      })();
      var b2VoronoiDiagram = (function() {
        function b2VoronoiDiagram(generatorCapacity) {
          this.m_generatorCapacity = 0;
          this.m_generatorCount = 0;
          this.m_countX = 0;
          this.m_countY = 0;
          this.m_diagram = [];
          this.m_generatorBuffer = b2MakeArray(generatorCapacity, (function(index) {
            return new b2VoronoiDiagram.Generator();
          }));
          this.m_generatorCapacity = generatorCapacity;
        }
        b2VoronoiDiagram.prototype.AddGenerator = function(center, tag, necessary) {
          var g = this.m_generatorBuffer[this.m_generatorCount++];
          g.center.Copy(center);
          g.tag = tag;
          g.necessary = necessary;
        };
        b2VoronoiDiagram.prototype.Generate = function(radius, margin) {
          var inverseRadius = 1 / radius;
          var lower = new b2Vec2(+b2_maxFloat, +b2_maxFloat);
          var upper = new b2Vec2(-b2_maxFloat, -b2_maxFloat);
          var necessary_count = 0;
          for (var k = 0; k < this.m_generatorCount; k++) {
            var g = this.m_generatorBuffer[k];
            if (g.necessary) {
              b2Vec2.MinV(lower, g.center, lower);
              b2Vec2.MaxV(upper, g.center, upper);
              ++necessary_count;
            }
          }
          if (0 === necessary_count) {
            this.m_countX = 0;
            this.m_countY = 0;
            return;
          }
          lower.x -= margin;
          lower.y -= margin;
          upper.x += margin;
          upper.y += margin;
          this.m_countX = 1 + Math.floor(inverseRadius * (upper.x - lower.x));
          this.m_countY = 1 + Math.floor(inverseRadius * (upper.y - lower.y));
          this.m_diagram = [];
          var queue = new b2StackQueue(4 * this.m_countX * this.m_countY);
          for (var k = 0; k < this.m_generatorCount; k++) {
            var g = this.m_generatorBuffer[k];
            g.center.SelfSub(lower).SelfMul(inverseRadius);
            var x = Math.floor(g.center.x);
            var y = Math.floor(g.center.y);
            x >= 0 && y >= 0 && x < this.m_countX && y < this.m_countY && queue.Push(new b2VoronoiDiagram.Task(x, y, x + y * this.m_countX, g));
          }
          while (!queue.Empty()) {
            var task = queue.Front();
            var x = task.m_x;
            var y = task.m_y;
            var i = task.m_i;
            var g = task.m_generator;
            queue.Pop();
            if (!this.m_diagram[i]) {
              this.m_diagram[i] = g;
              x > 0 && queue.Push(new b2VoronoiDiagram.Task(x - 1, y, i - 1, g));
              y > 0 && queue.Push(new b2VoronoiDiagram.Task(x, y - 1, i - this.m_countX, g));
              x < this.m_countX - 1 && queue.Push(new b2VoronoiDiagram.Task(x + 1, y, i + 1, g));
              y < this.m_countY - 1 && queue.Push(new b2VoronoiDiagram.Task(x, y + 1, i + this.m_countX, g));
            }
          }
          for (var y = 0; y < this.m_countY; y++) for (var x = 0; x < this.m_countX - 1; x++) {
            var i = x + y * this.m_countX;
            var a = this.m_diagram[i];
            var b = this.m_diagram[i + 1];
            if (a !== b) {
              queue.Push(new b2VoronoiDiagram.Task(x, y, i, b));
              queue.Push(new b2VoronoiDiagram.Task(x + 1, y, i + 1, a));
            }
          }
          for (var y = 0; y < this.m_countY - 1; y++) for (var x = 0; x < this.m_countX; x++) {
            var i = x + y * this.m_countX;
            var a = this.m_diagram[i];
            var b = this.m_diagram[i + this.m_countX];
            if (a !== b) {
              queue.Push(new b2VoronoiDiagram.Task(x, y, i, b));
              queue.Push(new b2VoronoiDiagram.Task(x, y + 1, i + this.m_countX, a));
            }
          }
          while (!queue.Empty()) {
            var task = queue.Front();
            var x = task.m_x;
            var y = task.m_y;
            var i = task.m_i;
            var k = task.m_generator;
            queue.Pop();
            var a = this.m_diagram[i];
            var b = k;
            if (a !== b) {
              var ax = a.center.x - x;
              var ay = a.center.y - y;
              var bx = b.center.x - x;
              var by = b.center.y - y;
              var a2 = ax * ax + ay * ay;
              var b2 = bx * bx + by * by;
              if (a2 > b2) {
                this.m_diagram[i] = b;
                x > 0 && queue.Push(new b2VoronoiDiagram.Task(x - 1, y, i - 1, b));
                y > 0 && queue.Push(new b2VoronoiDiagram.Task(x, y - 1, i - this.m_countX, b));
                x < this.m_countX - 1 && queue.Push(new b2VoronoiDiagram.Task(x + 1, y, i + 1, b));
                y < this.m_countY - 1 && queue.Push(new b2VoronoiDiagram.Task(x, y + 1, i + this.m_countX, b));
              }
            }
          }
        };
        b2VoronoiDiagram.prototype.GetNodes = function(callback) {
          for (var y = 0; y < this.m_countY - 1; y++) for (var x = 0; x < this.m_countX - 1; x++) {
            var i = x + y * this.m_countX;
            var a = this.m_diagram[i];
            var b = this.m_diagram[i + 1];
            var c = this.m_diagram[i + this.m_countX];
            var d = this.m_diagram[i + 1 + this.m_countX];
            if (b !== c) {
              a !== b && a !== c && (a.necessary || b.necessary || c.necessary) && callback(a.tag, b.tag, c.tag);
              d !== b && d !== c && (a.necessary || b.necessary || c.necessary) && callback(b.tag, d.tag, c.tag);
            }
          }
        };
        return b2VoronoiDiagram;
      })();
      (function(b2VoronoiDiagram) {
        var Generator = (function() {
          function Generator() {
            this.center = new b2Vec2();
            this.tag = 0;
            this.necessary = false;
          }
          return Generator;
        })();
        b2VoronoiDiagram.Generator = Generator;
        var Task = (function() {
          function Task(x, y, i, g) {
            this.m_x = x;
            this.m_y = y;
            this.m_i = i;
            this.m_generator = g;
          }
          return Task;
        })();
        b2VoronoiDiagram.Task = Task;
      })(b2VoronoiDiagram || (b2VoronoiDiagram = {}));
      function std_iter_swap(array, a, b) {
        var tmp = array[a];
        array[a] = array[b];
        array[b] = tmp;
      }
      function default_compare(a, b) {
        return a < b;
      }
      function std_sort(array, first, len, cmp) {
        void 0 === first && (first = 0);
        void 0 === len && (len = array.length - first);
        void 0 === cmp && (cmp = default_compare);
        var left = first;
        var stack = [];
        var pos = 0;
        for (;;) {
          for (;left + 1 < len; len++) {
            var pivot = array[left + Math.floor(Math.random() * (len - left))];
            stack[pos++] = len;
            for (var right = left - 1; ;) {
              while (cmp(array[++right], pivot)) ;
              while (cmp(pivot, array[--len])) ;
              if (right >= len) break;
              std_iter_swap(array, right, len);
            }
          }
          if (0 === pos) break;
          left = len;
          len = stack[--pos];
        }
        return array;
      }
      function std_stable_sort(array, first, len, cmp) {
        void 0 === first && (first = 0);
        void 0 === len && (len = array.length - first);
        void 0 === cmp && (cmp = default_compare);
        return std_sort(array, first, len, cmp);
      }
      function std_remove_if(array, predicate, length) {
        void 0 === length && (length = array.length);
        var l = 0;
        for (var c = 0; c < length; ++c) {
          if (predicate(array[c])) continue;
          if (c === l) {
            ++l;
            continue;
          }
          std_iter_swap(array, l++, c);
        }
        return l;
      }
      function std_lower_bound(array, first, last, val, cmp) {
        void 0 === cmp && (cmp = default_compare);
        var count = last - first;
        while (count > 0) {
          var step = Math.floor(count / 2);
          var it = first + step;
          if (cmp(array[it], val)) {
            first = ++it;
            count -= step + 1;
          } else count = step;
        }
        return first;
      }
      function std_upper_bound(array, first, last, val, cmp) {
        void 0 === cmp && (cmp = default_compare);
        var count = last - first;
        while (count > 0) {
          var step = Math.floor(count / 2);
          var it = first + step;
          if (cmp(val, array[it])) count = step; else {
            first = ++it;
            count -= step + 1;
          }
        }
        return first;
      }
      function std_rotate(array, first, n_first, last) {
        var next = n_first;
        while (first !== next) {
          std_iter_swap(array, first++, next++);
          next === last ? next = n_first : first === n_first && (n_first = next);
        }
      }
      function std_unique(array, first, last, cmp) {
        if (first === last) return last;
        var result = first;
        while (++first !== last) cmp(array[result], array[first]) || std_iter_swap(array, ++result, first);
        return ++result;
      }
      var b2GrowableBuffer = (function() {
        function b2GrowableBuffer(allocator) {
          this.data = [];
          this.count = 0;
          this.capacity = 0;
          this.allocator = allocator;
        }
        b2GrowableBuffer.prototype.Append = function() {
          this.count >= this.capacity && this.Grow();
          return this.count++;
        };
        b2GrowableBuffer.prototype.Reserve = function(newCapacity) {
          if (this.capacity >= newCapacity) return;
          for (var i = this.capacity; i < newCapacity; ++i) this.data[i] = this.allocator();
          this.capacity = newCapacity;
        };
        b2GrowableBuffer.prototype.Grow = function() {
          var newCapacity = this.capacity ? 2 * this.capacity : b2_minParticleSystemBufferCapacity;
          this.Reserve(newCapacity);
        };
        b2GrowableBuffer.prototype.Free = function() {
          if (0 === this.data.length) return;
          this.data = [];
          this.capacity = 0;
          this.count = 0;
        };
        b2GrowableBuffer.prototype.Shorten = function(newEnd) {};
        b2GrowableBuffer.prototype.Data = function() {
          return this.data;
        };
        b2GrowableBuffer.prototype.GetCount = function() {
          return this.count;
        };
        b2GrowableBuffer.prototype.SetCount = function(newCount) {
          this.count = newCount;
        };
        b2GrowableBuffer.prototype.GetCapacity = function() {
          return this.capacity;
        };
        b2GrowableBuffer.prototype.RemoveIf = function(pred) {
          this.count = std_remove_if(this.data, pred, this.count);
        };
        b2GrowableBuffer.prototype.Unique = function(pred) {
          this.count = std_unique(this.data, 0, this.count, pred);
        };
        return b2GrowableBuffer;
      })();
      var b2FixtureParticleQueryCallback = (function(_super) {
        __extends(b2FixtureParticleQueryCallback, _super);
        function b2FixtureParticleQueryCallback(system) {
          var _this = _super.call(this) || this;
          _this.m_system = system;
          return _this;
        }
        b2FixtureParticleQueryCallback.prototype.ShouldQueryParticleSystem = function(system) {
          return false;
        };
        b2FixtureParticleQueryCallback.prototype.ReportFixture = function(fixture) {
          if (fixture.IsSensor()) return true;
          var shape = fixture.GetShape();
          var childCount = shape.GetChildCount();
          for (var childIndex = 0; childIndex < childCount; childIndex++) {
            var aabb = fixture.GetAABB(childIndex);
            var enumerator = this.m_system.GetInsideBoundsEnumerator(aabb);
            var index = void 0;
            while ((index = enumerator.GetNext()) >= 0) this.ReportFixtureAndParticle(fixture, childIndex, index);
          }
          return true;
        };
        b2FixtureParticleQueryCallback.prototype.ReportParticle = function(system, index) {
          return false;
        };
        b2FixtureParticleQueryCallback.prototype.ReportFixtureAndParticle = function(fixture, childIndex, index) {};
        return b2FixtureParticleQueryCallback;
      })(b2QueryCallback);
      var b2ParticleContact = (function() {
        function b2ParticleContact() {
          this.indexA = 0;
          this.indexB = 0;
          this.weight = 0;
          this.normal = new b2Vec2();
          this.flags = 0;
        }
        b2ParticleContact.prototype.SetIndices = function(a, b) {
          this.indexA = a;
          this.indexB = b;
        };
        b2ParticleContact.prototype.SetWeight = function(w) {
          this.weight = w;
        };
        b2ParticleContact.prototype.SetNormal = function(n) {
          this.normal.Copy(n);
        };
        b2ParticleContact.prototype.SetFlags = function(f) {
          this.flags = f;
        };
        b2ParticleContact.prototype.GetIndexA = function() {
          return this.indexA;
        };
        b2ParticleContact.prototype.GetIndexB = function() {
          return this.indexB;
        };
        b2ParticleContact.prototype.GetWeight = function() {
          return this.weight;
        };
        b2ParticleContact.prototype.GetNormal = function() {
          return this.normal;
        };
        b2ParticleContact.prototype.GetFlags = function() {
          return this.flags;
        };
        b2ParticleContact.prototype.IsEqual = function(rhs) {
          return this.indexA === rhs.indexA && this.indexB === rhs.indexB && this.flags === rhs.flags && this.weight === rhs.weight && this.normal.x === rhs.normal.x && this.normal.y === rhs.normal.y;
        };
        b2ParticleContact.prototype.IsNotEqual = function(rhs) {
          return !this.IsEqual(rhs);
        };
        b2ParticleContact.prototype.ApproximatelyEqual = function(rhs) {
          var MAX_WEIGHT_DIFF = .01;
          var MAX_NORMAL_DIFF_SQ = 1e-4;
          return this.indexA === rhs.indexA && this.indexB === rhs.indexB && this.flags === rhs.flags && b2Abs(this.weight - rhs.weight) < MAX_WEIGHT_DIFF && b2Vec2.DistanceSquaredVV(this.normal, rhs.normal) < MAX_NORMAL_DIFF_SQ;
        };
        return b2ParticleContact;
      })();
      var b2ParticleBodyContact = (function() {
        function b2ParticleBodyContact() {
          this.index = 0;
          this.weight = 0;
          this.normal = new b2Vec2();
          this.mass = 0;
        }
        return b2ParticleBodyContact;
      })();
      var b2ParticlePair = (function() {
        function b2ParticlePair() {
          this.indexA = 0;
          this.indexB = 0;
          this.flags = 0;
          this.strength = 0;
          this.distance = 0;
        }
        return b2ParticlePair;
      })();
      var b2ParticleTriad = (function() {
        function b2ParticleTriad() {
          this.indexA = 0;
          this.indexB = 0;
          this.indexC = 0;
          this.flags = 0;
          this.strength = 0;
          this.pa = new b2Vec2(0, 0);
          this.pb = new b2Vec2(0, 0);
          this.pc = new b2Vec2(0, 0);
          this.ka = 0;
          this.kb = 0;
          this.kc = 0;
          this.s = 0;
        }
        return b2ParticleTriad;
      })();
      var b2ParticleSystemDef = (function() {
        function b2ParticleSystemDef() {
          this.strictContactCheck = false;
          this.density = 1;
          this.gravityScale = 1;
          this.radius = 1;
          this.maxCount = 0;
          this.pressureStrength = .005;
          this.dampingStrength = 1;
          this.elasticStrength = .25;
          this.springStrength = .25;
          this.viscousStrength = .25;
          this.surfaceTensionPressureStrength = .2;
          this.surfaceTensionNormalStrength = .2;
          this.repulsiveStrength = 1;
          this.powderStrength = .5;
          this.ejectionStrength = .5;
          this.staticPressureStrength = .2;
          this.staticPressureRelaxation = .2;
          this.staticPressureIterations = 8;
          this.colorMixingStrength = .5;
          this.destroyByAge = true;
          this.lifetimeGranularity = 1 / 60;
        }
        b2ParticleSystemDef.prototype.Copy = function(def) {
          this.strictContactCheck = def.strictContactCheck;
          this.density = def.density;
          this.gravityScale = def.gravityScale;
          this.radius = def.radius;
          this.maxCount = def.maxCount;
          this.pressureStrength = def.pressureStrength;
          this.dampingStrength = def.dampingStrength;
          this.elasticStrength = def.elasticStrength;
          this.springStrength = def.springStrength;
          this.viscousStrength = def.viscousStrength;
          this.surfaceTensionPressureStrength = def.surfaceTensionPressureStrength;
          this.surfaceTensionNormalStrength = def.surfaceTensionNormalStrength;
          this.repulsiveStrength = def.repulsiveStrength;
          this.powderStrength = def.powderStrength;
          this.ejectionStrength = def.ejectionStrength;
          this.staticPressureStrength = def.staticPressureStrength;
          this.staticPressureRelaxation = def.staticPressureRelaxation;
          this.staticPressureIterations = def.staticPressureIterations;
          this.colorMixingStrength = def.colorMixingStrength;
          this.destroyByAge = def.destroyByAge;
          this.lifetimeGranularity = def.lifetimeGranularity;
          return this;
        };
        b2ParticleSystemDef.prototype.Clone = function() {
          return new b2ParticleSystemDef().Copy(this);
        };
        return b2ParticleSystemDef;
      })();
      exports.b2ParticleSystem = (function() {
        function b2ParticleSystem(def, world) {
          this.m_paused = false;
          this.m_timestamp = 0;
          this.m_allParticleFlags = 0;
          this.m_needsUpdateAllParticleFlags = false;
          this.m_allGroupFlags = 0;
          this.m_needsUpdateAllGroupFlags = false;
          this.m_hasForce = false;
          this.m_iterationIndex = 0;
          this.m_inverseDensity = 0;
          this.m_particleDiameter = 0;
          this.m_inverseDiameter = 0;
          this.m_squaredDiameter = 0;
          this.m_count = 0;
          this.m_internalAllocatedCapacity = 0;
          this.m_handleIndexBuffer = new b2ParticleSystem.UserOverridableBuffer();
          this.m_flagsBuffer = new b2ParticleSystem.UserOverridableBuffer();
          this.m_positionBuffer = new b2ParticleSystem.UserOverridableBuffer();
          this.m_velocityBuffer = new b2ParticleSystem.UserOverridableBuffer();
          this.m_forceBuffer = [];
          this.m_weightBuffer = [];
          this.m_staticPressureBuffer = [];
          this.m_accumulationBuffer = [];
          this.m_accumulation2Buffer = [];
          this.m_depthBuffer = [];
          this.m_colorBuffer = new b2ParticleSystem.UserOverridableBuffer();
          this.m_groupBuffer = [];
          this.m_userDataBuffer = new b2ParticleSystem.UserOverridableBuffer();
          this.m_stuckThreshold = 0;
          this.m_lastBodyContactStepBuffer = new b2ParticleSystem.UserOverridableBuffer();
          this.m_bodyContactCountBuffer = new b2ParticleSystem.UserOverridableBuffer();
          this.m_consecutiveContactStepsBuffer = new b2ParticleSystem.UserOverridableBuffer();
          this.m_stuckParticleBuffer = new b2GrowableBuffer(function() {
            return 0;
          });
          this.m_proxyBuffer = new b2GrowableBuffer(function() {
            return new b2ParticleSystem.Proxy();
          });
          this.m_contactBuffer = new b2GrowableBuffer(function() {
            return new b2ParticleContact();
          });
          this.m_bodyContactBuffer = new b2GrowableBuffer(function() {
            return new b2ParticleBodyContact();
          });
          this.m_pairBuffer = new b2GrowableBuffer(function() {
            return new b2ParticlePair();
          });
          this.m_triadBuffer = new b2GrowableBuffer(function() {
            return new b2ParticleTriad();
          });
          this.m_expirationTimeBuffer = new b2ParticleSystem.UserOverridableBuffer();
          this.m_indexByExpirationTimeBuffer = new b2ParticleSystem.UserOverridableBuffer();
          this.m_timeElapsed = 0;
          this.m_expirationTimeBufferRequiresSorting = false;
          this.m_groupCount = 0;
          this.m_groupList = null;
          this.m_def = new b2ParticleSystemDef();
          this.m_prev = null;
          this.m_next = null;
          this.SetStrictContactCheck(def.strictContactCheck);
          this.SetDensity(def.density);
          this.SetGravityScale(def.gravityScale);
          this.SetRadius(def.radius);
          this.SetMaxParticleCount(def.maxCount);
          this.m_def = def.Clone();
          this.m_world = world;
          this.SetDestructionByAge(this.m_def.destroyByAge);
        }
        b2ParticleSystem.computeTag = function(x, y) {
          return (y + b2ParticleSystem.yOffset >>> 0 << b2ParticleSystem.yShift) + (b2ParticleSystem.xScale * x + b2ParticleSystem.xOffset >>> 0) >>> 0;
        };
        b2ParticleSystem.computeRelativeTag = function(tag, x, y) {
          return tag + (y << b2ParticleSystem.yShift) + (x << b2ParticleSystem.xShift) >>> 0;
        };
        b2ParticleSystem.prototype.Drop = function() {
          while (this.m_groupList) this.DestroyParticleGroup(this.m_groupList);
          this.FreeUserOverridableBuffer(this.m_handleIndexBuffer);
          this.FreeUserOverridableBuffer(this.m_flagsBuffer);
          this.FreeUserOverridableBuffer(this.m_lastBodyContactStepBuffer);
          this.FreeUserOverridableBuffer(this.m_bodyContactCountBuffer);
          this.FreeUserOverridableBuffer(this.m_consecutiveContactStepsBuffer);
          this.FreeUserOverridableBuffer(this.m_positionBuffer);
          this.FreeUserOverridableBuffer(this.m_velocityBuffer);
          this.FreeUserOverridableBuffer(this.m_colorBuffer);
          this.FreeUserOverridableBuffer(this.m_userDataBuffer);
          this.FreeUserOverridableBuffer(this.m_expirationTimeBuffer);
          this.FreeUserOverridableBuffer(this.m_indexByExpirationTimeBuffer);
          this.FreeBuffer(this.m_forceBuffer, this.m_internalAllocatedCapacity);
          this.FreeBuffer(this.m_weightBuffer, this.m_internalAllocatedCapacity);
          this.FreeBuffer(this.m_staticPressureBuffer, this.m_internalAllocatedCapacity);
          this.FreeBuffer(this.m_accumulationBuffer, this.m_internalAllocatedCapacity);
          this.FreeBuffer(this.m_accumulation2Buffer, this.m_internalAllocatedCapacity);
          this.FreeBuffer(this.m_depthBuffer, this.m_internalAllocatedCapacity);
          this.FreeBuffer(this.m_groupBuffer, this.m_internalAllocatedCapacity);
        };
        b2ParticleSystem.prototype.CreateParticle = function(def) {
          if (this.m_world.IsLocked()) throw new Error();
          if (this.m_count >= this.m_internalAllocatedCapacity) {
            var capacity = this.m_count ? 2 * this.m_count : b2_minParticleSystemBufferCapacity;
            this.ReallocateInternalAllocatedBuffers(capacity);
          }
          if (this.m_count >= this.m_internalAllocatedCapacity) {
            if (!this.m_def.destroyByAge) return b2_invalidParticleIndex;
            this.DestroyOldestParticle(0, false);
            this.SolveZombie();
          }
          var index = this.m_count++;
          if (!this.m_flagsBuffer.data) throw new Error();
          this.m_flagsBuffer.data[index] = 0;
          this.m_lastBodyContactStepBuffer.data && (this.m_lastBodyContactStepBuffer.data[index] = 0);
          this.m_bodyContactCountBuffer.data && (this.m_bodyContactCountBuffer.data[index] = 0);
          this.m_consecutiveContactStepsBuffer.data && (this.m_consecutiveContactStepsBuffer.data[index] = 0);
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          this.m_positionBuffer.data[index] = (this.m_positionBuffer.data[index] || new b2Vec2()).Copy(b2Maybe(def.position, b2Vec2.ZERO));
          this.m_velocityBuffer.data[index] = (this.m_velocityBuffer.data[index] || new b2Vec2()).Copy(b2Maybe(def.velocity, b2Vec2.ZERO));
          this.m_weightBuffer[index] = 0;
          this.m_forceBuffer[index] = (this.m_forceBuffer[index] || new b2Vec2()).SetZero();
          this.m_staticPressureBuffer && (this.m_staticPressureBuffer[index] = 0);
          this.m_depthBuffer && (this.m_depthBuffer[index] = 0);
          var color = new b2Color().Copy(b2Maybe(def.color, b2Color.ZERO));
          if (this.m_colorBuffer.data || !color.IsZero()) {
            this.m_colorBuffer.data = this.RequestBuffer(this.m_colorBuffer.data);
            this.m_colorBuffer.data[index] = (this.m_colorBuffer.data[index] || new b2Color()).Copy(color);
          }
          if (this.m_userDataBuffer.data || def.userData) {
            this.m_userDataBuffer.data = this.RequestBuffer(this.m_userDataBuffer.data);
            this.m_userDataBuffer.data[index] = def.userData;
          }
          this.m_handleIndexBuffer.data && (this.m_handleIndexBuffer.data[index] = null);
          var proxy = this.m_proxyBuffer.data[this.m_proxyBuffer.Append()];
          var lifetime = b2Maybe(def.lifetime, 0);
          var finiteLifetime = lifetime > 0;
          if (this.m_expirationTimeBuffer.data || finiteLifetime) {
            this.SetParticleLifetime(index, finiteLifetime ? lifetime : this.ExpirationTimeToLifetime(-this.GetQuantizedTimeElapsed()));
            if (!this.m_indexByExpirationTimeBuffer.data) throw new Error();
            this.m_indexByExpirationTimeBuffer.data[index] = index;
          }
          proxy.index = index;
          var group = b2Maybe(def.group, null);
          this.m_groupBuffer[index] = group;
          if (group) if (group.m_firstIndex < group.m_lastIndex) {
            this.RotateBuffer(group.m_firstIndex, group.m_lastIndex, index);
            group.m_lastIndex = index + 1;
          } else {
            group.m_firstIndex = index;
            group.m_lastIndex = index + 1;
          }
          this.SetParticleFlags(index, b2Maybe(def.flags, 0));
          return index;
        };
        b2ParticleSystem.prototype.GetParticleHandleFromIndex = function(index) {
          this.m_handleIndexBuffer.data = this.RequestBuffer(this.m_handleIndexBuffer.data);
          var handle = this.m_handleIndexBuffer.data[index];
          if (handle) return handle;
          handle = new b2ParticleHandle();
          handle.SetIndex(index);
          this.m_handleIndexBuffer.data[index] = handle;
          return handle;
        };
        b2ParticleSystem.prototype.DestroyParticle = function(index, callDestructionListener) {
          void 0 === callDestructionListener && (callDestructionListener = false);
          if (!this.m_flagsBuffer.data) throw new Error();
          var flags = exports.b2ParticleFlag.b2_zombieParticle;
          callDestructionListener && (flags |= exports.b2ParticleFlag.b2_destructionListenerParticle);
          this.SetParticleFlags(index, this.m_flagsBuffer.data[index] | flags);
        };
        b2ParticleSystem.prototype.DestroyOldestParticle = function(index, callDestructionListener) {
          void 0 === callDestructionListener && (callDestructionListener = false);
          var particleCount = this.GetParticleCount();
          if (!this.m_indexByExpirationTimeBuffer.data) throw new Error();
          if (!this.m_expirationTimeBuffer.data) throw new Error();
          var oldestFiniteLifetimeParticle = this.m_indexByExpirationTimeBuffer.data[particleCount - (index + 1)];
          var oldestInfiniteLifetimeParticle = this.m_indexByExpirationTimeBuffer.data[index];
          this.DestroyParticle(this.m_expirationTimeBuffer.data[oldestFiniteLifetimeParticle] > 0 ? oldestFiniteLifetimeParticle : oldestInfiniteLifetimeParticle, callDestructionListener);
        };
        b2ParticleSystem.prototype.DestroyParticlesInShape = function(shape, xf, callDestructionListener) {
          void 0 === callDestructionListener && (callDestructionListener = false);
          var s_aabb = b2ParticleSystem.DestroyParticlesInShape_s_aabb;
          if (this.m_world.IsLocked()) throw new Error();
          var callback = new b2ParticleSystem.DestroyParticlesInShapeCallback(this, shape, xf, callDestructionListener);
          var aabb = s_aabb;
          shape.ComputeAABB(aabb, xf, 0);
          this.m_world.QueryAABB(callback, aabb);
          return callback.Destroyed();
        };
        b2ParticleSystem.prototype.CreateParticleGroup = function(groupDef) {
          var s_transform = b2ParticleSystem.CreateParticleGroup_s_transform;
          if (this.m_world.IsLocked()) throw new Error();
          var transform = s_transform;
          transform.SetPositionAngle(b2Maybe(groupDef.position, b2Vec2.ZERO), b2Maybe(groupDef.angle, 0));
          var firstIndex = this.m_count;
          groupDef.shape && this.CreateParticlesWithShapeForGroup(groupDef.shape, groupDef, transform);
          groupDef.shapes && this.CreateParticlesWithShapesForGroup(groupDef.shapes, b2Maybe(groupDef.shapeCount, groupDef.shapes.length), groupDef, transform);
          if (groupDef.positionData) {
            var count = b2Maybe(groupDef.particleCount, groupDef.positionData.length);
            for (var i = 0; i < count; i++) {
              var p = groupDef.positionData[i];
              this.CreateParticleForGroup(groupDef, transform, p);
            }
          }
          var lastIndex = this.m_count;
          var group = new b2ParticleGroup(this);
          group.m_firstIndex = firstIndex;
          group.m_lastIndex = lastIndex;
          group.m_strength = b2Maybe(groupDef.strength, 1);
          group.m_userData = groupDef.userData;
          group.m_transform.Copy(transform);
          group.m_prev = null;
          group.m_next = this.m_groupList;
          this.m_groupList && (this.m_groupList.m_prev = group);
          this.m_groupList = group;
          ++this.m_groupCount;
          for (var i = firstIndex; i < lastIndex; i++) this.m_groupBuffer[i] = group;
          this.SetGroupFlags(group, b2Maybe(groupDef.groupFlags, 0));
          var filter = new b2ParticleSystem.ConnectionFilter();
          this.UpdateContacts(true);
          this.UpdatePairsAndTriads(firstIndex, lastIndex, filter);
          if (groupDef.group) {
            this.JoinParticleGroups(groupDef.group, group);
            group = groupDef.group;
          }
          return group;
        };
        b2ParticleSystem.prototype.JoinParticleGroups = function(groupA, groupB) {
          if (this.m_world.IsLocked()) throw new Error();
          this.RotateBuffer(groupB.m_firstIndex, groupB.m_lastIndex, this.m_count);
          this.RotateBuffer(groupA.m_firstIndex, groupA.m_lastIndex, groupB.m_firstIndex);
          var filter = new b2ParticleSystem.JoinParticleGroupsFilter(groupB.m_firstIndex);
          this.UpdateContacts(true);
          this.UpdatePairsAndTriads(groupA.m_firstIndex, groupB.m_lastIndex, filter);
          for (var i = groupB.m_firstIndex; i < groupB.m_lastIndex; i++) this.m_groupBuffer[i] = groupA;
          var groupFlags = groupA.m_groupFlags | groupB.m_groupFlags;
          this.SetGroupFlags(groupA, groupFlags);
          groupA.m_lastIndex = groupB.m_lastIndex;
          groupB.m_firstIndex = groupB.m_lastIndex;
          this.DestroyParticleGroup(groupB);
        };
        b2ParticleSystem.prototype.SplitParticleGroup = function(group) {
          this.UpdateContacts(true);
          var particleCount = group.GetParticleCount();
          var nodeBuffer = b2MakeArray(particleCount, (function(index) {
            return new b2ParticleSystem.ParticleListNode();
          }));
          b2ParticleSystem.InitializeParticleLists(group, nodeBuffer);
          this.MergeParticleListsInContact(group, nodeBuffer);
          var survivingList = b2ParticleSystem.FindLongestParticleList(group, nodeBuffer);
          this.MergeZombieParticleListNodes(group, nodeBuffer, survivingList);
          this.CreateParticleGroupsFromParticleList(group, nodeBuffer, survivingList);
          this.UpdatePairsAndTriadsWithParticleList(group, nodeBuffer);
        };
        b2ParticleSystem.prototype.GetParticleGroupList = function() {
          return this.m_groupList;
        };
        b2ParticleSystem.prototype.GetParticleGroupCount = function() {
          return this.m_groupCount;
        };
        b2ParticleSystem.prototype.GetParticleCount = function() {
          return this.m_count;
        };
        b2ParticleSystem.prototype.GetMaxParticleCount = function() {
          return this.m_def.maxCount;
        };
        b2ParticleSystem.prototype.SetMaxParticleCount = function(count) {
          this.m_def.maxCount = count;
        };
        b2ParticleSystem.prototype.GetAllParticleFlags = function() {
          return this.m_allParticleFlags;
        };
        b2ParticleSystem.prototype.GetAllGroupFlags = function() {
          return this.m_allGroupFlags;
        };
        b2ParticleSystem.prototype.SetPaused = function(paused) {
          this.m_paused = paused;
        };
        b2ParticleSystem.prototype.GetPaused = function() {
          return this.m_paused;
        };
        b2ParticleSystem.prototype.SetDensity = function(density) {
          this.m_def.density = density;
          this.m_inverseDensity = 1 / this.m_def.density;
        };
        b2ParticleSystem.prototype.GetDensity = function() {
          return this.m_def.density;
        };
        b2ParticleSystem.prototype.SetGravityScale = function(gravityScale) {
          this.m_def.gravityScale = gravityScale;
        };
        b2ParticleSystem.prototype.GetGravityScale = function() {
          return this.m_def.gravityScale;
        };
        b2ParticleSystem.prototype.SetDamping = function(damping) {
          this.m_def.dampingStrength = damping;
        };
        b2ParticleSystem.prototype.GetDamping = function() {
          return this.m_def.dampingStrength;
        };
        b2ParticleSystem.prototype.SetStaticPressureIterations = function(iterations) {
          this.m_def.staticPressureIterations = iterations;
        };
        b2ParticleSystem.prototype.GetStaticPressureIterations = function() {
          return this.m_def.staticPressureIterations;
        };
        b2ParticleSystem.prototype.SetRadius = function(radius) {
          this.m_particleDiameter = 2 * radius;
          this.m_squaredDiameter = this.m_particleDiameter * this.m_particleDiameter;
          this.m_inverseDiameter = 1 / this.m_particleDiameter;
        };
        b2ParticleSystem.prototype.GetRadius = function() {
          return this.m_particleDiameter / 2;
        };
        b2ParticleSystem.prototype.GetPositionBuffer = function() {
          if (!this.m_positionBuffer.data) throw new Error();
          return this.m_positionBuffer.data;
        };
        b2ParticleSystem.prototype.GetVelocityBuffer = function() {
          if (!this.m_velocityBuffer.data) throw new Error();
          return this.m_velocityBuffer.data;
        };
        b2ParticleSystem.prototype.GetColorBuffer = function() {
          this.m_colorBuffer.data = this.RequestBuffer(this.m_colorBuffer.data);
          return this.m_colorBuffer.data;
        };
        b2ParticleSystem.prototype.GetGroupBuffer = function() {
          return this.m_groupBuffer;
        };
        b2ParticleSystem.prototype.GetWeightBuffer = function() {
          return this.m_weightBuffer;
        };
        b2ParticleSystem.prototype.GetUserDataBuffer = function() {
          this.m_userDataBuffer.data = this.RequestBuffer(this.m_userDataBuffer.data);
          return this.m_userDataBuffer.data;
        };
        b2ParticleSystem.prototype.GetFlagsBuffer = function() {
          if (!this.m_flagsBuffer.data) throw new Error();
          return this.m_flagsBuffer.data;
        };
        b2ParticleSystem.prototype.SetParticleFlags = function(index, newFlags) {
          if (!this.m_flagsBuffer.data) throw new Error();
          var oldFlags = this.m_flagsBuffer.data[index];
          oldFlags & ~newFlags && (this.m_needsUpdateAllParticleFlags = true);
          if (~this.m_allParticleFlags & newFlags) {
            newFlags & exports.b2ParticleFlag.b2_tensileParticle && (this.m_accumulation2Buffer = this.RequestBuffer(this.m_accumulation2Buffer));
            newFlags & exports.b2ParticleFlag.b2_colorMixingParticle && (this.m_colorBuffer.data = this.RequestBuffer(this.m_colorBuffer.data));
            this.m_allParticleFlags |= newFlags;
          }
          this.m_flagsBuffer.data[index] = newFlags;
        };
        b2ParticleSystem.prototype.GetParticleFlags = function(index) {
          if (!this.m_flagsBuffer.data) throw new Error();
          return this.m_flagsBuffer.data[index];
        };
        b2ParticleSystem.prototype.SetFlagsBuffer = function(buffer, capacity) {
          this.SetUserOverridableBuffer(this.m_flagsBuffer, buffer, capacity);
        };
        b2ParticleSystem.prototype.SetPositionBuffer = function(buffer, capacity) {
          this.SetUserOverridableBuffer(this.m_positionBuffer, buffer, capacity);
        };
        b2ParticleSystem.prototype.SetVelocityBuffer = function(buffer, capacity) {
          this.SetUserOverridableBuffer(this.m_velocityBuffer, buffer, capacity);
        };
        b2ParticleSystem.prototype.SetColorBuffer = function(buffer, capacity) {
          this.SetUserOverridableBuffer(this.m_colorBuffer, buffer, capacity);
        };
        b2ParticleSystem.prototype.SetUserDataBuffer = function(buffer, capacity) {
          this.SetUserOverridableBuffer(this.m_userDataBuffer, buffer, capacity);
        };
        b2ParticleSystem.prototype.GetContacts = function() {
          return this.m_contactBuffer.data;
        };
        b2ParticleSystem.prototype.GetContactCount = function() {
          return this.m_contactBuffer.count;
        };
        b2ParticleSystem.prototype.GetBodyContacts = function() {
          return this.m_bodyContactBuffer.data;
        };
        b2ParticleSystem.prototype.GetBodyContactCount = function() {
          return this.m_bodyContactBuffer.count;
        };
        b2ParticleSystem.prototype.GetPairs = function() {
          return this.m_pairBuffer.data;
        };
        b2ParticleSystem.prototype.GetPairCount = function() {
          return this.m_pairBuffer.count;
        };
        b2ParticleSystem.prototype.GetTriads = function() {
          return this.m_triadBuffer.data;
        };
        b2ParticleSystem.prototype.GetTriadCount = function() {
          return this.m_triadBuffer.count;
        };
        b2ParticleSystem.prototype.SetStuckThreshold = function(steps) {
          this.m_stuckThreshold = steps;
          if (steps > 0) {
            this.m_lastBodyContactStepBuffer.data = this.RequestBuffer(this.m_lastBodyContactStepBuffer.data);
            this.m_bodyContactCountBuffer.data = this.RequestBuffer(this.m_bodyContactCountBuffer.data);
            this.m_consecutiveContactStepsBuffer.data = this.RequestBuffer(this.m_consecutiveContactStepsBuffer.data);
          }
        };
        b2ParticleSystem.prototype.GetStuckCandidates = function() {
          return this.m_stuckParticleBuffer.Data();
        };
        b2ParticleSystem.prototype.GetStuckCandidateCount = function() {
          return this.m_stuckParticleBuffer.GetCount();
        };
        b2ParticleSystem.prototype.ComputeCollisionEnergy = function() {
          if (!this.m_velocityBuffer.data) throw new Error();
          var s_v = b2ParticleSystem.ComputeCollisionEnergy_s_v;
          var vel_data = this.m_velocityBuffer.data;
          var sum_v2 = 0;
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            var a = contact.indexA;
            var b = contact.indexB;
            var n = contact.normal;
            var v = b2Vec2.SubVV(vel_data[b], vel_data[a], s_v);
            var vn = b2Vec2.DotVV(v, n);
            vn < 0 && (sum_v2 += vn * vn);
          }
          return .5 * this.GetParticleMass() * sum_v2;
        };
        b2ParticleSystem.prototype.SetStrictContactCheck = function(enabled) {
          this.m_def.strictContactCheck = enabled;
        };
        b2ParticleSystem.prototype.GetStrictContactCheck = function() {
          return this.m_def.strictContactCheck;
        };
        b2ParticleSystem.prototype.SetParticleLifetime = function(index, lifetime) {
          var initializeExpirationTimes = null === this.m_indexByExpirationTimeBuffer.data;
          this.m_expirationTimeBuffer.data = this.RequestBuffer(this.m_expirationTimeBuffer.data);
          this.m_indexByExpirationTimeBuffer.data = this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data);
          if (initializeExpirationTimes) {
            var particleCount = this.GetParticleCount();
            for (var i = 0; i < particleCount; ++i) this.m_indexByExpirationTimeBuffer.data[i] = i;
          }
          var quantizedLifetime = lifetime / this.m_def.lifetimeGranularity;
          var newExpirationTime = quantizedLifetime > 0 ? this.GetQuantizedTimeElapsed() + quantizedLifetime : quantizedLifetime;
          if (newExpirationTime !== this.m_expirationTimeBuffer.data[index]) {
            this.m_expirationTimeBuffer.data[index] = newExpirationTime;
            this.m_expirationTimeBufferRequiresSorting = true;
          }
        };
        b2ParticleSystem.prototype.GetParticleLifetime = function(index) {
          return this.ExpirationTimeToLifetime(this.GetExpirationTimeBuffer()[index]);
        };
        b2ParticleSystem.prototype.SetDestructionByAge = function(enable) {
          enable && this.GetExpirationTimeBuffer();
          this.m_def.destroyByAge = enable;
        };
        b2ParticleSystem.prototype.GetDestructionByAge = function() {
          return this.m_def.destroyByAge;
        };
        b2ParticleSystem.prototype.GetExpirationTimeBuffer = function() {
          this.m_expirationTimeBuffer.data = this.RequestBuffer(this.m_expirationTimeBuffer.data);
          return this.m_expirationTimeBuffer.data;
        };
        b2ParticleSystem.prototype.ExpirationTimeToLifetime = function(expirationTime) {
          return (expirationTime > 0 ? expirationTime - this.GetQuantizedTimeElapsed() : expirationTime) * this.m_def.lifetimeGranularity;
        };
        b2ParticleSystem.prototype.GetIndexByExpirationTimeBuffer = function() {
          this.GetParticleCount() ? this.SetParticleLifetime(0, this.GetParticleLifetime(0)) : this.m_indexByExpirationTimeBuffer.data = this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data);
          if (!this.m_indexByExpirationTimeBuffer.data) throw new Error();
          return this.m_indexByExpirationTimeBuffer.data;
        };
        b2ParticleSystem.prototype.ParticleApplyLinearImpulse = function(index, impulse) {
          this.ApplyLinearImpulse(index, index + 1, impulse);
        };
        b2ParticleSystem.prototype.ApplyLinearImpulse = function(firstIndex, lastIndex, impulse) {
          if (!this.m_velocityBuffer.data) throw new Error();
          var vel_data = this.m_velocityBuffer.data;
          var numParticles = lastIndex - firstIndex;
          var totalMass = numParticles * this.GetParticleMass();
          var velocityDelta = new b2Vec2().Copy(impulse).SelfMul(1 / totalMass);
          for (var i = firstIndex; i < lastIndex; i++) vel_data[i].SelfAdd(velocityDelta);
        };
        b2ParticleSystem.IsSignificantForce = function(force) {
          return 0 !== force.x || 0 !== force.y;
        };
        b2ParticleSystem.prototype.ParticleApplyForce = function(index, force) {
          if (!this.m_flagsBuffer.data) throw new Error();
          if (b2ParticleSystem.IsSignificantForce(force) && this.ForceCanBeApplied(this.m_flagsBuffer.data[index])) {
            this.PrepareForceBuffer();
            this.m_forceBuffer[index].SelfAdd(force);
          }
        };
        b2ParticleSystem.prototype.ApplyForce = function(firstIndex, lastIndex, force) {
          var distributedForce = new b2Vec2().Copy(force).SelfMul(1 / (lastIndex - firstIndex));
          if (b2ParticleSystem.IsSignificantForce(distributedForce)) {
            this.PrepareForceBuffer();
            for (var i = firstIndex; i < lastIndex; i++) this.m_forceBuffer[i].SelfAdd(distributedForce);
          }
        };
        b2ParticleSystem.prototype.GetNext = function() {
          return this.m_next;
        };
        b2ParticleSystem.prototype.QueryAABB = function(callback, aabb) {
          if (0 === this.m_proxyBuffer.count) return;
          var beginProxy = 0;
          var endProxy = this.m_proxyBuffer.count;
          var firstProxy = std_lower_bound(this.m_proxyBuffer.data, beginProxy, endProxy, b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.lowerBound.x, this.m_inverseDiameter * aabb.lowerBound.y), b2ParticleSystem.Proxy.CompareProxyTag);
          var lastProxy = std_upper_bound(this.m_proxyBuffer.data, firstProxy, endProxy, b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.upperBound.x, this.m_inverseDiameter * aabb.upperBound.y), b2ParticleSystem.Proxy.CompareTagProxy);
          if (!this.m_positionBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          for (var k = firstProxy; k < lastProxy; ++k) {
            var proxy = this.m_proxyBuffer.data[k];
            var i = proxy.index;
            var p = pos_data[i];
            if (aabb.lowerBound.x < p.x && p.x < aabb.upperBound.x && aabb.lowerBound.y < p.y && p.y < aabb.upperBound.y && !callback.ReportParticle(this, i)) break;
          }
        };
        b2ParticleSystem.prototype.QueryShapeAABB = function(callback, shape, xf, childIndex) {
          void 0 === childIndex && (childIndex = 0);
          var s_aabb = b2ParticleSystem.QueryShapeAABB_s_aabb;
          var aabb = s_aabb;
          shape.ComputeAABB(aabb, xf, childIndex);
          this.QueryAABB(callback, aabb);
        };
        b2ParticleSystem.prototype.QueryPointAABB = function(callback, point, slop) {
          void 0 === slop && (slop = b2_linearSlop);
          var s_aabb = b2ParticleSystem.QueryPointAABB_s_aabb;
          var aabb = s_aabb;
          aabb.lowerBound.Set(point.x - slop, point.y - slop);
          aabb.upperBound.Set(point.x + slop, point.y + slop);
          this.QueryAABB(callback, aabb);
        };
        b2ParticleSystem.prototype.RayCast = function(callback, point1, point2) {
          var s_aabb = b2ParticleSystem.RayCast_s_aabb;
          var s_p = b2ParticleSystem.RayCast_s_p;
          var s_v = b2ParticleSystem.RayCast_s_v;
          var s_n = b2ParticleSystem.RayCast_s_n;
          var s_point = b2ParticleSystem.RayCast_s_point;
          if (0 === this.m_proxyBuffer.count) return;
          if (!this.m_positionBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var aabb = s_aabb;
          b2Vec2.MinV(point1, point2, aabb.lowerBound);
          b2Vec2.MaxV(point1, point2, aabb.upperBound);
          var fraction = 1;
          var v = b2Vec2.SubVV(point2, point1, s_v);
          var v2 = b2Vec2.DotVV(v, v);
          var enumerator = this.GetInsideBoundsEnumerator(aabb);
          var i;
          while ((i = enumerator.GetNext()) >= 0) {
            var p = b2Vec2.SubVV(point1, pos_data[i], s_p);
            var pv = b2Vec2.DotVV(p, v);
            var p2 = b2Vec2.DotVV(p, p);
            var determinant = pv * pv - v2 * (p2 - this.m_squaredDiameter);
            if (determinant >= 0) {
              var sqrtDeterminant = b2Sqrt(determinant);
              var t = (-pv - sqrtDeterminant) / v2;
              if (t > fraction) continue;
              if (t < 0) {
                t = (-pv + sqrtDeterminant) / v2;
                if (t < 0 || t > fraction) continue;
              }
              var n = b2Vec2.AddVMulSV(p, t, v, s_n);
              n.Normalize();
              var f = callback.ReportParticle(this, i, b2Vec2.AddVMulSV(point1, t, v, s_point), n, t);
              fraction = b2Min(fraction, f);
              if (fraction <= 0) break;
            }
          }
        };
        b2ParticleSystem.prototype.ComputeAABB = function(aabb) {
          var particleCount = this.GetParticleCount();
          aabb.lowerBound.x = +b2_maxFloat;
          aabb.lowerBound.y = +b2_maxFloat;
          aabb.upperBound.x = -b2_maxFloat;
          aabb.upperBound.y = -b2_maxFloat;
          if (!this.m_positionBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          for (var i = 0; i < particleCount; i++) {
            var p = pos_data[i];
            b2Vec2.MinV(aabb.lowerBound, p, aabb.lowerBound);
            b2Vec2.MaxV(aabb.upperBound, p, aabb.upperBound);
          }
          aabb.lowerBound.x -= this.m_particleDiameter;
          aabb.lowerBound.y -= this.m_particleDiameter;
          aabb.upperBound.x += this.m_particleDiameter;
          aabb.upperBound.y += this.m_particleDiameter;
        };
        b2ParticleSystem.prototype.FreeBuffer = function(b, capacity) {
          if (null === b) return;
          b.length = 0;
        };
        b2ParticleSystem.prototype.FreeUserOverridableBuffer = function(b) {
          0 === b.userSuppliedCapacity && this.FreeBuffer(b.data, this.m_internalAllocatedCapacity);
        };
        b2ParticleSystem.prototype.ReallocateBuffer3 = function(oldBuffer, oldCapacity, newCapacity) {
          if (newCapacity <= oldCapacity) throw new Error();
          var newBuffer = oldBuffer ? oldBuffer.slice() : [];
          newBuffer.length = newCapacity;
          return newBuffer;
        };
        b2ParticleSystem.prototype.ReallocateBuffer5 = function(buffer, userSuppliedCapacity, oldCapacity, newCapacity, deferred) {
          if (newCapacity <= oldCapacity) throw new Error();
          if (!(!userSuppliedCapacity || newCapacity <= userSuppliedCapacity)) throw new Error();
          deferred && !buffer || userSuppliedCapacity || (buffer = this.ReallocateBuffer3(buffer, oldCapacity, newCapacity));
          return buffer;
        };
        b2ParticleSystem.prototype.ReallocateBuffer4 = function(buffer, oldCapacity, newCapacity, deferred) {
          return this.ReallocateBuffer5(buffer.data, buffer.userSuppliedCapacity, oldCapacity, newCapacity, deferred);
        };
        b2ParticleSystem.prototype.RequestBuffer = function(buffer) {
          if (!buffer) {
            0 === this.m_internalAllocatedCapacity && this.ReallocateInternalAllocatedBuffers(b2_minParticleSystemBufferCapacity);
            buffer = [];
            buffer.length = this.m_internalAllocatedCapacity;
          }
          return buffer;
        };
        b2ParticleSystem.prototype.ReallocateHandleBuffers = function(newCapacity) {
          this.m_handleIndexBuffer.data = this.ReallocateBuffer4(this.m_handleIndexBuffer, this.m_internalAllocatedCapacity, newCapacity, true);
        };
        b2ParticleSystem.prototype.ReallocateInternalAllocatedBuffers = function(capacity) {
          function LimitCapacity(capacity, maxCount) {
            return maxCount && capacity > maxCount ? maxCount : capacity;
          }
          capacity = LimitCapacity(capacity, this.m_def.maxCount);
          capacity = LimitCapacity(capacity, this.m_flagsBuffer.userSuppliedCapacity);
          capacity = LimitCapacity(capacity, this.m_positionBuffer.userSuppliedCapacity);
          capacity = LimitCapacity(capacity, this.m_velocityBuffer.userSuppliedCapacity);
          capacity = LimitCapacity(capacity, this.m_colorBuffer.userSuppliedCapacity);
          capacity = LimitCapacity(capacity, this.m_userDataBuffer.userSuppliedCapacity);
          if (this.m_internalAllocatedCapacity < capacity) {
            this.ReallocateHandleBuffers(capacity);
            this.m_flagsBuffer.data = this.ReallocateBuffer4(this.m_flagsBuffer, this.m_internalAllocatedCapacity, capacity, false);
            var stuck = this.m_stuckThreshold > 0;
            this.m_lastBodyContactStepBuffer.data = this.ReallocateBuffer4(this.m_lastBodyContactStepBuffer, this.m_internalAllocatedCapacity, capacity, stuck);
            this.m_bodyContactCountBuffer.data = this.ReallocateBuffer4(this.m_bodyContactCountBuffer, this.m_internalAllocatedCapacity, capacity, stuck);
            this.m_consecutiveContactStepsBuffer.data = this.ReallocateBuffer4(this.m_consecutiveContactStepsBuffer, this.m_internalAllocatedCapacity, capacity, stuck);
            this.m_positionBuffer.data = this.ReallocateBuffer4(this.m_positionBuffer, this.m_internalAllocatedCapacity, capacity, false);
            this.m_velocityBuffer.data = this.ReallocateBuffer4(this.m_velocityBuffer, this.m_internalAllocatedCapacity, capacity, false);
            this.m_forceBuffer = this.ReallocateBuffer5(this.m_forceBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);
            this.m_weightBuffer = this.ReallocateBuffer5(this.m_weightBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);
            this.m_staticPressureBuffer = this.ReallocateBuffer5(this.m_staticPressureBuffer, 0, this.m_internalAllocatedCapacity, capacity, true);
            this.m_accumulationBuffer = this.ReallocateBuffer5(this.m_accumulationBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);
            this.m_accumulation2Buffer = this.ReallocateBuffer5(this.m_accumulation2Buffer, 0, this.m_internalAllocatedCapacity, capacity, true);
            this.m_depthBuffer = this.ReallocateBuffer5(this.m_depthBuffer, 0, this.m_internalAllocatedCapacity, capacity, true);
            this.m_colorBuffer.data = this.ReallocateBuffer4(this.m_colorBuffer, this.m_internalAllocatedCapacity, capacity, true);
            this.m_groupBuffer = this.ReallocateBuffer5(this.m_groupBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);
            this.m_userDataBuffer.data = this.ReallocateBuffer4(this.m_userDataBuffer, this.m_internalAllocatedCapacity, capacity, true);
            this.m_expirationTimeBuffer.data = this.ReallocateBuffer4(this.m_expirationTimeBuffer, this.m_internalAllocatedCapacity, capacity, true);
            this.m_indexByExpirationTimeBuffer.data = this.ReallocateBuffer4(this.m_indexByExpirationTimeBuffer, this.m_internalAllocatedCapacity, capacity, false);
            this.m_internalAllocatedCapacity = capacity;
          }
        };
        b2ParticleSystem.prototype.CreateParticleForGroup = function(groupDef, xf, p) {
          var particleDef = new b2ParticleDef();
          particleDef.flags = b2Maybe(groupDef.flags, 0);
          b2Transform.MulXV(xf, p, particleDef.position);
          b2Vec2.AddVV(b2Maybe(groupDef.linearVelocity, b2Vec2.ZERO), b2Vec2.CrossSV(b2Maybe(groupDef.angularVelocity, 0), b2Vec2.SubVV(particleDef.position, b2Maybe(groupDef.position, b2Vec2.ZERO), b2Vec2.s_t0), b2Vec2.s_t0), particleDef.velocity);
          particleDef.color.Copy(b2Maybe(groupDef.color, b2Color.ZERO));
          particleDef.lifetime = b2Maybe(groupDef.lifetime, 0);
          particleDef.userData = groupDef.userData;
          this.CreateParticle(particleDef);
        };
        b2ParticleSystem.prototype.CreateParticlesStrokeShapeForGroup = function(shape, groupDef, xf) {
          var s_edge = b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_edge;
          var s_d = b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_d;
          var s_p = b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_p;
          var stride = b2Maybe(groupDef.stride, 0);
          0 === stride && (stride = this.GetParticleStride());
          var positionOnEdge = 0;
          var childCount = shape.GetChildCount();
          for (var childIndex = 0; childIndex < childCount; childIndex++) {
            var edge = null;
            if (shape.GetType() === exports.b2ShapeType.e_edgeShape) edge = shape; else {
              edge = s_edge;
              shape.GetChildEdge(edge, childIndex);
            }
            var d = b2Vec2.SubVV(edge.m_vertex2, edge.m_vertex1, s_d);
            var edgeLength = d.Length();
            while (positionOnEdge < edgeLength) {
              var p = b2Vec2.AddVMulSV(edge.m_vertex1, positionOnEdge / edgeLength, d, s_p);
              this.CreateParticleForGroup(groupDef, xf, p);
              positionOnEdge += stride;
            }
            positionOnEdge -= edgeLength;
          }
        };
        b2ParticleSystem.prototype.CreateParticlesFillShapeForGroup = function(shape, groupDef, xf) {
          var s_aabb = b2ParticleSystem.CreateParticlesFillShapeForGroup_s_aabb;
          var s_p = b2ParticleSystem.CreateParticlesFillShapeForGroup_s_p;
          var stride = b2Maybe(groupDef.stride, 0);
          0 === stride && (stride = this.GetParticleStride());
          var identity = b2Transform.IDENTITY;
          var aabb = s_aabb;
          shape.ComputeAABB(aabb, identity, 0);
          for (var y = Math.floor(aabb.lowerBound.y / stride) * stride; y < aabb.upperBound.y; y += stride) for (var x = Math.floor(aabb.lowerBound.x / stride) * stride; x < aabb.upperBound.x; x += stride) {
            var p = s_p.Set(x, y);
            shape.TestPoint(identity, p) && this.CreateParticleForGroup(groupDef, xf, p);
          }
        };
        b2ParticleSystem.prototype.CreateParticlesWithShapeForGroup = function(shape, groupDef, xf) {
          switch (shape.GetType()) {
           case exports.b2ShapeType.e_edgeShape:
           case exports.b2ShapeType.e_chainShape:
            this.CreateParticlesStrokeShapeForGroup(shape, groupDef, xf);
            break;

           case exports.b2ShapeType.e_polygonShape:
           case exports.b2ShapeType.e_circleShape:
            this.CreateParticlesFillShapeForGroup(shape, groupDef, xf);
          }
        };
        b2ParticleSystem.prototype.CreateParticlesWithShapesForGroup = function(shapes, shapeCount, groupDef, xf) {
          var compositeShape = new b2ParticleSystem.CompositeShape(shapes, shapeCount);
          this.CreateParticlesFillShapeForGroup(compositeShape, groupDef, xf);
        };
        b2ParticleSystem.prototype.CloneParticle = function(oldIndex, group) {
          var def = new b2ParticleDef();
          if (!this.m_flagsBuffer.data) throw new Error();
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          def.flags = this.m_flagsBuffer.data[oldIndex];
          def.position.Copy(this.m_positionBuffer.data[oldIndex]);
          def.velocity.Copy(this.m_velocityBuffer.data[oldIndex]);
          this.m_colorBuffer.data && def.color.Copy(this.m_colorBuffer.data[oldIndex]);
          this.m_userDataBuffer.data && (def.userData = this.m_userDataBuffer.data[oldIndex]);
          def.group = group;
          var newIndex = this.CreateParticle(def);
          if (this.m_handleIndexBuffer.data) {
            var handle = this.m_handleIndexBuffer.data[oldIndex];
            handle && handle.SetIndex(newIndex);
            this.m_handleIndexBuffer.data[newIndex] = handle;
            this.m_handleIndexBuffer.data[oldIndex] = null;
          }
          this.m_lastBodyContactStepBuffer.data && (this.m_lastBodyContactStepBuffer.data[newIndex] = this.m_lastBodyContactStepBuffer.data[oldIndex]);
          this.m_bodyContactCountBuffer.data && (this.m_bodyContactCountBuffer.data[newIndex] = this.m_bodyContactCountBuffer.data[oldIndex]);
          this.m_consecutiveContactStepsBuffer.data && (this.m_consecutiveContactStepsBuffer.data[newIndex] = this.m_consecutiveContactStepsBuffer.data[oldIndex]);
          this.m_hasForce && this.m_forceBuffer[newIndex].Copy(this.m_forceBuffer[oldIndex]);
          this.m_staticPressureBuffer && (this.m_staticPressureBuffer[newIndex] = this.m_staticPressureBuffer[oldIndex]);
          this.m_depthBuffer && (this.m_depthBuffer[newIndex] = this.m_depthBuffer[oldIndex]);
          this.m_expirationTimeBuffer.data && (this.m_expirationTimeBuffer.data[newIndex] = this.m_expirationTimeBuffer.data[oldIndex]);
          return newIndex;
        };
        b2ParticleSystem.prototype.DestroyParticlesInGroup = function(group, callDestructionListener) {
          void 0 === callDestructionListener && (callDestructionListener = false);
          for (var i = group.m_firstIndex; i < group.m_lastIndex; i++) this.DestroyParticle(i, callDestructionListener);
        };
        b2ParticleSystem.prototype.DestroyParticleGroup = function(group) {
          this.m_world.m_destructionListener && this.m_world.m_destructionListener.SayGoodbyeParticleGroup(group);
          this.SetGroupFlags(group, 0);
          for (var i = group.m_firstIndex; i < group.m_lastIndex; i++) this.m_groupBuffer[i] = null;
          group.m_prev && (group.m_prev.m_next = group.m_next);
          group.m_next && (group.m_next.m_prev = group.m_prev);
          group === this.m_groupList && (this.m_groupList = group.m_next);
          --this.m_groupCount;
        };
        b2ParticleSystem.ParticleCanBeConnected = function(flags, group) {
          return 0 !== (flags & (exports.b2ParticleFlag.b2_wallParticle | exports.b2ParticleFlag.b2_springParticle | exports.b2ParticleFlag.b2_elasticParticle)) || null !== group && 0 !== (group.GetGroupFlags() & exports.b2ParticleGroupFlag.b2_rigidParticleGroup);
        };
        b2ParticleSystem.prototype.UpdatePairsAndTriads = function(firstIndex, lastIndex, filter) {
          var s_dab = b2ParticleSystem.UpdatePairsAndTriads_s_dab;
          var s_dbc = b2ParticleSystem.UpdatePairsAndTriads_s_dbc;
          var s_dca = b2ParticleSystem.UpdatePairsAndTriads_s_dca;
          if (!this.m_flagsBuffer.data) throw new Error();
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var particleFlags = 0;
          for (var i = firstIndex; i < lastIndex; i++) particleFlags |= this.m_flagsBuffer.data[i];
          if (particleFlags & b2ParticleSystem.k_pairFlags) for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            var a = contact.indexA;
            var b = contact.indexB;
            var af = this.m_flagsBuffer.data[a];
            var bf = this.m_flagsBuffer.data[b];
            var groupA = this.m_groupBuffer[a];
            var groupB = this.m_groupBuffer[b];
            if (a >= firstIndex && a < lastIndex && b >= firstIndex && b < lastIndex && !((af | bf) & exports.b2ParticleFlag.b2_zombieParticle) && (af | bf) & b2ParticleSystem.k_pairFlags && (filter.IsNecessary(a) || filter.IsNecessary(b)) && b2ParticleSystem.ParticleCanBeConnected(af, groupA) && b2ParticleSystem.ParticleCanBeConnected(bf, groupB) && filter.ShouldCreatePair(a, b)) {
              var pair = this.m_pairBuffer.data[this.m_pairBuffer.Append()];
              pair.indexA = a;
              pair.indexB = b;
              pair.flags = contact.flags;
              pair.strength = b2Min(groupA ? groupA.m_strength : 1, groupB ? groupB.m_strength : 1);
              pair.distance = b2Vec2.DistanceVV(pos_data[a], pos_data[b]);
            }
            std_stable_sort(this.m_pairBuffer.data, 0, this.m_pairBuffer.count, b2ParticleSystem.ComparePairIndices);
            this.m_pairBuffer.Unique(b2ParticleSystem.MatchPairIndices);
          }
          if (particleFlags & b2ParticleSystem.k_triadFlags) {
            var diagram = new b2VoronoiDiagram(lastIndex - firstIndex);
            for (var i = firstIndex; i < lastIndex; i++) {
              var flags = this.m_flagsBuffer.data[i];
              var group = this.m_groupBuffer[i];
              flags & exports.b2ParticleFlag.b2_zombieParticle || !b2ParticleSystem.ParticleCanBeConnected(flags, group) || diagram.AddGenerator(pos_data[i], i, filter.IsNecessary(i));
            }
            var stride = this.GetParticleStride();
            diagram.Generate(stride / 2, 2 * stride);
            var system_1 = this;
            var callback = function callback(a, b, c) {
              if (!system_1.m_flagsBuffer.data) throw new Error();
              var af = system_1.m_flagsBuffer.data[a];
              var bf = system_1.m_flagsBuffer.data[b];
              var cf = system_1.m_flagsBuffer.data[c];
              if ((af | bf | cf) & b2ParticleSystem.k_triadFlags && filter.ShouldCreateTriad(a, b, c)) {
                var pa = pos_data[a];
                var pb = pos_data[b];
                var pc = pos_data[c];
                var dab = b2Vec2.SubVV(pa, pb, s_dab);
                var dbc = b2Vec2.SubVV(pb, pc, s_dbc);
                var dca = b2Vec2.SubVV(pc, pa, s_dca);
                var maxDistanceSquared = b2_maxTriadDistanceSquared * system_1.m_squaredDiameter;
                if (b2Vec2.DotVV(dab, dab) > maxDistanceSquared || b2Vec2.DotVV(dbc, dbc) > maxDistanceSquared || b2Vec2.DotVV(dca, dca) > maxDistanceSquared) return;
                var groupA = system_1.m_groupBuffer[a];
                var groupB = system_1.m_groupBuffer[b];
                var groupC = system_1.m_groupBuffer[c];
                var triad = system_1.m_triadBuffer.data[system_1.m_triadBuffer.Append()];
                triad.indexA = a;
                triad.indexB = b;
                triad.indexC = c;
                triad.flags = af | bf | cf;
                triad.strength = b2Min(b2Min(groupA ? groupA.m_strength : 1, groupB ? groupB.m_strength : 1), groupC ? groupC.m_strength : 1);
                var midPoint_x = (pa.x + pb.x + pc.x) / 3;
                var midPoint_y = (pa.y + pb.y + pc.y) / 3;
                triad.pa.x = pa.x - midPoint_x;
                triad.pa.y = pa.y - midPoint_y;
                triad.pb.x = pb.x - midPoint_x;
                triad.pb.y = pb.y - midPoint_y;
                triad.pc.x = pc.x - midPoint_x;
                triad.pc.y = pc.y - midPoint_y;
                triad.ka = -b2Vec2.DotVV(dca, dab);
                triad.kb = -b2Vec2.DotVV(dab, dbc);
                triad.kc = -b2Vec2.DotVV(dbc, dca);
                triad.s = b2Vec2.CrossVV(pa, pb) + b2Vec2.CrossVV(pb, pc) + b2Vec2.CrossVV(pc, pa);
              }
            };
            diagram.GetNodes(callback);
            std_stable_sort(this.m_triadBuffer.data, 0, this.m_triadBuffer.count, b2ParticleSystem.CompareTriadIndices);
            this.m_triadBuffer.Unique(b2ParticleSystem.MatchTriadIndices);
          }
        };
        b2ParticleSystem.prototype.UpdatePairsAndTriadsWithReactiveParticles = function() {
          var filter = new b2ParticleSystem.ReactiveFilter(this.m_flagsBuffer);
          this.UpdatePairsAndTriads(0, this.m_count, filter);
          if (!this.m_flagsBuffer.data) throw new Error();
          for (var i = 0; i < this.m_count; i++) this.m_flagsBuffer.data[i] &= ~exports.b2ParticleFlag.b2_reactiveParticle;
          this.m_allParticleFlags &= ~exports.b2ParticleFlag.b2_reactiveParticle;
        };
        b2ParticleSystem.ComparePairIndices = function(a, b) {
          var diffA = a.indexA - b.indexA;
          if (0 !== diffA) return diffA < 0;
          return a.indexB < b.indexB;
        };
        b2ParticleSystem.MatchPairIndices = function(a, b) {
          return a.indexA === b.indexA && a.indexB === b.indexB;
        };
        b2ParticleSystem.CompareTriadIndices = function(a, b) {
          var diffA = a.indexA - b.indexA;
          if (0 !== diffA) return diffA < 0;
          var diffB = a.indexB - b.indexB;
          if (0 !== diffB) return diffB < 0;
          return a.indexC < b.indexC;
        };
        b2ParticleSystem.MatchTriadIndices = function(a, b) {
          return a.indexA === b.indexA && a.indexB === b.indexB && a.indexC === b.indexC;
        };
        b2ParticleSystem.InitializeParticleLists = function(group, nodeBuffer) {
          var bufferIndex = group.GetBufferIndex();
          var particleCount = group.GetParticleCount();
          for (var i = 0; i < particleCount; i++) {
            var node = nodeBuffer[i];
            node.list = node;
            node.next = null;
            node.count = 1;
            node.index = i + bufferIndex;
          }
        };
        b2ParticleSystem.prototype.MergeParticleListsInContact = function(group, nodeBuffer) {
          var bufferIndex = group.GetBufferIndex();
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            var a = contact.indexA;
            var b = contact.indexB;
            if (!group.ContainsParticle(a) || !group.ContainsParticle(b)) continue;
            var listA = nodeBuffer[a - bufferIndex].list;
            var listB = nodeBuffer[b - bufferIndex].list;
            if (listA === listB) continue;
            if (listA.count < listB.count) {
              var _tmp = listA;
              listA = listB;
              listB = _tmp;
            }
            b2ParticleSystem.MergeParticleLists(listA, listB);
          }
        };
        b2ParticleSystem.MergeParticleLists = function(listA, listB) {
          for (var b = listB; ;) {
            b.list = listA;
            var nextB = b.next;
            if (!nextB) {
              b.next = listA.next;
              break;
            }
            b = nextB;
          }
          listA.next = listB;
          listA.count += listB.count;
          listB.count = 0;
        };
        b2ParticleSystem.FindLongestParticleList = function(group, nodeBuffer) {
          var particleCount = group.GetParticleCount();
          var result = nodeBuffer[0];
          for (var i = 0; i < particleCount; i++) {
            var node = nodeBuffer[i];
            result.count < node.count && (result = node);
          }
          return result;
        };
        b2ParticleSystem.prototype.MergeZombieParticleListNodes = function(group, nodeBuffer, survivingList) {
          if (!this.m_flagsBuffer.data) throw new Error();
          var particleCount = group.GetParticleCount();
          for (var i = 0; i < particleCount; i++) {
            var node = nodeBuffer[i];
            node !== survivingList && this.m_flagsBuffer.data[node.index] & exports.b2ParticleFlag.b2_zombieParticle && b2ParticleSystem.MergeParticleListAndNode(survivingList, node);
          }
        };
        b2ParticleSystem.MergeParticleListAndNode = function(list, node) {
          node.list = list;
          node.next = list.next;
          list.next = node;
          list.count++;
          node.count = 0;
        };
        b2ParticleSystem.prototype.CreateParticleGroupsFromParticleList = function(group, nodeBuffer, survivingList) {
          if (!this.m_flagsBuffer.data) throw new Error();
          var particleCount = group.GetParticleCount();
          var def = new b2ParticleGroupDef();
          def.groupFlags = group.GetGroupFlags();
          def.userData = group.GetUserData();
          for (var i = 0; i < particleCount; i++) {
            var list = nodeBuffer[i];
            if (!list.count || list === survivingList) continue;
            var newGroup = this.CreateParticleGroup(def);
            for (var node = list; node; node = node.next) {
              var oldIndex = node.index;
              var newIndex = this.CloneParticle(oldIndex, newGroup);
              this.m_flagsBuffer.data[oldIndex] |= exports.b2ParticleFlag.b2_zombieParticle;
              node.index = newIndex;
            }
          }
        };
        b2ParticleSystem.prototype.UpdatePairsAndTriadsWithParticleList = function(group, nodeBuffer) {
          var bufferIndex = group.GetBufferIndex();
          for (var k = 0; k < this.m_pairBuffer.count; k++) {
            var pair = this.m_pairBuffer.data[k];
            var a = pair.indexA;
            var b = pair.indexB;
            group.ContainsParticle(a) && (pair.indexA = nodeBuffer[a - bufferIndex].index);
            group.ContainsParticle(b) && (pair.indexB = nodeBuffer[b - bufferIndex].index);
          }
          for (var k = 0; k < this.m_triadBuffer.count; k++) {
            var triad = this.m_triadBuffer.data[k];
            var a = triad.indexA;
            var b = triad.indexB;
            var c = triad.indexC;
            group.ContainsParticle(a) && (triad.indexA = nodeBuffer[a - bufferIndex].index);
            group.ContainsParticle(b) && (triad.indexB = nodeBuffer[b - bufferIndex].index);
            group.ContainsParticle(c) && (triad.indexC = nodeBuffer[c - bufferIndex].index);
          }
        };
        b2ParticleSystem.prototype.ComputeDepth = function() {
          var contactGroups = [];
          var contactGroupsCount = 0;
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            var a = contact.indexA;
            var b = contact.indexB;
            var groupA = this.m_groupBuffer[a];
            var groupB = this.m_groupBuffer[b];
            groupA && groupA === groupB && groupA.m_groupFlags & exports.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth && (contactGroups[contactGroupsCount++] = contact);
          }
          var groupsToUpdate = [];
          var groupsToUpdateCount = 0;
          for (var group = this.m_groupList; group; group = group.GetNext()) if (group.m_groupFlags & exports.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth) {
            groupsToUpdate[groupsToUpdateCount++] = group;
            this.SetGroupFlags(group, group.m_groupFlags & ~exports.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth);
            for (var i = group.m_firstIndex; i < group.m_lastIndex; i++) this.m_accumulationBuffer[i] = 0;
          }
          for (var k = 0; k < contactGroupsCount; k++) {
            var contact = contactGroups[k];
            var a = contact.indexA;
            var b = contact.indexB;
            var w = contact.weight;
            this.m_accumulationBuffer[a] += w;
            this.m_accumulationBuffer[b] += w;
          }
          for (var i = 0; i < groupsToUpdateCount; i++) {
            var group = groupsToUpdate[i];
            for (var i_1 = group.m_firstIndex; i_1 < group.m_lastIndex; i_1++) {
              var w = this.m_accumulationBuffer[i_1];
              this.m_depthBuffer[i_1] = w < .8 ? 0 : b2_maxFloat;
            }
          }
          var iterationCount = b2Sqrt(this.m_count) >> 0;
          for (var t = 0; t < iterationCount; t++) {
            var updated = false;
            for (var k = 0; k < contactGroupsCount; k++) {
              var contact = contactGroups[k];
              var a = contact.indexA;
              var b = contact.indexB;
              var r = 1 - contact.weight;
              var ap0 = this.m_depthBuffer[a];
              var bp0 = this.m_depthBuffer[b];
              var ap1 = bp0 + r;
              var bp1 = ap0 + r;
              if (ap0 > ap1) {
                this.m_depthBuffer[a] = ap1;
                updated = true;
              }
              if (bp0 > bp1) {
                this.m_depthBuffer[b] = bp1;
                updated = true;
              }
            }
            if (!updated) break;
          }
          for (var i = 0; i < groupsToUpdateCount; i++) {
            var group = groupsToUpdate[i];
            for (var i_2 = group.m_firstIndex; i_2 < group.m_lastIndex; i_2++) this.m_depthBuffer[i_2] < b2_maxFloat ? this.m_depthBuffer[i_2] *= this.m_particleDiameter : this.m_depthBuffer[i_2] = 0;
          }
        };
        b2ParticleSystem.prototype.GetInsideBoundsEnumerator = function(aabb) {
          var lowerTag = b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.lowerBound.x - 1, this.m_inverseDiameter * aabb.lowerBound.y - 1);
          var upperTag = b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.upperBound.x + 1, this.m_inverseDiameter * aabb.upperBound.y + 1);
          var beginProxy = 0;
          var endProxy = this.m_proxyBuffer.count;
          var firstProxy = std_lower_bound(this.m_proxyBuffer.data, beginProxy, endProxy, lowerTag, b2ParticleSystem.Proxy.CompareProxyTag);
          var lastProxy = std_upper_bound(this.m_proxyBuffer.data, beginProxy, endProxy, upperTag, b2ParticleSystem.Proxy.CompareTagProxy);
          return new b2ParticleSystem.InsideBoundsEnumerator(this, lowerTag, upperTag, firstProxy, lastProxy);
        };
        b2ParticleSystem.prototype.UpdateAllParticleFlags = function() {
          if (!this.m_flagsBuffer.data) throw new Error();
          this.m_allParticleFlags = 0;
          for (var i = 0; i < this.m_count; i++) this.m_allParticleFlags |= this.m_flagsBuffer.data[i];
          this.m_needsUpdateAllParticleFlags = false;
        };
        b2ParticleSystem.prototype.UpdateAllGroupFlags = function() {
          this.m_allGroupFlags = 0;
          for (var group = this.m_groupList; group; group = group.GetNext()) this.m_allGroupFlags |= group.m_groupFlags;
          this.m_needsUpdateAllGroupFlags = false;
        };
        b2ParticleSystem.prototype.AddContact = function(a, b, contacts) {
          if (!this.m_flagsBuffer.data) throw new Error();
          if (!this.m_positionBuffer.data) throw new Error();
          var s_d = b2ParticleSystem.AddContact_s_d;
          var pos_data = this.m_positionBuffer.data;
          var d = b2Vec2.SubVV(pos_data[b], pos_data[a], s_d);
          var distBtParticlesSq = b2Vec2.DotVV(d, d);
          if (distBtParticlesSq < this.m_squaredDiameter) {
            var invD = b2InvSqrt(distBtParticlesSq);
            isFinite(invD) || (invD = 198177537e11);
            var contact = this.m_contactBuffer.data[this.m_contactBuffer.Append()];
            contact.indexA = a;
            contact.indexB = b;
            contact.flags = this.m_flagsBuffer.data[a] | this.m_flagsBuffer.data[b];
            contact.weight = 1 - distBtParticlesSq * invD * this.m_inverseDiameter;
            b2Vec2.MulSV(invD, d, contact.normal);
          }
        };
        b2ParticleSystem.prototype.FindContacts_Reference = function(contacts) {
          var beginProxy = 0;
          var endProxy = this.m_proxyBuffer.count;
          this.m_contactBuffer.count = 0;
          for (var a = beginProxy, c = beginProxy; a < endProxy; a++) {
            var rightTag = b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag, 1, 0);
            for (var b = a + 1; b < endProxy; b++) {
              if (rightTag < this.m_proxyBuffer.data[b].tag) break;
              this.AddContact(this.m_proxyBuffer.data[a].index, this.m_proxyBuffer.data[b].index, this.m_contactBuffer);
            }
            var bottomLeftTag = b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag, -1, 1);
            for (;c < endProxy; c++) if (bottomLeftTag <= this.m_proxyBuffer.data[c].tag) break;
            var bottomRightTag = b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag, 1, 1);
            for (var b = c; b < endProxy; b++) {
              if (bottomRightTag < this.m_proxyBuffer.data[b].tag) break;
              this.AddContact(this.m_proxyBuffer.data[a].index, this.m_proxyBuffer.data[b].index, this.m_contactBuffer);
            }
          }
        };
        b2ParticleSystem.prototype.FindContacts = function(contacts) {
          this.FindContacts_Reference(contacts);
        };
        b2ParticleSystem.prototype.UpdateProxies_Reference = function(proxies) {
          if (!this.m_positionBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var inv_diam = this.m_inverseDiameter;
          for (var k = 0; k < this.m_proxyBuffer.count; ++k) {
            var proxy = this.m_proxyBuffer.data[k];
            var i = proxy.index;
            var p = pos_data[i];
            proxy.tag = b2ParticleSystem.computeTag(inv_diam * p.x, inv_diam * p.y);
          }
        };
        b2ParticleSystem.prototype.UpdateProxies = function(proxies) {
          this.UpdateProxies_Reference(proxies);
        };
        b2ParticleSystem.prototype.SortProxies = function(proxies) {
          std_sort(this.m_proxyBuffer.data, 0, this.m_proxyBuffer.count, b2ParticleSystem.Proxy.CompareProxyProxy);
        };
        b2ParticleSystem.prototype.FilterContacts = function(contacts) {
          var contactFilter = this.GetParticleContactFilter();
          if (null === contactFilter) return;
          var system = this;
          var predicate = function predicate(contact) {
            return 0 !== (contact.flags & exports.b2ParticleFlag.b2_particleContactFilterParticle) && !contactFilter.ShouldCollideParticleParticle(system, contact.indexA, contact.indexB);
          };
          this.m_contactBuffer.RemoveIf(predicate);
        };
        b2ParticleSystem.prototype.NotifyContactListenerPreContact = function(particlePairs) {
          var contactListener = this.GetParticleContactListener();
          if (null === contactListener) return;
          particlePairs.Initialize(this.m_contactBuffer, this.m_flagsBuffer);
          throw new Error();
        };
        b2ParticleSystem.prototype.NotifyContactListenerPostContact = function(particlePairs) {
          var contactListener = this.GetParticleContactListener();
          if (null === contactListener) return;
          for (var k = 0; k < this.m_contactBuffer.count; ++k) {
            var contact = this.m_contactBuffer.data[k];
            contactListener.BeginContactParticleParticle(this, contact);
          }
          throw new Error();
        };
        b2ParticleSystem.b2ParticleContactIsZombie = function(contact) {
          return (contact.flags & exports.b2ParticleFlag.b2_zombieParticle) === exports.b2ParticleFlag.b2_zombieParticle;
        };
        b2ParticleSystem.prototype.UpdateContacts = function(exceptZombie) {
          this.UpdateProxies(this.m_proxyBuffer);
          this.SortProxies(this.m_proxyBuffer);
          var particlePairs = new b2ParticleSystem.b2ParticlePairSet();
          this.NotifyContactListenerPreContact(particlePairs);
          this.FindContacts(this.m_contactBuffer);
          this.FilterContacts(this.m_contactBuffer);
          this.NotifyContactListenerPostContact(particlePairs);
          exceptZombie && this.m_contactBuffer.RemoveIf(b2ParticleSystem.b2ParticleContactIsZombie);
        };
        b2ParticleSystem.prototype.NotifyBodyContactListenerPreContact = function(fixtureSet) {
          var contactListener = this.GetFixtureContactListener();
          if (null === contactListener) return;
          fixtureSet.Initialize(this.m_bodyContactBuffer, this.m_flagsBuffer);
          throw new Error();
        };
        b2ParticleSystem.prototype.NotifyBodyContactListenerPostContact = function(fixtureSet) {
          var contactListener = this.GetFixtureContactListener();
          if (null === contactListener) return;
          for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {
            var contact = this.m_bodyContactBuffer.data[k];
            contactListener.BeginContactFixtureParticle(this, contact);
          }
          throw new Error();
        };
        b2ParticleSystem.prototype.UpdateBodyContacts = function() {
          var s_aabb = b2ParticleSystem.UpdateBodyContacts_s_aabb;
          var fixtureSet = new b2ParticleSystem.FixtureParticleSet();
          this.NotifyBodyContactListenerPreContact(fixtureSet);
          if (this.m_stuckThreshold > 0) {
            if (!this.m_bodyContactCountBuffer.data) throw new Error();
            if (!this.m_lastBodyContactStepBuffer.data) throw new Error();
            if (!this.m_consecutiveContactStepsBuffer.data) throw new Error();
            var particleCount = this.GetParticleCount();
            for (var i = 0; i < particleCount; i++) {
              this.m_bodyContactCountBuffer.data[i] = 0;
              this.m_timestamp > this.m_lastBodyContactStepBuffer.data[i] + 1 && (this.m_consecutiveContactStepsBuffer.data[i] = 0);
            }
          }
          this.m_bodyContactBuffer.SetCount(0);
          this.m_stuckParticleBuffer.SetCount(0);
          var aabb = s_aabb;
          this.ComputeAABB(aabb);
          var callback = new b2ParticleSystem.UpdateBodyContactsCallback(this, this.GetFixtureContactFilter());
          this.m_world.QueryAABB(callback, aabb);
          this.m_def.strictContactCheck && this.RemoveSpuriousBodyContacts();
          this.NotifyBodyContactListenerPostContact(fixtureSet);
        };
        b2ParticleSystem.prototype.Solve = function(step) {
          var s_subStep = b2ParticleSystem.Solve_s_subStep;
          if (0 === this.m_count) return;
          this.m_expirationTimeBuffer.data && this.SolveLifetimes(step);
          this.m_allParticleFlags & exports.b2ParticleFlag.b2_zombieParticle && this.SolveZombie();
          this.m_needsUpdateAllParticleFlags && this.UpdateAllParticleFlags();
          this.m_needsUpdateAllGroupFlags && this.UpdateAllGroupFlags();
          if (this.m_paused) return;
          for (this.m_iterationIndex = 0; this.m_iterationIndex < step.particleIterations; this.m_iterationIndex++) {
            ++this.m_timestamp;
            var subStep = s_subStep.Copy(step);
            subStep.dt /= step.particleIterations;
            subStep.inv_dt *= step.particleIterations;
            this.UpdateContacts(false);
            this.UpdateBodyContacts();
            this.ComputeWeight();
            this.m_allGroupFlags & exports.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth && this.ComputeDepth();
            this.m_allParticleFlags & exports.b2ParticleFlag.b2_reactiveParticle && this.UpdatePairsAndTriadsWithReactiveParticles();
            this.m_hasForce && this.SolveForce(subStep);
            this.m_allParticleFlags & exports.b2ParticleFlag.b2_viscousParticle && this.SolveViscous();
            this.m_allParticleFlags & exports.b2ParticleFlag.b2_repulsiveParticle && this.SolveRepulsive(subStep);
            this.m_allParticleFlags & exports.b2ParticleFlag.b2_powderParticle && this.SolvePowder(subStep);
            this.m_allParticleFlags & exports.b2ParticleFlag.b2_tensileParticle && this.SolveTensile(subStep);
            this.m_allGroupFlags & exports.b2ParticleGroupFlag.b2_solidParticleGroup && this.SolveSolid(subStep);
            this.m_allParticleFlags & exports.b2ParticleFlag.b2_colorMixingParticle && this.SolveColorMixing();
            this.SolveGravity(subStep);
            this.m_allParticleFlags & exports.b2ParticleFlag.b2_staticPressureParticle && this.SolveStaticPressure(subStep);
            this.SolvePressure(subStep);
            this.SolveDamping(subStep);
            this.m_allParticleFlags & b2ParticleSystem.k_extraDampingFlags && this.SolveExtraDamping();
            this.m_allParticleFlags & exports.b2ParticleFlag.b2_elasticParticle && this.SolveElastic(subStep);
            this.m_allParticleFlags & exports.b2ParticleFlag.b2_springParticle && this.SolveSpring(subStep);
            this.LimitVelocity(subStep);
            this.m_allGroupFlags & exports.b2ParticleGroupFlag.b2_rigidParticleGroup && this.SolveRigidDamping();
            this.m_allParticleFlags & exports.b2ParticleFlag.b2_barrierParticle && this.SolveBarrier(subStep);
            this.SolveCollision(subStep);
            this.m_allGroupFlags & exports.b2ParticleGroupFlag.b2_rigidParticleGroup && this.SolveRigid(subStep);
            this.m_allParticleFlags & exports.b2ParticleFlag.b2_wallParticle && this.SolveWall();
            if (!this.m_positionBuffer.data) throw new Error();
            if (!this.m_velocityBuffer.data) throw new Error();
            for (var i = 0; i < this.m_count; i++) this.m_positionBuffer.data[i].SelfMulAdd(subStep.dt, this.m_velocityBuffer.data[i]);
          }
        };
        b2ParticleSystem.prototype.SolveCollision = function(step) {
          var s_aabb = b2ParticleSystem.SolveCollision_s_aabb;
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var vel_data = this.m_velocityBuffer.data;
          var aabb = s_aabb;
          aabb.lowerBound.x = +b2_maxFloat;
          aabb.lowerBound.y = +b2_maxFloat;
          aabb.upperBound.x = -b2_maxFloat;
          aabb.upperBound.y = -b2_maxFloat;
          for (var i = 0; i < this.m_count; i++) {
            var v = vel_data[i];
            var p1 = pos_data[i];
            var p2_x = p1.x + step.dt * v.x;
            var p2_y = p1.y + step.dt * v.y;
            aabb.lowerBound.x = b2Min(aabb.lowerBound.x, b2Min(p1.x, p2_x));
            aabb.lowerBound.y = b2Min(aabb.lowerBound.y, b2Min(p1.y, p2_y));
            aabb.upperBound.x = b2Max(aabb.upperBound.x, b2Max(p1.x, p2_x));
            aabb.upperBound.y = b2Max(aabb.upperBound.y, b2Max(p1.y, p2_y));
          }
          var callback = new b2ParticleSystem.SolveCollisionCallback(this, step);
          this.m_world.QueryAABB(callback, aabb);
        };
        b2ParticleSystem.prototype.LimitVelocity = function(step) {
          if (!this.m_velocityBuffer.data) throw new Error();
          var vel_data = this.m_velocityBuffer.data;
          var criticalVelocitySquared = this.GetCriticalVelocitySquared(step);
          for (var i = 0; i < this.m_count; i++) {
            var v = vel_data[i];
            var v2 = b2Vec2.DotVV(v, v);
            v2 > criticalVelocitySquared && v.SelfMul(b2Sqrt(criticalVelocitySquared / v2));
          }
        };
        b2ParticleSystem.prototype.SolveGravity = function(step) {
          if (!this.m_velocityBuffer.data) throw new Error();
          var s_gravity = b2ParticleSystem.SolveGravity_s_gravity;
          var vel_data = this.m_velocityBuffer.data;
          var gravity = b2Vec2.MulSV(step.dt * this.m_def.gravityScale, this.m_world.GetGravity(), s_gravity);
          for (var i = 0; i < this.m_count; i++) vel_data[i].SelfAdd(gravity);
        };
        b2ParticleSystem.prototype.SolveBarrier = function(step) {
          var s_aabb = b2ParticleSystem.SolveBarrier_s_aabb;
          var s_va = b2ParticleSystem.SolveBarrier_s_va;
          var s_vb = b2ParticleSystem.SolveBarrier_s_vb;
          var s_pba = b2ParticleSystem.SolveBarrier_s_pba;
          var s_vba = b2ParticleSystem.SolveBarrier_s_vba;
          var s_vc = b2ParticleSystem.SolveBarrier_s_vc;
          var s_pca = b2ParticleSystem.SolveBarrier_s_pca;
          var s_vca = b2ParticleSystem.SolveBarrier_s_vca;
          var s_qba = b2ParticleSystem.SolveBarrier_s_qba;
          var s_qca = b2ParticleSystem.SolveBarrier_s_qca;
          var s_dv = b2ParticleSystem.SolveBarrier_s_dv;
          var s_f = b2ParticleSystem.SolveBarrier_s_f;
          if (!this.m_flagsBuffer.data) throw new Error();
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var vel_data = this.m_velocityBuffer.data;
          for (var i = 0; i < this.m_count; i++) {
            var flags = this.m_flagsBuffer.data[i];
            0 !== (flags & b2ParticleSystem.k_barrierWallFlags) && vel_data[i].SetZero();
          }
          var tmax = b2_barrierCollisionTime * step.dt;
          var mass = this.GetParticleMass();
          for (var k = 0; k < this.m_pairBuffer.count; k++) {
            var pair = this.m_pairBuffer.data[k];
            if (pair.flags & exports.b2ParticleFlag.b2_barrierParticle) {
              var a = pair.indexA;
              var b = pair.indexB;
              var pa = pos_data[a];
              var pb = pos_data[b];
              var aabb = s_aabb;
              b2Vec2.MinV(pa, pb, aabb.lowerBound);
              b2Vec2.MaxV(pa, pb, aabb.upperBound);
              var aGroup = this.m_groupBuffer[a];
              var bGroup = this.m_groupBuffer[b];
              var va = this.GetLinearVelocity(aGroup, a, pa, s_va);
              var vb = this.GetLinearVelocity(bGroup, b, pb, s_vb);
              var pba = b2Vec2.SubVV(pb, pa, s_pba);
              var vba = b2Vec2.SubVV(vb, va, s_vba);
              var enumerator = this.GetInsideBoundsEnumerator(aabb);
              var c = void 0;
              while ((c = enumerator.GetNext()) >= 0) {
                var pc = pos_data[c];
                var cGroup = this.m_groupBuffer[c];
                if (aGroup !== cGroup && bGroup !== cGroup) {
                  var vc = this.GetLinearVelocity(cGroup, c, pc, s_vc);
                  var pca = b2Vec2.SubVV(pc, pa, s_pca);
                  var vca = b2Vec2.SubVV(vc, va, s_vca);
                  var e2 = b2Vec2.CrossVV(vba, vca);
                  var e1 = b2Vec2.CrossVV(pba, vca) - b2Vec2.CrossVV(pca, vba);
                  var e0 = b2Vec2.CrossVV(pba, pca);
                  var s = void 0, t = void 0;
                  var qba = s_qba, qca = s_qca;
                  if (0 === e2) {
                    if (0 === e1) continue;
                    t = -e0 / e1;
                    if (!(t >= 0 && t < tmax)) continue;
                    b2Vec2.AddVMulSV(pba, t, vba, qba);
                    b2Vec2.AddVMulSV(pca, t, vca, qca);
                    s = b2Vec2.DotVV(qba, qca) / b2Vec2.DotVV(qba, qba);
                    if (!(s >= 0 && s <= 1)) continue;
                  } else {
                    var det = e1 * e1 - 4 * e0 * e2;
                    if (det < 0) continue;
                    var sqrtDet = b2Sqrt(det);
                    var t1 = (-e1 - sqrtDet) / (2 * e2);
                    var t2 = (-e1 + sqrtDet) / (2 * e2);
                    if (t1 > t2) {
                      var tmp = t1;
                      t1 = t2;
                      t2 = tmp;
                    }
                    t = t1;
                    b2Vec2.AddVMulSV(pba, t, vba, qba);
                    b2Vec2.AddVMulSV(pca, t, vca, qca);
                    s = b2Vec2.DotVV(qba, qca) / b2Vec2.DotVV(qba, qba);
                    if (!(t >= 0 && t < tmax && s >= 0 && s <= 1)) {
                      t = t2;
                      if (!(t >= 0 && t < tmax)) continue;
                      b2Vec2.AddVMulSV(pba, t, vba, qba);
                      b2Vec2.AddVMulSV(pca, t, vca, qca);
                      s = b2Vec2.DotVV(qba, qca) / b2Vec2.DotVV(qba, qba);
                      if (!(s >= 0 && s <= 1)) continue;
                    }
                  }
                  var dv = s_dv;
                  dv.x = va.x + s * vba.x - vc.x;
                  dv.y = va.y + s * vba.y - vc.y;
                  var f = b2Vec2.MulSV(mass, dv, s_f);
                  if (cGroup && this.IsRigidGroup(cGroup)) {
                    var mass_1 = cGroup.GetMass();
                    var inertia = cGroup.GetInertia();
                    mass_1 > 0 && cGroup.m_linearVelocity.SelfMulAdd(1 / mass_1, f);
                    inertia > 0 && (cGroup.m_angularVelocity += b2Vec2.CrossVV(b2Vec2.SubVV(pc, cGroup.GetCenter(), b2Vec2.s_t0), f) / inertia);
                  } else vel_data[c].SelfAdd(dv);
                  this.ParticleApplyForce(c, f.SelfMul(-step.inv_dt));
                }
              }
            }
          }
        };
        b2ParticleSystem.prototype.SolveStaticPressure = function(step) {
          if (!this.m_flagsBuffer.data) throw new Error();
          this.m_staticPressureBuffer = this.RequestBuffer(this.m_staticPressureBuffer);
          var criticalPressure = this.GetCriticalPressure(step);
          var pressurePerWeight = this.m_def.staticPressureStrength * criticalPressure;
          var maxPressure = b2_maxParticlePressure * criticalPressure;
          var relaxation = this.m_def.staticPressureRelaxation;
          for (var t = 0; t < this.m_def.staticPressureIterations; t++) {
            for (var i = 0; i < this.m_count; i++) this.m_accumulationBuffer[i] = 0;
            for (var k = 0; k < this.m_contactBuffer.count; k++) {
              var contact = this.m_contactBuffer.data[k];
              if (contact.flags & exports.b2ParticleFlag.b2_staticPressureParticle) {
                var a = contact.indexA;
                var b = contact.indexB;
                var w = contact.weight;
                this.m_accumulationBuffer[a] += w * this.m_staticPressureBuffer[b];
                this.m_accumulationBuffer[b] += w * this.m_staticPressureBuffer[a];
              }
            }
            for (var i = 0; i < this.m_count; i++) {
              var w = this.m_weightBuffer[i];
              if (this.m_flagsBuffer.data[i] & exports.b2ParticleFlag.b2_staticPressureParticle) {
                var wh = this.m_accumulationBuffer[i];
                var h = (wh + pressurePerWeight * (w - b2_minParticleWeight)) / (w + relaxation);
                this.m_staticPressureBuffer[i] = b2Clamp(h, 0, maxPressure);
              } else this.m_staticPressureBuffer[i] = 0;
            }
          }
        };
        b2ParticleSystem.prototype.ComputeWeight = function() {
          for (var k = 0; k < this.m_count; k++) this.m_weightBuffer[k] = 0;
          for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {
            var contact = this.m_bodyContactBuffer.data[k];
            var a = contact.index;
            var w = contact.weight;
            this.m_weightBuffer[a] += w;
          }
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            var a = contact.indexA;
            var b = contact.indexB;
            var w = contact.weight;
            this.m_weightBuffer[a] += w;
            this.m_weightBuffer[b] += w;
          }
        };
        b2ParticleSystem.prototype.SolvePressure = function(step) {
          var s_f = b2ParticleSystem.SolvePressure_s_f;
          if (!this.m_flagsBuffer.data) throw new Error();
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var vel_data = this.m_velocityBuffer.data;
          var criticalPressure = this.GetCriticalPressure(step);
          var pressurePerWeight = this.m_def.pressureStrength * criticalPressure;
          var maxPressure = b2_maxParticlePressure * criticalPressure;
          for (var i = 0; i < this.m_count; i++) {
            var w = this.m_weightBuffer[i];
            var h = pressurePerWeight * b2Max(0, w - b2_minParticleWeight);
            this.m_accumulationBuffer[i] = b2Min(h, maxPressure);
          }
          if (this.m_allParticleFlags & b2ParticleSystem.k_noPressureFlags) for (var i = 0; i < this.m_count; i++) this.m_flagsBuffer.data[i] & b2ParticleSystem.k_noPressureFlags && (this.m_accumulationBuffer[i] = 0);
          if (this.m_allParticleFlags & exports.b2ParticleFlag.b2_staticPressureParticle) for (var i = 0; i < this.m_count; i++) this.m_flagsBuffer.data[i] & exports.b2ParticleFlag.b2_staticPressureParticle && (this.m_accumulationBuffer[i] += this.m_staticPressureBuffer[i]);
          var velocityPerPressure = step.dt / (this.m_def.density * this.m_particleDiameter);
          var inv_mass = this.GetParticleInvMass();
          for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {
            var contact = this.m_bodyContactBuffer.data[k];
            var a = contact.index;
            var b = contact.body;
            var w = contact.weight;
            var m = contact.mass;
            var n = contact.normal;
            var p = pos_data[a];
            var h = this.m_accumulationBuffer[a] + pressurePerWeight * w;
            var f = b2Vec2.MulSV(velocityPerPressure * w * m * h, n, s_f);
            vel_data[a].SelfMulSub(inv_mass, f);
            b.ApplyLinearImpulse(f, p, true);
          }
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            var a = contact.indexA;
            var b = contact.indexB;
            var w = contact.weight;
            var n = contact.normal;
            var h = this.m_accumulationBuffer[a] + this.m_accumulationBuffer[b];
            var f = b2Vec2.MulSV(velocityPerPressure * w * h, n, s_f);
            vel_data[a].SelfSub(f);
            vel_data[b].SelfAdd(f);
          }
        };
        b2ParticleSystem.prototype.SolveDamping = function(step) {
          var s_v = b2ParticleSystem.SolveDamping_s_v;
          var s_f = b2ParticleSystem.SolveDamping_s_f;
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var vel_data = this.m_velocityBuffer.data;
          var linearDamping = this.m_def.dampingStrength;
          var quadraticDamping = 1 / this.GetCriticalVelocity(step);
          var inv_mass = this.GetParticleInvMass();
          for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {
            var contact = this.m_bodyContactBuffer.data[k];
            var a = contact.index;
            var b = contact.body;
            var w = contact.weight;
            var m = contact.mass;
            var n = contact.normal;
            var p = pos_data[a];
            var v = b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, b2Vec2.s_t0), vel_data[a], s_v);
            var vn = b2Vec2.DotVV(v, n);
            if (vn < 0) {
              var damping = b2Max(linearDamping * w, b2Min(-quadraticDamping * vn, .5));
              var f = b2Vec2.MulSV(damping * m * vn, n, s_f);
              vel_data[a].SelfMulAdd(inv_mass, f);
              b.ApplyLinearImpulse(f.SelfNeg(), p, true);
            }
          }
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            var a = contact.indexA;
            var b = contact.indexB;
            var w = contact.weight;
            var n = contact.normal;
            var v = b2Vec2.SubVV(vel_data[b], vel_data[a], s_v);
            var vn = b2Vec2.DotVV(v, n);
            if (vn < 0) {
              var damping = b2Max(linearDamping * w, b2Min(-quadraticDamping * vn, .5));
              var f = b2Vec2.MulSV(damping * vn, n, s_f);
              vel_data[a].SelfAdd(f);
              vel_data[b].SelfSub(f);
            }
          }
        };
        b2ParticleSystem.prototype.SolveRigidDamping = function() {
          var s_t0 = b2ParticleSystem.SolveRigidDamping_s_t0;
          var s_t1 = b2ParticleSystem.SolveRigidDamping_s_t1;
          var s_p = b2ParticleSystem.SolveRigidDamping_s_p;
          var s_v = b2ParticleSystem.SolveRigidDamping_s_v;
          var invMassA = [ 0 ], invInertiaA = [ 0 ], tangentDistanceA = [ 0 ];
          var invMassB = [ 0 ], invInertiaB = [ 0 ], tangentDistanceB = [ 0 ];
          if (!this.m_positionBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var damping = this.m_def.dampingStrength;
          for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {
            var contact = this.m_bodyContactBuffer.data[k];
            var a = contact.index;
            var aGroup = this.m_groupBuffer[a];
            if (aGroup && this.IsRigidGroup(aGroup)) {
              var b = contact.body;
              var n = contact.normal;
              var w = contact.weight;
              var p = pos_data[a];
              var v = b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, s_t0), aGroup.GetLinearVelocityFromWorldPoint(p, s_t1), s_v);
              var vn = b2Vec2.DotVV(v, n);
              if (vn < 0) {
                this.InitDampingParameterWithRigidGroupOrParticle(invMassA, invInertiaA, tangentDistanceA, true, aGroup, a, p, n);
                this.InitDampingParameter(invMassB, invInertiaB, tangentDistanceB, b.GetMass(), b.GetInertia() - b.GetMass() * b.GetLocalCenter().LengthSquared(), b.GetWorldCenter(), p, n);
                var f = damping * b2Min(w, 1) * this.ComputeDampingImpulse(invMassA[0], invInertiaA[0], tangentDistanceA[0], invMassB[0], invInertiaB[0], tangentDistanceB[0], vn);
                this.ApplyDamping(invMassA[0], invInertiaA[0], tangentDistanceA[0], true, aGroup, a, f, n);
                b.ApplyLinearImpulse(b2Vec2.MulSV(-f, n, b2Vec2.s_t0), p, true);
              }
            }
          }
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            var a = contact.indexA;
            var b = contact.indexB;
            var n = contact.normal;
            var w = contact.weight;
            var aGroup = this.m_groupBuffer[a];
            var bGroup = this.m_groupBuffer[b];
            var aRigid = this.IsRigidGroup(aGroup);
            var bRigid = this.IsRigidGroup(bGroup);
            if (aGroup !== bGroup && (aRigid || bRigid)) {
              var p = b2Vec2.MidVV(pos_data[a], pos_data[b], s_p);
              var v = b2Vec2.SubVV(this.GetLinearVelocity(bGroup, b, p, s_t0), this.GetLinearVelocity(aGroup, a, p, s_t1), s_v);
              var vn = b2Vec2.DotVV(v, n);
              if (vn < 0) {
                this.InitDampingParameterWithRigidGroupOrParticle(invMassA, invInertiaA, tangentDistanceA, aRigid, aGroup, a, p, n);
                this.InitDampingParameterWithRigidGroupOrParticle(invMassB, invInertiaB, tangentDistanceB, bRigid, bGroup, b, p, n);
                var f = damping * w * this.ComputeDampingImpulse(invMassA[0], invInertiaA[0], tangentDistanceA[0], invMassB[0], invInertiaB[0], tangentDistanceB[0], vn);
                this.ApplyDamping(invMassA[0], invInertiaA[0], tangentDistanceA[0], aRigid, aGroup, a, f, n);
                this.ApplyDamping(invMassB[0], invInertiaB[0], tangentDistanceB[0], bRigid, bGroup, b, -f, n);
              }
            }
          }
        };
        b2ParticleSystem.prototype.SolveExtraDamping = function() {
          var s_v = b2ParticleSystem.SolveExtraDamping_s_v;
          var s_f = b2ParticleSystem.SolveExtraDamping_s_f;
          if (!this.m_flagsBuffer.data) throw new Error();
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var vel_data = this.m_velocityBuffer.data;
          var pos_data = this.m_positionBuffer.data;
          var inv_mass = this.GetParticleInvMass();
          for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {
            var contact = this.m_bodyContactBuffer.data[k];
            var a = contact.index;
            if (this.m_flagsBuffer.data[a] & b2ParticleSystem.k_extraDampingFlags) {
              var b = contact.body;
              var m = contact.mass;
              var n = contact.normal;
              var p = pos_data[a];
              var v = b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, b2Vec2.s_t0), vel_data[a], s_v);
              var vn = b2Vec2.DotVV(v, n);
              if (vn < 0) {
                var f = b2Vec2.MulSV(.5 * m * vn, n, s_f);
                vel_data[a].SelfMulAdd(inv_mass, f);
                b.ApplyLinearImpulse(f.SelfNeg(), p, true);
              }
            }
          }
        };
        b2ParticleSystem.prototype.SolveWall = function() {
          if (!this.m_flagsBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var vel_data = this.m_velocityBuffer.data;
          for (var i = 0; i < this.m_count; i++) this.m_flagsBuffer.data[i] & exports.b2ParticleFlag.b2_wallParticle && vel_data[i].SetZero();
        };
        b2ParticleSystem.prototype.SolveRigid = function(step) {
          var s_position = b2ParticleSystem.SolveRigid_s_position;
          var s_rotation = b2ParticleSystem.SolveRigid_s_rotation;
          var s_transform = b2ParticleSystem.SolveRigid_s_transform;
          var s_velocityTransform = b2ParticleSystem.SolveRigid_s_velocityTransform;
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var vel_data = this.m_velocityBuffer.data;
          for (var group = this.m_groupList; group; group = group.GetNext()) if (group.m_groupFlags & exports.b2ParticleGroupFlag.b2_rigidParticleGroup) {
            group.UpdateStatistics();
            var rotation = s_rotation;
            rotation.SetAngle(step.dt * group.m_angularVelocity);
            var position = b2Vec2.AddVV(group.m_center, b2Vec2.SubVV(b2Vec2.MulSV(step.dt, group.m_linearVelocity, b2Vec2.s_t0), b2Rot.MulRV(rotation, group.m_center, b2Vec2.s_t1), b2Vec2.s_t0), s_position);
            var transform = s_transform;
            transform.SetPositionRotation(position, rotation);
            b2Transform.MulXX(transform, group.m_transform, group.m_transform);
            var velocityTransform = s_velocityTransform;
            velocityTransform.p.x = step.inv_dt * transform.p.x;
            velocityTransform.p.y = step.inv_dt * transform.p.y;
            velocityTransform.q.s = step.inv_dt * transform.q.s;
            velocityTransform.q.c = step.inv_dt * (transform.q.c - 1);
            for (var i = group.m_firstIndex; i < group.m_lastIndex; i++) b2Transform.MulXV(velocityTransform, pos_data[i], vel_data[i]);
          }
        };
        b2ParticleSystem.prototype.SolveElastic = function(step) {
          var s_pa = b2ParticleSystem.SolveElastic_s_pa;
          var s_pb = b2ParticleSystem.SolveElastic_s_pb;
          var s_pc = b2ParticleSystem.SolveElastic_s_pc;
          var s_r = b2ParticleSystem.SolveElastic_s_r;
          var s_t0 = b2ParticleSystem.SolveElastic_s_t0;
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var vel_data = this.m_velocityBuffer.data;
          var elasticStrength = step.inv_dt * this.m_def.elasticStrength;
          for (var k = 0; k < this.m_triadBuffer.count; k++) {
            var triad = this.m_triadBuffer.data[k];
            if (triad.flags & exports.b2ParticleFlag.b2_elasticParticle) {
              var a = triad.indexA;
              var b = triad.indexB;
              var c = triad.indexC;
              var oa = triad.pa;
              var ob = triad.pb;
              var oc = triad.pc;
              var pa = s_pa.Copy(pos_data[a]);
              var pb = s_pb.Copy(pos_data[b]);
              var pc = s_pc.Copy(pos_data[c]);
              var va = vel_data[a];
              var vb = vel_data[b];
              var vc = vel_data[c];
              pa.SelfMulAdd(step.dt, va);
              pb.SelfMulAdd(step.dt, vb);
              pc.SelfMulAdd(step.dt, vc);
              var midPoint_x = (pa.x + pb.x + pc.x) / 3;
              var midPoint_y = (pa.y + pb.y + pc.y) / 3;
              pa.x -= midPoint_x;
              pa.y -= midPoint_y;
              pb.x -= midPoint_x;
              pb.y -= midPoint_y;
              pc.x -= midPoint_x;
              pc.y -= midPoint_y;
              var r = s_r;
              r.s = b2Vec2.CrossVV(oa, pa) + b2Vec2.CrossVV(ob, pb) + b2Vec2.CrossVV(oc, pc);
              r.c = b2Vec2.DotVV(oa, pa) + b2Vec2.DotVV(ob, pb) + b2Vec2.DotVV(oc, pc);
              var r2 = r.s * r.s + r.c * r.c;
              var invR = b2InvSqrt(r2);
              isFinite(invR) || (invR = 198177537e11);
              r.s *= invR;
              r.c *= invR;
              var strength = elasticStrength * triad.strength;
              b2Rot.MulRV(r, oa, s_t0);
              b2Vec2.SubVV(s_t0, pa, s_t0);
              b2Vec2.MulSV(strength, s_t0, s_t0);
              va.SelfAdd(s_t0);
              b2Rot.MulRV(r, ob, s_t0);
              b2Vec2.SubVV(s_t0, pb, s_t0);
              b2Vec2.MulSV(strength, s_t0, s_t0);
              vb.SelfAdd(s_t0);
              b2Rot.MulRV(r, oc, s_t0);
              b2Vec2.SubVV(s_t0, pc, s_t0);
              b2Vec2.MulSV(strength, s_t0, s_t0);
              vc.SelfAdd(s_t0);
            }
          }
        };
        b2ParticleSystem.prototype.SolveSpring = function(step) {
          var s_pa = b2ParticleSystem.SolveSpring_s_pa;
          var s_pb = b2ParticleSystem.SolveSpring_s_pb;
          var s_d = b2ParticleSystem.SolveSpring_s_d;
          var s_f = b2ParticleSystem.SolveSpring_s_f;
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var vel_data = this.m_velocityBuffer.data;
          var springStrength = step.inv_dt * this.m_def.springStrength;
          for (var k = 0; k < this.m_pairBuffer.count; k++) {
            var pair = this.m_pairBuffer.data[k];
            if (pair.flags & exports.b2ParticleFlag.b2_springParticle) {
              var a = pair.indexA;
              var b = pair.indexB;
              var pa = s_pa.Copy(pos_data[a]);
              var pb = s_pb.Copy(pos_data[b]);
              var va = vel_data[a];
              var vb = vel_data[b];
              pa.SelfMulAdd(step.dt, va);
              pb.SelfMulAdd(step.dt, vb);
              var d = b2Vec2.SubVV(pb, pa, s_d);
              var r0 = pair.distance;
              var r1 = d.Length();
              var strength = springStrength * pair.strength;
              var f = b2Vec2.MulSV(strength * (r0 - r1) / r1, d, s_f);
              va.SelfSub(f);
              vb.SelfAdd(f);
            }
          }
        };
        b2ParticleSystem.prototype.SolveTensile = function(step) {
          var s_weightedNormal = b2ParticleSystem.SolveTensile_s_weightedNormal;
          var s_s = b2ParticleSystem.SolveTensile_s_s;
          var s_f = b2ParticleSystem.SolveTensile_s_f;
          if (!this.m_velocityBuffer.data) throw new Error();
          var vel_data = this.m_velocityBuffer.data;
          for (var i = 0; i < this.m_count; i++) {
            this.m_accumulation2Buffer[i] = new b2Vec2();
            this.m_accumulation2Buffer[i].SetZero();
          }
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            if (contact.flags & exports.b2ParticleFlag.b2_tensileParticle) {
              var a = contact.indexA;
              var b = contact.indexB;
              var w = contact.weight;
              var n = contact.normal;
              var weightedNormal = b2Vec2.MulSV((1 - w) * w, n, s_weightedNormal);
              this.m_accumulation2Buffer[a].SelfSub(weightedNormal);
              this.m_accumulation2Buffer[b].SelfAdd(weightedNormal);
            }
          }
          var criticalVelocity = this.GetCriticalVelocity(step);
          var pressureStrength = this.m_def.surfaceTensionPressureStrength * criticalVelocity;
          var normalStrength = this.m_def.surfaceTensionNormalStrength * criticalVelocity;
          var maxVelocityVariation = b2_maxParticleForce * criticalVelocity;
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            if (contact.flags & exports.b2ParticleFlag.b2_tensileParticle) {
              var a = contact.indexA;
              var b = contact.indexB;
              var w = contact.weight;
              var n = contact.normal;
              var h = this.m_weightBuffer[a] + this.m_weightBuffer[b];
              var s = b2Vec2.SubVV(this.m_accumulation2Buffer[b], this.m_accumulation2Buffer[a], s_s);
              var fn = b2Min(pressureStrength * (h - 2) + normalStrength * b2Vec2.DotVV(s, n), maxVelocityVariation) * w;
              var f = b2Vec2.MulSV(fn, n, s_f);
              vel_data[a].SelfSub(f);
              vel_data[b].SelfAdd(f);
            }
          }
        };
        b2ParticleSystem.prototype.SolveViscous = function() {
          var s_v = b2ParticleSystem.SolveViscous_s_v;
          var s_f = b2ParticleSystem.SolveViscous_s_f;
          if (!this.m_flagsBuffer.data) throw new Error();
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var vel_data = this.m_velocityBuffer.data;
          var viscousStrength = this.m_def.viscousStrength;
          var inv_mass = this.GetParticleInvMass();
          for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {
            var contact = this.m_bodyContactBuffer.data[k];
            var a = contact.index;
            if (this.m_flagsBuffer.data[a] & exports.b2ParticleFlag.b2_viscousParticle) {
              var b = contact.body;
              var w = contact.weight;
              var m = contact.mass;
              var p = pos_data[a];
              var v = b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, b2Vec2.s_t0), vel_data[a], s_v);
              var f = b2Vec2.MulSV(viscousStrength * m * w, v, s_f);
              vel_data[a].SelfMulAdd(inv_mass, f);
              b.ApplyLinearImpulse(f.SelfNeg(), p, true);
            }
          }
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            if (contact.flags & exports.b2ParticleFlag.b2_viscousParticle) {
              var a = contact.indexA;
              var b = contact.indexB;
              var w = contact.weight;
              var v = b2Vec2.SubVV(vel_data[b], vel_data[a], s_v);
              var f = b2Vec2.MulSV(viscousStrength * w, v, s_f);
              vel_data[a].SelfAdd(f);
              vel_data[b].SelfSub(f);
            }
          }
        };
        b2ParticleSystem.prototype.SolveRepulsive = function(step) {
          var s_f = b2ParticleSystem.SolveRepulsive_s_f;
          if (!this.m_velocityBuffer.data) throw new Error();
          var vel_data = this.m_velocityBuffer.data;
          var repulsiveStrength = this.m_def.repulsiveStrength * this.GetCriticalVelocity(step);
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            if (contact.flags & exports.b2ParticleFlag.b2_repulsiveParticle) {
              var a = contact.indexA;
              var b = contact.indexB;
              if (this.m_groupBuffer[a] !== this.m_groupBuffer[b]) {
                var w = contact.weight;
                var n = contact.normal;
                var f = b2Vec2.MulSV(repulsiveStrength * w, n, s_f);
                vel_data[a].SelfSub(f);
                vel_data[b].SelfAdd(f);
              }
            }
          }
        };
        b2ParticleSystem.prototype.SolvePowder = function(step) {
          var s_f = b2ParticleSystem.SolvePowder_s_f;
          if (!this.m_flagsBuffer.data) throw new Error();
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var pos_data = this.m_positionBuffer.data;
          var vel_data = this.m_velocityBuffer.data;
          var powderStrength = this.m_def.powderStrength * this.GetCriticalVelocity(step);
          var minWeight = 1 - b2_particleStride;
          var inv_mass = this.GetParticleInvMass();
          for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {
            var contact = this.m_bodyContactBuffer.data[k];
            var a = contact.index;
            if (this.m_flagsBuffer.data[a] & exports.b2ParticleFlag.b2_powderParticle) {
              var w = contact.weight;
              if (w > minWeight) {
                var b = contact.body;
                var m = contact.mass;
                var p = pos_data[a];
                var n = contact.normal;
                var f = b2Vec2.MulSV(powderStrength * m * (w - minWeight), n, s_f);
                vel_data[a].SelfMulSub(inv_mass, f);
                b.ApplyLinearImpulse(f, p, true);
              }
            }
          }
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            if (contact.flags & exports.b2ParticleFlag.b2_powderParticle) {
              var w = contact.weight;
              if (w > minWeight) {
                var a = contact.indexA;
                var b = contact.indexB;
                var n = contact.normal;
                var f = b2Vec2.MulSV(powderStrength * (w - minWeight), n, s_f);
                vel_data[a].SelfSub(f);
                vel_data[b].SelfAdd(f);
              }
            }
          }
        };
        b2ParticleSystem.prototype.SolveSolid = function(step) {
          var s_f = b2ParticleSystem.SolveSolid_s_f;
          if (!this.m_velocityBuffer.data) throw new Error();
          var vel_data = this.m_velocityBuffer.data;
          this.m_depthBuffer = this.RequestBuffer(this.m_depthBuffer);
          var ejectionStrength = step.inv_dt * this.m_def.ejectionStrength;
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            var a = contact.indexA;
            var b = contact.indexB;
            if (this.m_groupBuffer[a] !== this.m_groupBuffer[b]) {
              var w = contact.weight;
              var n = contact.normal;
              var h = this.m_depthBuffer[a] + this.m_depthBuffer[b];
              var f = b2Vec2.MulSV(ejectionStrength * h * w, n, s_f);
              vel_data[a].SelfSub(f);
              vel_data[b].SelfAdd(f);
            }
          }
        };
        b2ParticleSystem.prototype.SolveForce = function(step) {
          if (!this.m_velocityBuffer.data) throw new Error();
          var vel_data = this.m_velocityBuffer.data;
          var velocityPerForce = step.dt * this.GetParticleInvMass();
          for (var i = 0; i < this.m_count; i++) vel_data[i].SelfMulAdd(velocityPerForce, this.m_forceBuffer[i]);
          this.m_hasForce = false;
        };
        b2ParticleSystem.prototype.SolveColorMixing = function() {
          if (!this.m_flagsBuffer.data) throw new Error();
          if (!this.m_colorBuffer.data) throw new Error();
          var colorMixing = .5 * this.m_def.colorMixingStrength;
          if (colorMixing) for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            var a = contact.indexA;
            var b = contact.indexB;
            if (this.m_flagsBuffer.data[a] & this.m_flagsBuffer.data[b] & exports.b2ParticleFlag.b2_colorMixingParticle) {
              var colorA = this.m_colorBuffer.data[a];
              var colorB = this.m_colorBuffer.data[b];
              b2Color.MixColors(colorA, colorB, colorMixing);
            }
          }
        };
        b2ParticleSystem.prototype.SolveZombie = function() {
          if (!this.m_flagsBuffer.data) throw new Error();
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          var newCount = 0;
          var newIndices = [];
          for (var i = 0; i < this.m_count; i++) newIndices[i] = b2_invalidParticleIndex;
          var allParticleFlags = 0;
          for (var i = 0; i < this.m_count; i++) {
            var flags = this.m_flagsBuffer.data[i];
            if (flags & exports.b2ParticleFlag.b2_zombieParticle) {
              var destructionListener = this.m_world.m_destructionListener;
              flags & exports.b2ParticleFlag.b2_destructionListenerParticle && destructionListener && destructionListener.SayGoodbyeParticle(this, i);
              if (this.m_handleIndexBuffer.data) {
                var handle = this.m_handleIndexBuffer.data[i];
                if (handle) {
                  handle.SetIndex(b2_invalidParticleIndex);
                  this.m_handleIndexBuffer.data[i] = null;
                }
              }
              newIndices[i] = b2_invalidParticleIndex;
            } else {
              newIndices[i] = newCount;
              if (i !== newCount) {
                if (this.m_handleIndexBuffer.data) {
                  var handle = this.m_handleIndexBuffer.data[i];
                  handle && handle.SetIndex(newCount);
                  this.m_handleIndexBuffer.data[newCount] = handle;
                }
                this.m_flagsBuffer.data[newCount] = this.m_flagsBuffer.data[i];
                this.m_lastBodyContactStepBuffer.data && (this.m_lastBodyContactStepBuffer.data[newCount] = this.m_lastBodyContactStepBuffer.data[i]);
                this.m_bodyContactCountBuffer.data && (this.m_bodyContactCountBuffer.data[newCount] = this.m_bodyContactCountBuffer.data[i]);
                this.m_consecutiveContactStepsBuffer.data && (this.m_consecutiveContactStepsBuffer.data[newCount] = this.m_consecutiveContactStepsBuffer.data[i]);
                this.m_positionBuffer.data[newCount].Copy(this.m_positionBuffer.data[i]);
                this.m_velocityBuffer.data[newCount].Copy(this.m_velocityBuffer.data[i]);
                this.m_groupBuffer[newCount] = this.m_groupBuffer[i];
                this.m_hasForce && this.m_forceBuffer[newCount].Copy(this.m_forceBuffer[i]);
                this.m_staticPressureBuffer && (this.m_staticPressureBuffer[newCount] = this.m_staticPressureBuffer[i]);
                this.m_depthBuffer && (this.m_depthBuffer[newCount] = this.m_depthBuffer[i]);
                this.m_colorBuffer.data && this.m_colorBuffer.data[newCount].Copy(this.m_colorBuffer.data[i]);
                this.m_userDataBuffer.data && (this.m_userDataBuffer.data[newCount] = this.m_userDataBuffer.data[i]);
                this.m_expirationTimeBuffer.data && (this.m_expirationTimeBuffer.data[newCount] = this.m_expirationTimeBuffer.data[i]);
              }
              newCount++;
              allParticleFlags |= flags;
            }
          }
          var Test = {
            IsProxyInvalid: function IsProxyInvalid(proxy) {
              return proxy.index < 0;
            },
            IsContactInvalid: function IsContactInvalid(contact) {
              return contact.indexA < 0 || contact.indexB < 0;
            },
            IsBodyContactInvalid: function IsBodyContactInvalid(contact) {
              return contact.index < 0;
            },
            IsPairInvalid: function IsPairInvalid(pair) {
              return pair.indexA < 0 || pair.indexB < 0;
            },
            IsTriadInvalid: function IsTriadInvalid(triad) {
              return triad.indexA < 0 || triad.indexB < 0 || triad.indexC < 0;
            }
          };
          for (var k = 0; k < this.m_proxyBuffer.count; k++) {
            var proxy = this.m_proxyBuffer.data[k];
            proxy.index = newIndices[proxy.index];
          }
          this.m_proxyBuffer.RemoveIf(Test.IsProxyInvalid);
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            contact.indexA = newIndices[contact.indexA];
            contact.indexB = newIndices[contact.indexB];
          }
          this.m_contactBuffer.RemoveIf(Test.IsContactInvalid);
          for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {
            var contact = this.m_bodyContactBuffer.data[k];
            contact.index = newIndices[contact.index];
          }
          this.m_bodyContactBuffer.RemoveIf(Test.IsBodyContactInvalid);
          for (var k = 0; k < this.m_pairBuffer.count; k++) {
            var pair = this.m_pairBuffer.data[k];
            pair.indexA = newIndices[pair.indexA];
            pair.indexB = newIndices[pair.indexB];
          }
          this.m_pairBuffer.RemoveIf(Test.IsPairInvalid);
          for (var k = 0; k < this.m_triadBuffer.count; k++) {
            var triad = this.m_triadBuffer.data[k];
            triad.indexA = newIndices[triad.indexA];
            triad.indexB = newIndices[triad.indexB];
            triad.indexC = newIndices[triad.indexC];
          }
          this.m_triadBuffer.RemoveIf(Test.IsTriadInvalid);
          if (this.m_indexByExpirationTimeBuffer.data) {
            var writeOffset = 0;
            for (var readOffset = 0; readOffset < this.m_count; readOffset++) {
              var newIndex = newIndices[this.m_indexByExpirationTimeBuffer.data[readOffset]];
              newIndex !== b2_invalidParticleIndex && (this.m_indexByExpirationTimeBuffer.data[writeOffset++] = newIndex);
            }
          }
          for (var group = this.m_groupList; group; group = group.GetNext()) {
            var firstIndex = newCount;
            var lastIndex = 0;
            var modified = false;
            for (var i = group.m_firstIndex; i < group.m_lastIndex; i++) {
              var j = newIndices[i];
              if (j >= 0) {
                firstIndex = b2Min(firstIndex, j);
                lastIndex = b2Max(lastIndex, j + 1);
              } else modified = true;
            }
            if (firstIndex < lastIndex) {
              group.m_firstIndex = firstIndex;
              group.m_lastIndex = lastIndex;
              modified && group.m_groupFlags & exports.b2ParticleGroupFlag.b2_solidParticleGroup && this.SetGroupFlags(group, group.m_groupFlags | exports.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth);
            } else {
              group.m_firstIndex = 0;
              group.m_lastIndex = 0;
              group.m_groupFlags & exports.b2ParticleGroupFlag.b2_particleGroupCanBeEmpty || this.SetGroupFlags(group, group.m_groupFlags | exports.b2ParticleGroupFlag.b2_particleGroupWillBeDestroyed);
            }
          }
          this.m_count = newCount;
          this.m_allParticleFlags = allParticleFlags;
          this.m_needsUpdateAllParticleFlags = false;
          for (var group = this.m_groupList; group; ) {
            var next = group.GetNext();
            group.m_groupFlags & exports.b2ParticleGroupFlag.b2_particleGroupWillBeDestroyed && this.DestroyParticleGroup(group);
            group = next;
          }
        };
        b2ParticleSystem.prototype.SolveLifetimes = function(step) {
          if (!this.m_expirationTimeBuffer.data) throw new Error();
          if (!this.m_indexByExpirationTimeBuffer.data) throw new Error();
          this.m_timeElapsed = this.LifetimeToExpirationTime(step.dt);
          var quantizedTimeElapsed = this.GetQuantizedTimeElapsed();
          var expirationTimes = this.m_expirationTimeBuffer.data;
          var expirationTimeIndices = this.m_indexByExpirationTimeBuffer.data;
          var particleCount = this.GetParticleCount();
          if (this.m_expirationTimeBufferRequiresSorting) {
            var ExpirationTimeComparator = function ExpirationTimeComparator(particleIndexA, particleIndexB) {
              var expirationTimeA = expirationTimes[particleIndexA];
              var expirationTimeB = expirationTimes[particleIndexB];
              var infiniteExpirationTimeA = expirationTimeA <= 0;
              var infiniteExpirationTimeB = expirationTimeB <= 0;
              return infiniteExpirationTimeA === infiniteExpirationTimeB ? expirationTimeA > expirationTimeB : infiniteExpirationTimeA;
            };
            std_sort(expirationTimeIndices, 0, particleCount, ExpirationTimeComparator);
            this.m_expirationTimeBufferRequiresSorting = false;
          }
          for (var i = particleCount - 1; i >= 0; --i) {
            var particleIndex = expirationTimeIndices[i];
            var expirationTime = expirationTimes[particleIndex];
            if (quantizedTimeElapsed < expirationTime || expirationTime <= 0) break;
            this.DestroyParticle(particleIndex);
          }
        };
        b2ParticleSystem.prototype.RotateBuffer = function(start, mid, end) {
          if (start === mid || mid === end) return;
          function newIndices(i) {
            return i < start ? i : i < mid ? i + end - mid : i < end ? i + start - mid : i;
          }
          if (!this.m_flagsBuffer.data) throw new Error();
          if (!this.m_positionBuffer.data) throw new Error();
          if (!this.m_velocityBuffer.data) throw new Error();
          std_rotate(this.m_flagsBuffer.data, start, mid, end);
          this.m_lastBodyContactStepBuffer.data && std_rotate(this.m_lastBodyContactStepBuffer.data, start, mid, end);
          this.m_bodyContactCountBuffer.data && std_rotate(this.m_bodyContactCountBuffer.data, start, mid, end);
          this.m_consecutiveContactStepsBuffer.data && std_rotate(this.m_consecutiveContactStepsBuffer.data, start, mid, end);
          std_rotate(this.m_positionBuffer.data, start, mid, end);
          std_rotate(this.m_velocityBuffer.data, start, mid, end);
          std_rotate(this.m_groupBuffer, start, mid, end);
          this.m_hasForce && std_rotate(this.m_forceBuffer, start, mid, end);
          this.m_staticPressureBuffer && std_rotate(this.m_staticPressureBuffer, start, mid, end);
          this.m_depthBuffer && std_rotate(this.m_depthBuffer, start, mid, end);
          this.m_colorBuffer.data && std_rotate(this.m_colorBuffer.data, start, mid, end);
          this.m_userDataBuffer.data && std_rotate(this.m_userDataBuffer.data, start, mid, end);
          if (this.m_handleIndexBuffer.data) {
            std_rotate(this.m_handleIndexBuffer.data, start, mid, end);
            for (var i = start; i < end; ++i) {
              var handle = this.m_handleIndexBuffer.data[i];
              handle && handle.SetIndex(newIndices(handle.GetIndex()));
            }
          }
          if (this.m_expirationTimeBuffer.data) {
            std_rotate(this.m_expirationTimeBuffer.data, start, mid, end);
            var particleCount = this.GetParticleCount();
            if (!this.m_indexByExpirationTimeBuffer.data) throw new Error();
            var indexByExpirationTime = this.m_indexByExpirationTimeBuffer.data;
            for (var i = 0; i < particleCount; ++i) indexByExpirationTime[i] = newIndices(indexByExpirationTime[i]);
          }
          for (var k = 0; k < this.m_proxyBuffer.count; k++) {
            var proxy = this.m_proxyBuffer.data[k];
            proxy.index = newIndices(proxy.index);
          }
          for (var k = 0; k < this.m_contactBuffer.count; k++) {
            var contact = this.m_contactBuffer.data[k];
            contact.indexA = newIndices(contact.indexA);
            contact.indexB = newIndices(contact.indexB);
          }
          for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {
            var contact = this.m_bodyContactBuffer.data[k];
            contact.index = newIndices(contact.index);
          }
          for (var k = 0; k < this.m_pairBuffer.count; k++) {
            var pair = this.m_pairBuffer.data[k];
            pair.indexA = newIndices(pair.indexA);
            pair.indexB = newIndices(pair.indexB);
          }
          for (var k = 0; k < this.m_triadBuffer.count; k++) {
            var triad = this.m_triadBuffer.data[k];
            triad.indexA = newIndices(triad.indexA);
            triad.indexB = newIndices(triad.indexB);
            triad.indexC = newIndices(triad.indexC);
          }
          for (var group = this.m_groupList; group; group = group.GetNext()) {
            group.m_firstIndex = newIndices(group.m_firstIndex);
            group.m_lastIndex = newIndices(group.m_lastIndex - 1) + 1;
          }
        };
        b2ParticleSystem.prototype.GetCriticalVelocity = function(step) {
          return this.m_particleDiameter * step.inv_dt;
        };
        b2ParticleSystem.prototype.GetCriticalVelocitySquared = function(step) {
          var velocity = this.GetCriticalVelocity(step);
          return velocity * velocity;
        };
        b2ParticleSystem.prototype.GetCriticalPressure = function(step) {
          return this.m_def.density * this.GetCriticalVelocitySquared(step);
        };
        b2ParticleSystem.prototype.GetParticleStride = function() {
          return b2_particleStride * this.m_particleDiameter;
        };
        b2ParticleSystem.prototype.GetParticleMass = function() {
          var stride = this.GetParticleStride();
          return this.m_def.density * stride * stride;
        };
        b2ParticleSystem.prototype.GetParticleInvMass = function() {
          var inverseStride = this.m_inverseDiameter * (1 / b2_particleStride);
          return this.m_inverseDensity * inverseStride * inverseStride;
        };
        b2ParticleSystem.prototype.GetFixtureContactFilter = function() {
          return this.m_allParticleFlags & exports.b2ParticleFlag.b2_fixtureContactFilterParticle ? this.m_world.m_contactManager.m_contactFilter : null;
        };
        b2ParticleSystem.prototype.GetParticleContactFilter = function() {
          return this.m_allParticleFlags & exports.b2ParticleFlag.b2_particleContactFilterParticle ? this.m_world.m_contactManager.m_contactFilter : null;
        };
        b2ParticleSystem.prototype.GetFixtureContactListener = function() {
          return this.m_allParticleFlags & exports.b2ParticleFlag.b2_fixtureContactListenerParticle ? this.m_world.m_contactManager.m_contactListener : null;
        };
        b2ParticleSystem.prototype.GetParticleContactListener = function() {
          return this.m_allParticleFlags & exports.b2ParticleFlag.b2_particleContactListenerParticle ? this.m_world.m_contactManager.m_contactListener : null;
        };
        b2ParticleSystem.prototype.SetUserOverridableBuffer = function(buffer, newData, newCapacity) {
          buffer.data = newData;
          buffer.userSuppliedCapacity = newCapacity;
        };
        b2ParticleSystem.prototype.SetGroupFlags = function(group, newFlags) {
          var oldFlags = group.m_groupFlags;
          (oldFlags ^ newFlags) & exports.b2ParticleGroupFlag.b2_solidParticleGroup && (newFlags |= exports.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth);
          oldFlags & ~newFlags && (this.m_needsUpdateAllGroupFlags = true);
          if (~this.m_allGroupFlags & newFlags) {
            newFlags & exports.b2ParticleGroupFlag.b2_solidParticleGroup && (this.m_depthBuffer = this.RequestBuffer(this.m_depthBuffer));
            this.m_allGroupFlags |= newFlags;
          }
          group.m_groupFlags = newFlags;
        };
        b2ParticleSystem.BodyContactCompare = function(lhs, rhs) {
          if (lhs.index === rhs.index) return lhs.weight > rhs.weight;
          return lhs.index < rhs.index;
        };
        b2ParticleSystem.prototype.RemoveSpuriousBodyContacts = function() {
          std_sort(this.m_bodyContactBuffer.data, 0, this.m_bodyContactBuffer.count, b2ParticleSystem.BodyContactCompare);
          var s_n = b2ParticleSystem.RemoveSpuriousBodyContacts_s_n;
          var s_pos = b2ParticleSystem.RemoveSpuriousBodyContacts_s_pos;
          var s_normal = b2ParticleSystem.RemoveSpuriousBodyContacts_s_normal;
          var k_maxContactsPerPoint = 3;
          var system = this;
          var lastIndex = -1;
          var currentContacts = 0;
          var b2ParticleBodyContactRemovePredicate = function b2ParticleBodyContactRemovePredicate(contact) {
            if (contact.index !== lastIndex) {
              currentContacts = 0;
              lastIndex = contact.index;
            }
            if (currentContacts++ > k_maxContactsPerPoint) return true;
            var n = s_n.Copy(contact.normal);
            n.SelfMul(system.m_particleDiameter * (1 - contact.weight));
            if (!system.m_positionBuffer.data) throw new Error();
            var pos = b2Vec2.AddVV(system.m_positionBuffer.data[contact.index], n, s_pos);
            if (!contact.fixture.TestPoint(pos)) {
              var childCount = contact.fixture.GetShape().GetChildCount();
              for (var childIndex = 0; childIndex < childCount; childIndex++) {
                var normal = s_normal;
                var distance = contact.fixture.ComputeDistance(pos, normal, childIndex);
                if (distance < b2_linearSlop) return false;
              }
              return true;
            }
            return false;
          };
          this.m_bodyContactBuffer.count = std_remove_if(this.m_bodyContactBuffer.data, b2ParticleBodyContactRemovePredicate, this.m_bodyContactBuffer.count);
        };
        b2ParticleSystem.prototype.DetectStuckParticle = function(particle) {
          if (this.m_stuckThreshold <= 0) return;
          if (!this.m_bodyContactCountBuffer.data) throw new Error();
          if (!this.m_consecutiveContactStepsBuffer.data) throw new Error();
          if (!this.m_lastBodyContactStepBuffer.data) throw new Error();
          ++this.m_bodyContactCountBuffer.data[particle];
          if (2 === this.m_bodyContactCountBuffer.data[particle]) {
            ++this.m_consecutiveContactStepsBuffer.data[particle];
            this.m_consecutiveContactStepsBuffer.data[particle] > this.m_stuckThreshold && (this.m_stuckParticleBuffer.data[this.m_stuckParticleBuffer.Append()] = particle);
          }
          this.m_lastBodyContactStepBuffer.data[particle] = this.m_timestamp;
        };
        b2ParticleSystem.prototype.ValidateParticleIndex = function(index) {
          return index >= 0 && index < this.GetParticleCount() && index !== b2_invalidParticleIndex;
        };
        b2ParticleSystem.prototype.GetQuantizedTimeElapsed = function() {
          return Math.floor(this.m_timeElapsed / 4294967296);
        };
        b2ParticleSystem.prototype.LifetimeToExpirationTime = function(lifetime) {
          return this.m_timeElapsed + Math.floor(lifetime / this.m_def.lifetimeGranularity * 4294967296);
        };
        b2ParticleSystem.prototype.ForceCanBeApplied = function(flags) {
          return !(flags & exports.b2ParticleFlag.b2_wallParticle);
        };
        b2ParticleSystem.prototype.PrepareForceBuffer = function() {
          if (!this.m_hasForce) {
            for (var i = 0; i < this.m_count; i++) this.m_forceBuffer[i].SetZero();
            this.m_hasForce = true;
          }
        };
        b2ParticleSystem.prototype.IsRigidGroup = function(group) {
          return null !== group && 0 !== (group.m_groupFlags & exports.b2ParticleGroupFlag.b2_rigidParticleGroup);
        };
        b2ParticleSystem.prototype.GetLinearVelocity = function(group, particleIndex, point, out) {
          if (group && this.IsRigidGroup(group)) return group.GetLinearVelocityFromWorldPoint(point, out);
          if (!this.m_velocityBuffer.data) throw new Error();
          return out.Copy(this.m_velocityBuffer.data[particleIndex]);
        };
        b2ParticleSystem.prototype.InitDampingParameter = function(invMass, invInertia, tangentDistance, mass, inertia, center, point, normal) {
          invMass[0] = mass > 0 ? 1 / mass : 0;
          invInertia[0] = inertia > 0 ? 1 / inertia : 0;
          tangentDistance[0] = b2Vec2.CrossVV(b2Vec2.SubVV(point, center, b2Vec2.s_t0), normal);
        };
        b2ParticleSystem.prototype.InitDampingParameterWithRigidGroupOrParticle = function(invMass, invInertia, tangentDistance, isRigidGroup, group, particleIndex, point, normal) {
          if (group && isRigidGroup) this.InitDampingParameter(invMass, invInertia, tangentDistance, group.GetMass(), group.GetInertia(), group.GetCenter(), point, normal); else {
            if (!this.m_flagsBuffer.data) throw new Error();
            var flags = this.m_flagsBuffer.data[particleIndex];
            this.InitDampingParameter(invMass, invInertia, tangentDistance, flags & exports.b2ParticleFlag.b2_wallParticle ? 0 : this.GetParticleMass(), 0, point, point, normal);
          }
        };
        b2ParticleSystem.prototype.ComputeDampingImpulse = function(invMassA, invInertiaA, tangentDistanceA, invMassB, invInertiaB, tangentDistanceB, normalVelocity) {
          var invMass = invMassA + invInertiaA * tangentDistanceA * tangentDistanceA + invMassB + invInertiaB * tangentDistanceB * tangentDistanceB;
          return invMass > 0 ? normalVelocity / invMass : 0;
        };
        b2ParticleSystem.prototype.ApplyDamping = function(invMass, invInertia, tangentDistance, isRigidGroup, group, particleIndex, impulse, normal) {
          if (group && isRigidGroup) {
            group.m_linearVelocity.SelfMulAdd(impulse * invMass, normal);
            group.m_angularVelocity += impulse * tangentDistance * invInertia;
          } else {
            if (!this.m_velocityBuffer.data) throw new Error();
            this.m_velocityBuffer.data[particleIndex].SelfMulAdd(impulse * invMass, normal);
          }
        };
        b2ParticleSystem.xTruncBits = 12;
        b2ParticleSystem.yTruncBits = 12;
        b2ParticleSystem.tagBits = 32;
        b2ParticleSystem.yOffset = 1 << b2ParticleSystem.yTruncBits - 1;
        b2ParticleSystem.yShift = b2ParticleSystem.tagBits - b2ParticleSystem.yTruncBits;
        b2ParticleSystem.xShift = b2ParticleSystem.tagBits - b2ParticleSystem.yTruncBits - b2ParticleSystem.xTruncBits;
        b2ParticleSystem.xScale = 1 << b2ParticleSystem.xShift;
        b2ParticleSystem.xOffset = b2ParticleSystem.xScale * (1 << b2ParticleSystem.xTruncBits - 1);
        b2ParticleSystem.yMask = (1 << b2ParticleSystem.yTruncBits) - 1 << b2ParticleSystem.yShift;
        b2ParticleSystem.xMask = ~b2ParticleSystem.yMask;
        b2ParticleSystem.DestroyParticlesInShape_s_aabb = new b2AABB();
        b2ParticleSystem.CreateParticleGroup_s_transform = new b2Transform();
        b2ParticleSystem.ComputeCollisionEnergy_s_v = new b2Vec2();
        b2ParticleSystem.QueryShapeAABB_s_aabb = new b2AABB();
        b2ParticleSystem.QueryPointAABB_s_aabb = new b2AABB();
        b2ParticleSystem.RayCast_s_aabb = new b2AABB();
        b2ParticleSystem.RayCast_s_p = new b2Vec2();
        b2ParticleSystem.RayCast_s_v = new b2Vec2();
        b2ParticleSystem.RayCast_s_n = new b2Vec2();
        b2ParticleSystem.RayCast_s_point = new b2Vec2();
        b2ParticleSystem.k_pairFlags = exports.b2ParticleFlag.b2_springParticle;
        b2ParticleSystem.k_triadFlags = exports.b2ParticleFlag.b2_elasticParticle;
        b2ParticleSystem.k_noPressureFlags = exports.b2ParticleFlag.b2_powderParticle | exports.b2ParticleFlag.b2_tensileParticle;
        b2ParticleSystem.k_extraDampingFlags = exports.b2ParticleFlag.b2_staticPressureParticle;
        b2ParticleSystem.k_barrierWallFlags = exports.b2ParticleFlag.b2_barrierParticle | exports.b2ParticleFlag.b2_wallParticle;
        b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_edge = new b2EdgeShape();
        b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_d = new b2Vec2();
        b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_p = new b2Vec2();
        b2ParticleSystem.CreateParticlesFillShapeForGroup_s_aabb = new b2AABB();
        b2ParticleSystem.CreateParticlesFillShapeForGroup_s_p = new b2Vec2();
        b2ParticleSystem.UpdatePairsAndTriads_s_dab = new b2Vec2();
        b2ParticleSystem.UpdatePairsAndTriads_s_dbc = new b2Vec2();
        b2ParticleSystem.UpdatePairsAndTriads_s_dca = new b2Vec2();
        b2ParticleSystem.AddContact_s_d = new b2Vec2();
        b2ParticleSystem.UpdateBodyContacts_s_aabb = new b2AABB();
        b2ParticleSystem.Solve_s_subStep = new b2TimeStep();
        b2ParticleSystem.SolveCollision_s_aabb = new b2AABB();
        b2ParticleSystem.SolveGravity_s_gravity = new b2Vec2();
        b2ParticleSystem.SolveBarrier_s_aabb = new b2AABB();
        b2ParticleSystem.SolveBarrier_s_va = new b2Vec2();
        b2ParticleSystem.SolveBarrier_s_vb = new b2Vec2();
        b2ParticleSystem.SolveBarrier_s_pba = new b2Vec2();
        b2ParticleSystem.SolveBarrier_s_vba = new b2Vec2();
        b2ParticleSystem.SolveBarrier_s_vc = new b2Vec2();
        b2ParticleSystem.SolveBarrier_s_pca = new b2Vec2();
        b2ParticleSystem.SolveBarrier_s_vca = new b2Vec2();
        b2ParticleSystem.SolveBarrier_s_qba = new b2Vec2();
        b2ParticleSystem.SolveBarrier_s_qca = new b2Vec2();
        b2ParticleSystem.SolveBarrier_s_dv = new b2Vec2();
        b2ParticleSystem.SolveBarrier_s_f = new b2Vec2();
        b2ParticleSystem.SolvePressure_s_f = new b2Vec2();
        b2ParticleSystem.SolveDamping_s_v = new b2Vec2();
        b2ParticleSystem.SolveDamping_s_f = new b2Vec2();
        b2ParticleSystem.SolveRigidDamping_s_t0 = new b2Vec2();
        b2ParticleSystem.SolveRigidDamping_s_t1 = new b2Vec2();
        b2ParticleSystem.SolveRigidDamping_s_p = new b2Vec2();
        b2ParticleSystem.SolveRigidDamping_s_v = new b2Vec2();
        b2ParticleSystem.SolveExtraDamping_s_v = new b2Vec2();
        b2ParticleSystem.SolveExtraDamping_s_f = new b2Vec2();
        b2ParticleSystem.SolveRigid_s_position = new b2Vec2();
        b2ParticleSystem.SolveRigid_s_rotation = new b2Rot();
        b2ParticleSystem.SolveRigid_s_transform = new b2Transform();
        b2ParticleSystem.SolveRigid_s_velocityTransform = new b2Transform();
        b2ParticleSystem.SolveElastic_s_pa = new b2Vec2();
        b2ParticleSystem.SolveElastic_s_pb = new b2Vec2();
        b2ParticleSystem.SolveElastic_s_pc = new b2Vec2();
        b2ParticleSystem.SolveElastic_s_r = new b2Rot();
        b2ParticleSystem.SolveElastic_s_t0 = new b2Vec2();
        b2ParticleSystem.SolveSpring_s_pa = new b2Vec2();
        b2ParticleSystem.SolveSpring_s_pb = new b2Vec2();
        b2ParticleSystem.SolveSpring_s_d = new b2Vec2();
        b2ParticleSystem.SolveSpring_s_f = new b2Vec2();
        b2ParticleSystem.SolveTensile_s_weightedNormal = new b2Vec2();
        b2ParticleSystem.SolveTensile_s_s = new b2Vec2();
        b2ParticleSystem.SolveTensile_s_f = new b2Vec2();
        b2ParticleSystem.SolveViscous_s_v = new b2Vec2();
        b2ParticleSystem.SolveViscous_s_f = new b2Vec2();
        b2ParticleSystem.SolveRepulsive_s_f = new b2Vec2();
        b2ParticleSystem.SolvePowder_s_f = new b2Vec2();
        b2ParticleSystem.SolveSolid_s_f = new b2Vec2();
        b2ParticleSystem.RemoveSpuriousBodyContacts_s_n = new b2Vec2();
        b2ParticleSystem.RemoveSpuriousBodyContacts_s_pos = new b2Vec2();
        b2ParticleSystem.RemoveSpuriousBodyContacts_s_normal = new b2Vec2();
        return b2ParticleSystem;
      })();
      (function(b2ParticleSystem) {
        var UserOverridableBuffer = (function() {
          function UserOverridableBuffer() {
            this.data = null;
            this.userSuppliedCapacity = 0;
          }
          return UserOverridableBuffer;
        })();
        b2ParticleSystem.UserOverridableBuffer = UserOverridableBuffer;
        var Proxy = (function() {
          function Proxy() {
            this.index = b2_invalidParticleIndex;
            this.tag = 0;
          }
          Proxy.CompareProxyProxy = function(a, b) {
            return a.tag < b.tag;
          };
          Proxy.CompareTagProxy = function(a, b) {
            return a < b.tag;
          };
          Proxy.CompareProxyTag = function(a, b) {
            return a.tag < b;
          };
          return Proxy;
        })();
        b2ParticleSystem.Proxy = Proxy;
        var InsideBoundsEnumerator = (function() {
          function InsideBoundsEnumerator(system, lower, upper, first, last) {
            this.m_system = system;
            this.m_xLower = (lower & b2ParticleSystem.xMask) >>> 0;
            this.m_xUpper = (upper & b2ParticleSystem.xMask) >>> 0;
            this.m_yLower = (lower & b2ParticleSystem.yMask) >>> 0;
            this.m_yUpper = (upper & b2ParticleSystem.yMask) >>> 0;
            this.m_first = first;
            this.m_last = last;
          }
          InsideBoundsEnumerator.prototype.GetNext = function() {
            while (this.m_first < this.m_last) {
              var xTag = (this.m_system.m_proxyBuffer.data[this.m_first].tag & b2ParticleSystem.xMask) >>> 0;
              if (xTag >= this.m_xLower && xTag <= this.m_xUpper) return this.m_system.m_proxyBuffer.data[this.m_first++].index;
              this.m_first++;
            }
            return b2_invalidParticleIndex;
          };
          return InsideBoundsEnumerator;
        })();
        b2ParticleSystem.InsideBoundsEnumerator = InsideBoundsEnumerator;
        var ParticleListNode = (function() {
          function ParticleListNode() {
            this.next = null;
            this.count = 0;
            this.index = 0;
          }
          return ParticleListNode;
        })();
        b2ParticleSystem.ParticleListNode = ParticleListNode;
        var FixedSetAllocator = (function() {
          function FixedSetAllocator() {}
          FixedSetAllocator.prototype.Allocate = function(itemSize, count) {
            return count;
          };
          FixedSetAllocator.prototype.Clear = function() {};
          FixedSetAllocator.prototype.GetCount = function() {
            return 0;
          };
          FixedSetAllocator.prototype.Invalidate = function(itemIndex) {};
          FixedSetAllocator.prototype.GetValidBuffer = function() {
            return [];
          };
          FixedSetAllocator.prototype.GetBuffer = function() {
            return [];
          };
          FixedSetAllocator.prototype.SetCount = function(count) {};
          return FixedSetAllocator;
        })();
        b2ParticleSystem.FixedSetAllocator = FixedSetAllocator;
        var FixtureParticle = (function() {
          function FixtureParticle(fixture, particle) {
            this.second = b2_invalidParticleIndex;
            this.first = fixture;
            this.second = particle;
          }
          return FixtureParticle;
        })();
        b2ParticleSystem.FixtureParticle = FixtureParticle;
        var FixtureParticleSet = (function(_super) {
          __extends(FixtureParticleSet, _super);
          function FixtureParticleSet() {
            return null !== _super && _super.apply(this, arguments) || this;
          }
          FixtureParticleSet.prototype.Initialize = function(bodyContactBuffer, flagsBuffer) {};
          FixtureParticleSet.prototype.Find = function(pair) {
            return b2_invalidParticleIndex;
          };
          return FixtureParticleSet;
        })(b2ParticleSystem.FixedSetAllocator);
        b2ParticleSystem.FixtureParticleSet = FixtureParticleSet;
        var ParticlePair = (function() {
          function ParticlePair(particleA, particleB) {
            this.first = b2_invalidParticleIndex;
            this.second = b2_invalidParticleIndex;
            this.first = particleA;
            this.second = particleB;
          }
          return ParticlePair;
        })();
        b2ParticleSystem.ParticlePair = ParticlePair;
        var b2ParticlePairSet = (function(_super) {
          __extends(b2ParticlePairSet, _super);
          function b2ParticlePairSet() {
            return null !== _super && _super.apply(this, arguments) || this;
          }
          b2ParticlePairSet.prototype.Initialize = function(contactBuffer, flagsBuffer) {};
          b2ParticlePairSet.prototype.Find = function(pair) {
            return b2_invalidParticleIndex;
          };
          return b2ParticlePairSet;
        })(b2ParticleSystem.FixedSetAllocator);
        b2ParticleSystem.b2ParticlePairSet = b2ParticlePairSet;
        var ConnectionFilter = (function() {
          function ConnectionFilter() {}
          ConnectionFilter.prototype.IsNecessary = function(index) {
            return true;
          };
          ConnectionFilter.prototype.ShouldCreatePair = function(a, b) {
            return true;
          };
          ConnectionFilter.prototype.ShouldCreateTriad = function(a, b, c) {
            return true;
          };
          return ConnectionFilter;
        })();
        b2ParticleSystem.ConnectionFilter = ConnectionFilter;
        var DestroyParticlesInShapeCallback = (function(_super) {
          __extends(DestroyParticlesInShapeCallback, _super);
          function DestroyParticlesInShapeCallback(system, shape, xf, callDestructionListener) {
            var _this = _super.call(this) || this;
            _this.m_callDestructionListener = false;
            _this.m_destroyed = 0;
            _this.m_system = system;
            _this.m_shape = shape;
            _this.m_xf = xf;
            _this.m_callDestructionListener = callDestructionListener;
            _this.m_destroyed = 0;
            return _this;
          }
          DestroyParticlesInShapeCallback.prototype.ReportFixture = function(fixture) {
            return false;
          };
          DestroyParticlesInShapeCallback.prototype.ReportParticle = function(particleSystem, index) {
            if (particleSystem !== this.m_system) return false;
            if (!this.m_system.m_positionBuffer.data) throw new Error();
            if (this.m_shape.TestPoint(this.m_xf, this.m_system.m_positionBuffer.data[index])) {
              this.m_system.DestroyParticle(index, this.m_callDestructionListener);
              this.m_destroyed++;
            }
            return true;
          };
          DestroyParticlesInShapeCallback.prototype.Destroyed = function() {
            return this.m_destroyed;
          };
          return DestroyParticlesInShapeCallback;
        })(b2QueryCallback);
        b2ParticleSystem.DestroyParticlesInShapeCallback = DestroyParticlesInShapeCallback;
        var JoinParticleGroupsFilter = (function(_super) {
          __extends(JoinParticleGroupsFilter, _super);
          function JoinParticleGroupsFilter(threshold) {
            var _this = _super.call(this) || this;
            _this.m_threshold = 0;
            _this.m_threshold = threshold;
            return _this;
          }
          JoinParticleGroupsFilter.prototype.ShouldCreatePair = function(a, b) {
            return a < this.m_threshold && this.m_threshold <= b || b < this.m_threshold && this.m_threshold <= a;
          };
          JoinParticleGroupsFilter.prototype.ShouldCreateTriad = function(a, b, c) {
            return (a < this.m_threshold || b < this.m_threshold || c < this.m_threshold) && (this.m_threshold <= a || this.m_threshold <= b || this.m_threshold <= c);
          };
          return JoinParticleGroupsFilter;
        })(b2ParticleSystem.ConnectionFilter);
        b2ParticleSystem.JoinParticleGroupsFilter = JoinParticleGroupsFilter;
        var CompositeShape = (function(_super) {
          __extends(CompositeShape, _super);
          function CompositeShape(shapes, shapeCount) {
            void 0 === shapeCount && (shapeCount = shapes.length);
            var _this = _super.call(this, exports.b2ShapeType.e_unknown, 0) || this;
            _this.m_shapeCount = 0;
            _this.m_shapes = shapes;
            _this.m_shapeCount = shapeCount;
            return _this;
          }
          CompositeShape.prototype.Clone = function() {
            throw new Error();
          };
          CompositeShape.prototype.GetChildCount = function() {
            return 1;
          };
          CompositeShape.prototype.TestPoint = function(xf, p) {
            for (var i = 0; i < this.m_shapeCount; i++) if (this.m_shapes[i].TestPoint(xf, p)) return true;
            return false;
          };
          CompositeShape.prototype.ComputeDistance = function(xf, p, normal, childIndex) {
            return 0;
          };
          CompositeShape.prototype.RayCast = function(output, input, xf, childIndex) {
            return false;
          };
          CompositeShape.prototype.ComputeAABB = function(aabb, xf, childIndex) {
            var s_subaabb = new b2AABB();
            aabb.lowerBound.x = +b2_maxFloat;
            aabb.lowerBound.y = +b2_maxFloat;
            aabb.upperBound.x = -b2_maxFloat;
            aabb.upperBound.y = -b2_maxFloat;
            for (var i = 0; i < this.m_shapeCount; i++) {
              var childCount = this.m_shapes[i].GetChildCount();
              for (var j = 0; j < childCount; j++) {
                var subaabb = s_subaabb;
                this.m_shapes[i].ComputeAABB(subaabb, xf, j);
                aabb.Combine1(subaabb);
              }
            }
          };
          CompositeShape.prototype.ComputeMass = function(massData, density) {};
          CompositeShape.prototype.SetupDistanceProxy = function(proxy, index) {};
          CompositeShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
            return 0;
          };
          CompositeShape.prototype.Dump = function(log) {};
          return CompositeShape;
        })(b2Shape);
        b2ParticleSystem.CompositeShape = CompositeShape;
        var ReactiveFilter = (function(_super) {
          __extends(ReactiveFilter, _super);
          function ReactiveFilter(flagsBuffer) {
            var _this = _super.call(this) || this;
            _this.m_flagsBuffer = flagsBuffer;
            return _this;
          }
          ReactiveFilter.prototype.IsNecessary = function(index) {
            if (!this.m_flagsBuffer.data) throw new Error();
            return 0 !== (this.m_flagsBuffer.data[index] & exports.b2ParticleFlag.b2_reactiveParticle);
          };
          return ReactiveFilter;
        })(b2ParticleSystem.ConnectionFilter);
        b2ParticleSystem.ReactiveFilter = ReactiveFilter;
        var UpdateBodyContactsCallback = (function(_super) {
          __extends(UpdateBodyContactsCallback, _super);
          function UpdateBodyContactsCallback(system, contactFilter) {
            var _this = _super.call(this, system) || this;
            _this.m_contactFilter = contactFilter;
            return _this;
          }
          UpdateBodyContactsCallback.prototype.ShouldCollideFixtureParticle = function(fixture, particleSystem, particleIndex) {
            if (this.m_contactFilter) {
              var flags = this.m_system.GetFlagsBuffer();
              if (flags[particleIndex] & exports.b2ParticleFlag.b2_fixtureContactFilterParticle) return this.m_contactFilter.ShouldCollideFixtureParticle(fixture, this.m_system, particleIndex);
            }
            return true;
          };
          UpdateBodyContactsCallback.prototype.ReportFixtureAndParticle = function(fixture, childIndex, a) {
            var s_n = b2ParticleSystem.UpdateBodyContactsCallback.ReportFixtureAndParticle_s_n;
            var s_rp = b2ParticleSystem.UpdateBodyContactsCallback.ReportFixtureAndParticle_s_rp;
            if (!this.m_system.m_flagsBuffer.data) throw new Error();
            if (!this.m_system.m_positionBuffer.data) throw new Error();
            var ap = this.m_system.m_positionBuffer.data[a];
            var n = s_n;
            var d = fixture.ComputeDistance(ap, n, childIndex);
            if (d < this.m_system.m_particleDiameter && this.ShouldCollideFixtureParticle(fixture, this.m_system, a)) {
              var b = fixture.GetBody();
              var bp = b.GetWorldCenter();
              var bm = b.GetMass();
              var bI = b.GetInertia() - bm * b.GetLocalCenter().LengthSquared();
              var invBm = bm > 0 ? 1 / bm : 0;
              var invBI = bI > 0 ? 1 / bI : 0;
              var invAm = this.m_system.m_flagsBuffer.data[a] & exports.b2ParticleFlag.b2_wallParticle ? 0 : this.m_system.GetParticleInvMass();
              var rp = b2Vec2.SubVV(ap, bp, s_rp);
              var rpn = b2Vec2.CrossVV(rp, n);
              var invM = invAm + invBm + invBI * rpn * rpn;
              var contact = this.m_system.m_bodyContactBuffer.data[this.m_system.m_bodyContactBuffer.Append()];
              contact.index = a;
              contact.body = b;
              contact.fixture = fixture;
              contact.weight = 1 - d * this.m_system.m_inverseDiameter;
              contact.normal.Copy(n.SelfNeg());
              contact.mass = invM > 0 ? 1 / invM : 0;
              this.m_system.DetectStuckParticle(a);
            }
          };
          UpdateBodyContactsCallback.ReportFixtureAndParticle_s_n = new b2Vec2();
          UpdateBodyContactsCallback.ReportFixtureAndParticle_s_rp = new b2Vec2();
          return UpdateBodyContactsCallback;
        })(b2FixtureParticleQueryCallback);
        b2ParticleSystem.UpdateBodyContactsCallback = UpdateBodyContactsCallback;
        var SolveCollisionCallback = (function(_super) {
          __extends(SolveCollisionCallback, _super);
          function SolveCollisionCallback(system, step) {
            var _this = _super.call(this, system) || this;
            _this.m_step = step;
            return _this;
          }
          SolveCollisionCallback.prototype.ReportFixtureAndParticle = function(fixture, childIndex, a) {
            var s_p1 = b2ParticleSystem.SolveCollisionCallback.ReportFixtureAndParticle_s_p1;
            var s_output = b2ParticleSystem.SolveCollisionCallback.ReportFixtureAndParticle_s_output;
            var s_input = b2ParticleSystem.SolveCollisionCallback.ReportFixtureAndParticle_s_input;
            var s_p = b2ParticleSystem.SolveCollisionCallback.ReportFixtureAndParticle_s_p;
            var s_v = b2ParticleSystem.SolveCollisionCallback.ReportFixtureAndParticle_s_v;
            var s_f = b2ParticleSystem.SolveCollisionCallback.ReportFixtureAndParticle_s_f;
            var body = fixture.GetBody();
            if (!this.m_system.m_positionBuffer.data) throw new Error();
            if (!this.m_system.m_velocityBuffer.data) throw new Error();
            var ap = this.m_system.m_positionBuffer.data[a];
            var av = this.m_system.m_velocityBuffer.data[a];
            var output = s_output;
            var input = s_input;
            if (0 === this.m_system.m_iterationIndex) {
              var p1 = b2Transform.MulTXV(body.m_xf0, ap, s_p1);
              if (fixture.GetShape().GetType() === exports.b2ShapeType.e_circleShape) {
                p1.SelfSub(body.GetLocalCenter());
                b2Rot.MulRV(body.m_xf0.q, p1, p1);
                b2Rot.MulTRV(body.m_xf.q, p1, p1);
                p1.SelfAdd(body.GetLocalCenter());
              }
              b2Transform.MulXV(body.m_xf, p1, input.p1);
            } else input.p1.Copy(ap);
            b2Vec2.AddVMulSV(ap, this.m_step.dt, av, input.p2);
            input.maxFraction = 1;
            if (fixture.RayCast(output, input, childIndex)) {
              var n = output.normal;
              var p = s_p;
              p.x = (1 - output.fraction) * input.p1.x + output.fraction * input.p2.x + b2_linearSlop * n.x;
              p.y = (1 - output.fraction) * input.p1.y + output.fraction * input.p2.y + b2_linearSlop * n.y;
              var v = s_v;
              v.x = this.m_step.inv_dt * (p.x - ap.x);
              v.y = this.m_step.inv_dt * (p.y - ap.y);
              this.m_system.m_velocityBuffer.data[a].Copy(v);
              var f = s_f;
              f.x = this.m_step.inv_dt * this.m_system.GetParticleMass() * (av.x - v.x);
              f.y = this.m_step.inv_dt * this.m_system.GetParticleMass() * (av.y - v.y);
              this.m_system.ParticleApplyForce(a, f);
            }
          };
          SolveCollisionCallback.prototype.ReportParticle = function(system, index) {
            return false;
          };
          SolveCollisionCallback.ReportFixtureAndParticle_s_p1 = new b2Vec2();
          SolveCollisionCallback.ReportFixtureAndParticle_s_output = new b2RayCastOutput();
          SolveCollisionCallback.ReportFixtureAndParticle_s_input = new b2RayCastInput();
          SolveCollisionCallback.ReportFixtureAndParticle_s_p = new b2Vec2();
          SolveCollisionCallback.ReportFixtureAndParticle_s_v = new b2Vec2();
          SolveCollisionCallback.ReportFixtureAndParticle_s_f = new b2Vec2();
          return SolveCollisionCallback;
        })(b2FixtureParticleQueryCallback);
        b2ParticleSystem.SolveCollisionCallback = SolveCollisionCallback;
      })(exports.b2ParticleSystem || (exports.b2ParticleSystem = {}));
      var b2World = (function() {
        function b2World(gravity) {
          this.m_newFixture = false;
          this.m_locked = false;
          this.m_clearForces = true;
          this.m_contactManager = new b2ContactManager();
          this.m_bodyList = null;
          this.m_jointList = null;
          this.m_particleSystemList = null;
          this.m_bodyCount = 0;
          this.m_jointCount = 0;
          this.m_gravity = new b2Vec2();
          this.m_allowSleep = true;
          this.m_destructionListener = null;
          this.m_debugDraw = null;
          this.m_inv_dt0 = 0;
          this.m_warmStarting = true;
          this.m_continuousPhysics = true;
          this.m_subStepping = false;
          this.m_stepComplete = true;
          this.m_profile = new b2Profile();
          this.m_island = new b2Island();
          this.s_stack = [];
          this.m_controllerList = null;
          this.m_controllerCount = 0;
          this.m_gravity.Copy(gravity);
        }
        b2World.prototype.SetDestructionListener = function(listener) {
          this.m_destructionListener = listener;
        };
        b2World.prototype.SetContactFilter = function(filter) {
          this.m_contactManager.m_contactFilter = filter;
        };
        b2World.prototype.SetContactListener = function(listener) {
          this.m_contactManager.m_contactListener = listener;
        };
        b2World.prototype.SetDebugDraw = function(debugDraw) {
          this.m_debugDraw = debugDraw;
        };
        b2World.prototype.CreateBody = function(def) {
          void 0 === def && (def = {});
          if (this.IsLocked()) throw new Error();
          var b = new b2Body(def, this);
          b.m_prev = null;
          b.m_next = this.m_bodyList;
          this.m_bodyList && (this.m_bodyList.m_prev = b);
          this.m_bodyList = b;
          ++this.m_bodyCount;
          return b;
        };
        b2World.prototype.DestroyBody = function(b) {
          if (this.IsLocked()) throw new Error();
          var je = b.m_jointList;
          while (je) {
            var je0 = je;
            je = je.next;
            this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(je0.joint);
            this.DestroyJoint(je0.joint);
            b.m_jointList = je;
          }
          b.m_jointList = null;
          var coe = b.m_controllerList;
          while (coe) {
            var coe0 = coe;
            coe = coe.nextController;
            coe0.controller.RemoveBody(b);
          }
          var ce = b.m_contactList;
          while (ce) {
            var ce0 = ce;
            ce = ce.next;
            this.m_contactManager.Destroy(ce0.contact);
          }
          b.m_contactList = null;
          var f = b.m_fixtureList;
          while (f) {
            var f0 = f;
            f = f.m_next;
            this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(f0);
            f0.DestroyProxies();
            f0.Destroy();
            b.m_fixtureList = f;
            b.m_fixtureCount -= 1;
          }
          b.m_fixtureList = null;
          b.m_fixtureCount = 0;
          b.m_prev && (b.m_prev.m_next = b.m_next);
          b.m_next && (b.m_next.m_prev = b.m_prev);
          b === this.m_bodyList && (this.m_bodyList = b.m_next);
          --this.m_bodyCount;
        };
        b2World._Joint_Create = function(def, allocator) {
          switch (def.type) {
           case exports.b2JointType.e_distanceJoint:
            return new b2DistanceJoint(def);

           case exports.b2JointType.e_mouseJoint:
            return new b2MouseJoint(def);

           case exports.b2JointType.e_prismaticJoint:
            return new b2PrismaticJoint(def);

           case exports.b2JointType.e_revoluteJoint:
            return new b2RevoluteJoint(def);

           case exports.b2JointType.e_pulleyJoint:
            return new b2PulleyJoint(def);

           case exports.b2JointType.e_gearJoint:
            return new b2GearJoint(def);

           case exports.b2JointType.e_wheelJoint:
            return new b2WheelJoint(def);

           case exports.b2JointType.e_weldJoint:
            return new b2WeldJoint(def);

           case exports.b2JointType.e_frictionJoint:
            return new b2FrictionJoint(def);

           case exports.b2JointType.e_ropeJoint:
            return new b2RopeJoint(def);

           case exports.b2JointType.e_motorJoint:
            return new b2MotorJoint(def);

           case exports.b2JointType.e_areaJoint:
            return new b2AreaJoint(def);
          }
          throw new Error();
        };
        b2World._Joint_Destroy = function(joint, allocator) {};
        b2World.prototype.CreateJoint = function(def) {
          if (this.IsLocked()) throw new Error();
          var j = b2World._Joint_Create(def, null);
          j.m_prev = null;
          j.m_next = this.m_jointList;
          this.m_jointList && (this.m_jointList.m_prev = j);
          this.m_jointList = j;
          ++this.m_jointCount;
          j.m_edgeA.prev = null;
          j.m_edgeA.next = j.m_bodyA.m_jointList;
          j.m_bodyA.m_jointList && (j.m_bodyA.m_jointList.prev = j.m_edgeA);
          j.m_bodyA.m_jointList = j.m_edgeA;
          j.m_edgeB.prev = null;
          j.m_edgeB.next = j.m_bodyB.m_jointList;
          j.m_bodyB.m_jointList && (j.m_bodyB.m_jointList.prev = j.m_edgeB);
          j.m_bodyB.m_jointList = j.m_edgeB;
          var bodyA = def.bodyA;
          var bodyB = def.bodyB;
          if (!def.collideConnected) {
            var edge = bodyB.GetContactList();
            while (edge) {
              edge.other === bodyA && edge.contact.FlagForFiltering();
              edge = edge.next;
            }
          }
          return j;
        };
        b2World.prototype.DestroyJoint = function(j) {
          if (this.IsLocked()) throw new Error();
          var collideConnected = j.m_collideConnected;
          j.m_prev && (j.m_prev.m_next = j.m_next);
          j.m_next && (j.m_next.m_prev = j.m_prev);
          j === this.m_jointList && (this.m_jointList = j.m_next);
          var bodyA = j.m_bodyA;
          var bodyB = j.m_bodyB;
          bodyA.SetAwake(true);
          bodyB.SetAwake(true);
          j.m_edgeA.prev && (j.m_edgeA.prev.next = j.m_edgeA.next);
          j.m_edgeA.next && (j.m_edgeA.next.prev = j.m_edgeA.prev);
          j.m_edgeA === bodyA.m_jointList && (bodyA.m_jointList = j.m_edgeA.next);
          j.m_edgeA.prev = null;
          j.m_edgeA.next = null;
          j.m_edgeB.prev && (j.m_edgeB.prev.next = j.m_edgeB.next);
          j.m_edgeB.next && (j.m_edgeB.next.prev = j.m_edgeB.prev);
          j.m_edgeB === bodyB.m_jointList && (bodyB.m_jointList = j.m_edgeB.next);
          j.m_edgeB.prev = null;
          j.m_edgeB.next = null;
          b2World._Joint_Destroy(j, null);
          --this.m_jointCount;
          if (!collideConnected) {
            var edge = bodyB.GetContactList();
            while (edge) {
              edge.other === bodyA && edge.contact.FlagForFiltering();
              edge = edge.next;
            }
          }
        };
        b2World.prototype.CreateParticleSystem = function(def) {
          if (this.IsLocked()) throw new Error();
          var p = new exports.b2ParticleSystem(def, this);
          p.m_prev = null;
          p.m_next = this.m_particleSystemList;
          this.m_particleSystemList && (this.m_particleSystemList.m_prev = p);
          this.m_particleSystemList = p;
          return p;
        };
        b2World.prototype.DestroyParticleSystem = function(p) {
          if (this.IsLocked()) throw new Error();
          p.m_prev && (p.m_prev.m_next = p.m_next);
          p.m_next && (p.m_next.m_prev = p.m_prev);
          p === this.m_particleSystemList && (this.m_particleSystemList = p.m_next);
        };
        b2World.prototype.CalculateReasonableParticleIterations = function(timeStep) {
          if (null === this.m_particleSystemList) return 1;
          function GetSmallestRadius(world) {
            var smallestRadius = b2_maxFloat;
            for (var system = world.GetParticleSystemList(); null !== system; system = system.m_next) smallestRadius = b2Min(smallestRadius, system.GetRadius());
            return smallestRadius;
          }
          return b2CalculateParticleIterations(this.m_gravity.Length(), GetSmallestRadius(this), timeStep);
        };
        b2World.prototype.Step = function(dt, velocityIterations, positionIterations, particleIterations) {
          void 0 === particleIterations && (particleIterations = this.CalculateReasonableParticleIterations(dt));
          var stepTimer = b2World.Step_s_stepTimer.Reset();
          if (this.m_newFixture) {
            this.m_contactManager.FindNewContacts();
            this.m_newFixture = false;
          }
          this.m_locked = true;
          var step = b2World.Step_s_step;
          step.dt = dt;
          step.velocityIterations = velocityIterations;
          step.positionIterations = positionIterations;
          step.particleIterations = particleIterations;
          step.inv_dt = dt > 0 ? 1 / dt : 0;
          step.dtRatio = this.m_inv_dt0 * dt;
          step.warmStarting = this.m_warmStarting;
          var timer = b2World.Step_s_timer.Reset();
          this.m_contactManager.Collide();
          this.m_profile.collide = timer.GetMilliseconds();
          if (this.m_stepComplete && step.dt > 0) {
            var timer_1 = b2World.Step_s_timer.Reset();
            for (var p = this.m_particleSystemList; p; p = p.m_next) p.Solve(step);
            this.Solve(step);
            this.m_profile.solve = timer_1.GetMilliseconds();
          }
          if (this.m_continuousPhysics && step.dt > 0) {
            var timer_2 = b2World.Step_s_timer.Reset();
            this.SolveTOI(step);
            this.m_profile.solveTOI = timer_2.GetMilliseconds();
          }
          step.dt > 0 && (this.m_inv_dt0 = step.inv_dt);
          this.m_clearForces && this.ClearForces();
          this.m_locked = false;
          this.m_profile.step = stepTimer.GetMilliseconds();
        };
        b2World.prototype.ClearForces = function() {
          for (var body = this.m_bodyList; body; body = body.m_next) {
            body.m_force.SetZero();
            body.m_torque = 0;
          }
        };
        b2World.prototype.DrawParticleSystem = function(system) {
          if (null === this.m_debugDraw) return;
          var particleCount = system.GetParticleCount();
          if (particleCount) {
            var radius = system.GetRadius();
            var positionBuffer = system.GetPositionBuffer();
            if (system.m_colorBuffer.data) {
              var colorBuffer = system.GetColorBuffer();
              this.m_debugDraw.DrawParticles(positionBuffer, radius, colorBuffer, particleCount);
            } else this.m_debugDraw.DrawParticles(positionBuffer, radius, null, particleCount);
          }
        };
        b2World.prototype.DrawDebugData = function() {
          if (null === this.m_debugDraw) return;
          var flags = this.m_debugDraw.GetFlags();
          var color = b2World.DrawDebugData_s_color.SetRGB(0, 0, 0);
          if (flags & exports.b2DrawFlags.e_shapeBit) for (var b = this.m_bodyList; b; b = b.m_next) {
            var xf = b.m_xf;
            this.m_debugDraw.PushTransform(xf);
            for (var f = b.GetFixtureList(); f; f = f.m_next) if (b.IsActive()) if (b.GetType() === exports.b2BodyType.b2_staticBody) {
              color.SetRGB(.5, .9, .5);
              this.DrawShape(f, color);
            } else if (b.GetType() === exports.b2BodyType.b2_kinematicBody) {
              color.SetRGB(.5, .5, .9);
              this.DrawShape(f, color);
            } else if (b.IsAwake()) {
              color.SetRGB(.9, .7, .7);
              this.DrawShape(f, color);
            } else {
              color.SetRGB(.6, .6, .6);
              this.DrawShape(f, color);
            } else {
              color.SetRGB(.5, .5, .3);
              this.DrawShape(f, color);
            }
            this.m_debugDraw.PopTransform(xf);
          }
          if (flags & exports.b2DrawFlags.e_particleBit) for (var p = this.m_particleSystemList; p; p = p.m_next) this.DrawParticleSystem(p);
          if (flags & exports.b2DrawFlags.e_jointBit) for (var j = this.m_jointList; j; j = j.m_next) this.DrawJoint(j);
          if (flags & exports.b2DrawFlags.e_aabbBit) {
            color.SetRGB(.9, .3, .9);
            var vs = b2World.DrawDebugData_s_vs;
            for (var b = this.m_bodyList; b; b = b.m_next) {
              if (!b.IsActive()) continue;
              for (var f = b.GetFixtureList(); f; f = f.m_next) for (var i = 0; i < f.m_proxyCount; ++i) {
                var proxy = f.m_proxies[i];
                var aabb = proxy.treeNode.aabb;
                vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
                vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
                vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
                vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
                this.m_debugDraw.DrawPolygon(vs, 4, color);
              }
            }
          }
          if (flags & exports.b2DrawFlags.e_centerOfMassBit) for (var b = this.m_bodyList; b; b = b.m_next) {
            var xf = b2World.DrawDebugData_s_xf;
            xf.q.Copy(b.m_xf.q);
            xf.p.Copy(b.GetWorldCenter());
            this.m_debugDraw.DrawTransform(xf);
          }
          if (flags & exports.b2DrawFlags.e_controllerBit) for (var c = this.m_controllerList; c; c = c.m_next) c.Draw(this.m_debugDraw);
        };
        b2World.prototype.QueryAABB = function(callback, aabb, fn) {
          this.m_contactManager.m_broadPhase.Query(aabb, (function(proxy) {
            var fixture_proxy = proxy.userData;
            var fixture = fixture_proxy.fixture;
            if (callback) return callback.ReportFixture(fixture);
            if (fn) return fn(fixture);
            return true;
          }));
          if (callback instanceof b2QueryCallback) for (var p = this.m_particleSystemList; p; p = p.m_next) callback.ShouldQueryParticleSystem(p) && p.QueryAABB(callback, aabb);
        };
        b2World.prototype.QueryAllAABB = function(aabb, out) {
          void 0 === out && (out = []);
          this.QueryAABB(null, aabb, (function(fixture) {
            out.push(fixture);
            return true;
          }));
          return out;
        };
        b2World.prototype.QueryPointAABB = function(callback, point, fn) {
          this.m_contactManager.m_broadPhase.QueryPoint(point, (function(proxy) {
            var fixture_proxy = proxy.userData;
            var fixture = fixture_proxy.fixture;
            if (callback) return callback.ReportFixture(fixture);
            if (fn) return fn(fixture);
            return true;
          }));
          if (callback instanceof b2QueryCallback) for (var p = this.m_particleSystemList; p; p = p.m_next) callback.ShouldQueryParticleSystem(p) && p.QueryPointAABB(callback, point);
        };
        b2World.prototype.QueryAllPointAABB = function(point, out) {
          void 0 === out && (out = []);
          this.QueryPointAABB(null, point, (function(fixture) {
            out.push(fixture);
            return true;
          }));
          return out;
        };
        b2World.prototype.QueryFixtureShape = function(callback, shape, index, transform, fn) {
          var aabb = b2World.QueryFixtureShape_s_aabb;
          shape.ComputeAABB(aabb, transform, index);
          this.m_contactManager.m_broadPhase.Query(aabb, (function(proxy) {
            var fixture_proxy = proxy.userData;
            var fixture = fixture_proxy.fixture;
            if (b2TestOverlapShape(shape, index, fixture.GetShape(), fixture_proxy.childIndex, transform, fixture.GetBody().GetTransform())) {
              if (callback) return callback.ReportFixture(fixture);
              if (fn) return fn(fixture);
            }
            return true;
          }));
          if (callback instanceof b2QueryCallback) for (var p = this.m_particleSystemList; p; p = p.m_next) callback.ShouldQueryParticleSystem(p) && p.QueryAABB(callback, aabb);
        };
        b2World.prototype.QueryAllFixtureShape = function(shape, index, transform, out) {
          void 0 === out && (out = []);
          this.QueryFixtureShape(null, shape, index, transform, (function(fixture) {
            out.push(fixture);
            return true;
          }));
          return out;
        };
        b2World.prototype.QueryFixturePoint = function(callback, point, fn) {
          this.m_contactManager.m_broadPhase.QueryPoint(point, (function(proxy) {
            var fixture_proxy = proxy.userData;
            var fixture = fixture_proxy.fixture;
            if (fixture.TestPoint(point)) {
              if (callback) return callback.ReportFixture(fixture);
              if (fn) return fn(fixture);
            }
            return true;
          }));
          if (callback) for (var p = this.m_particleSystemList; p; p = p.m_next) callback.ShouldQueryParticleSystem(p) && p.QueryPointAABB(callback, point);
        };
        b2World.prototype.QueryAllFixturePoint = function(point, out) {
          void 0 === out && (out = []);
          this.QueryFixturePoint(null, point, (function(fixture) {
            out.push(fixture);
            return true;
          }));
          return out;
        };
        b2World.prototype.RayCast = function(callback, point1, point2, fn) {
          var input = b2World.RayCast_s_input;
          input.maxFraction = 1;
          input.p1.Copy(point1);
          input.p2.Copy(point2);
          this.m_contactManager.m_broadPhase.RayCast(input, (function(input, proxy) {
            var fixture_proxy = proxy.userData;
            var fixture = fixture_proxy.fixture;
            var index = fixture_proxy.childIndex;
            var output = b2World.RayCast_s_output;
            var hit = fixture.RayCast(output, input, index);
            if (hit) {
              var fraction = output.fraction;
              var point = b2World.RayCast_s_point;
              point.Set((1 - fraction) * point1.x + fraction * point2.x, (1 - fraction) * point1.y + fraction * point2.y);
              if (callback) return callback.ReportFixture(fixture, point, output.normal, fraction);
              if (fn) return fn(fixture, point, output.normal, fraction);
            }
            return input.maxFraction;
          }));
          if (callback) for (var p = this.m_particleSystemList; p; p = p.m_next) callback.ShouldQueryParticleSystem(p) && p.RayCast(callback, point1, point2);
        };
        b2World.prototype.RayCastOne = function(point1, point2) {
          var result = null;
          var min_fraction = 1;
          this.RayCast(null, point1, point2, (function(fixture, point, normal, fraction) {
            if (fraction < min_fraction) {
              min_fraction = fraction;
              result = fixture;
            }
            return min_fraction;
          }));
          return result;
        };
        b2World.prototype.RayCastAll = function(point1, point2, out) {
          void 0 === out && (out = []);
          this.RayCast(null, point1, point2, (function(fixture, point, normal, fraction) {
            out.push(fixture);
            return 1;
          }));
          return out;
        };
        b2World.prototype.GetBodyList = function() {
          return this.m_bodyList;
        };
        b2World.prototype.GetJointList = function() {
          return this.m_jointList;
        };
        b2World.prototype.GetParticleSystemList = function() {
          return this.m_particleSystemList;
        };
        b2World.prototype.GetContactList = function() {
          return this.m_contactManager.m_contactList;
        };
        b2World.prototype.SetAllowSleeping = function(flag) {
          if (flag === this.m_allowSleep) return;
          this.m_allowSleep = flag;
          if (!this.m_allowSleep) for (var b = this.m_bodyList; b; b = b.m_next) b.SetAwake(true);
        };
        b2World.prototype.GetAllowSleeping = function() {
          return this.m_allowSleep;
        };
        b2World.prototype.SetWarmStarting = function(flag) {
          this.m_warmStarting = flag;
        };
        b2World.prototype.GetWarmStarting = function() {
          return this.m_warmStarting;
        };
        b2World.prototype.SetContinuousPhysics = function(flag) {
          this.m_continuousPhysics = flag;
        };
        b2World.prototype.GetContinuousPhysics = function() {
          return this.m_continuousPhysics;
        };
        b2World.prototype.SetSubStepping = function(flag) {
          this.m_subStepping = flag;
        };
        b2World.prototype.GetSubStepping = function() {
          return this.m_subStepping;
        };
        b2World.prototype.GetProxyCount = function() {
          return this.m_contactManager.m_broadPhase.GetProxyCount();
        };
        b2World.prototype.GetBodyCount = function() {
          return this.m_bodyCount;
        };
        b2World.prototype.GetJointCount = function() {
          return this.m_jointCount;
        };
        b2World.prototype.GetContactCount = function() {
          return this.m_contactManager.m_contactCount;
        };
        b2World.prototype.GetTreeHeight = function() {
          return this.m_contactManager.m_broadPhase.GetTreeHeight();
        };
        b2World.prototype.GetTreeBalance = function() {
          return this.m_contactManager.m_broadPhase.GetTreeBalance();
        };
        b2World.prototype.GetTreeQuality = function() {
          return this.m_contactManager.m_broadPhase.GetTreeQuality();
        };
        b2World.prototype.SetGravity = function(gravity, wake) {
          void 0 === wake && (wake = true);
          if (!b2Vec2.IsEqualToV(this.m_gravity, gravity)) {
            this.m_gravity.Copy(gravity);
            if (wake) for (var b = this.m_bodyList; b; b = b.m_next) b.SetAwake(true);
          }
        };
        b2World.prototype.GetGravity = function() {
          return this.m_gravity;
        };
        b2World.prototype.IsLocked = function() {
          return this.m_locked;
        };
        b2World.prototype.SetAutoClearForces = function(flag) {
          this.m_clearForces = flag;
        };
        b2World.prototype.GetAutoClearForces = function() {
          return this.m_clearForces;
        };
        b2World.prototype.ShiftOrigin = function(newOrigin) {
          if (this.IsLocked()) throw new Error();
          for (var b = this.m_bodyList; b; b = b.m_next) {
            b.m_xf.p.SelfSub(newOrigin);
            b.m_sweep.c0.SelfSub(newOrigin);
            b.m_sweep.c.SelfSub(newOrigin);
          }
          for (var j = this.m_jointList; j; j = j.m_next) j.ShiftOrigin(newOrigin);
          this.m_contactManager.m_broadPhase.ShiftOrigin(newOrigin);
        };
        b2World.prototype.GetContactManager = function() {
          return this.m_contactManager;
        };
        b2World.prototype.GetProfile = function() {
          return this.m_profile;
        };
        b2World.prototype.Dump = function(log) {
          if (this.m_locked) return;
          log("const g: b2Vec2 = new b2Vec2(%.15f, %.15f);\n", this.m_gravity.x, this.m_gravity.y);
          log("this.m_world.SetGravity(g);\n");
          log("const bodies: b2Body[] = [];\n");
          log("const joints: b2Joint[] = [];\n");
          var i = 0;
          for (var b = this.m_bodyList; b; b = b.m_next) {
            b.m_islandIndex = i;
            b.Dump(log);
            ++i;
          }
          i = 0;
          for (var j = this.m_jointList; j; j = j.m_next) {
            j.m_index = i;
            ++i;
          }
          for (var j = this.m_jointList; j; j = j.m_next) {
            if (j.m_type === exports.b2JointType.e_gearJoint) continue;
            log("{\n");
            j.Dump(log);
            log("}\n");
          }
          for (var j = this.m_jointList; j; j = j.m_next) {
            if (j.m_type !== exports.b2JointType.e_gearJoint) continue;
            log("{\n");
            j.Dump(log);
            log("}\n");
          }
        };
        b2World.prototype.DrawJoint = function(joint) {
          if (null === this.m_debugDraw) return;
          var bodyA = joint.GetBodyA();
          var bodyB = joint.GetBodyB();
          var xf1 = bodyA.m_xf;
          var xf2 = bodyB.m_xf;
          var x1 = xf1.p;
          var x2 = xf2.p;
          var p1 = joint.GetAnchorA(b2World.DrawJoint_s_p1);
          var p2 = joint.GetAnchorB(b2World.DrawJoint_s_p2);
          var color = b2World.DrawJoint_s_color.SetRGB(.5, .8, .8);
          switch (joint.m_type) {
           case exports.b2JointType.e_distanceJoint:
            this.m_debugDraw.DrawSegment(p1, p2, color);
            break;

           case exports.b2JointType.e_pulleyJoint:
            var pulley = joint;
            var s1 = pulley.GetGroundAnchorA();
            var s2 = pulley.GetGroundAnchorB();
            this.m_debugDraw.DrawSegment(s1, p1, color);
            this.m_debugDraw.DrawSegment(s2, p2, color);
            this.m_debugDraw.DrawSegment(s1, s2, color);
            break;

           case exports.b2JointType.e_mouseJoint:
            var c = b2World.DrawJoint_s_c;
            c.Set(0, 1, 0);
            this.m_debugDraw.DrawPoint(p1, 4, c);
            this.m_debugDraw.DrawPoint(p2, 4, c);
            c.Set(.8, .8, .8);
            this.m_debugDraw.DrawSegment(p1, p2, c);
            break;

           default:
            this.m_debugDraw.DrawSegment(x1, p1, color);
            this.m_debugDraw.DrawSegment(p1, p2, color);
            this.m_debugDraw.DrawSegment(x2, p2, color);
          }
        };
        b2World.prototype.DrawShape = function(fixture, color) {
          if (null === this.m_debugDraw) return;
          var shape = fixture.GetShape();
          switch (shape.m_type) {
           case exports.b2ShapeType.e_circleShape:
            var circle = shape;
            var center = circle.m_p;
            var radius = circle.m_radius;
            var axis = b2Vec2.UNITX;
            this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
            break;

           case exports.b2ShapeType.e_edgeShape:
            var edge = shape;
            var v1 = edge.m_vertex1;
            var v2 = edge.m_vertex2;
            this.m_debugDraw.DrawSegment(v1, v2, color);
            break;

           case exports.b2ShapeType.e_chainShape:
            var chain = shape;
            var count = chain.m_count;
            var vertices = chain.m_vertices;
            var ghostColor = b2World.DrawShape_s_ghostColor.SetRGBA(.75 * color.r, .75 * color.g, .75 * color.b, color.a);
            var v1 = vertices[0];
            this.m_debugDraw.DrawPoint(v1, 4, color);
            if (chain.m_hasPrevVertex) {
              var vp = chain.m_prevVertex;
              this.m_debugDraw.DrawSegment(vp, v1, ghostColor);
              this.m_debugDraw.DrawCircle(vp, .1, ghostColor);
            }
            for (var i = 1; i < count; ++i) {
              var v2 = vertices[i];
              this.m_debugDraw.DrawSegment(v1, v2, color);
              this.m_debugDraw.DrawPoint(v2, 4, color);
              v1 = v2;
            }
            if (chain.m_hasNextVertex) {
              var vn = chain.m_nextVertex;
              this.m_debugDraw.DrawSegment(vn, v1, ghostColor);
              this.m_debugDraw.DrawCircle(vn, .1, ghostColor);
            }
            break;

           case exports.b2ShapeType.e_polygonShape:
            var poly = shape;
            var vertexCount = poly.m_count;
            var vertices = poly.m_vertices;
            this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
          }
        };
        b2World.prototype.Solve = function(step) {
          for (var b = this.m_bodyList; b; b = b.m_next) b.m_xf0.Copy(b.m_xf);
          for (var controller = this.m_controllerList; controller; controller = controller.m_next) controller.Step(step);
          this.m_profile.solveInit = 0;
          this.m_profile.solveVelocity = 0;
          this.m_profile.solvePosition = 0;
          var island = this.m_island;
          island.Initialize(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener);
          for (var b = this.m_bodyList; b; b = b.m_next) b.m_islandFlag = false;
          for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) c.m_islandFlag = false;
          for (var j = this.m_jointList; j; j = j.m_next) j.m_islandFlag = false;
          var stack = this.s_stack;
          for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
            if (seed.m_islandFlag) continue;
            if (!seed.IsAwake() || !seed.IsActive()) continue;
            if (seed.GetType() === exports.b2BodyType.b2_staticBody) continue;
            island.Clear();
            var stackCount = 0;
            stack[stackCount++] = seed;
            seed.m_islandFlag = true;
            while (stackCount > 0) {
              var b = stack[--stackCount];
              if (!b) throw new Error();
              island.AddBody(b);
              b.m_awakeFlag = true;
              if (b.GetType() === exports.b2BodyType.b2_staticBody) continue;
              for (var ce = b.m_contactList; ce; ce = ce.next) {
                var contact = ce.contact;
                if (contact.m_islandFlag) continue;
                if (!contact.IsEnabled() || !contact.IsTouching()) continue;
                var sensorA = contact.m_fixtureA.m_isSensor;
                var sensorB = contact.m_fixtureB.m_isSensor;
                if (sensorA || sensorB) continue;
                island.AddContact(contact);
                contact.m_islandFlag = true;
                var other = ce.other;
                if (!other) throw new Error();
                if (other.m_islandFlag) continue;
                stack[stackCount++] = other;
                other.m_islandFlag = true;
              }
              for (var je = b.m_jointList; je; je = je.next) {
                if (je.joint.m_islandFlag) continue;
                var other = je.other;
                if (!other.IsActive()) continue;
                island.AddJoint(je.joint);
                je.joint.m_islandFlag = true;
                if (other.m_islandFlag) continue;
                stack[stackCount++] = other;
                other.m_islandFlag = true;
              }
            }
            var profile = new b2Profile();
            island.Solve(profile, step, this.m_gravity, this.m_allowSleep);
            this.m_profile.solveInit += profile.solveInit;
            this.m_profile.solveVelocity += profile.solveVelocity;
            this.m_profile.solvePosition += profile.solvePosition;
            for (var i = 0; i < island.m_bodyCount; ++i) {
              var b = island.m_bodies[i];
              b.GetType() === exports.b2BodyType.b2_staticBody && (b.m_islandFlag = false);
            }
          }
          for (var i = 0; i < stack.length; ++i) {
            if (!stack[i]) break;
            stack[i] = null;
          }
          var timer = new b2Timer();
          for (var b = this.m_bodyList; b; b = b.m_next) {
            if (!b.m_islandFlag) continue;
            if (b.GetType() === exports.b2BodyType.b2_staticBody) continue;
            b.SynchronizeFixtures();
          }
          this.m_contactManager.FindNewContacts();
          this.m_profile.broadphase = timer.GetMilliseconds();
        };
        b2World.prototype.SolveTOI = function(step) {
          var island = this.m_island;
          island.Initialize(2 * b2_maxTOIContacts, b2_maxTOIContacts, 0, null, this.m_contactManager.m_contactListener);
          if (this.m_stepComplete) {
            for (var b = this.m_bodyList; b; b = b.m_next) {
              b.m_islandFlag = false;
              b.m_sweep.alpha0 = 0;
            }
            for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) {
              c.m_toiFlag = false;
              c.m_islandFlag = false;
              c.m_toiCount = 0;
              c.m_toi = 1;
            }
          }
          for (;;) {
            var minContact = null;
            var minAlpha = 1;
            for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) {
              if (!c.IsEnabled()) continue;
              if (c.m_toiCount > b2_maxSubSteps) continue;
              var alpha = 1;
              if (c.m_toiFlag) alpha = c.m_toi; else {
                var fA_1 = c.GetFixtureA();
                var fB_1 = c.GetFixtureB();
                if (fA_1.IsSensor() || fB_1.IsSensor()) continue;
                var bA_1 = fA_1.GetBody();
                var bB_1 = fB_1.GetBody();
                var typeA = bA_1.m_type;
                var typeB = bB_1.m_type;
                var activeA = bA_1.IsAwake() && typeA !== exports.b2BodyType.b2_staticBody;
                var activeB = bB_1.IsAwake() && typeB !== exports.b2BodyType.b2_staticBody;
                if (!activeA && !activeB) continue;
                var collideA = bA_1.IsBullet() || typeA !== exports.b2BodyType.b2_dynamicBody;
                var collideB = bB_1.IsBullet() || typeB !== exports.b2BodyType.b2_dynamicBody;
                if (!collideA && !collideB) continue;
                var alpha0 = bA_1.m_sweep.alpha0;
                if (bA_1.m_sweep.alpha0 < bB_1.m_sweep.alpha0) {
                  alpha0 = bB_1.m_sweep.alpha0;
                  bA_1.m_sweep.Advance(alpha0);
                } else if (bB_1.m_sweep.alpha0 < bA_1.m_sweep.alpha0) {
                  alpha0 = bA_1.m_sweep.alpha0;
                  bB_1.m_sweep.Advance(alpha0);
                }
                var indexA = c.GetChildIndexA();
                var indexB = c.GetChildIndexB();
                var input = b2World.SolveTOI_s_toi_input;
                input.proxyA.SetShape(fA_1.GetShape(), indexA);
                input.proxyB.SetShape(fB_1.GetShape(), indexB);
                input.sweepA.Copy(bA_1.m_sweep);
                input.sweepB.Copy(bB_1.m_sweep);
                input.tMax = 1;
                var output = b2World.SolveTOI_s_toi_output;
                b2TimeOfImpact(output, input);
                var beta = output.t;
                alpha = output.state === exports.b2TOIOutputState.e_touching ? b2Min(alpha0 + (1 - alpha0) * beta, 1) : 1;
                c.m_toi = alpha;
                c.m_toiFlag = true;
              }
              if (alpha < minAlpha) {
                minContact = c;
                minAlpha = alpha;
              }
            }
            if (null === minContact || 1 - 10 * b2_epsilon < minAlpha) {
              this.m_stepComplete = true;
              break;
            }
            var fA = minContact.GetFixtureA();
            var fB = minContact.GetFixtureB();
            var bA = fA.GetBody();
            var bB = fB.GetBody();
            var backup1 = b2World.SolveTOI_s_backup1.Copy(bA.m_sweep);
            var backup2 = b2World.SolveTOI_s_backup2.Copy(bB.m_sweep);
            bA.Advance(minAlpha);
            bB.Advance(minAlpha);
            minContact.Update(this.m_contactManager.m_contactListener);
            minContact.m_toiFlag = false;
            ++minContact.m_toiCount;
            if (!minContact.IsEnabled() || !minContact.IsTouching()) {
              minContact.SetEnabled(false);
              bA.m_sweep.Copy(backup1);
              bB.m_sweep.Copy(backup2);
              bA.SynchronizeTransform();
              bB.SynchronizeTransform();
              continue;
            }
            bA.SetAwake(true);
            bB.SetAwake(true);
            island.Clear();
            island.AddBody(bA);
            island.AddBody(bB);
            island.AddContact(minContact);
            bA.m_islandFlag = true;
            bB.m_islandFlag = true;
            minContact.m_islandFlag = true;
            for (var i = 0; i < 2; ++i) {
              var body = 0 === i ? bA : bB;
              if (body.m_type === exports.b2BodyType.b2_dynamicBody) for (var ce = body.m_contactList; ce; ce = ce.next) {
                if (island.m_bodyCount === island.m_bodyCapacity) break;
                if (island.m_contactCount === island.m_contactCapacity) break;
                var contact = ce.contact;
                if (contact.m_islandFlag) continue;
                var other = ce.other;
                if (other.m_type === exports.b2BodyType.b2_dynamicBody && !body.IsBullet() && !other.IsBullet()) continue;
                var sensorA = contact.m_fixtureA.m_isSensor;
                var sensorB = contact.m_fixtureB.m_isSensor;
                if (sensorA || sensorB) continue;
                var backup = b2World.SolveTOI_s_backup.Copy(other.m_sweep);
                other.m_islandFlag || other.Advance(minAlpha);
                contact.Update(this.m_contactManager.m_contactListener);
                if (!contact.IsEnabled()) {
                  other.m_sweep.Copy(backup);
                  other.SynchronizeTransform();
                  continue;
                }
                if (!contact.IsTouching()) {
                  other.m_sweep.Copy(backup);
                  other.SynchronizeTransform();
                  continue;
                }
                contact.m_islandFlag = true;
                island.AddContact(contact);
                if (other.m_islandFlag) continue;
                other.m_islandFlag = true;
                other.m_type !== exports.b2BodyType.b2_staticBody && other.SetAwake(true);
                island.AddBody(other);
              }
            }
            var subStep = b2World.SolveTOI_s_subStep;
            subStep.dt = (1 - minAlpha) * step.dt;
            subStep.inv_dt = 1 / subStep.dt;
            subStep.dtRatio = 1;
            subStep.positionIterations = 20;
            subStep.velocityIterations = step.velocityIterations;
            subStep.particleIterations = step.particleIterations;
            subStep.warmStarting = false;
            island.SolveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);
            for (var i = 0; i < island.m_bodyCount; ++i) {
              var body = island.m_bodies[i];
              body.m_islandFlag = false;
              if (body.m_type !== exports.b2BodyType.b2_dynamicBody) continue;
              body.SynchronizeFixtures();
              for (var ce = body.m_contactList; ce; ce = ce.next) {
                ce.contact.m_toiFlag = false;
                ce.contact.m_islandFlag = false;
              }
            }
            this.m_contactManager.FindNewContacts();
            if (this.m_subStepping) {
              this.m_stepComplete = false;
              break;
            }
          }
        };
        b2World.prototype.AddController = function(controller) {
          controller.m_next = this.m_controllerList;
          controller.m_prev = null;
          this.m_controllerList && (this.m_controllerList.m_prev = controller);
          this.m_controllerList = controller;
          ++this.m_controllerCount;
          return controller;
        };
        b2World.prototype.RemoveController = function(controller) {
          controller.m_prev && (controller.m_prev.m_next = controller.m_next);
          controller.m_next && (controller.m_next.m_prev = controller.m_prev);
          this.m_controllerList === controller && (this.m_controllerList = controller.m_next);
          --this.m_controllerCount;
          controller.m_prev = null;
          controller.m_next = null;
          return controller;
        };
        b2World.Step_s_step = new b2TimeStep();
        b2World.Step_s_stepTimer = new b2Timer();
        b2World.Step_s_timer = new b2Timer();
        b2World.DrawDebugData_s_color = new b2Color(0, 0, 0);
        b2World.DrawDebugData_s_vs = b2Vec2.MakeArray(4);
        b2World.DrawDebugData_s_xf = new b2Transform();
        b2World.QueryFixtureShape_s_aabb = new b2AABB();
        b2World.RayCast_s_input = new b2RayCastInput();
        b2World.RayCast_s_output = new b2RayCastOutput();
        b2World.RayCast_s_point = new b2Vec2();
        b2World.DrawJoint_s_p1 = new b2Vec2();
        b2World.DrawJoint_s_p2 = new b2Vec2();
        b2World.DrawJoint_s_color = new b2Color(.5, .8, .8);
        b2World.DrawJoint_s_c = new b2Color();
        b2World.DrawShape_s_ghostColor = new b2Color();
        b2World.SolveTOI_s_subStep = new b2TimeStep();
        b2World.SolveTOI_s_backup = new b2Sweep();
        b2World.SolveTOI_s_backup1 = new b2Sweep();
        b2World.SolveTOI_s_backup2 = new b2Sweep();
        b2World.SolveTOI_s_toi_input = new b2TOIInput();
        b2World.SolveTOI_s_toi_output = new b2TOIOutput();
        return b2World;
      })();
      var b2ControllerEdge = (function() {
        function b2ControllerEdge(controller, body) {
          this.prevBody = null;
          this.nextBody = null;
          this.prevController = null;
          this.nextController = null;
          this.controller = controller;
          this.body = body;
        }
        return b2ControllerEdge;
      })();
      var b2Controller = (function() {
        function b2Controller() {
          this.m_bodyList = null;
          this.m_bodyCount = 0;
          this.m_prev = null;
          this.m_next = null;
        }
        b2Controller.prototype.GetNext = function() {
          return this.m_next;
        };
        b2Controller.prototype.GetPrev = function() {
          return this.m_prev;
        };
        b2Controller.prototype.GetBodyList = function() {
          return this.m_bodyList;
        };
        b2Controller.prototype.AddBody = function(body) {
          var edge = new b2ControllerEdge(this, body);
          edge.nextBody = this.m_bodyList;
          edge.prevBody = null;
          this.m_bodyList && (this.m_bodyList.prevBody = edge);
          this.m_bodyList = edge;
          ++this.m_bodyCount;
          edge.nextController = body.m_controllerList;
          edge.prevController = null;
          body.m_controllerList && (body.m_controllerList.prevController = edge);
          body.m_controllerList = edge;
          ++body.m_controllerCount;
        };
        b2Controller.prototype.RemoveBody = function(body) {
          if (this.m_bodyCount <= 0) throw new Error();
          var edge = this.m_bodyList;
          while (edge && edge.body !== body) edge = edge.nextBody;
          if (null === edge) throw new Error();
          edge.prevBody && (edge.prevBody.nextBody = edge.nextBody);
          edge.nextBody && (edge.nextBody.prevBody = edge.prevBody);
          this.m_bodyList === edge && (this.m_bodyList = edge.nextBody);
          --this.m_bodyCount;
          edge.nextController && (edge.nextController.prevController = edge.prevController);
          edge.prevController && (edge.prevController.nextController = edge.nextController);
          body.m_controllerList === edge && (body.m_controllerList = edge.nextController);
          --body.m_controllerCount;
        };
        b2Controller.prototype.Clear = function() {
          while (this.m_bodyList) this.RemoveBody(this.m_bodyList.body);
          this.m_bodyCount = 0;
        };
        return b2Controller;
      })();
      var b2BuoyancyController = (function(_super) {
        __extends(b2BuoyancyController, _super);
        function b2BuoyancyController() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.normal = new b2Vec2(0, 1);
          _this.offset = 0;
          _this.density = 0;
          _this.velocity = new b2Vec2(0, 0);
          _this.linearDrag = 0;
          _this.angularDrag = 0;
          _this.useDensity = false;
          _this.useWorldGravity = true;
          _this.gravity = new b2Vec2(0, 0);
          return _this;
        }
        b2BuoyancyController.prototype.Step = function(step) {
          if (!this.m_bodyList) return;
          this.useWorldGravity && this.gravity.Copy(this.m_bodyList.body.GetWorld().GetGravity());
          for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) continue;
            var areac = new b2Vec2();
            var massc = new b2Vec2();
            var area = 0;
            var mass = 0;
            for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.m_next) {
              var sc = new b2Vec2();
              var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
              area += sarea;
              areac.x += sarea * sc.x;
              areac.y += sarea * sc.y;
              var shapeDensity = 0;
              shapeDensity = this.useDensity ? fixture.GetDensity() : 1;
              mass += sarea * shapeDensity;
              massc.x += sarea * sc.x * shapeDensity;
              massc.y += sarea * sc.y * shapeDensity;
            }
            areac.x /= area;
            areac.y /= area;
            massc.x /= mass;
            massc.y /= mass;
            if (area < b2_epsilon) continue;
            var buoyancyForce = this.gravity.Clone().SelfNeg();
            buoyancyForce.SelfMul(this.density * area);
            body.ApplyForce(buoyancyForce, massc);
            var dragForce = body.GetLinearVelocityFromWorldPoint(areac, new b2Vec2());
            dragForce.SelfSub(this.velocity);
            dragForce.SelfMul(-this.linearDrag * area);
            body.ApplyForce(dragForce, areac);
            body.ApplyTorque(-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag);
          }
        };
        b2BuoyancyController.prototype.Draw = function(debugDraw) {
          var r = 100;
          var p1 = new b2Vec2();
          var p2 = new b2Vec2();
          p1.x = this.normal.x * this.offset + this.normal.y * r;
          p1.y = this.normal.y * this.offset - this.normal.x * r;
          p2.x = this.normal.x * this.offset - this.normal.y * r;
          p2.y = this.normal.y * this.offset + this.normal.x * r;
          var color = new b2Color(0, 0, .8);
          debugDraw.DrawSegment(p1, p2, color);
        };
        return b2BuoyancyController;
      })(b2Controller);
      var b2ConstantAccelController = (function(_super) {
        __extends(b2ConstantAccelController, _super);
        function b2ConstantAccelController() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.A = new b2Vec2(0, 0);
          return _this;
        }
        b2ConstantAccelController.prototype.Step = function(step) {
          var dtA = b2Vec2.MulSV(step.dt, this.A, b2ConstantAccelController.Step_s_dtA);
          for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) continue;
            body.SetLinearVelocity(b2Vec2.AddVV(body.GetLinearVelocity(), dtA, b2Vec2.s_t0));
          }
        };
        b2ConstantAccelController.prototype.Draw = function(draw) {};
        b2ConstantAccelController.Step_s_dtA = new b2Vec2();
        return b2ConstantAccelController;
      })(b2Controller);
      var b2ConstantForceController = (function(_super) {
        __extends(b2ConstantForceController, _super);
        function b2ConstantForceController() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.F = new b2Vec2(0, 0);
          return _this;
        }
        b2ConstantForceController.prototype.Step = function(step) {
          for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) continue;
            body.ApplyForce(this.F, body.GetWorldCenter());
          }
        };
        b2ConstantForceController.prototype.Draw = function(draw) {};
        return b2ConstantForceController;
      })(b2Controller);
      var b2GravityController = (function(_super) {
        __extends(b2GravityController, _super);
        function b2GravityController() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.G = 1;
          _this.invSqr = true;
          return _this;
        }
        b2GravityController.prototype.Step = function(step) {
          if (this.invSqr) for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body1 = i.body;
            var p1 = body1.GetWorldCenter();
            var mass1 = body1.GetMass();
            for (var j = this.m_bodyList; j && j !== i; j = j.nextBody) {
              var body2 = j.body;
              var p2 = body2.GetWorldCenter();
              var mass2 = body2.GetMass();
              var dx = p2.x - p1.x;
              var dy = p2.y - p1.y;
              var r2 = dx * dx + dy * dy;
              if (r2 < b2_epsilon) continue;
              var f = b2GravityController.Step_s_f.Set(dx, dy);
              f.SelfMul(this.G / r2 / b2Sqrt(r2) * mass1 * mass2);
              body1.IsAwake() && body1.ApplyForce(f, p1);
              body2.IsAwake() && body2.ApplyForce(f.SelfMul(-1), p2);
            }
          } else for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body1 = i.body;
            var p1 = body1.GetWorldCenter();
            var mass1 = body1.GetMass();
            for (var j = this.m_bodyList; j && j !== i; j = j.nextBody) {
              var body2 = j.body;
              var p2 = body2.GetWorldCenter();
              var mass2 = body2.GetMass();
              var dx = p2.x - p1.x;
              var dy = p2.y - p1.y;
              var r2 = dx * dx + dy * dy;
              if (r2 < b2_epsilon) continue;
              var f = b2GravityController.Step_s_f.Set(dx, dy);
              f.SelfMul(this.G / r2 * mass1 * mass2);
              body1.IsAwake() && body1.ApplyForce(f, p1);
              body2.IsAwake() && body2.ApplyForce(f.SelfMul(-1), p2);
            }
          }
        };
        b2GravityController.prototype.Draw = function(draw) {};
        b2GravityController.Step_s_f = new b2Vec2();
        return b2GravityController;
      })(b2Controller);
      var b2TensorDampingController = (function(_super) {
        __extends(b2TensorDampingController, _super);
        function b2TensorDampingController() {
          var _this = null !== _super && _super.apply(this, arguments) || this;
          _this.T = new b2Mat22();
          _this.maxTimestep = 0;
          return _this;
        }
        b2TensorDampingController.prototype.Step = function(step) {
          var timestep = step.dt;
          if (timestep <= b2_epsilon) return;
          timestep > this.maxTimestep && this.maxTimestep > 0 && (timestep = this.maxTimestep);
          for (var i = this.m_bodyList; i; i = i.nextBody) {
            var body = i.body;
            if (!body.IsAwake()) continue;
            var damping = body.GetWorldVector(b2Mat22.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity(), b2Vec2.s_t0), b2Vec2.s_t1), b2TensorDampingController.Step_s_damping);
            body.SetLinearVelocity(b2Vec2.AddVV(body.GetLinearVelocity(), b2Vec2.MulSV(timestep, damping, b2Vec2.s_t0), b2Vec2.s_t1));
          }
        };
        b2TensorDampingController.prototype.Draw = function(draw) {};
        b2TensorDampingController.prototype.SetAxisAligned = function(xDamping, yDamping) {
          this.T.ex.x = -xDamping;
          this.T.ex.y = 0;
          this.T.ey.x = 0;
          this.T.ey.y = -yDamping;
          this.maxTimestep = xDamping > 0 || yDamping > 0 ? 1 / b2Max(xDamping, yDamping) : 0;
        };
        b2TensorDampingController.Step_s_damping = new b2Vec2();
        return b2TensorDampingController;
      })(b2Controller);
      var b2RopeDef = (function() {
        function b2RopeDef() {
          this.vertices = [];
          this.count = 0;
          this.masses = [];
          this.gravity = new b2Vec2(0, 0);
          this.damping = .1;
          this.k2 = .9;
          this.k3 = .1;
        }
        return b2RopeDef;
      })();
      var b2Rope = (function() {
        function b2Rope() {
          this.m_count = 0;
          this.m_ps = [];
          this.m_p0s = [];
          this.m_vs = [];
          this.m_ims = [];
          this.m_Ls = [];
          this.m_as = [];
          this.m_gravity = new b2Vec2();
          this.m_damping = 0;
          this.m_k2 = 1;
          this.m_k3 = .1;
        }
        b2Rope.prototype.GetVertexCount = function() {
          return this.m_count;
        };
        b2Rope.prototype.GetVertices = function() {
          return this.m_ps;
        };
        b2Rope.prototype.Initialize = function(def) {
          this.m_count = def.count;
          this.m_ps = b2Vec2.MakeArray(this.m_count);
          this.m_p0s = b2Vec2.MakeArray(this.m_count);
          this.m_vs = b2Vec2.MakeArray(this.m_count);
          this.m_ims = b2MakeNumberArray(this.m_count);
          for (var i = 0; i < this.m_count; ++i) {
            this.m_ps[i].Copy(def.vertices[i]);
            this.m_p0s[i].Copy(def.vertices[i]);
            this.m_vs[i].SetZero();
            var m = def.masses[i];
            this.m_ims[i] = m > 0 ? 1 / m : 0;
          }
          var count2 = this.m_count - 1;
          var count3 = this.m_count - 2;
          this.m_Ls = b2MakeNumberArray(count2);
          this.m_as = b2MakeNumberArray(count3);
          for (var i = 0; i < count2; ++i) {
            var p1 = this.m_ps[i];
            var p2 = this.m_ps[i + 1];
            this.m_Ls[i] = b2Vec2.DistanceVV(p1, p2);
          }
          for (var i = 0; i < count3; ++i) {
            var p1 = this.m_ps[i];
            var p2 = this.m_ps[i + 1];
            var p3 = this.m_ps[i + 2];
            var d1 = b2Vec2.SubVV(p2, p1, b2Vec2.s_t0);
            var d2 = b2Vec2.SubVV(p3, p2, b2Vec2.s_t1);
            var a = b2Vec2.CrossVV(d1, d2);
            var b = b2Vec2.DotVV(d1, d2);
            this.m_as[i] = b2Atan2(a, b);
          }
          this.m_gravity.Copy(def.gravity);
          this.m_damping = def.damping;
          this.m_k2 = def.k2;
          this.m_k3 = def.k3;
        };
        b2Rope.prototype.Step = function(h, iterations) {
          if (0 === h) return;
          var d = Math.exp(-h * this.m_damping);
          for (var i = 0; i < this.m_count; ++i) {
            this.m_p0s[i].Copy(this.m_ps[i]);
            this.m_ims[i] > 0 && this.m_vs[i].SelfMulAdd(h, this.m_gravity);
            this.m_vs[i].SelfMul(d);
            this.m_ps[i].SelfMulAdd(h, this.m_vs[i]);
          }
          for (var i = 0; i < iterations; ++i) {
            this.SolveC2();
            this.SolveC3();
            this.SolveC2();
          }
          var inv_h = 1 / h;
          for (var i = 0; i < this.m_count; ++i) b2Vec2.MulSV(inv_h, b2Vec2.SubVV(this.m_ps[i], this.m_p0s[i], b2Vec2.s_t0), this.m_vs[i]);
        };
        b2Rope.prototype.SolveC2 = function() {
          var count2 = this.m_count - 1;
          for (var i = 0; i < count2; ++i) {
            var p1 = this.m_ps[i];
            var p2 = this.m_ps[i + 1];
            var d = b2Vec2.SubVV(p2, p1, b2Rope.s_d);
            var L = d.Normalize();
            var im1 = this.m_ims[i];
            var im2 = this.m_ims[i + 1];
            if (im1 + im2 === 0) continue;
            var s1 = im1 / (im1 + im2);
            var s2 = im2 / (im1 + im2);
            p1.SelfMulSub(this.m_k2 * s1 * (this.m_Ls[i] - L), d);
            p2.SelfMulAdd(this.m_k2 * s2 * (this.m_Ls[i] - L), d);
          }
        };
        b2Rope.prototype.SetAngle = function(angle) {
          var count3 = this.m_count - 2;
          for (var i = 0; i < count3; ++i) this.m_as[i] = angle;
        };
        b2Rope.prototype.SolveC3 = function() {
          var count3 = this.m_count - 2;
          for (var i = 0; i < count3; ++i) {
            var p1 = this.m_ps[i];
            var p2 = this.m_ps[i + 1];
            var p3 = this.m_ps[i + 2];
            var m1 = this.m_ims[i];
            var m2 = this.m_ims[i + 1];
            var m3 = this.m_ims[i + 2];
            var d1 = b2Vec2.SubVV(p2, p1, b2Rope.s_d1);
            var d2 = b2Vec2.SubVV(p3, p2, b2Rope.s_d2);
            var L1sqr = d1.LengthSquared();
            var L2sqr = d2.LengthSquared();
            if (L1sqr * L2sqr === 0) continue;
            var a = b2Vec2.CrossVV(d1, d2);
            var b = b2Vec2.DotVV(d1, d2);
            var angle = b2Atan2(a, b);
            var Jd1 = b2Vec2.MulSV(-1 / L1sqr, d1.SelfSkew(), b2Rope.s_Jd1);
            var Jd2 = b2Vec2.MulSV(1 / L2sqr, d2.SelfSkew(), b2Rope.s_Jd2);
            var J1 = b2Vec2.NegV(Jd1, b2Rope.s_J1);
            var J2 = b2Vec2.SubVV(Jd1, Jd2, b2Rope.s_J2);
            var J3 = Jd2;
            var mass = m1 * b2Vec2.DotVV(J1, J1) + m2 * b2Vec2.DotVV(J2, J2) + m3 * b2Vec2.DotVV(J3, J3);
            if (0 === mass) continue;
            mass = 1 / mass;
            var C = angle - this.m_as[i];
            while (C > b2_pi) {
              angle -= 2 * b2_pi;
              C = angle - this.m_as[i];
            }
            while (C < -b2_pi) {
              angle += 2 * b2_pi;
              C = angle - this.m_as[i];
            }
            var impulse = -this.m_k3 * mass * C;
            p1.SelfMulAdd(m1 * impulse, J1);
            p2.SelfMulAdd(m2 * impulse, J2);
            p3.SelfMulAdd(m3 * impulse, J3);
          }
        };
        b2Rope.prototype.Draw = function(draw) {
          var c = new b2Color(.4, .5, .7);
          for (var i = 0; i < this.m_count - 1; ++i) draw.DrawSegment(this.m_ps[i], this.m_ps[i + 1], c);
        };
        b2Rope.s_d = new b2Vec2();
        b2Rope.s_d1 = new b2Vec2();
        b2Rope.s_d2 = new b2Vec2();
        b2Rope.s_Jd1 = new b2Vec2();
        b2Rope.s_Jd2 = new b2Vec2();
        b2Rope.s_J1 = new b2Vec2();
        b2Rope.s_J2 = new b2Vec2();
        return b2Rope;
      })();
      exports.b2Assert = b2Assert;
      exports.b2Maybe = b2Maybe;
      exports.b2_maxFloat = b2_maxFloat;
      exports.b2_epsilon = b2_epsilon;
      exports.b2_epsilon_sq = b2_epsilon_sq;
      exports.b2_pi = b2_pi;
      exports.b2_maxManifoldPoints = b2_maxManifoldPoints;
      exports.b2_maxPolygonVertices = b2_maxPolygonVertices;
      exports.b2_aabbExtension = b2_aabbExtension;
      exports.b2_aabbMultiplier = b2_aabbMultiplier;
      exports.b2_linearSlop = b2_linearSlop;
      exports.b2_angularSlop = b2_angularSlop;
      exports.b2_polygonRadius = b2_polygonRadius;
      exports.b2_maxSubSteps = b2_maxSubSteps;
      exports.b2_maxTOIContacts = b2_maxTOIContacts;
      exports.b2_velocityThreshold = b2_velocityThreshold;
      exports.b2_maxLinearCorrection = b2_maxLinearCorrection;
      exports.b2_maxAngularCorrection = b2_maxAngularCorrection;
      exports.b2_maxTranslation = b2_maxTranslation;
      exports.b2_maxTranslationSquared = b2_maxTranslationSquared;
      exports.b2_maxRotation = b2_maxRotation;
      exports.b2_maxRotationSquared = b2_maxRotationSquared;
      exports.b2_baumgarte = b2_baumgarte;
      exports.b2_toiBaumgarte = b2_toiBaumgarte;
      exports.b2_invalidParticleIndex = b2_invalidParticleIndex;
      exports.b2_maxParticleIndex = b2_maxParticleIndex;
      exports.b2_particleStride = b2_particleStride;
      exports.b2_minParticleWeight = b2_minParticleWeight;
      exports.b2_maxParticlePressure = b2_maxParticlePressure;
      exports.b2_maxParticleForce = b2_maxParticleForce;
      exports.b2_maxTriadDistance = b2_maxTriadDistance;
      exports.b2_maxTriadDistanceSquared = b2_maxTriadDistanceSquared;
      exports.b2_minParticleSystemBufferCapacity = b2_minParticleSystemBufferCapacity;
      exports.b2_barrierCollisionTime = b2_barrierCollisionTime;
      exports.b2_timeToSleep = b2_timeToSleep;
      exports.b2_linearSleepTolerance = b2_linearSleepTolerance;
      exports.b2_angularSleepTolerance = b2_angularSleepTolerance;
      exports.b2Alloc = b2Alloc;
      exports.b2Free = b2Free;
      exports.b2Log = b2Log;
      exports.b2Version = b2Version;
      exports.b2_version = b2_version;
      exports.b2_branch = b2_branch;
      exports.b2_commit = b2_commit;
      exports.b2ParseInt = b2ParseInt;
      exports.b2ParseUInt = b2ParseUInt;
      exports.b2MakeArray = b2MakeArray;
      exports.b2MakeNullArray = b2MakeNullArray;
      exports.b2MakeNumberArray = b2MakeNumberArray;
      exports.b2_pi_over_180 = b2_pi_over_180;
      exports.b2_180_over_pi = b2_180_over_pi;
      exports.b2_two_pi = b2_two_pi;
      exports.b2Abs = b2Abs;
      exports.b2Min = b2Min;
      exports.b2Max = b2Max;
      exports.b2Clamp = b2Clamp;
      exports.b2Swap = b2Swap;
      exports.b2IsValid = b2IsValid;
      exports.b2Sq = b2Sq;
      exports.b2InvSqrt = b2InvSqrt;
      exports.b2Sqrt = b2Sqrt;
      exports.b2Pow = b2Pow;
      exports.b2DegToRad = b2DegToRad;
      exports.b2RadToDeg = b2RadToDeg;
      exports.b2Cos = b2Cos;
      exports.b2Sin = b2Sin;
      exports.b2Acos = b2Acos;
      exports.b2Asin = b2Asin;
      exports.b2Atan2 = b2Atan2;
      exports.b2NextPowerOfTwo = b2NextPowerOfTwo;
      exports.b2IsPowerOfTwo = b2IsPowerOfTwo;
      exports.b2Random = b2Random;
      exports.b2RandomRange = b2RandomRange;
      exports.b2Vec2 = b2Vec2;
      exports.b2Vec2_zero = b2Vec2_zero;
      exports.b2Vec3 = b2Vec3;
      exports.b2Mat22 = b2Mat22;
      exports.b2Mat33 = b2Mat33;
      exports.b2Rot = b2Rot;
      exports.b2Transform = b2Transform;
      exports.b2Sweep = b2Sweep;
      exports.b2Color = b2Color;
      exports.b2Draw = b2Draw;
      exports.b2Timer = b2Timer;
      exports.b2Counter = b2Counter;
      exports.b2GrowableStack = b2GrowableStack;
      exports.b2BlockAllocator = b2BlockAllocator;
      exports.b2StackAllocator = b2StackAllocator;
      exports.b2ContactFeature = b2ContactFeature;
      exports.b2ContactID = b2ContactID;
      exports.b2ManifoldPoint = b2ManifoldPoint;
      exports.b2Manifold = b2Manifold;
      exports.b2WorldManifold = b2WorldManifold;
      exports.b2GetPointStates = b2GetPointStates;
      exports.b2ClipVertex = b2ClipVertex;
      exports.b2RayCastInput = b2RayCastInput;
      exports.b2RayCastOutput = b2RayCastOutput;
      exports.b2AABB = b2AABB;
      exports.b2TestOverlapAABB = b2TestOverlapAABB;
      exports.b2ClipSegmentToLine = b2ClipSegmentToLine;
      exports.b2TestOverlapShape = b2TestOverlapShape;
      exports.b2DistanceProxy = b2DistanceProxy;
      exports.b2SimplexCache = b2SimplexCache;
      exports.b2DistanceInput = b2DistanceInput;
      exports.b2DistanceOutput = b2DistanceOutput;
      exports.b2ShapeCastInput = b2ShapeCastInput;
      exports.b2ShapeCastOutput = b2ShapeCastOutput;
      exports.b2_gjk_reset = b2_gjk_reset;
      exports.b2SimplexVertex = b2SimplexVertex;
      exports.b2Simplex = b2Simplex;
      exports.b2Distance = b2Distance;
      exports.b2ShapeCast = b2ShapeCast;
      exports.b2Pair = b2Pair;
      exports.b2BroadPhase = b2BroadPhase;
      exports.b2PairLessThan = b2PairLessThan;
      exports.b2TreeNode = b2TreeNode;
      exports.b2DynamicTree = b2DynamicTree;
      exports.b2_toi_reset = b2_toi_reset;
      exports.b2TOIInput = b2TOIInput;
      exports.b2TOIOutput = b2TOIOutput;
      exports.b2SeparationFunction = b2SeparationFunction;
      exports.b2TimeOfImpact = b2TimeOfImpact;
      exports.b2CollideCircles = b2CollideCircles;
      exports.b2CollidePolygonAndCircle = b2CollidePolygonAndCircle;
      exports.b2CollidePolygons = b2CollidePolygons;
      exports.b2CollideEdgeAndCircle = b2CollideEdgeAndCircle;
      exports.b2CollideEdgeAndPolygon = b2CollideEdgeAndPolygon;
      exports.b2MassData = b2MassData;
      exports.b2Shape = b2Shape;
      exports.b2CircleShape = b2CircleShape;
      exports.b2PolygonShape = b2PolygonShape;
      exports.b2EdgeShape = b2EdgeShape;
      exports.b2ChainShape = b2ChainShape;
      exports.b2Filter = b2Filter;
      exports.b2FixtureDef = b2FixtureDef;
      exports.b2FixtureProxy = b2FixtureProxy;
      exports.b2Fixture = b2Fixture;
      exports.b2BodyDef = b2BodyDef;
      exports.b2Body = b2Body;
      exports.b2World = b2World;
      exports.b2DestructionListener = b2DestructionListener;
      exports.b2ContactFilter = b2ContactFilter;
      exports.b2ContactImpulse = b2ContactImpulse;
      exports.b2ContactListener = b2ContactListener;
      exports.b2QueryCallback = b2QueryCallback;
      exports.b2RayCastCallback = b2RayCastCallback;
      exports.b2Island = b2Island;
      exports.b2Profile = b2Profile;
      exports.b2TimeStep = b2TimeStep;
      exports.b2Position = b2Position;
      exports.b2Velocity = b2Velocity;
      exports.b2SolverData = b2SolverData;
      exports.b2ContactManager = b2ContactManager;
      exports.b2MixFriction = b2MixFriction;
      exports.b2MixRestitution = b2MixRestitution;
      exports.b2ContactEdge = b2ContactEdge;
      exports.b2Contact = b2Contact;
      exports.b2ContactRegister = b2ContactRegister;
      exports.b2ContactFactory = b2ContactFactory;
      exports.g_blockSolve = g_blockSolve;
      exports.b2VelocityConstraintPoint = b2VelocityConstraintPoint;
      exports.b2ContactVelocityConstraint = b2ContactVelocityConstraint;
      exports.b2ContactPositionConstraint = b2ContactPositionConstraint;
      exports.b2ContactSolverDef = b2ContactSolverDef;
      exports.b2PositionSolverManifold = b2PositionSolverManifold;
      exports.b2ContactSolver = b2ContactSolver;
      exports.b2CircleContact = b2CircleContact;
      exports.b2PolygonContact = b2PolygonContact;
      exports.b2PolygonAndCircleContact = b2PolygonAndCircleContact;
      exports.b2EdgeAndCircleContact = b2EdgeAndCircleContact;
      exports.b2EdgeAndPolygonContact = b2EdgeAndPolygonContact;
      exports.b2ChainAndCircleContact = b2ChainAndCircleContact;
      exports.b2ChainAndPolygonContact = b2ChainAndPolygonContact;
      exports.b2Jacobian = b2Jacobian;
      exports.b2JointEdge = b2JointEdge;
      exports.b2JointDef = b2JointDef;
      exports.b2Joint = b2Joint;
      exports.b2AreaJointDef = b2AreaJointDef;
      exports.b2AreaJoint = b2AreaJoint;
      exports.b2DistanceJointDef = b2DistanceJointDef;
      exports.b2DistanceJoint = b2DistanceJoint;
      exports.b2FrictionJointDef = b2FrictionJointDef;
      exports.b2FrictionJoint = b2FrictionJoint;
      exports.b2GearJointDef = b2GearJointDef;
      exports.b2GearJoint = b2GearJoint;
      exports.b2MotorJointDef = b2MotorJointDef;
      exports.b2MotorJoint = b2MotorJoint;
      exports.b2MouseJointDef = b2MouseJointDef;
      exports.b2MouseJoint = b2MouseJoint;
      exports.b2PrismaticJointDef = b2PrismaticJointDef;
      exports.b2PrismaticJoint = b2PrismaticJoint;
      exports.b2_minPulleyLength = b2_minPulleyLength;
      exports.b2PulleyJointDef = b2PulleyJointDef;
      exports.b2PulleyJoint = b2PulleyJoint;
      exports.b2RevoluteJointDef = b2RevoluteJointDef;
      exports.b2RevoluteJoint = b2RevoluteJoint;
      exports.b2RopeJointDef = b2RopeJointDef;
      exports.b2RopeJoint = b2RopeJoint;
      exports.b2WeldJointDef = b2WeldJointDef;
      exports.b2WeldJoint = b2WeldJoint;
      exports.b2WheelJointDef = b2WheelJointDef;
      exports.b2WheelJoint = b2WheelJoint;
      exports.b2ControllerEdge = b2ControllerEdge;
      exports.b2Controller = b2Controller;
      exports.b2BuoyancyController = b2BuoyancyController;
      exports.b2ConstantAccelController = b2ConstantAccelController;
      exports.b2ConstantForceController = b2ConstantForceController;
      exports.b2GravityController = b2GravityController;
      exports.b2TensorDampingController = b2TensorDampingController;
      exports.b2ParticleDef = b2ParticleDef;
      exports.b2CalculateParticleIterations = b2CalculateParticleIterations;
      exports.b2ParticleHandle = b2ParticleHandle;
      exports.b2ParticleGroupDef = b2ParticleGroupDef;
      exports.b2ParticleGroup = b2ParticleGroup;
      exports.b2GrowableBuffer = b2GrowableBuffer;
      exports.b2FixtureParticleQueryCallback = b2FixtureParticleQueryCallback;
      exports.b2ParticleContact = b2ParticleContact;
      exports.b2ParticleBodyContact = b2ParticleBodyContact;
      exports.b2ParticlePair = b2ParticlePair;
      exports.b2ParticleTriad = b2ParticleTriad;
      exports.b2ParticleSystemDef = b2ParticleSystemDef;
      exports.b2RopeDef = b2RopeDef;
      exports.b2Rope = b2Rope;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
    }));
  }), {} ],
  463: [ (function(require, module, exports) {
    "use strict";
    !(function(e) {
      if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else {
        var f;
        "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), 
        f.CANNON = e();
      }
    })((function() {
      var define, module, exports;
      return (function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = "function" == typeof require && require;
              if (!u && a) return a(o, !0);
              if (i) return i(o, !0);
              throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
              exports: {}
            };
            t[o][0].call(f.exports, (function(e) {
              var n = t[o][1][e];
              return s(n || e);
            }), f, f.exports, e, t, n, r);
          }
          return n[o].exports;
        }
        var i = "function" == typeof require && require;
        for (var o = 0; o < r.length; o++) s(r[o]);
        return s;
      })({
        1: [ (function(_dereq_, module, exports) {
          module.exports = {
            name: "@cocos/cannon",
            version: "1.1.1-exp.3",
            description: "A lightweight 3D physics engine written in JavaScript.",
            homepage: "https://github.com/cocos-creator/cannon.js",
            author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se), JayceLai",
            keywords: [ "cannon.js", "cocos", "creator", "physics", "engine", "3d" ],
            scripts: {
              build: "grunt && npm run preprocess && grunt addLicense && grunt addDate",
              preprocess: "node node_modules/uglify-js/bin/uglifyjs build/cannon.js -o build/cannon.min.js -c -m"
            },
            main: "./build/cannon.min.js",
            engines: {
              node: "*"
            },
            repository: {
              type: "git",
              url: "https://github.com/cocos-creator/cannon.js.git"
            },
            bugs: {
              url: "https://github.com/cocos-creator/cannon.js/issues"
            },
            licenses: [ {
              type: "MIT"
            } ],
            devDependencies: {
              jshint: "latest",
              "uglify-js": "latest",
              nodeunit: "^0.9.0",
              grunt: "~0.4.0",
              "grunt-contrib-jshint": "~0.1.1",
              "grunt-contrib-nodeunit": "^0.4.1",
              "grunt-contrib-concat": "~0.1.3",
              "grunt-contrib-uglify": "^0.5.1",
              "grunt-browserify": "^2.1.4",
              "grunt-contrib-yuidoc": "^0.5.2",
              browserify: "*"
            },
            dependencies: {}
          };
        }), {} ],
        2: [ (function(_dereq_, module, exports) {
          module.exports = {
            version: _dereq_("../package.json").version,
            AABB: _dereq_("./collision/AABB"),
            ArrayCollisionMatrix: _dereq_("./collision/ArrayCollisionMatrix"),
            Body: _dereq_("./objects/Body"),
            Box: _dereq_("./shapes/Box"),
            Broadphase: _dereq_("./collision/Broadphase"),
            Constraint: _dereq_("./constraints/Constraint"),
            ContactEquation: _dereq_("./equations/ContactEquation"),
            Narrowphase: _dereq_("./world/Narrowphase"),
            ConeTwistConstraint: _dereq_("./constraints/ConeTwistConstraint"),
            ContactMaterial: _dereq_("./material/ContactMaterial"),
            ConvexPolyhedron: _dereq_("./shapes/ConvexPolyhedron"),
            Cylinder: _dereq_("./shapes/Cylinder"),
            DistanceConstraint: _dereq_("./constraints/DistanceConstraint"),
            Equation: _dereq_("./equations/Equation"),
            EventTarget: _dereq_("./utils/EventTarget"),
            FrictionEquation: _dereq_("./equations/FrictionEquation"),
            GSSolver: _dereq_("./solver/GSSolver"),
            GridBroadphase: _dereq_("./collision/GridBroadphase"),
            Heightfield: _dereq_("./shapes/Heightfield"),
            HingeConstraint: _dereq_("./constraints/HingeConstraint"),
            LockConstraint: _dereq_("./constraints/LockConstraint"),
            Mat3: _dereq_("./math/Mat3"),
            Material: _dereq_("./material/Material"),
            NaiveBroadphase: _dereq_("./collision/NaiveBroadphase"),
            ObjectCollisionMatrix: _dereq_("./collision/ObjectCollisionMatrix"),
            Pool: _dereq_("./utils/Pool"),
            Particle: _dereq_("./shapes/Particle"),
            Plane: _dereq_("./shapes/Plane"),
            PointToPointConstraint: _dereq_("./constraints/PointToPointConstraint"),
            Quaternion: _dereq_("./math/Quaternion"),
            Ray: _dereq_("./collision/Ray"),
            RaycastVehicle: _dereq_("./objects/RaycastVehicle"),
            RaycastResult: _dereq_("./collision/RaycastResult"),
            RigidVehicle: _dereq_("./objects/RigidVehicle"),
            RotationalEquation: _dereq_("./equations/RotationalEquation"),
            RotationalMotorEquation: _dereq_("./equations/RotationalMotorEquation"),
            SAPBroadphase: _dereq_("./collision/SAPBroadphase"),
            SPHSystem: _dereq_("./objects/SPHSystem"),
            Shape: _dereq_("./shapes/Shape"),
            Solver: _dereq_("./solver/Solver"),
            Sphere: _dereq_("./shapes/Sphere"),
            SplitSolver: _dereq_("./solver/SplitSolver"),
            Spring: _dereq_("./objects/Spring"),
            Transform: _dereq_("./math/Transform"),
            Trimesh: _dereq_("./shapes/Trimesh"),
            Vec3: _dereq_("./math/Vec3"),
            Vec3Pool: _dereq_("./utils/Vec3Pool"),
            World: _dereq_("./world/World"),
            Octree: _dereq_("./utils/Octree"),
            CMath: _dereq_("./math/CMath")
          };
        }), {
          "../package.json": 1,
          "./collision/AABB": 3,
          "./collision/ArrayCollisionMatrix": 4,
          "./collision/Broadphase": 5,
          "./collision/GridBroadphase": 6,
          "./collision/NaiveBroadphase": 7,
          "./collision/ObjectCollisionMatrix": 8,
          "./collision/Ray": 10,
          "./collision/RaycastResult": 11,
          "./collision/SAPBroadphase": 12,
          "./constraints/ConeTwistConstraint": 13,
          "./constraints/Constraint": 14,
          "./constraints/DistanceConstraint": 15,
          "./constraints/HingeConstraint": 16,
          "./constraints/LockConstraint": 17,
          "./constraints/PointToPointConstraint": 18,
          "./equations/ContactEquation": 20,
          "./equations/Equation": 21,
          "./equations/FrictionEquation": 22,
          "./equations/RotationalEquation": 23,
          "./equations/RotationalMotorEquation": 24,
          "./material/ContactMaterial": 25,
          "./material/Material": 26,
          "./math/CMath": 27,
          "./math/Mat3": 29,
          "./math/Quaternion": 30,
          "./math/Transform": 31,
          "./math/Vec3": 32,
          "./objects/Body": 33,
          "./objects/RaycastVehicle": 34,
          "./objects/RigidVehicle": 35,
          "./objects/SPHSystem": 36,
          "./objects/Spring": 37,
          "./shapes/Box": 39,
          "./shapes/ConvexPolyhedron": 40,
          "./shapes/Cylinder": 41,
          "./shapes/Heightfield": 42,
          "./shapes/Particle": 43,
          "./shapes/Plane": 44,
          "./shapes/Shape": 45,
          "./shapes/Sphere": 46,
          "./shapes/Trimesh": 47,
          "./solver/GSSolver": 48,
          "./solver/Solver": 49,
          "./solver/SplitSolver": 50,
          "./utils/EventTarget": 51,
          "./utils/Octree": 52,
          "./utils/Pool": 53,
          "./utils/Vec3Pool": 56,
          "./world/Narrowphase": 57,
          "./world/World": 58
        } ],
        3: [ (function(_dereq_, module, exports) {
          var Vec3 = _dereq_("../math/Vec3");
          var Utils = _dereq_("../utils/Utils");
          module.exports = AABB;
          function AABB(options) {
            options = options || {};
            this.lowerBound = new Vec3();
            options.lowerBound && this.lowerBound.copy(options.lowerBound);
            this.upperBound = new Vec3();
            options.upperBound && this.upperBound.copy(options.upperBound);
          }
          var tmp = new Vec3();
          AABB.prototype.setFromPoints = function(points, position, quaternion, skinSize) {
            var l = this.lowerBound, u = this.upperBound, q = quaternion;
            l.copy(points[0]);
            q && q.vmult(l, l);
            u.copy(l);
            for (var i = 1; i < points.length; i++) {
              var p = points[i];
              if (q) {
                q.vmult(p, tmp);
                p = tmp;
              }
              p.x > u.x && (u.x = p.x);
              p.x < l.x && (l.x = p.x);
              p.y > u.y && (u.y = p.y);
              p.y < l.y && (l.y = p.y);
              p.z > u.z && (u.z = p.z);
              p.z < l.z && (l.z = p.z);
            }
            if (position) {
              position.vadd(l, l);
              position.vadd(u, u);
            }
            if (skinSize) {
              l.x -= skinSize;
              l.y -= skinSize;
              l.z -= skinSize;
              u.x += skinSize;
              u.y += skinSize;
              u.z += skinSize;
            }
            return this;
          };
          AABB.prototype.copy = function(aabb) {
            this.lowerBound.copy(aabb.lowerBound);
            this.upperBound.copy(aabb.upperBound);
            return this;
          };
          AABB.prototype.clone = function() {
            return new AABB().copy(this);
          };
          AABB.prototype.extend = function(aabb) {
            this.lowerBound.x = Math.min(this.lowerBound.x, aabb.lowerBound.x);
            this.upperBound.x = Math.max(this.upperBound.x, aabb.upperBound.x);
            this.lowerBound.y = Math.min(this.lowerBound.y, aabb.lowerBound.y);
            this.upperBound.y = Math.max(this.upperBound.y, aabb.upperBound.y);
            this.lowerBound.z = Math.min(this.lowerBound.z, aabb.lowerBound.z);
            this.upperBound.z = Math.max(this.upperBound.z, aabb.upperBound.z);
          };
          AABB.prototype.overlaps = function(aabb) {
            var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
            var overlapsX = l2.x <= u1.x && u1.x <= u2.x || l1.x <= u2.x && u2.x <= u1.x;
            var overlapsY = l2.y <= u1.y && u1.y <= u2.y || l1.y <= u2.y && u2.y <= u1.y;
            var overlapsZ = l2.z <= u1.z && u1.z <= u2.z || l1.z <= u2.z && u2.z <= u1.z;
            return overlapsX && overlapsY && overlapsZ;
          };
          AABB.prototype.volume = function() {
            var l = this.lowerBound, u = this.upperBound;
            return (u.x - l.x) * (u.y - l.y) * (u.z - l.z);
          };
          AABB.prototype.contains = function(aabb) {
            var l1 = this.lowerBound, u1 = this.upperBound, l2 = aabb.lowerBound, u2 = aabb.upperBound;
            return l1.x <= l2.x && u1.x >= u2.x && l1.y <= l2.y && u1.y >= u2.y && l1.z <= l2.z && u1.z >= u2.z;
          };
          AABB.prototype.getCorners = function(a, b, c, d, e, f, g, h) {
            var l = this.lowerBound, u = this.upperBound;
            a.copy(l);
            b.set(u.x, l.y, l.z);
            c.set(u.x, u.y, l.z);
            d.set(l.x, u.y, u.z);
            e.set(u.x, l.y, u.z);
            f.set(l.x, u.y, l.z);
            g.set(l.x, l.y, u.z);
            h.copy(u);
          };
          var transformIntoFrame_corners = [ new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3() ];
          AABB.prototype.toLocalFrame = function(frame, target) {
            var corners = transformIntoFrame_corners;
            var a = corners[0];
            var b = corners[1];
            var c = corners[2];
            var d = corners[3];
            var e = corners[4];
            var f = corners[5];
            var g = corners[6];
            var h = corners[7];
            this.getCorners(a, b, c, d, e, f, g, h);
            for (var i = 0; 8 !== i; i++) {
              var corner = corners[i];
              frame.pointToLocal(corner, corner);
            }
            return target.setFromPoints(corners);
          };
          AABB.prototype.toWorldFrame = function(frame, target) {
            var corners = transformIntoFrame_corners;
            var a = corners[0];
            var b = corners[1];
            var c = corners[2];
            var d = corners[3];
            var e = corners[4];
            var f = corners[5];
            var g = corners[6];
            var h = corners[7];
            this.getCorners(a, b, c, d, e, f, g, h);
            for (var i = 0; 8 !== i; i++) {
              var corner = corners[i];
              frame.pointToWorld(corner, corner);
            }
            return target.setFromPoints(corners);
          };
          AABB.prototype.overlapsRay = function(ray) {
            var t = 0;
            var dirFracX = 1 / ray._direction.x;
            var dirFracY = 1 / ray._direction.y;
            var dirFracZ = 1 / ray._direction.z;
            var t1 = (this.lowerBound.x - ray.from.x) * dirFracX;
            var t2 = (this.upperBound.x - ray.from.x) * dirFracX;
            var t3 = (this.lowerBound.y - ray.from.y) * dirFracY;
            var t4 = (this.upperBound.y - ray.from.y) * dirFracY;
            var t5 = (this.lowerBound.z - ray.from.z) * dirFracZ;
            var t6 = (this.upperBound.z - ray.from.z) * dirFracZ;
            var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
            var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
            if (tmax < 0) return false;
            if (tmin > tmax) return false;
            return true;
          };
        }), {
          "../math/Vec3": 32,
          "../utils/Utils": 55
        } ],
        4: [ (function(_dereq_, module, exports) {
          module.exports = ArrayCollisionMatrix;
          function ArrayCollisionMatrix() {
            this.matrix = [];
          }
          ArrayCollisionMatrix.prototype.get = function(i, j) {
            i = i.index;
            j = j.index;
            if (j > i) {
              var temp = j;
              j = i;
              i = temp;
            }
            return this.matrix[(i * (i + 1) >> 1) + j - 1];
          };
          ArrayCollisionMatrix.prototype.set = function(i, j, value) {
            i = i.index;
            j = j.index;
            if (j > i) {
              var temp = j;
              j = i;
              i = temp;
            }
            this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
          };
          ArrayCollisionMatrix.prototype.reset = function() {
            for (var i = 0, l = this.matrix.length; i !== l; i++) this.matrix[i] = 0;
          };
          ArrayCollisionMatrix.prototype.setNumObjects = function(n) {
            this.matrix.length = n * (n - 1) >> 1;
          };
        }), {} ],
        5: [ (function(_dereq_, module, exports) {
          var Body = _dereq_("../objects/Body");
          var Vec3 = _dereq_("../math/Vec3");
          var Quaternion = _dereq_("../math/Quaternion");
          var Shape = _dereq_("../shapes/Shape");
          var Plane = _dereq_("../shapes/Plane");
          module.exports = Broadphase;
          function Broadphase() {
            this.world = null;
            this.useBoundingBoxes = false;
            this.dirty = true;
          }
          Broadphase.prototype.collisionPairs = function(world, p1, p2) {
            throw new Error("collisionPairs not implemented for this BroadPhase class!");
          };
          Broadphase.prototype.needBroadphaseCollision = function(bodyA, bodyB) {
            if (0 === (bodyA.collisionFilterGroup & bodyB.collisionFilterMask) || 0 === (bodyB.collisionFilterGroup & bodyA.collisionFilterMask)) return false;
            if (bodyA.hasTrigger || bodyB.hasTrigger) return true;
            if ((0 !== (bodyA.type & Body.STATIC) || bodyA.sleepState === Body.SLEEPING) && (0 !== (bodyB.type & Body.STATIC) || bodyB.sleepState === Body.SLEEPING)) return false;
            return true;
          };
          Broadphase.prototype.intersectionTest = function(bodyA, bodyB, pairs1, pairs2) {
            this.useBoundingBoxes ? this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2) : this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);
          };
          var Broadphase_collisionPairs_r = new Vec3(), Broadphase_collisionPairs_normal = new Vec3(), Broadphase_collisionPairs_quat = new Quaternion(), Broadphase_collisionPairs_relpos = new Vec3();
          Broadphase.prototype.doBoundingSphereBroadphase = function(bodyA, bodyB, pairs1, pairs2) {
            var r = Broadphase_collisionPairs_r;
            bodyB.position.vsub(bodyA.position, r);
            var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);
            var norm2 = r.norm2();
            if (norm2 < boundingRadiusSum2) {
              pairs1.push(bodyA);
              pairs2.push(bodyB);
            }
          };
          Broadphase.prototype.doBoundingBoxBroadphase = function(bodyA, bodyB, pairs1, pairs2) {
            bodyA.aabbNeedsUpdate && bodyA.computeAABB();
            bodyB.aabbNeedsUpdate && bodyB.computeAABB();
            if (bodyA.aabb.overlaps(bodyB.aabb)) {
              pairs1.push(bodyA);
              pairs2.push(bodyB);
            }
          };
          var Broadphase_makePairsUnique_temp = {
            keys: []
          }, Broadphase_makePairsUnique_p1 = [], Broadphase_makePairsUnique_p2 = [];
          Broadphase.prototype.makePairsUnique = function(pairs1, pairs2) {
            var t = Broadphase_makePairsUnique_temp, p1 = Broadphase_makePairsUnique_p1, p2 = Broadphase_makePairsUnique_p2, N = pairs1.length;
            for (var i = 0; i !== N; i++) {
              p1[i] = pairs1[i];
              p2[i] = pairs2[i];
            }
            pairs1.length = 0;
            pairs2.length = 0;
            for (var i = 0; i !== N; i++) {
              var id1 = p1[i].id, id2 = p2[i].id;
              var key = id1 < id2 ? id1 + "," + id2 : id2 + "," + id1;
              t[key] = i;
              t.keys.push(key);
            }
            for (var i = 0; i !== t.keys.length; i++) {
              var key = t.keys.pop(), pairIndex = t[key];
              pairs1.push(p1[pairIndex]);
              pairs2.push(p2[pairIndex]);
              delete t[key];
            }
          };
          Broadphase.prototype.setWorld = function(world) {};
          var bsc_dist = new Vec3();
          Broadphase.boundingSphereCheck = function(bodyA, bodyB) {
            var dist = bsc_dist;
            bodyA.position.vsub(bodyB.position, dist);
            return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius, 2) > dist.norm2();
          };
          Broadphase.prototype.aabbQuery = function(world, aabb, result) {
            console.warn(".aabbQuery is not implemented in this Broadphase subclass.");
            return [];
          };
        }), {
          "../math/Quaternion": 30,
          "../math/Vec3": 32,
          "../objects/Body": 33,
          "../shapes/Plane": 44,
          "../shapes/Shape": 45
        } ],
        6: [ (function(_dereq_, module, exports) {
          module.exports = GridBroadphase;
          var Broadphase = _dereq_("./Broadphase");
          var Vec3 = _dereq_("../math/Vec3");
          var Shape = _dereq_("../shapes/Shape");
          function GridBroadphase(aabbMin, aabbMax, nx, ny, nz) {
            Broadphase.apply(this);
            this.nx = nx || 10;
            this.ny = ny || 10;
            this.nz = nz || 10;
            this.aabbMin = aabbMin || new Vec3(100, 100, 100);
            this.aabbMax = aabbMax || new Vec3(-100, -100, -100);
            var nbins = this.nx * this.ny * this.nz;
            if (nbins <= 0) throw "GridBroadphase: Each dimension's n must be >0";
            this.bins = [];
            this.binLengths = [];
            this.bins.length = nbins;
            this.binLengths.length = nbins;
            for (var i = 0; i < nbins; i++) {
              this.bins[i] = [];
              this.binLengths[i] = 0;
            }
          }
          GridBroadphase.prototype = new Broadphase();
          GridBroadphase.prototype.constructor = GridBroadphase;
          var GridBroadphase_collisionPairs_d = new Vec3();
          var GridBroadphase_collisionPairs_binPos = new Vec3();
          GridBroadphase.prototype.collisionPairs = function(world, pairs1, pairs2) {
            var N = world.numObjects(), bodies = world.bodies;
            var max = this.aabbMax, min = this.aabbMin, nx = this.nx, ny = this.ny, nz = this.nz;
            var xstep = ny * nz;
            var ystep = nz;
            var zstep = 1;
            var xmax = max.x, ymax = max.y, zmax = max.z, xmin = min.x, ymin = min.y, zmin = min.z;
            var xmult = nx / (xmax - xmin), ymult = ny / (ymax - ymin), zmult = nz / (zmax - zmin);
            var binsizeX = (xmax - xmin) / nx, binsizeY = (ymax - ymin) / ny, binsizeZ = (zmax - zmin) / nz;
            var binRadius = .5 * Math.sqrt(binsizeX * binsizeX + binsizeY * binsizeY + binsizeZ * binsizeZ);
            var types = Shape.types;
            var SPHERE = types.SPHERE, PLANE = types.PLANE, BOX = types.BOX, COMPOUND = types.COMPOUND, CONVEXPOLYHEDRON = types.CONVEXPOLYHEDRON;
            var bins = this.bins, binLengths = this.binLengths, Nbins = this.bins.length;
            for (var i = 0; i !== Nbins; i++) binLengths[i] = 0;
            var ceil = Math.ceil;
            var min = Math.min;
            var max = Math.max;
            function addBoxToBins(x0, y0, z0, x1, y1, z1, bi) {
              var xoff0 = (x0 - xmin) * xmult | 0, yoff0 = (y0 - ymin) * ymult | 0, zoff0 = (z0 - zmin) * zmult | 0, xoff1 = ceil((x1 - xmin) * xmult), yoff1 = ceil((y1 - ymin) * ymult), zoff1 = ceil((z1 - zmin) * zmult);
              xoff0 < 0 ? xoff0 = 0 : xoff0 >= nx && (xoff0 = nx - 1);
              yoff0 < 0 ? yoff0 = 0 : yoff0 >= ny && (yoff0 = ny - 1);
              zoff0 < 0 ? zoff0 = 0 : zoff0 >= nz && (zoff0 = nz - 1);
              xoff1 < 0 ? xoff1 = 0 : xoff1 >= nx && (xoff1 = nx - 1);
              yoff1 < 0 ? yoff1 = 0 : yoff1 >= ny && (yoff1 = ny - 1);
              zoff1 < 0 ? zoff1 = 0 : zoff1 >= nz && (zoff1 = nz - 1);
              xoff0 *= xstep;
              yoff0 *= ystep;
              zoff0 *= zstep;
              xoff1 *= xstep;
              yoff1 *= ystep;
              zoff1 *= zstep;
              for (var xoff = xoff0; xoff <= xoff1; xoff += xstep) for (var yoff = yoff0; yoff <= yoff1; yoff += ystep) for (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {
                var idx = xoff + yoff + zoff;
                bins[idx][binLengths[idx]++] = bi;
              }
            }
            for (var i = 0; i !== N; i++) {
              var bi = bodies[i];
              var si = bi.shape;
              switch (si.type) {
               case SPHERE:
                var x = bi.position.x, y = bi.position.y, z = bi.position.z;
                var r = si.radius;
                addBoxToBins(x - r, y - r, z - r, x + r, y + r, z + r, bi);
                break;

               case PLANE:
                si.worldNormalNeedsUpdate && si.computeWorldNormal(bi.quaternion);
                var planeNormal = si.worldNormal;
                var xreset = xmin + .5 * binsizeX - bi.position.x, yreset = ymin + .5 * binsizeY - bi.position.y, zreset = zmin + .5 * binsizeZ - bi.position.z;
                var d = GridBroadphase_collisionPairs_d;
                d.set(xreset, yreset, zreset);
                for (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) for (var yi = 0, yoff = 0; yi !== ny; yi++, 
                yoff += ystep, d.z = zreset, d.y += binsizeY) for (var zi = 0, zoff = 0; zi !== nz; zi++, 
                zoff += zstep, d.z += binsizeZ) if (d.dot(planeNormal) < binRadius) {
                  var idx = xoff + yoff + zoff;
                  bins[idx][binLengths[idx]++] = bi;
                }
                break;

               default:
                bi.aabbNeedsUpdate && bi.computeAABB();
                addBoxToBins(bi.aabb.lowerBound.x, bi.aabb.lowerBound.y, bi.aabb.lowerBound.z, bi.aabb.upperBound.x, bi.aabb.upperBound.y, bi.aabb.upperBound.z, bi);
              }
            }
            for (var i = 0; i !== Nbins; i++) {
              var binLength = binLengths[i];
              if (binLength > 1) {
                var bin = bins[i];
                for (var xi = 0; xi !== binLength; xi++) {
                  var bi = bin[xi];
                  for (var yi = 0; yi !== xi; yi++) {
                    var bj = bin[yi];
                    this.needBroadphaseCollision(bi, bj) && this.intersectionTest(bi, bj, pairs1, pairs2);
                  }
                }
              }
            }
            this.makePairsUnique(pairs1, pairs2);
          };
        }), {
          "../math/Vec3": 32,
          "../shapes/Shape": 45,
          "./Broadphase": 5
        } ],
        7: [ (function(_dereq_, module, exports) {
          module.exports = NaiveBroadphase;
          var Broadphase = _dereq_("./Broadphase");
          var AABB = _dereq_("./AABB");
          function NaiveBroadphase() {
            Broadphase.apply(this);
          }
          NaiveBroadphase.prototype = new Broadphase();
          NaiveBroadphase.prototype.constructor = NaiveBroadphase;
          NaiveBroadphase.prototype.collisionPairs = function(world, pairs1, pairs2) {
            var bodies = world.bodies, n = bodies.length, i, j, bi, bj;
            for (i = 0; i !== n; i++) for (j = 0; j !== i; j++) {
              bi = bodies[i];
              bj = bodies[j];
              if (!this.needBroadphaseCollision(bi, bj)) continue;
              this.intersectionTest(bi, bj, pairs1, pairs2);
            }
          };
          var tmpAABB = new AABB();
          NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result) {
            result = result || [];
            for (var i = 0; i < world.bodies.length; i++) {
              var b = world.bodies[i];
              b.aabbNeedsUpdate && b.computeAABB();
              b.aabb.overlaps(aabb) && result.push(b);
            }
            return result;
          };
        }), {
          "./AABB": 3,
          "./Broadphase": 5
        } ],
        8: [ (function(_dereq_, module, exports) {
          module.exports = ObjectCollisionMatrix;
          function ObjectCollisionMatrix() {
            this.matrix = {};
          }
          ObjectCollisionMatrix.prototype.get = function(i, j) {
            i = i.id;
            j = j.id;
            if (j > i) {
              var temp = j;
              j = i;
              i = temp;
            }
            return i + "-" + j in this.matrix;
          };
          ObjectCollisionMatrix.prototype.set = function(i, j, value) {
            i = i.id;
            j = j.id;
            if (j > i) {
              var temp = j;
              j = i;
              i = temp;
            }
            value ? this.matrix[i + "-" + j] = true : delete this.matrix[i + "-" + j];
          };
          ObjectCollisionMatrix.prototype.reset = function() {
            this.matrix = {};
          };
          ObjectCollisionMatrix.prototype.setNumObjects = function(n) {};
        }), {} ],
        9: [ (function(_dereq_, module, exports) {
          module.exports = OverlapKeeper;
          function OverlapKeeper() {
            this.current = [];
            this.previous = [];
          }
          OverlapKeeper.prototype.getKey = function(i, j) {
            if (j < i) {
              var temp = j;
              j = i;
              i = temp;
            }
            return i << 16 | j;
          };
          OverlapKeeper.prototype.set = function(i, j) {
            var key = this.getKey(i, j);
            var current = this.current;
            var index = 0;
            while (key > current[index]) index++;
            if (key === current[index]) return;
            for (var j = current.length - 1; j >= index; j--) current[j + 1] = current[j];
            current[index] = key;
          };
          OverlapKeeper.prototype.tick = function() {
            var tmp = this.current;
            this.current = this.previous;
            this.previous = tmp;
            this.current.length = 0;
          };
          function unpackAndPush(array, key) {
            array.push((4294901760 & key) >> 16, 65535 & key);
          }
          OverlapKeeper.prototype.getDiff = function(additions, removals) {
            var a = this.current;
            var b = this.previous;
            var al = a.length;
            var bl = b.length;
            var j = 0;
            for (var i = 0; i < al; i++) {
              var found = false;
              var keyA = a[i];
              while (keyA > b[j]) j++;
              found = keyA === b[j];
              found || unpackAndPush(additions, keyA);
            }
            j = 0;
            for (var i = 0; i < bl; i++) {
              var found = false;
              var keyB = b[i];
              while (keyB > a[j]) j++;
              found = a[j] === keyB;
              found || unpackAndPush(removals, keyB);
            }
          };
        }), {} ],
        10: [ (function(_dereq_, module, exports) {
          module.exports = Ray;
          var Vec3 = _dereq_("../math/Vec3");
          var Quaternion = _dereq_("../math/Quaternion");
          var Transform = _dereq_("../math/Transform");
          var ConvexPolyhedron = _dereq_("../shapes/ConvexPolyhedron");
          var Box = _dereq_("../shapes/Box");
          var RaycastResult = _dereq_("../collision/RaycastResult");
          var Shape = _dereq_("../shapes/Shape");
          var AABB = _dereq_("../collision/AABB");
          function Ray(from, to) {
            this.from = from ? from.clone() : new Vec3();
            this.to = to ? to.clone() : new Vec3();
            this._direction = new Vec3();
            this.precision = 1e-4;
            this.checkCollisionResponse = true;
            this.skipBackfaces = false;
            this.collisionFilterMask = -1;
            this.collisionFilterGroup = -1;
            this.mode = Ray.ANY;
            this.result = new RaycastResult();
            this.hasHit = false;
            this.callback = function(result) {};
          }
          Ray.prototype.constructor = Ray;
          Ray.CLOSEST = 1;
          Ray.ANY = 2;
          Ray.ALL = 4;
          var tmpAABB = new AABB();
          var tmpArray = [];
          Ray.prototype.intersectWorld = function(world, options) {
            this.mode = options.mode || Ray.ANY;
            this.result = options.result || new RaycastResult();
            this.skipBackfaces = !!options.skipBackfaces;
            this.checkCollisionResponse = !!options.checkCollisionResponse;
            this.collisionFilterMask = "undefined" !== typeof options.collisionFilterMask ? options.collisionFilterMask : -1;
            this.collisionFilterGroup = "undefined" !== typeof options.collisionFilterGroup ? options.collisionFilterGroup : -1;
            options.from && this.from.copy(options.from);
            options.to && this.to.copy(options.to);
            this.callback = options.callback || function() {};
            this.hasHit = false;
            this.result.reset();
            this._updateDirection();
            this.getAABB(tmpAABB);
            tmpArray.length = 0;
            world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
            this.intersectBodies(tmpArray);
            return this.hasHit;
          };
          var v1 = new Vec3(), v2 = new Vec3();
          Ray.pointInTriangle = pointInTriangle;
          function pointInTriangle(p, a, b, c) {
            c.vsub(a, v0);
            b.vsub(a, v1);
            p.vsub(a, v2);
            var dot00 = v0.dot(v0);
            var dot01 = v0.dot(v1);
            var dot02 = v0.dot(v2);
            var dot11 = v1.dot(v1);
            var dot12 = v1.dot(v2);
            var u, v;
            return (u = dot11 * dot02 - dot01 * dot12) >= 0 && (v = dot00 * dot12 - dot01 * dot02) >= 0 && u + v < dot00 * dot11 - dot01 * dot01;
          }
          var intersectBody_xi = new Vec3();
          var intersectBody_qi = new Quaternion();
          Ray.prototype.intersectBody = function(body, result) {
            if (result) {
              this.result = result;
              this._updateDirection();
            }
            var checkCollisionResponse = this.checkCollisionResponse;
            if (checkCollisionResponse && !body.collisionResponse) return;
            if (0 === (this.collisionFilterGroup & body.collisionFilterMask) || 0 === (body.collisionFilterGroup & this.collisionFilterMask)) return;
            var xi = intersectBody_xi;
            var qi = intersectBody_qi;
            for (var i = 0, N = body.shapes.length; i < N; i++) {
              var shape = body.shapes[i];
              if (checkCollisionResponse && !shape.collisionResponse) continue;
              body.quaternion.mult(body.shapeOrientations[i], qi);
              body.quaternion.vmult(body.shapeOffsets[i], xi);
              xi.vadd(body.position, xi);
              this.intersectShape(shape, qi, xi, body);
              if (this.result._shouldStop) break;
            }
          };
          Ray.prototype.intersectBodies = function(bodies, result) {
            if (result) {
              this.result = result;
              this._updateDirection();
            }
            for (var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i++) this.intersectBody(bodies[i]);
          };
          Ray.prototype._updateDirection = function() {
            this.to.vsub(this.from, this._direction);
            this._direction.normalize();
          };
          Ray.prototype.intersectShape = function(shape, quat, position, body) {
            var from = this.from;
            var distance = distanceFromIntersection(from, this._direction, position);
            if (distance > shape.boundingSphereRadius) return;
            var intersectMethod = this[shape.type];
            intersectMethod && intersectMethod.call(this, shape, quat, position, body, shape);
          };
          var vector = new Vec3();
          var normal = new Vec3();
          var intersectPoint = new Vec3();
          var a = new Vec3();
          var b = new Vec3();
          var c = new Vec3();
          var d = new Vec3();
          var tmpRaycastResult = new RaycastResult();
          Ray.prototype.intersectBox = function(shape, quat, position, body, reportedShape) {
            return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body, reportedShape);
          };
          Ray.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;
          Ray.prototype.intersectPlane = function(shape, quat, position, body, reportedShape) {
            var from = this.from;
            var to = this.to;
            var direction = this._direction;
            var worldNormal = new Vec3(0, 0, 1);
            quat.vmult(worldNormal, worldNormal);
            var len = new Vec3();
            from.vsub(position, len);
            var planeToFrom = len.dot(worldNormal);
            to.vsub(position, len);
            var planeToTo = len.dot(worldNormal);
            if (planeToFrom * planeToTo > 0) return;
            if (from.distanceTo(to) < planeToFrom) return;
            var n_dot_dir = worldNormal.dot(direction);
            if (Math.abs(n_dot_dir) < this.precision) return;
            var planePointToFrom = new Vec3();
            var dir_scaled_with_t = new Vec3();
            var hitPointWorld = new Vec3();
            from.vsub(position, planePointToFrom);
            var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
            direction.scale(t, dir_scaled_with_t);
            from.vadd(dir_scaled_with_t, hitPointWorld);
            this.reportIntersection(worldNormal, hitPointWorld, reportedShape, body, -1);
          };
          Ray.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;
          Ray.prototype.getAABB = function(result) {
            var to = this.to;
            var from = this.from;
            result.lowerBound.x = Math.min(to.x, from.x);
            result.lowerBound.y = Math.min(to.y, from.y);
            result.lowerBound.z = Math.min(to.z, from.z);
            result.upperBound.x = Math.max(to.x, from.x);
            result.upperBound.y = Math.max(to.y, from.y);
            result.upperBound.z = Math.max(to.z, from.z);
          };
          var intersectConvexOptions = {
            faceList: [ 0 ]
          };
          var worldPillarOffset = new Vec3();
          var intersectHeightfield_localRay = new Ray();
          var intersectHeightfield_index = [];
          var intersectHeightfield_minMax = [];
          Ray.prototype.intersectHeightfield = function(shape, quat, position, body, reportedShape) {
            var data = shape.data, w = shape.elementSize;
            var localRay = intersectHeightfield_localRay;
            localRay.from.copy(this.from);
            localRay.to.copy(this.to);
            Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
            Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);
            localRay._updateDirection();
            var index = intersectHeightfield_index;
            var iMinX, iMinY, iMaxX, iMaxY;
            iMinX = iMinY = 0;
            iMaxX = iMaxY = shape.data.length - 1;
            var aabb = new AABB();
            localRay.getAABB(aabb);
            shape.getIndexOfPosition(aabb.lowerBound.x, aabb.lowerBound.y, index, true);
            iMinX = Math.max(iMinX, index[0]);
            iMinY = Math.max(iMinY, index[1]);
            shape.getIndexOfPosition(aabb.upperBound.x, aabb.upperBound.y, index, true);
            iMaxX = Math.min(iMaxX, index[0] + 1);
            iMaxY = Math.min(iMaxY, index[1] + 1);
            for (var i = iMinX; i < iMaxX; i++) for (var j = iMinY; j < iMaxY; j++) {
              if (this.result._shouldStop) return;
              shape.getAabbAtIndex(i, j, aabb);
              if (!aabb.overlapsRay(localRay)) continue;
              shape.getConvexTrianglePillar(i, j, false);
              Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
              this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
              if (this.result._shouldStop) return;
              shape.getConvexTrianglePillar(i, j, true);
              Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
              this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, reportedShape, intersectConvexOptions);
            }
          };
          Ray.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;
          var Ray_intersectSphere_intersectionPoint = new Vec3();
          var Ray_intersectSphere_normal = new Vec3();
          Ray.prototype.intersectSphere = function(shape, quat, position, body, reportedShape) {
            var from = this.from, to = this.to, r = shape.radius;
            var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);
            var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
            var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);
            var delta = Math.pow(b, 2) - 4 * a * c;
            var intersectionPoint = Ray_intersectSphere_intersectionPoint;
            var normal = Ray_intersectSphere_normal;
            if (delta < 0) return;
            if (0 === delta) {
              from.lerp(to, delta, intersectionPoint);
              intersectionPoint.vsub(position, normal);
              normal.normalize();
              this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
            } else {
              var d1 = (-b - Math.sqrt(delta)) / (2 * a);
              var d2 = (-b + Math.sqrt(delta)) / (2 * a);
              if (d1 >= 0 && d1 <= 1) {
                from.lerp(to, d1, intersectionPoint);
                intersectionPoint.vsub(position, normal);
                normal.normalize();
                this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
              }
              if (this.result._shouldStop) return;
              if (d2 >= 0 && d2 <= 1) {
                from.lerp(to, d2, intersectionPoint);
                intersectionPoint.vsub(position, normal);
                normal.normalize();
                this.reportIntersection(normal, intersectionPoint, reportedShape, body, -1);
              }
            }
          };
          Ray.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;
          var intersectConvex_normal = new Vec3();
          var intersectConvex_minDistNormal = new Vec3();
          var intersectConvex_minDistIntersect = new Vec3();
          var intersectConvex_vector = new Vec3();
          Ray.prototype.intersectConvex = function intersectConvex(shape, quat, position, body, reportedShape, options) {
            var minDistNormal = intersectConvex_minDistNormal;
            var normal = intersectConvex_normal;
            var vector = intersectConvex_vector;
            var minDistIntersect = intersectConvex_minDistIntersect;
            var faceList = options && options.faceList || null;
            var faces = shape.faces, vertices = shape.vertices, normals = shape.faceNormals;
            var direction = this._direction;
            var from = this.from;
            var to = this.to;
            var fromToDistance = from.distanceTo(to);
            var minDist = -1;
            var Nfaces = faceList ? faceList.length : faces.length;
            var result = this.result;
            for (var j = 0; !result._shouldStop && j < Nfaces; j++) {
              var fi = faceList ? faceList[j] : j;
              var face = faces[fi];
              var faceNormal = normals[fi];
              var q = quat;
              var x = position;
              vector.copy(vertices[face[0]]);
              q.vmult(vector, vector);
              vector.vadd(x, vector);
              vector.vsub(from, vector);
              q.vmult(faceNormal, normal);
              var dot = direction.dot(normal);
              if (Math.abs(dot) < this.precision) continue;
              var scalar = normal.dot(vector) / dot;
              if (scalar < 0) continue;
              direction.mult(scalar, intersectPoint);
              intersectPoint.vadd(from, intersectPoint);
              a.copy(vertices[face[0]]);
              q.vmult(a, a);
              x.vadd(a, a);
              for (var i = 1; !result._shouldStop && i < face.length - 1; i++) {
                b.copy(vertices[face[i]]);
                c.copy(vertices[face[i + 1]]);
                q.vmult(b, b);
                q.vmult(c, c);
                x.vadd(b, b);
                x.vadd(c, c);
                var distance = intersectPoint.distanceTo(from);
                if (!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance) continue;
                this.reportIntersection(normal, intersectPoint, reportedShape, body, fi);
              }
            }
          };
          Ray.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;
          var intersectTrimesh_normal = new Vec3();
          var intersectTrimesh_localDirection = new Vec3();
          var intersectTrimesh_localFrom = new Vec3();
          var intersectTrimesh_localTo = new Vec3();
          var intersectTrimesh_worldNormal = new Vec3();
          var intersectTrimesh_worldIntersectPoint = new Vec3();
          var intersectTrimesh_localAABB = new AABB();
          var intersectTrimesh_triangles = [];
          var intersectTrimesh_treeTransform = new Transform();
          Ray.prototype.intersectTrimesh = function intersectTrimesh(mesh, quat, position, body, reportedShape, options) {
            var normal = intersectTrimesh_normal;
            var triangles = intersectTrimesh_triangles;
            var treeTransform = intersectTrimesh_treeTransform;
            var minDistNormal = intersectConvex_minDistNormal;
            var vector = intersectConvex_vector;
            var minDistIntersect = intersectConvex_minDistIntersect;
            var localAABB = intersectTrimesh_localAABB;
            var localDirection = intersectTrimesh_localDirection;
            var localFrom = intersectTrimesh_localFrom;
            var localTo = intersectTrimesh_localTo;
            var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
            var worldNormal = intersectTrimesh_worldNormal;
            var faceList = options && options.faceList || null;
            var indices = mesh.indices, vertices = mesh.vertices, normals = mesh.faceNormals;
            var from = this.from;
            var to = this.to;
            var direction = this._direction;
            var minDist = -1;
            treeTransform.position.copy(position);
            treeTransform.quaternion.copy(quat);
            Transform.vectorToLocalFrame(position, quat, direction, localDirection);
            Transform.pointToLocalFrame(position, quat, from, localFrom);
            Transform.pointToLocalFrame(position, quat, to, localTo);
            localTo.x *= mesh.scale.x;
            localTo.y *= mesh.scale.y;
            localTo.z *= mesh.scale.z;
            localFrom.x *= mesh.scale.x;
            localFrom.y *= mesh.scale.y;
            localFrom.z *= mesh.scale.z;
            localTo.vsub(localFrom, localDirection);
            localDirection.normalize();
            var fromToDistanceSquared = localFrom.distanceSquared(localTo);
            mesh.tree.rayQuery(this, treeTransform, triangles);
            for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {
              var trianglesIndex = triangles[i];
              mesh.getNormal(trianglesIndex, normal);
              mesh.getVertex(indices[3 * trianglesIndex], a);
              a.vsub(localFrom, vector);
              var dot = localDirection.dot(normal);
              var scalar = normal.dot(vector) / dot;
              if (scalar < 0) continue;
              localDirection.scale(scalar, intersectPoint);
              intersectPoint.vadd(localFrom, intersectPoint);
              mesh.getVertex(indices[3 * trianglesIndex + 1], b);
              mesh.getVertex(indices[3 * trianglesIndex + 2], c);
              var squaredDistance = intersectPoint.distanceSquared(localFrom);
              if (!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared) continue;
              Transform.vectorToWorldFrame(quat, normal, worldNormal);
              Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
              this.reportIntersection(worldNormal, worldIntersectPoint, reportedShape, body, trianglesIndex);
            }
            triangles.length = 0;
          };
          Ray.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh;
          Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex) {
            var from = this.from;
            var to = this.to;
            var distance = from.distanceTo(hitPointWorld);
            var result = this.result;
            if (this.skipBackfaces && normal.dot(this._direction) > 0) return;
            result.hitFaceIndex = "undefined" !== typeof hitFaceIndex ? hitFaceIndex : -1;
            switch (this.mode) {
             case Ray.ALL:
              this.hasHit = true;
              result.set(from, to, normal, hitPointWorld, shape, body, distance);
              result.hasHit = true;
              this.callback(result);
              break;

             case Ray.CLOSEST:
              if (distance < result.distance || !result.hasHit) {
                this.hasHit = true;
                result.hasHit = true;
                result.set(from, to, normal, hitPointWorld, shape, body, distance);
              }
              break;

             case Ray.ANY:
              this.hasHit = true;
              result.hasHit = true;
              result.set(from, to, normal, hitPointWorld, shape, body, distance);
              result._shouldStop = true;
            }
          };
          var v0 = new Vec3(), intersect = new Vec3();
          function distanceFromIntersection(from, direction, position) {
            position.vsub(from, v0);
            var dot = v0.dot(direction);
            direction.mult(dot, intersect);
            intersect.vadd(from, intersect);
            var distance = position.distanceTo(intersect);
            return distance;
          }
        }), {
          "../collision/AABB": 3,
          "../collision/RaycastResult": 11,
          "../math/Quaternion": 30,
          "../math/Transform": 31,
          "../math/Vec3": 32,
          "../shapes/Box": 39,
          "../shapes/ConvexPolyhedron": 40,
          "../shapes/Shape": 45
        } ],
        11: [ (function(_dereq_, module, exports) {
          var Vec3 = _dereq_("../math/Vec3");
          module.exports = RaycastResult;
          function RaycastResult() {
            this.rayFromWorld = new Vec3();
            this.rayToWorld = new Vec3();
            this.hitNormalWorld = new Vec3();
            this.hitPointWorld = new Vec3();
            this.hasHit = false;
            this.shape = null;
            this.body = null;
            this.hitFaceIndex = -1;
            this.distance = -1;
            this._shouldStop = false;
          }
          RaycastResult.prototype.reset = function() {
            this.rayFromWorld.setZero();
            this.rayToWorld.setZero();
            this.hitNormalWorld.setZero();
            this.hitPointWorld.setZero();
            this.hasHit = false;
            this.shape = null;
            this.body = null;
            this.hitFaceIndex = -1;
            this.distance = -1;
            this._shouldStop = false;
          };
          RaycastResult.prototype.abort = function() {
            this._shouldStop = true;
          };
          RaycastResult.prototype.set = function(rayFromWorld, rayToWorld, hitNormalWorld, hitPointWorld, shape, body, distance) {
            this.rayFromWorld.copy(rayFromWorld);
            this.rayToWorld.copy(rayToWorld);
            this.hitNormalWorld.copy(hitNormalWorld);
            this.hitPointWorld.copy(hitPointWorld);
            this.shape = shape;
            this.body = body;
            this.distance = distance;
          };
        }), {
          "../math/Vec3": 32
        } ],
        12: [ (function(_dereq_, module, exports) {
          var Shape = _dereq_("../shapes/Shape");
          var Broadphase = _dereq_("../collision/Broadphase");
          module.exports = SAPBroadphase;
          function SAPBroadphase(world) {
            Broadphase.apply(this);
            this.axisList = [];
            this.world = null;
            this.axisIndex = 0;
            var axisList = this.axisList;
            this._addBodyHandler = function(e) {
              axisList.push(e.body);
            };
            this._removeBodyHandler = function(e) {
              var idx = axisList.indexOf(e.body);
              -1 !== idx && axisList.splice(idx, 1);
            };
            world && this.setWorld(world);
          }
          SAPBroadphase.prototype = new Broadphase();
          SAPBroadphase.prototype.setWorld = function(world) {
            this.axisList.length = 0;
            for (var i = 0; i < world.bodies.length; i++) this.axisList.push(world.bodies[i]);
            world.removeEventListener("addBody", this._addBodyHandler);
            world.removeEventListener("removeBody", this._removeBodyHandler);
            world.addEventListener("addBody", this._addBodyHandler);
            world.addEventListener("removeBody", this._removeBodyHandler);
            this.world = world;
            this.dirty = true;
          };
          SAPBroadphase.insertionSortX = function(a) {
            for (var i = 1, l = a.length; i < l; i++) {
              var v = a[i];
              for (var j = i - 1; j >= 0; j--) {
                if (a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x) break;
                a[j + 1] = a[j];
              }
              a[j + 1] = v;
            }
            return a;
          };
          SAPBroadphase.insertionSortY = function(a) {
            for (var i = 1, l = a.length; i < l; i++) {
              var v = a[i];
              for (var j = i - 1; j >= 0; j--) {
                if (a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y) break;
                a[j + 1] = a[j];
              }
              a[j + 1] = v;
            }
            return a;
          };
          SAPBroadphase.insertionSortZ = function(a) {
            for (var i = 1, l = a.length; i < l; i++) {
              var v = a[i];
              for (var j = i - 1; j >= 0; j--) {
                if (a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z) break;
                a[j + 1] = a[j];
              }
              a[j + 1] = v;
            }
            return a;
          };
          SAPBroadphase.prototype.collisionPairs = function(world, p1, p2) {
            var bodies = this.axisList, N = bodies.length, axisIndex = this.axisIndex, i, j;
            if (this.dirty) {
              this.sortList();
              this.dirty = false;
            }
            for (i = 0; i !== N; i++) {
              var bi = bodies[i];
              for (j = i + 1; j < N; j++) {
                var bj = bodies[j];
                if (!this.needBroadphaseCollision(bi, bj)) continue;
                if (!SAPBroadphase.checkBounds(bi, bj, axisIndex)) break;
                this.intersectionTest(bi, bj, p1, p2);
              }
            }
          };
          SAPBroadphase.prototype.sortList = function() {
            var axisList = this.axisList;
            var axisIndex = this.axisIndex;
            var N = axisList.length;
            for (var i = 0; i !== N; i++) {
              var bi = axisList[i];
              bi.aabbNeedsUpdate && bi.computeAABB();
            }
            0 === axisIndex ? SAPBroadphase.insertionSortX(axisList) : 1 === axisIndex ? SAPBroadphase.insertionSortY(axisList) : 2 === axisIndex && SAPBroadphase.insertionSortZ(axisList);
          };
          SAPBroadphase.checkBounds = function(bi, bj, axisIndex) {
            var biPos;
            var bjPos;
            if (0 === axisIndex) {
              biPos = bi.position.x;
              bjPos = bj.position.x;
            } else if (1 === axisIndex) {
              biPos = bi.position.y;
              bjPos = bj.position.y;
            } else if (2 === axisIndex) {
              biPos = bi.position.z;
              bjPos = bj.position.z;
            }
            var ri = bi.boundingRadius, rj = bj.boundingRadius, boundA1 = biPos - ri, boundA2 = biPos + ri, boundB1 = bjPos - rj, boundB2 = bjPos + rj;
            return boundB1 < boundA2;
          };
          SAPBroadphase.prototype.autoDetectAxis = function() {
            var sumX = 0, sumX2 = 0, sumY = 0, sumY2 = 0, sumZ = 0, sumZ2 = 0, bodies = this.axisList, N = bodies.length, invN = 1 / N;
            for (var i = 0; i !== N; i++) {
              var b = bodies[i];
              var centerX = b.position.x;
              sumX += centerX;
              sumX2 += centerX * centerX;
              var centerY = b.position.y;
              sumY += centerY;
              sumY2 += centerY * centerY;
              var centerZ = b.position.z;
              sumZ += centerZ;
              sumZ2 += centerZ * centerZ;
            }
            var varianceX = sumX2 - sumX * sumX * invN, varianceY = sumY2 - sumY * sumY * invN, varianceZ = sumZ2 - sumZ * sumZ * invN;
            this.axisIndex = varianceX > varianceY ? varianceX > varianceZ ? 0 : 2 : varianceY > varianceZ ? 1 : 2;
          };
          SAPBroadphase.prototype.aabbQuery = function(world, aabb, result) {
            result = result || [];
            if (this.dirty) {
              this.sortList();
              this.dirty = false;
            }
            var axisIndex = this.axisIndex, axis = "x";
            1 === axisIndex && (axis = "y");
            2 === axisIndex && (axis = "z");
            var axisList = this.axisList;
            var lower = aabb.lowerBound[axis];
            var upper = aabb.upperBound[axis];
            for (var i = 0; i < axisList.length; i++) {
              var b = axisList[i];
              b.aabbNeedsUpdate && b.computeAABB();
              b.aabb.overlaps(aabb) && result.push(b);
            }
            return result;
          };
        }), {
          "../collision/Broadphase": 5,
          "../shapes/Shape": 45
        } ],
        13: [ (function(_dereq_, module, exports) {
          module.exports = ConeTwistConstraint;
          var Constraint = _dereq_("./Constraint");
          var PointToPointConstraint = _dereq_("./PointToPointConstraint");
          var ConeEquation = _dereq_("../equations/ConeEquation");
          var RotationalEquation = _dereq_("../equations/RotationalEquation");
          var ContactEquation = _dereq_("../equations/ContactEquation");
          var Vec3 = _dereq_("../math/Vec3");
          function ConeTwistConstraint(bodyA, bodyB, options) {
            options = options || {};
            var maxForce = "undefined" !== typeof options.maxForce ? options.maxForce : 1e6;
            var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
            var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
            this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
            this.axisB = options.axisB ? options.axisB.clone() : new Vec3();
            PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);
            this.collideConnected = !!options.collideConnected;
            this.angle = "undefined" !== typeof options.angle ? options.angle : 0;
            var c = this.coneEquation = new ConeEquation(bodyA, bodyB, options);
            var t = this.twistEquation = new RotationalEquation(bodyA, bodyB, options);
            this.twistAngle = "undefined" !== typeof options.twistAngle ? options.twistAngle : 0;
            c.maxForce = 0;
            c.minForce = -maxForce;
            t.maxForce = 0;
            t.minForce = -maxForce;
            this.equations.push(c, t);
          }
          ConeTwistConstraint.prototype = new PointToPointConstraint();
          ConeTwistConstraint.constructor = ConeTwistConstraint;
          var ConeTwistConstraint_update_tmpVec1 = new Vec3();
          var ConeTwistConstraint_update_tmpVec2 = new Vec3();
          ConeTwistConstraint.prototype.update = function() {
            var bodyA = this.bodyA, bodyB = this.bodyB, cone = this.coneEquation, twist = this.twistEquation;
            PointToPointConstraint.prototype.update.call(this);
            bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
            bodyB.vectorToWorldFrame(this.axisB, cone.axisB);
            this.axisA.tangents(twist.axisA, twist.axisA);
            bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);
            this.axisB.tangents(twist.axisB, twist.axisB);
            bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);
            cone.angle = this.angle;
            twist.maxAngle = this.twistAngle;
          };
        }), {
          "../equations/ConeEquation": 19,
          "../equations/ContactEquation": 20,
          "../equations/RotationalEquation": 23,
          "../math/Vec3": 32,
          "./Constraint": 14,
          "./PointToPointConstraint": 18
        } ],
        14: [ (function(_dereq_, module, exports) {
          module.exports = Constraint;
          var Utils = _dereq_("../utils/Utils");
          function Constraint(bodyA, bodyB, options) {
            options = Utils.defaults(options, {
              collideConnected: true,
              wakeUpBodies: true
            });
            this.equations = [];
            this.bodyA = bodyA;
            this.bodyB = bodyB;
            this.id = Constraint.idCounter++;
            this.collideConnected = options.collideConnected;
            if (options.wakeUpBodies) {
              bodyA && bodyA.wakeUp();
              bodyB && bodyB.wakeUp();
            }
          }
          Constraint.prototype.update = function() {
            throw new Error("method update() not implmemented in this Constraint subclass!");
          };
          Constraint.prototype.enable = function() {
            var eqs = this.equations;
            for (var i = 0; i < eqs.length; i++) eqs[i].enabled = true;
          };
          Constraint.prototype.disable = function() {
            var eqs = this.equations;
            for (var i = 0; i < eqs.length; i++) eqs[i].enabled = false;
          };
          Constraint.idCounter = 0;
        }), {
          "../utils/Utils": 55
        } ],
        15: [ (function(_dereq_, module, exports) {
          module.exports = DistanceConstraint;
          var Constraint = _dereq_("./Constraint");
          var ContactEquation = _dereq_("../equations/ContactEquation");
          function DistanceConstraint(bodyA, bodyB, distance, maxForce) {
            Constraint.call(this, bodyA, bodyB);
            "undefined" === typeof distance && (distance = bodyA.position.distanceTo(bodyB.position));
            "undefined" === typeof maxForce && (maxForce = 1e6);
            this.distance = distance;
            var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
            this.equations.push(eq);
            eq.minForce = -maxForce;
            eq.maxForce = maxForce;
          }
          DistanceConstraint.prototype = new Constraint();
          DistanceConstraint.prototype.update = function() {
            var bodyA = this.bodyA;
            var bodyB = this.bodyB;
            var eq = this.distanceEquation;
            var halfDist = .5 * this.distance;
            var normal = eq.ni;
            bodyB.position.vsub(bodyA.position, normal);
            normal.normalize();
            normal.mult(halfDist, eq.ri);
            normal.mult(-halfDist, eq.rj);
          };
        }), {
          "../equations/ContactEquation": 20,
          "./Constraint": 14
        } ],
        16: [ (function(_dereq_, module, exports) {
          module.exports = HingeConstraint;
          var Constraint = _dereq_("./Constraint");
          var PointToPointConstraint = _dereq_("./PointToPointConstraint");
          var RotationalEquation = _dereq_("../equations/RotationalEquation");
          var RotationalMotorEquation = _dereq_("../equations/RotationalMotorEquation");
          var ContactEquation = _dereq_("../equations/ContactEquation");
          var Vec3 = _dereq_("../math/Vec3");
          function HingeConstraint(bodyA, bodyB, options) {
            options = options || {};
            var maxForce = "undefined" !== typeof options.maxForce ? options.maxForce : 1e6;
            var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
            var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
            PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);
            var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
            axisA.normalize();
            var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1, 0, 0);
            axisB.normalize();
            var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);
            var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);
            var motor = this.motorEquation = new RotationalMotorEquation(bodyA, bodyB, maxForce);
            motor.enabled = false;
            this.equations.push(r1, r2, motor);
          }
          HingeConstraint.prototype = new PointToPointConstraint();
          HingeConstraint.constructor = HingeConstraint;
          HingeConstraint.prototype.enableMotor = function() {
            this.motorEquation.enabled = true;
          };
          HingeConstraint.prototype.disableMotor = function() {
            this.motorEquation.enabled = false;
          };
          HingeConstraint.prototype.setMotorSpeed = function(speed) {
            this.motorEquation.targetVelocity = speed;
          };
          HingeConstraint.prototype.setMotorMaxForce = function(maxForce) {
            this.motorEquation.maxForce = maxForce;
            this.motorEquation.minForce = -maxForce;
          };
          var HingeConstraint_update_tmpVec1 = new Vec3();
          var HingeConstraint_update_tmpVec2 = new Vec3();
          HingeConstraint.prototype.update = function() {
            var bodyA = this.bodyA, bodyB = this.bodyB, motor = this.motorEquation, r1 = this.rotationalEquation1, r2 = this.rotationalEquation2, worldAxisA = HingeConstraint_update_tmpVec1, worldAxisB = HingeConstraint_update_tmpVec2;
            var axisA = this.axisA;
            var axisB = this.axisB;
            PointToPointConstraint.prototype.update.call(this);
            bodyA.quaternion.vmult(axisA, worldAxisA);
            bodyB.quaternion.vmult(axisB, worldAxisB);
            worldAxisA.tangents(r1.axisA, r2.axisA);
            r1.axisB.copy(worldAxisB);
            r2.axisB.copy(worldAxisB);
            if (this.motorEquation.enabled) {
              bodyA.quaternion.vmult(this.axisA, motor.axisA);
              bodyB.quaternion.vmult(this.axisB, motor.axisB);
            }
          };
        }), {
          "../equations/ContactEquation": 20,
          "../equations/RotationalEquation": 23,
          "../equations/RotationalMotorEquation": 24,
          "../math/Vec3": 32,
          "./Constraint": 14,
          "./PointToPointConstraint": 18
        } ],
        17: [ (function(_dereq_, module, exports) {
          module.exports = LockConstraint;
          var Constraint = _dereq_("./Constraint");
          var PointToPointConstraint = _dereq_("./PointToPointConstraint");
          var RotationalEquation = _dereq_("../equations/RotationalEquation");
          var RotationalMotorEquation = _dereq_("../equations/RotationalMotorEquation");
          var ContactEquation = _dereq_("../equations/ContactEquation");
          var Vec3 = _dereq_("../math/Vec3");
          function LockConstraint(bodyA, bodyB, options) {
            options = options || {};
            var maxForce = "undefined" !== typeof options.maxForce ? options.maxForce : 1e6;
            var pivotA = new Vec3();
            var pivotB = new Vec3();
            var halfWay = new Vec3();
            bodyA.position.vadd(bodyB.position, halfWay);
            halfWay.scale(.5, halfWay);
            bodyB.pointToLocalFrame(halfWay, pivotB);
            bodyA.pointToLocalFrame(halfWay, pivotA);
            PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);
            this.xA = bodyA.vectorToLocalFrame(Vec3.UNIT_X);
            this.xB = bodyB.vectorToLocalFrame(Vec3.UNIT_X);
            this.yA = bodyA.vectorToLocalFrame(Vec3.UNIT_Y);
            this.yB = bodyB.vectorToLocalFrame(Vec3.UNIT_Y);
            this.zA = bodyA.vectorToLocalFrame(Vec3.UNIT_Z);
            this.zB = bodyB.vectorToLocalFrame(Vec3.UNIT_Z);
            var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);
            var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);
            var r3 = this.rotationalEquation3 = new RotationalEquation(bodyA, bodyB, options);
            this.equations.push(r1, r2, r3);
          }
          LockConstraint.prototype = new PointToPointConstraint();
          LockConstraint.constructor = LockConstraint;
          var LockConstraint_update_tmpVec1 = new Vec3();
          var LockConstraint_update_tmpVec2 = new Vec3();
          LockConstraint.prototype.update = function() {
            var bodyA = this.bodyA, bodyB = this.bodyB, motor = this.motorEquation, r1 = this.rotationalEquation1, r2 = this.rotationalEquation2, r3 = this.rotationalEquation3, worldAxisA = LockConstraint_update_tmpVec1, worldAxisB = LockConstraint_update_tmpVec2;
            PointToPointConstraint.prototype.update.call(this);
            bodyA.vectorToWorldFrame(this.xA, r1.axisA);
            bodyB.vectorToWorldFrame(this.yB, r1.axisB);
            bodyA.vectorToWorldFrame(this.yA, r2.axisA);
            bodyB.vectorToWorldFrame(this.zB, r2.axisB);
            bodyA.vectorToWorldFrame(this.zA, r3.axisA);
            bodyB.vectorToWorldFrame(this.xB, r3.axisB);
          };
        }), {
          "../equations/ContactEquation": 20,
          "../equations/RotationalEquation": 23,
          "../equations/RotationalMotorEquation": 24,
          "../math/Vec3": 32,
          "./Constraint": 14,
          "./PointToPointConstraint": 18
        } ],
        18: [ (function(_dereq_, module, exports) {
          module.exports = PointToPointConstraint;
          var Constraint = _dereq_("./Constraint");
          var ContactEquation = _dereq_("../equations/ContactEquation");
          var Vec3 = _dereq_("../math/Vec3");
          function PointToPointConstraint(bodyA, pivotA, bodyB, pivotB, maxForce) {
            Constraint.call(this, bodyA, bodyB);
            maxForce = "undefined" !== typeof maxForce ? maxForce : 1e6;
            this.pivotA = pivotA ? pivotA.clone() : new Vec3();
            this.pivotB = pivotB ? pivotB.clone() : new Vec3();
            var x = this.equationX = new ContactEquation(bodyA, bodyB);
            var y = this.equationY = new ContactEquation(bodyA, bodyB);
            var z = this.equationZ = new ContactEquation(bodyA, bodyB);
            this.equations.push(x, y, z);
            x.minForce = y.minForce = z.minForce = -maxForce;
            x.maxForce = y.maxForce = z.maxForce = maxForce;
            x.ni.set(1, 0, 0);
            y.ni.set(0, 1, 0);
            z.ni.set(0, 0, 1);
          }
          PointToPointConstraint.prototype = new Constraint();
          PointToPointConstraint.prototype.update = function() {
            var bodyA = this.bodyA;
            var bodyB = this.bodyB;
            var x = this.equationX;
            var y = this.equationY;
            var z = this.equationZ;
            bodyA.quaternion.vmult(this.pivotA, x.ri);
            bodyB.quaternion.vmult(this.pivotB, x.rj);
            y.ri.copy(x.ri);
            y.rj.copy(x.rj);
            z.ri.copy(x.ri);
            z.rj.copy(x.rj);
          };
        }), {
          "../equations/ContactEquation": 20,
          "../math/Vec3": 32,
          "./Constraint": 14
        } ],
        19: [ (function(_dereq_, module, exports) {
          module.exports = ConeEquation;
          var Vec3 = _dereq_("../math/Vec3");
          var Mat3 = _dereq_("../math/Mat3");
          var Equation = _dereq_("./Equation");
          var CMath = _dereq_("../math/CMath");
          function ConeEquation(bodyA, bodyB, options) {
            options = options || {};
            var maxForce = "undefined" !== typeof options.maxForce ? options.maxForce : 1e6;
            Equation.call(this, bodyA, bodyB, -maxForce, maxForce);
            this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
            this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);
            this.angle = "undefined" !== typeof options.angle ? options.angle : 0;
          }
          ConeEquation.prototype = new Equation();
          ConeEquation.prototype.constructor = ConeEquation;
          var tmpVec1 = new Vec3();
          var tmpVec2 = new Vec3();
          ConeEquation.prototype.computeB = function(h) {
            var a = this.a, b = this.b, ni = this.axisA, nj = this.axisB, nixnj = tmpVec1, njxni = tmpVec2, GA = this.jacobianElementA, GB = this.jacobianElementB;
            ni.cross(nj, nixnj);
            nj.cross(ni, njxni);
            GA.rotational.copy(njxni);
            GB.rotational.copy(nixnj);
            var g = CMath.cos(this.angle) - ni.dot(nj), GW = this.computeGW(), GiMf = this.computeGiMf();
            var B = -g * a - GW * b - h * GiMf;
            return B;
          };
        }), {
          "../math/CMath": 27,
          "../math/Mat3": 29,
          "../math/Vec3": 32,
          "./Equation": 21
        } ],
        20: [ (function(_dereq_, module, exports) {
          module.exports = ContactEquation;
          var Equation = _dereq_("./Equation");
          var Vec3 = _dereq_("../math/Vec3");
          var Mat3 = _dereq_("../math/Mat3");
          function ContactEquation(bodyA, bodyB, maxForce) {
            maxForce = "undefined" !== typeof maxForce ? maxForce : 1e6;
            Equation.call(this, bodyA, bodyB, 0, maxForce);
            this.si = null;
            this.sj = null;
            this.restitution = 0;
            this.ri = new Vec3();
            this.rj = new Vec3();
            this.ni = new Vec3();
          }
          ContactEquation.prototype = new Equation();
          ContactEquation.prototype.constructor = ContactEquation;
          var ContactEquation_computeB_temp1 = new Vec3();
          var ContactEquation_computeB_temp2 = new Vec3();
          var ContactEquation_computeB_temp3 = new Vec3();
          ContactEquation.prototype.computeB = function(h) {
            var a = this.a, b = this.b, bi = this.bi, bj = this.bj, ri = this.ri, rj = this.rj, rixn = ContactEquation_computeB_temp1, rjxn = ContactEquation_computeB_temp2, vi = bi.velocity, wi = bi.angularVelocity, fi = bi.force, taui = bi.torque, vj = bj.velocity, wj = bj.angularVelocity, fj = bj.force, tauj = bj.torque, penetrationVec = ContactEquation_computeB_temp3, GA = this.jacobianElementA, GB = this.jacobianElementB, n = this.ni;
            ri.cross(n, rixn);
            rj.cross(n, rjxn);
            n.negate(GA.spatial);
            rixn.negate(GA.rotational);
            GB.spatial.copy(n);
            GB.rotational.copy(rjxn);
            penetrationVec.copy(bj.position);
            penetrationVec.vadd(rj, penetrationVec);
            penetrationVec.vsub(bi.position, penetrationVec);
            penetrationVec.vsub(ri, penetrationVec);
            var g = n.dot(penetrationVec);
            var ePlusOne = this.restitution + 1;
            var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
            var GiMf = this.computeGiMf();
            var B = -g * a - GW * b - h * GiMf;
            return B;
          };
          var ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
          var ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
          var ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
          var ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
          var ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();
          ContactEquation.prototype.getImpactVelocityAlongNormal = function() {
            var vi = ContactEquation_getImpactVelocityAlongNormal_vi;
            var vj = ContactEquation_getImpactVelocityAlongNormal_vj;
            var xi = ContactEquation_getImpactVelocityAlongNormal_xi;
            var xj = ContactEquation_getImpactVelocityAlongNormal_xj;
            var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;
            this.bi.position.vadd(this.ri, xi);
            this.bj.position.vadd(this.rj, xj);
            this.bi.getVelocityAtWorldPoint(xi, vi);
            this.bj.getVelocityAtWorldPoint(xj, vj);
            vi.vsub(vj, relVel);
            return this.ni.dot(relVel);
          };
        }), {
          "../math/Mat3": 29,
          "../math/Vec3": 32,
          "./Equation": 21
        } ],
        21: [ (function(_dereq_, module, exports) {
          module.exports = Equation;
          var JacobianElement = _dereq_("../math/JacobianElement"), Vec3 = _dereq_("../math/Vec3");
          function Equation(bi, bj, minForce, maxForce) {
            this.id = Equation.id++;
            this.minForce = "undefined" === typeof minForce ? -1e6 : minForce;
            this.maxForce = "undefined" === typeof maxForce ? 1e6 : maxForce;
            this.bi = bi;
            this.bj = bj;
            this.a = 0;
            this.b = 0;
            this.eps = 0;
            this.jacobianElementA = new JacobianElement();
            this.jacobianElementB = new JacobianElement();
            this.enabled = true;
            this.multiplier = 0;
            this.setSpookParams(1e7, 4, 1 / 60);
          }
          Equation.prototype.constructor = Equation;
          Equation.id = 0;
          Equation.prototype.setSpookParams = function(stiffness, relaxation, timeStep) {
            var d = relaxation, k = stiffness, h = timeStep;
            this.a = 4 / (h * (1 + 4 * d));
            this.b = 4 * d / (1 + 4 * d);
            this.eps = 4 / (h * h * k * (1 + 4 * d));
          };
          Equation.prototype.computeB = function(a, b, h) {
            var GW = this.computeGW(), Gq = this.computeGq(), GiMf = this.computeGiMf();
            return -Gq * a - GW * b - GiMf * h;
          };
          Equation.prototype.computeGq = function() {
            var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, xi = bi.position, xj = bj.position;
            return GA.spatial.dot(xi) + GB.spatial.dot(xj);
          };
          var zero = new Vec3();
          Equation.prototype.computeGW = function() {
            var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, vi = bi.velocity, vj = bj.velocity, wi = bi.angularVelocity, wj = bj.angularVelocity;
            return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
          };
          Equation.prototype.computeGWlambda = function() {
            var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, vi = bi.vlambda, vj = bj.vlambda, wi = bi.wlambda, wj = bj.wlambda;
            return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
          };
          var iMfi = new Vec3(), iMfj = new Vec3(), invIi_vmult_taui = new Vec3(), invIj_vmult_tauj = new Vec3();
          Equation.prototype.computeGiMf = function() {
            var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, fi = bi.force, ti = bi.torque, fj = bj.force, tj = bj.torque, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve;
            fi.scale(invMassi, iMfi);
            fj.scale(invMassj, iMfj);
            bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui);
            bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj);
            return GA.multiplyVectors(iMfi, invIi_vmult_taui) + GB.multiplyVectors(iMfj, invIj_vmult_tauj);
          };
          var tmp = new Vec3();
          Equation.prototype.computeGiMGt = function() {
            var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, invMassi = bi.invMassSolve, invMassj = bj.invMassSolve, invIi = bi.invInertiaWorldSolve, invIj = bj.invInertiaWorldSolve, result = invMassi + invMassj;
            invIi.vmult(GA.rotational, tmp);
            result += tmp.dot(GA.rotational);
            invIj.vmult(GB.rotational, tmp);
            result += tmp.dot(GB.rotational);
            return result;
          };
          var addToWlambda_temp = new Vec3(), addToWlambda_Gi = new Vec3(), addToWlambda_Gj = new Vec3(), addToWlambda_ri = new Vec3(), addToWlambda_rj = new Vec3(), addToWlambda_Mdiag = new Vec3();
          Equation.prototype.addToWlambda = function(deltalambda) {
            var GA = this.jacobianElementA, GB = this.jacobianElementB, bi = this.bi, bj = this.bj, temp = addToWlambda_temp;
            bi.vlambda.addScaledVector(bi.invMassSolve * deltalambda, GA.spatial, bi.vlambda);
            bj.vlambda.addScaledVector(bj.invMassSolve * deltalambda, GB.spatial, bj.vlambda);
            bi.invInertiaWorldSolve.vmult(GA.rotational, temp);
            bi.wlambda.addScaledVector(deltalambda, temp, bi.wlambda);
            bj.invInertiaWorldSolve.vmult(GB.rotational, temp);
            bj.wlambda.addScaledVector(deltalambda, temp, bj.wlambda);
          };
          Equation.prototype.computeC = function() {
            return this.computeGiMGt() + this.eps;
          };
        }), {
          "../math/JacobianElement": 28,
          "../math/Vec3": 32
        } ],
        22: [ (function(_dereq_, module, exports) {
          module.exports = FrictionEquation;
          var Equation = _dereq_("./Equation");
          var Vec3 = _dereq_("../math/Vec3");
          var Mat3 = _dereq_("../math/Mat3");
          function FrictionEquation(bodyA, bodyB, slipForce) {
            Equation.call(this, bodyA, bodyB, -slipForce, slipForce);
            this.ri = new Vec3();
            this.rj = new Vec3();
            this.t = new Vec3();
          }
          FrictionEquation.prototype = new Equation();
          FrictionEquation.prototype.constructor = FrictionEquation;
          var FrictionEquation_computeB_temp1 = new Vec3();
          var FrictionEquation_computeB_temp2 = new Vec3();
          FrictionEquation.prototype.computeB = function(h) {
            var a = this.a, b = this.b, bi = this.bi, bj = this.bj, ri = this.ri, rj = this.rj, rixt = FrictionEquation_computeB_temp1, rjxt = FrictionEquation_computeB_temp2, t = this.t;
            ri.cross(t, rixt);
            rj.cross(t, rjxt);
            var GA = this.jacobianElementA, GB = this.jacobianElementB;
            t.negate(GA.spatial);
            rixt.negate(GA.rotational);
            GB.spatial.copy(t);
            GB.rotational.copy(rjxt);
            var GW = this.computeGW();
            var GiMf = this.computeGiMf();
            var B = -GW * b - h * GiMf;
            return B;
          };
        }), {
          "../math/Mat3": 29,
          "../math/Vec3": 32,
          "./Equation": 21
        } ],
        23: [ (function(_dereq_, module, exports) {
          module.exports = RotationalEquation;
          var Vec3 = _dereq_("../math/Vec3");
          var Mat3 = _dereq_("../math/Mat3");
          var Equation = _dereq_("./Equation");
          var CMath = _dereq_("../math/CMath");
          function RotationalEquation(bodyA, bodyB, options) {
            options = options || {};
            var maxForce = "undefined" !== typeof options.maxForce ? options.maxForce : 1e6;
            Equation.call(this, bodyA, bodyB, -maxForce, maxForce);
            this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
            this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);
            this.maxAngle = Math.PI / 2;
          }
          RotationalEquation.prototype = new Equation();
          RotationalEquation.prototype.constructor = RotationalEquation;
          var tmpVec1 = new Vec3();
          var tmpVec2 = new Vec3();
          RotationalEquation.prototype.computeB = function(h) {
            var a = this.a, b = this.b, ni = this.axisA, nj = this.axisB, nixnj = tmpVec1, njxni = tmpVec2, GA = this.jacobianElementA, GB = this.jacobianElementB;
            ni.cross(nj, nixnj);
            nj.cross(ni, njxni);
            GA.rotational.copy(njxni);
            GB.rotational.copy(nixnj);
            var g = CMath.cos(this.maxAngle) - ni.dot(nj), GW = this.computeGW(), GiMf = this.computeGiMf();
            var B = -g * a - GW * b - h * GiMf;
            return B;
          };
        }), {
          "../math/CMath": 27,
          "../math/Mat3": 29,
          "../math/Vec3": 32,
          "./Equation": 21
        } ],
        24: [ (function(_dereq_, module, exports) {
          module.exports = RotationalMotorEquation;
          var Vec3 = _dereq_("../math/Vec3");
          var Mat3 = _dereq_("../math/Mat3");
          var Equation = _dereq_("./Equation");
          function RotationalMotorEquation(bodyA, bodyB, maxForce) {
            maxForce = "undefined" !== typeof maxForce ? maxForce : 1e6;
            Equation.call(this, bodyA, bodyB, -maxForce, maxForce);
            this.axisA = new Vec3();
            this.axisB = new Vec3();
            this.targetVelocity = 0;
          }
          RotationalMotorEquation.prototype = new Equation();
          RotationalMotorEquation.prototype.constructor = RotationalMotorEquation;
          RotationalMotorEquation.prototype.computeB = function(h) {
            var a = this.a, b = this.b, bi = this.bi, bj = this.bj, axisA = this.axisA, axisB = this.axisB, GA = this.jacobianElementA, GB = this.jacobianElementB;
            GA.rotational.copy(axisA);
            axisB.negate(GB.rotational);
            var GW = this.computeGW() - this.targetVelocity, GiMf = this.computeGiMf();
            var B = -GW * b - h * GiMf;
            return B;
          };
        }), {
          "../math/Mat3": 29,
          "../math/Vec3": 32,
          "./Equation": 21
        } ],
        25: [ (function(_dereq_, module, exports) {
          var Utils = _dereq_("../utils/Utils");
          module.exports = ContactMaterial;
          function ContactMaterial(m1, m2, options) {
            options = Utils.defaults(options, {
              friction: .3,
              restitution: .3,
              contactEquationStiffness: 1e7,
              contactEquationRelaxation: 3,
              frictionEquationStiffness: 1e7,
              frictionEquationRelaxation: 3
            });
            this.id = ContactMaterial.idCounter++;
            this.materials = [ m1, m2 ];
            this.friction = options.friction;
            this.restitution = options.restitution;
            this.contactEquationStiffness = options.contactEquationStiffness;
            this.contactEquationRelaxation = options.contactEquationRelaxation;
            this.frictionEquationStiffness = options.frictionEquationStiffness;
            this.frictionEquationRelaxation = options.frictionEquationRelaxation;
          }
          ContactMaterial.idCounter = 0;
        }), {
          "../utils/Utils": 55
        } ],
        26: [ (function(_dereq_, module, exports) {
          module.exports = Material;
          function Material(options) {
            var name = "";
            options = options || {};
            if ("string" === typeof options) {
              name = options;
              options = {};
            } else "object" === typeof options && (name = "");
            this.name = name;
            this.id = Material.idCounter++;
            this.friction = "undefined" !== typeof options.friction ? options.friction : -1;
            this.restitution = "undefined" !== typeof options.restitution ? options.restitution : -1;
          }
          Material.idCounter = 0;
        }), {} ],
        27: [ (function(_dereq_, module, exports) {
          var rad2ang = 180 / Math.PI;
          function radian2angle(rad) {
            return rad * rad2ang;
          }
          var sinArr = {};
          function calculateSinByDigit(digit) {
            if (sinArr.digit == digit) return;
            var step = 1 / Math.pow(10, digit);
            for (var i = 0; i <= 90; i += step) sinArr[i.toFixed(digit)] = Math.sin(i / rad2ang);
            sinArr.digit = digit;
          }
          function sin360(angle, digit) {
            if (angle <= 90) return sinArr[angle.toFixed(digit)];
            if (angle <= 180) {
              angle = 180 - angle;
              return sinArr[angle.toFixed(digit)];
            }
            if (angle <= 270) {
              angle -= 180;
              return -sinArr[angle.toFixed(digit)];
            }
            angle = 360 - angle;
            return -sinArr[angle.toFixed(digit)];
          }
          function sin(rad) {
            var angle = radian2angle(rad) % 360;
            angle < 0 && (angle += 360);
            return sin360(angle, CMath._digit);
          }
          function cos(rad) {
            var angle = (radian2angle(rad) + 90) % 360;
            angle < 0 && (angle += 360);
            return sin360(angle, CMath._digit);
          }
          function sinNative(rad) {
            return Math.sin(rad).toFixed(CMath.digit);
          }
          function cosNative(rad) {
            return Math.cos(rad).toFixed(CMath.digit);
          }
          var CMath = {
            sin: Math.sin,
            cos: Math.cos,
            atan2: Math.atan2
          };
          CMath._sin = sin;
          CMath._cos = cos;
          CMath._sinArr = sinArr;
          CMath._sin360 = sin360;
          CMath._sinNative = sinNative;
          CMath._cosNative = cosNative;
          CMath._radian2angle = radian2angle;
          CMath._calculateSinByDigit = calculateSinByDigit;
          CMath._digit = 1;
          Object.defineProperty(CMath, "digit", {
            get: function get() {
              return this._digit;
            },
            set: function set(v) {
              this._digit = v;
              1 == this._mode && calculateSinByDigit(v);
            }
          });
          CMath._mode = 0;
          Object.defineProperty(CMath, "mode", {
            get: function get() {
              return this._mode;
            },
            set: function set(v) {
              if (this._mode != v) {
                this._mode = v;
                if (0 == v) {
                  CMath.sin = Math.sin;
                  CMath.cos = Math.cos;
                } else if (1 == v) {
                  CMath.digit = CMath._digit;
                  CMath.sin = sin;
                  CMath.cos = cos;
                } else if (2 == v) {
                  CMath.sin = sinNative;
                  CMath.cos = cosNative;
                }
              }
            }
          });
          module.exports = CMath;
        }), {} ],
        28: [ (function(_dereq_, module, exports) {
          module.exports = JacobianElement;
          var Vec3 = _dereq_("./Vec3");
          function JacobianElement() {
            this.spatial = new Vec3();
            this.rotational = new Vec3();
          }
          JacobianElement.prototype.multiplyElement = function(element) {
            return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
          };
          JacobianElement.prototype.multiplyVectors = function(spatial, rotational) {
            return spatial.dot(this.spatial) + rotational.dot(this.rotational);
          };
        }), {
          "./Vec3": 32
        } ],
        29: [ (function(_dereq_, module, exports) {
          module.exports = Mat3;
          var Vec3 = _dereq_("./Vec3");
          function Mat3(elements) {
            this.elements = elements || [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
          }
          Mat3.prototype.identity = function() {
            var e = this.elements;
            e[0] = 1;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 1;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = 1;
          };
          Mat3.prototype.setZero = function() {
            var e = this.elements;
            e[0] = 0;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 0;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = 0;
          };
          Mat3.prototype.setTrace = function(vec3) {
            var e = this.elements;
            e[0] = vec3.x;
            e[4] = vec3.y;
            e[8] = vec3.z;
          };
          Mat3.prototype.getTrace = function(target) {
            var target = target || new Vec3();
            var e = this.elements;
            target.x = e[0];
            target.y = e[4];
            target.z = e[8];
          };
          Mat3.prototype.vmult = function(v, target) {
            target = target || new Vec3();
            var e = this.elements, x = v.x, y = v.y, z = v.z;
            target.x = e[0] * x + e[1] * y + e[2] * z;
            target.y = e[3] * x + e[4] * y + e[5] * z;
            target.z = e[6] * x + e[7] * y + e[8] * z;
            return target;
          };
          Mat3.prototype.smult = function(s) {
            for (var i = 0; i < this.elements.length; i++) this.elements[i] *= s;
          };
          Mat3.prototype.mmult = function(m, target) {
            var r = target || new Mat3();
            for (var i = 0; i < 3; i++) for (var j = 0; j < 3; j++) {
              var sum = 0;
              for (var k = 0; k < 3; k++) sum += m.elements[i + 3 * k] * this.elements[k + 3 * j];
              r.elements[i + 3 * j] = sum;
            }
            return r;
          };
          Mat3.prototype.scale = function(v, target) {
            target = target || new Mat3();
            var e = this.elements, t = target.elements;
            for (var i = 0; 3 !== i; i++) {
              t[3 * i + 0] = v.x * e[3 * i + 0];
              t[3 * i + 1] = v.y * e[3 * i + 1];
              t[3 * i + 2] = v.z * e[3 * i + 2];
            }
            return target;
          };
          Mat3.prototype.solve = function(b, target) {
            target = target || new Vec3();
            var nr = 3;
            var nc = 4;
            var eqns = [];
            for (var i = 0; i < nr * nc; i++) eqns.push(0);
            var i, j;
            for (i = 0; i < 3; i++) for (j = 0; j < 3; j++) eqns[i + nc * j] = this.elements[i + 3 * j];
            eqns[3] = b.x;
            eqns[7] = b.y;
            eqns[11] = b.z;
            var n = 3, k = n, np;
            var kp = 4;
            var p, els;
            do {
              i = k - n;
              if (0 === eqns[i + nc * i]) for (j = i + 1; j < k; j++) if (0 !== eqns[i + nc * j]) {
                np = kp;
                do {
                  p = kp - np;
                  eqns[p + nc * i] += eqns[p + nc * j];
                } while (--np);
                break;
              }
              if (0 !== eqns[i + nc * i]) for (j = i + 1; j < k; j++) {
                var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                np = kp;
                do {
                  p = kp - np;
                  eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                } while (--np);
              }
            } while (--n);
            target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];
            target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];
            target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];
            if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || Infinity === target.x || Infinity === target.y || Infinity === target.z) throw "Could not solve equation! Got x=[" + target.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
            return target;
          };
          Mat3.prototype.e = function(row, column, value) {
            if (void 0 === value) return this.elements[column + 3 * row];
            this.elements[column + 3 * row] = value;
          };
          Mat3.prototype.copy = function(source) {
            for (var i = 0; i < source.elements.length; i++) this.elements[i] = source.elements[i];
            return this;
          };
          Mat3.prototype.toString = function() {
            var r = "";
            var sep = ",";
            for (var i = 0; i < 9; i++) r += this.elements[i] + sep;
            return r;
          };
          Mat3.prototype.reverse = function(target) {
            target = target || new Mat3();
            var nr = 3;
            var nc = 6;
            var eqns = [];
            for (var i = 0; i < nr * nc; i++) eqns.push(0);
            var i, j;
            for (i = 0; i < 3; i++) for (j = 0; j < 3; j++) eqns[i + nc * j] = this.elements[i + 3 * j];
            eqns[3] = 1;
            eqns[9] = 0;
            eqns[15] = 0;
            eqns[4] = 0;
            eqns[10] = 1;
            eqns[16] = 0;
            eqns[5] = 0;
            eqns[11] = 0;
            eqns[17] = 1;
            var n = 3, k = n, np;
            var kp = nc;
            var p;
            do {
              i = k - n;
              if (0 === eqns[i + nc * i]) for (j = i + 1; j < k; j++) if (0 !== eqns[i + nc * j]) {
                np = kp;
                do {
                  p = kp - np;
                  eqns[p + nc * i] += eqns[p + nc * j];
                } while (--np);
                break;
              }
              if (0 !== eqns[i + nc * i]) for (j = i + 1; j < k; j++) {
                var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                np = kp;
                do {
                  p = kp - np;
                  eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                } while (--np);
              }
            } while (--n);
            i = 2;
            do {
              j = i - 1;
              do {
                var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                np = nc;
                do {
                  p = nc - np;
                  eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                } while (--np);
              } while (j--);
            } while (--i);
            i = 2;
            do {
              var multiplier = 1 / eqns[i + nc * i];
              np = nc;
              do {
                p = nc - np;
                eqns[p + nc * i] = eqns[p + nc * i] * multiplier;
              } while (--np);
            } while (i--);
            i = 2;
            do {
              j = 2;
              do {
                p = eqns[nr + j + nc * i];
                if (isNaN(p) || Infinity === p) throw "Could not reverse! A=[" + this.toString() + "]";
                target.e(i, j, p);
              } while (j--);
            } while (i--);
            return target;
          };
          Mat3.prototype.setRotationFromQuaternion = function(q) {
            var x = q.x, y = q.y, z = q.z, w = q.w, x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2, e = this.elements;
            e[0] = 1 - (yy + zz);
            e[1] = xy - wz;
            e[2] = xz + wy;
            e[3] = xy + wz;
            e[4] = 1 - (xx + zz);
            e[5] = yz - wx;
            e[6] = xz - wy;
            e[7] = yz + wx;
            e[8] = 1 - (xx + yy);
            return this;
          };
          Mat3.prototype.transpose = function(target) {
            target = target || new Mat3();
            var Mt = target.elements, M = this.elements;
            for (var i = 0; 3 !== i; i++) for (var j = 0; 3 !== j; j++) Mt[3 * i + j] = M[3 * j + i];
            return target;
          };
        }), {
          "./Vec3": 32
        } ],
        30: [ (function(_dereq_, module, exports) {
          module.exports = Quaternion;
          var Vec3 = _dereq_("./Vec3");
          var CMath = _dereq_("./CMath");
          function Quaternion(x, y, z, w) {
            this.x = void 0 !== x ? x : 0;
            this.y = void 0 !== y ? y : 0;
            this.z = void 0 !== z ? z : 0;
            this.w = void 0 !== w ? w : 1;
          }
          Quaternion.prototype.set = function(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
          };
          Quaternion.prototype.toString = function() {
            return this.x + "," + this.y + "," + this.z + "," + this.w;
          };
          Quaternion.prototype.toArray = function() {
            return [ this.x, this.y, this.z, this.w ];
          };
          Quaternion.prototype.setFromAxisAngle = function(axis, angle) {
            var s = CMath.sin(.5 * angle);
            this.x = axis.x * s;
            this.y = axis.y * s;
            this.z = axis.z * s;
            this.w = CMath.cos(.5 * angle);
            return this;
          };
          Quaternion.prototype.toAxisAngle = function(targetAxis) {
            targetAxis = targetAxis || new Vec3();
            this.normalize();
            var angle = 2 * Math.acos(this.w);
            var s = Math.sqrt(1 - this.w * this.w);
            if (s < .001) {
              targetAxis.x = this.x;
              targetAxis.y = this.y;
              targetAxis.z = this.z;
            } else {
              targetAxis.x = this.x / s;
              targetAxis.y = this.y / s;
              targetAxis.z = this.z / s;
            }
            return [ targetAxis, angle ];
          };
          var sfv_t1 = new Vec3(), sfv_t2 = new Vec3();
          Quaternion.prototype.setFromVectors = function(u, v) {
            if (u.isAntiparallelTo(v)) {
              var t1 = sfv_t1;
              var t2 = sfv_t2;
              u.tangents(t1, t2);
              this.setFromAxisAngle(t1, Math.PI);
            } else {
              var a = u.cross(v);
              this.x = a.x;
              this.y = a.y;
              this.z = a.z;
              this.w = Math.sqrt(Math.pow(u.norm(), 2) * Math.pow(v.norm(), 2)) + u.dot(v);
              this.normalize();
            }
            return this;
          };
          var Quaternion_mult_va = new Vec3();
          var Quaternion_mult_vb = new Vec3();
          var Quaternion_mult_vaxvb = new Vec3();
          Quaternion.prototype.mult = function(q, target) {
            target = target || new Quaternion();
            var ax = this.x, ay = this.y, az = this.z, aw = this.w, bx = q.x, by = q.y, bz = q.z, bw = q.w;
            target.x = ax * bw + aw * bx + ay * bz - az * by;
            target.y = ay * bw + aw * by + az * bx - ax * bz;
            target.z = az * bw + aw * bz + ax * by - ay * bx;
            target.w = aw * bw - ax * bx - ay * by - az * bz;
            return target;
          };
          Quaternion.prototype.inverse = function(target) {
            var x = this.x, y = this.y, z = this.z, w = this.w;
            target = target || new Quaternion();
            this.conjugate(target);
            var inorm2 = 1 / (x * x + y * y + z * z + w * w);
            target.x *= inorm2;
            target.y *= inorm2;
            target.z *= inorm2;
            target.w *= inorm2;
            return target;
          };
          Quaternion.prototype.conjugate = function(target) {
            target = target || new Quaternion();
            target.x = -this.x;
            target.y = -this.y;
            target.z = -this.z;
            target.w = this.w;
            return target;
          };
          Quaternion.prototype.normalize = function() {
            var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            if (0 === l) {
              this.x = 0;
              this.y = 0;
              this.z = 0;
              this.w = 0;
            } else {
              l = 1 / l;
              this.x *= l;
              this.y *= l;
              this.z *= l;
              this.w *= l;
            }
            return this;
          };
          Quaternion.prototype.normalizeFast = function() {
            var f = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
            if (0 === f) {
              this.x = 0;
              this.y = 0;
              this.z = 0;
              this.w = 0;
            } else {
              this.x *= f;
              this.y *= f;
              this.z *= f;
              this.w *= f;
            }
            return this;
          };
          Quaternion.prototype.vmult = function(v, target) {
            target = target || new Vec3();
            var x = v.x, y = v.y, z = v.z;
            var qx = this.x, qy = this.y, qz = this.z, qw = this.w;
            var ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return target;
          };
          Quaternion.prototype.copy = function(source) {
            this.x = source.x;
            this.y = source.y;
            this.z = source.z;
            this.w = source.w;
            return this;
          };
          Quaternion.prototype.toEuler = function(target, order) {
            order = order || "YZX";
            var heading, attitude, bank;
            var x = this.x, y = this.y, z = this.z, w = this.w;
            switch (order) {
             case "YZX":
              var test = x * y + z * w;
              if (test > .499) {
                heading = 2 * CMath.atan2(x, w);
                attitude = Math.PI / 2;
                bank = 0;
              }
              if (test < -.499) {
                heading = -2 * CMath.atan2(x, w);
                attitude = -Math.PI / 2;
                bank = 0;
              }
              if (isNaN(heading)) {
                var sqx = x * x;
                var sqy = y * y;
                var sqz = z * z;
                heading = CMath.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz);
                attitude = Math.asin(2 * test);
                bank = CMath.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz);
              }
              break;

             default:
              throw new Error("Euler order " + order + " not supported yet.");
            }
            target.y = heading;
            target.z = attitude;
            target.x = bank;
          };
          Quaternion.prototype.setFromEuler = function(x, y, z, order) {
            order = order || "XYZ";
            var c1 = CMath.cos(x / 2);
            var c2 = CMath.cos(y / 2);
            var c3 = CMath.cos(z / 2);
            var s1 = CMath.sin(x / 2);
            var s2 = CMath.sin(y / 2);
            var s3 = CMath.sin(z / 2);
            if ("XYZ" === order) {
              this.x = s1 * c2 * c3 + c1 * s2 * s3;
              this.y = c1 * s2 * c3 - s1 * c2 * s3;
              this.z = c1 * c2 * s3 + s1 * s2 * c3;
              this.w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if ("YXZ" === order) {
              this.x = s1 * c2 * c3 + c1 * s2 * s3;
              this.y = c1 * s2 * c3 - s1 * c2 * s3;
              this.z = c1 * c2 * s3 - s1 * s2 * c3;
              this.w = c1 * c2 * c3 + s1 * s2 * s3;
            } else if ("ZXY" === order) {
              this.x = s1 * c2 * c3 - c1 * s2 * s3;
              this.y = c1 * s2 * c3 + s1 * c2 * s3;
              this.z = c1 * c2 * s3 + s1 * s2 * c3;
              this.w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if ("ZYX" === order) {
              this.x = s1 * c2 * c3 - c1 * s2 * s3;
              this.y = c1 * s2 * c3 + s1 * c2 * s3;
              this.z = c1 * c2 * s3 - s1 * s2 * c3;
              this.w = c1 * c2 * c3 + s1 * s2 * s3;
            } else if ("YZX" === order) {
              this.x = s1 * c2 * c3 + c1 * s2 * s3;
              this.y = c1 * s2 * c3 + s1 * c2 * s3;
              this.z = c1 * c2 * s3 - s1 * s2 * c3;
              this.w = c1 * c2 * c3 - s1 * s2 * s3;
            } else if ("XZY" === order) {
              this.x = s1 * c2 * c3 - c1 * s2 * s3;
              this.y = c1 * s2 * c3 - s1 * c2 * s3;
              this.z = c1 * c2 * s3 + s1 * s2 * c3;
              this.w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            return this;
          };
          Quaternion.prototype.clone = function() {
            return new Quaternion(this.x, this.y, this.z, this.w);
          };
          Quaternion.prototype.slerp = function(toQuat, t, target) {
            target = target || new Quaternion();
            var ax = this.x, ay = this.y, az = this.z, aw = this.w, bx = toQuat.x, by = toQuat.y, bz = toQuat.z, bw = toQuat.w;
            var omega, cosom, sinom, scale0, scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0) {
              cosom = -cosom;
              bx = -bx;
              by = -by;
              bz = -bz;
              bw = -bw;
            }
            if (1 - cosom > 1e-6) {
              omega = Math.acos(cosom);
              sinom = CMath.sin(omega);
              scale0 = CMath.sin((1 - t) * omega) / sinom;
              scale1 = CMath.sin(t * omega) / sinom;
            } else {
              scale0 = 1 - t;
              scale1 = t;
            }
            target.x = scale0 * ax + scale1 * bx;
            target.y = scale0 * ay + scale1 * by;
            target.z = scale0 * az + scale1 * bz;
            target.w = scale0 * aw + scale1 * bw;
            return target;
          };
          Quaternion.prototype.integrate = function(angularVelocity, dt, angularFactor, target) {
            target = target || new Quaternion();
            var ax = angularVelocity.x * angularFactor.x, ay = angularVelocity.y * angularFactor.y, az = angularVelocity.z * angularFactor.z, bx = this.x, by = this.y, bz = this.z, bw = this.w;
            var half_dt = .5 * dt;
            target.x += half_dt * (ax * bw + ay * bz - az * by);
            target.y += half_dt * (ay * bw + az * bx - ax * bz);
            target.z += half_dt * (az * bw + ax * by - ay * bx);
            target.w += half_dt * (-ax * bx - ay * by - az * bz);
            return target;
          };
        }), {
          "./CMath": 27,
          "./Vec3": 32
        } ],
        31: [ (function(_dereq_, module, exports) {
          var Vec3 = _dereq_("./Vec3");
          var Quaternion = _dereq_("./Quaternion");
          module.exports = Transform;
          function Transform(options) {
            options = options || {};
            this.position = new Vec3();
            options.position && this.position.copy(options.position);
            this.quaternion = new Quaternion();
            options.quaternion && this.quaternion.copy(options.quaternion);
          }
          var tmpQuat = new Quaternion();
          Transform.pointToLocalFrame = function(position, quaternion, worldPoint, result) {
            var result = result || new Vec3();
            worldPoint.vsub(position, result);
            quaternion.conjugate(tmpQuat);
            tmpQuat.vmult(result, result);
            return result;
          };
          Transform.prototype.pointToLocal = function(worldPoint, result) {
            return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
          };
          Transform.pointToWorldFrame = function(position, quaternion, localPoint, result) {
            var result = result || new Vec3();
            quaternion.vmult(localPoint, result);
            result.vadd(position, result);
            return result;
          };
          Transform.prototype.pointToWorld = function(localPoint, result) {
            return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
          };
          Transform.prototype.vectorToWorldFrame = function(localVector, result) {
            var result = result || new Vec3();
            this.quaternion.vmult(localVector, result);
            return result;
          };
          Transform.vectorToWorldFrame = function(quaternion, localVector, result) {
            quaternion.vmult(localVector, result);
            return result;
          };
          Transform.vectorToLocalFrame = function(position, quaternion, worldVector, result) {
            var result = result || new Vec3();
            quaternion.w *= -1;
            quaternion.vmult(worldVector, result);
            quaternion.w *= -1;
            return result;
          };
        }), {
          "./Quaternion": 30,
          "./Vec3": 32
        } ],
        32: [ (function(_dereq_, module, exports) {
          module.exports = Vec3;
          var Mat3 = _dereq_("./Mat3");
          function Vec3(x, y, z) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
          }
          Vec3.ZERO = new Vec3(0, 0, 0);
          Vec3.UNIT_X = new Vec3(1, 0, 0);
          Vec3.UNIT_Y = new Vec3(0, 1, 0);
          Vec3.UNIT_Z = new Vec3(0, 0, 1);
          Vec3.prototype.cross = function(v, target) {
            var vx = v.x, vy = v.y, vz = v.z, x = this.x, y = this.y, z = this.z;
            target = target || new Vec3();
            target.x = y * vz - z * vy;
            target.y = z * vx - x * vz;
            target.z = x * vy - y * vx;
            return target;
          };
          Vec3.prototype.set = function(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
          };
          Vec3.prototype.setZero = function() {
            this.x = this.y = this.z = 0;
          };
          Vec3.prototype.vadd = function(v, target) {
            if (!target) return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z);
            target.x = v.x + this.x;
            target.y = v.y + this.y;
            target.z = v.z + this.z;
          };
          Vec3.prototype.vsub = function(v, target) {
            if (!target) return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z);
            target.x = this.x - v.x;
            target.y = this.y - v.y;
            target.z = this.z - v.z;
          };
          Vec3.prototype.crossmat = function() {
            return new Mat3([ 0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0 ]);
          };
          Vec3.prototype.normalize = function() {
            var x = this.x, y = this.y, z = this.z;
            var n = Math.sqrt(x * x + y * y + z * z);
            if (n > 0) {
              var invN = 1 / n;
              this.x *= invN;
              this.y *= invN;
              this.z *= invN;
            } else {
              this.x = 0;
              this.y = 0;
              this.z = 0;
            }
            return n;
          };
          Vec3.prototype.unit = function(target) {
            target = target || new Vec3();
            var x = this.x, y = this.y, z = this.z;
            var ninv = Math.sqrt(x * x + y * y + z * z);
            if (ninv > 0) {
              ninv = 1 / ninv;
              target.x = x * ninv;
              target.y = y * ninv;
              target.z = z * ninv;
            } else {
              target.x = 1;
              target.y = 0;
              target.z = 0;
            }
            return target;
          };
          Vec3.prototype.norm = function() {
            var x = this.x, y = this.y, z = this.z;
            return Math.sqrt(x * x + y * y + z * z);
          };
          Vec3.prototype.length = Vec3.prototype.norm;
          Vec3.prototype.norm2 = function() {
            return this.dot(this);
          };
          Vec3.prototype.lengthSquared = Vec3.prototype.norm2;
          Vec3.prototype.distanceTo = function(p) {
            var x = this.x, y = this.y, z = this.z;
            var px = p.x, py = p.y, pz = p.z;
            return Math.sqrt((px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z));
          };
          Vec3.prototype.distanceSquared = function(p) {
            var x = this.x, y = this.y, z = this.z;
            var px = p.x, py = p.y, pz = p.z;
            return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);
          };
          Vec3.prototype.mult = function(scalar, target) {
            target = target || new Vec3();
            var x = this.x, y = this.y, z = this.z;
            target.x = scalar * x;
            target.y = scalar * y;
            target.z = scalar * z;
            return target;
          };
          Vec3.prototype.vmul = function(vector, target) {
            target = target || new Vec3();
            target.x = vector.x * this.x;
            target.y = vector.y * this.y;
            target.z = vector.z * this.z;
            return target;
          };
          Vec3.prototype.scale = Vec3.prototype.mult;
          Vec3.prototype.addScaledVector = function(scalar, vector, target) {
            target = target || new Vec3();
            target.x = this.x + scalar * vector.x;
            target.y = this.y + scalar * vector.y;
            target.z = this.z + scalar * vector.z;
            return target;
          };
          Vec3.prototype.dot = function(v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
          };
          Vec3.prototype.isZero = function() {
            return 0 === this.x && 0 === this.y && 0 === this.z;
          };
          Vec3.prototype.negate = function(target) {
            target = target || new Vec3();
            target.x = -this.x;
            target.y = -this.y;
            target.z = -this.z;
            return target;
          };
          var Vec3_tangents_n = new Vec3();
          var Vec3_tangents_randVec = new Vec3();
          Vec3.prototype.tangents = function(t1, t2) {
            var norm = this.norm();
            if (norm > 0) {
              var n = Vec3_tangents_n;
              var inorm = 1 / norm;
              n.set(this.x * inorm, this.y * inorm, this.z * inorm);
              var randVec = Vec3_tangents_randVec;
              if (Math.abs(n.x) < .9) {
                randVec.set(1, 0, 0);
                n.cross(randVec, t1);
              } else {
                randVec.set(0, 1, 0);
                n.cross(randVec, t1);
              }
              n.cross(t1, t2);
            } else {
              t1.set(1, 0, 0);
              t2.set(0, 1, 0);
            }
          };
          Vec3.prototype.toString = function() {
            return this.x + "," + this.y + "," + this.z;
          };
          Vec3.prototype.toArray = function() {
            return [ this.x, this.y, this.z ];
          };
          Vec3.prototype.copy = function(source) {
            this.x = source.x;
            this.y = source.y;
            this.z = source.z;
            return this;
          };
          Vec3.prototype.lerp = function(v, t, target) {
            var x = this.x, y = this.y, z = this.z;
            target.x = x + (v.x - x) * t;
            target.y = y + (v.y - y) * t;
            target.z = z + (v.z - z) * t;
          };
          Vec3.prototype.almostEquals = function(v, precision) {
            void 0 === precision && (precision = 1e-6);
            if (Math.abs(this.x - v.x) > precision || Math.abs(this.y - v.y) > precision || Math.abs(this.z - v.z) > precision) return false;
            return true;
          };
          Vec3.prototype.almostZero = function(precision) {
            void 0 === precision && (precision = 1e-6);
            if (Math.abs(this.x) > precision || Math.abs(this.y) > precision || Math.abs(this.z) > precision) return false;
            return true;
          };
          var antip_neg = new Vec3();
          Vec3.prototype.isAntiparallelTo = function(v, precision) {
            this.negate(antip_neg);
            return antip_neg.almostEquals(v, precision);
          };
          Vec3.prototype.clone = function() {
            return new Vec3(this.x, this.y, this.z);
          };
        }), {
          "./Mat3": 29
        } ],
        33: [ (function(_dereq_, module, exports) {
          module.exports = Body;
          var EventTarget = _dereq_("../utils/EventTarget");
          var Shape = _dereq_("../shapes/Shape");
          var Vec3 = _dereq_("../math/Vec3");
          var Mat3 = _dereq_("../math/Mat3");
          var Quaternion = _dereq_("../math/Quaternion");
          var Material = _dereq_("../material/Material");
          var AABB = _dereq_("../collision/AABB");
          var Box = _dereq_("../shapes/Box");
          var World = _dereq_("../world/World");
          function Body(options) {
            options = options || {};
            EventTarget.apply(this);
            this.id = Body.idCounter++;
            this.world = null;
            this.preStep = null;
            this.postStep = null;
            this.vlambda = new Vec3();
            this.collisionFilterGroup = "number" === typeof options.collisionFilterGroup ? options.collisionFilterGroup : 1;
            this.collisionFilterMask = "number" === typeof options.collisionFilterMask ? options.collisionFilterMask : -1;
            this.collisionResponse = true;
            this.position = new Vec3();
            this.previousPosition = new Vec3();
            this.interpolatedPosition = new Vec3();
            this.initPosition = new Vec3();
            if (options.position) {
              this.position.copy(options.position);
              this.previousPosition.copy(options.position);
              this.interpolatedPosition.copy(options.position);
              this.initPosition.copy(options.position);
            }
            this.velocity = new Vec3();
            options.velocity && this.velocity.copy(options.velocity);
            this.initVelocity = new Vec3();
            this.force = new Vec3();
            var mass = "number" === typeof options.mass ? options.mass : 0;
            this.mass = mass;
            this.invMass = mass > 0 ? 1 / mass : 0;
            this.material = options.material || null;
            this.linearDamping = "number" === typeof options.linearDamping ? options.linearDamping : .01;
            this.type = mass <= 0 ? Body.STATIC : Body.DYNAMIC;
            typeof options.type === typeof Body.STATIC && (this.type = options.type);
            this.allowSleep = "undefined" === typeof options.allowSleep || options.allowSleep;
            this.sleepState = 0;
            this.sleepSpeedLimit = "undefined" !== typeof options.sleepSpeedLimit ? options.sleepSpeedLimit : .1;
            this.sleepTimeLimit = "undefined" !== typeof options.sleepTimeLimit ? options.sleepTimeLimit : 1;
            this.timeLastSleepy = 0;
            this._wakeUpAfterNarrowphase = false;
            this.torque = new Vec3();
            this.quaternion = new Quaternion();
            this.initQuaternion = new Quaternion();
            this.previousQuaternion = new Quaternion();
            this.interpolatedQuaternion = new Quaternion();
            if (options.quaternion) {
              this.quaternion.copy(options.quaternion);
              this.initQuaternion.copy(options.quaternion);
              this.previousQuaternion.copy(options.quaternion);
              this.interpolatedQuaternion.copy(options.quaternion);
            }
            this.angularVelocity = new Vec3();
            options.angularVelocity && this.angularVelocity.copy(options.angularVelocity);
            this.initAngularVelocity = new Vec3();
            this.shapes = [];
            this.shapeOffsets = [];
            this.shapeOrientations = [];
            this.inertia = new Vec3();
            this.invInertia = new Vec3();
            this.invInertiaWorld = new Mat3();
            this.invMassSolve = 0;
            this.invInertiaSolve = new Vec3();
            this.invInertiaWorldSolve = new Mat3();
            this.fixedRotation = "undefined" !== typeof options.fixedRotation && options.fixedRotation;
            this.useGravity = true;
            this.angularDamping = "undefined" !== typeof options.angularDamping ? options.angularDamping : .01;
            this.linearFactor = new Vec3(1, 1, 1);
            options.linearFactor && this.linearFactor.copy(options.linearFactor);
            this.angularFactor = new Vec3(1, 1, 1);
            options.angularFactor && this.angularFactor.copy(options.angularFactor);
            this.aabb = new AABB();
            this.aabbNeedsUpdate = true;
            this.boundingRadius = 0;
            this.wlambda = new Vec3();
            options.shape && this.addShape(options.shape);
            this.hasTrigger = true;
            this.updateMassProperties();
          }
          Body.prototype = new EventTarget();
          Body.prototype.constructor = Body;
          Body.COLLIDE_EVENT_NAME = "collide";
          Body.DYNAMIC = 1;
          Body.STATIC = 2;
          Body.KINEMATIC = 4;
          Body.AWAKE = 0;
          Body.SLEEPY = 1;
          Body.SLEEPING = 2;
          Body.idCounter = 0;
          Body.wakeupEvent = {
            type: "wakeup"
          };
          Body.prototype.wakeUp = function() {
            World.SLEEPING = false;
            var s = this.sleepState;
            this.sleepState = 0;
            this._wakeUpAfterNarrowphase = false;
            s === Body.SLEEPING && this.dispatchEvent(Body.wakeupEvent);
          };
          Body.prototype.sleep = function() {
            this.sleepState = Body.SLEEPING;
            this.velocity.set(0, 0, 0);
            this.angularVelocity.set(0, 0, 0);
            this._wakeUpAfterNarrowphase = false;
          };
          Body.sleepyEvent = {
            type: "sleepy"
          };
          Body.sleepEvent = {
            type: "sleep"
          };
          Body.prototype.sleepTick = function(time) {
            if (this.allowSleep) {
              var sleepState = this.sleepState;
              var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();
              var speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);
              if (sleepState === Body.AWAKE && speedSquared < speedLimitSquared) {
                this.sleepState = Body.SLEEPY;
                this.timeLastSleepy = time;
                this.dispatchEvent(Body.sleepyEvent);
              } else if (sleepState === Body.SLEEPY && speedSquared > speedLimitSquared) this.wakeUp(); else if (sleepState === Body.SLEEPY && time - this.timeLastSleepy > this.sleepTimeLimit) {
                this.sleep();
                this.dispatchEvent(Body.sleepEvent);
              }
            }
          };
          Body.prototype.updateSolveMassProperties = function() {
            if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
              this.invMassSolve = 0;
              this.invInertiaSolve.setZero();
              this.invInertiaWorldSolve.setZero();
            } else {
              this.invMassSolve = this.invMass;
              this.invInertiaSolve.copy(this.invInertia);
              this.invInertiaWorldSolve.copy(this.invInertiaWorld);
            }
          };
          Body.prototype.pointToLocalFrame = function(worldPoint, result) {
            var result = result || new Vec3();
            worldPoint.vsub(this.position, result);
            this.quaternion.conjugate().vmult(result, result);
            return result;
          };
          Body.prototype.vectorToLocalFrame = function(worldVector, result) {
            var result = result || new Vec3();
            this.quaternion.conjugate().vmult(worldVector, result);
            return result;
          };
          Body.prototype.pointToWorldFrame = function(localPoint, result) {
            var result = result || new Vec3();
            this.quaternion.vmult(localPoint, result);
            result.vadd(this.position, result);
            return result;
          };
          Body.prototype.vectorToWorldFrame = function(localVector, result) {
            var result = result || new Vec3();
            this.quaternion.vmult(localVector, result);
            return result;
          };
          var tmpVec = new Vec3();
          var tmpQuat = new Quaternion();
          Body.prototype.addShape = function(shape, _offset, _orientation) {
            var offset = new Vec3();
            var orientation = new Quaternion();
            _offset && offset.copy(_offset);
            _orientation && orientation.copy(_orientation);
            this.shapes.push(shape);
            this.shapeOffsets.push(offset);
            this.shapeOrientations.push(orientation);
            this.aabbNeedsUpdate = true;
            this.updateMassProperties();
            this.updateBoundingRadius();
            this.updateHasTrigger();
            World.idToShapeMap[shape.id] = shape;
            shape.body = this;
            return this;
          };
          Body.prototype.removeShape = function(shape) {
            var idx = this.shapes.indexOf(shape);
            if (-1 === idx) return;
            this.shapes.splice(idx, 1);
            this.shapeOffsets.splice(idx, 1);
            this.shapeOrientations.splice(idx, 1);
            this.aabbNeedsUpdate = true;
            this.updateMassProperties();
            this.updateBoundingRadius();
            this.updateHasTrigger();
          };
          Body.prototype.updateBoundingRadius = function() {
            var shapes = this.shapes, shapeOffsets = this.shapeOffsets, N = shapes.length, radius = 0;
            for (var i = 0; i !== N; i++) {
              var shape = shapes[i];
              shape.updateBoundingSphereRadius();
              var offset = shapeOffsets[i].norm(), r = shape.boundingSphereRadius;
              offset + r > radius && (radius = offset + r);
            }
            this.boundingRadius = radius;
          };
          var computeAABB_shapeAABB = new AABB();
          Body.prototype.computeAABB = function() {
            var shapes = this.shapes, shapeOffsets = this.shapeOffsets, shapeOrientations = this.shapeOrientations, N = shapes.length, offset = tmpVec, orientation = tmpQuat, bodyQuat = this.quaternion, aabb = this.aabb, shapeAABB = computeAABB_shapeAABB;
            for (var i = 0; i !== N; i++) {
              var shape = shapes[i];
              bodyQuat.vmult(shapeOffsets[i], offset);
              offset.vadd(this.position, offset);
              shapeOrientations[i].mult(bodyQuat, orientation);
              shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);
              0 === i ? aabb.copy(shapeAABB) : aabb.extend(shapeAABB);
            }
            this.aabbNeedsUpdate = false;
          };
          var uiw_m1 = new Mat3(), uiw_m2 = new Mat3(), uiw_m3 = new Mat3();
          Body.prototype.updateInertiaWorld = function(force) {
            var I = this.invInertia;
            if (I.x !== I.y || I.y !== I.z || force) {
              var m1 = uiw_m1, m2 = uiw_m2, m3 = uiw_m3;
              m1.setRotationFromQuaternion(this.quaternion);
              m1.transpose(m2);
              m1.scale(I, m1);
              m1.mmult(m2, this.invInertiaWorld);
            } else ;
          };
          var Body_applyForce_r = new Vec3();
          var Body_applyForce_rotForce = new Vec3();
          Body.prototype.applyForce = function(force, relativePoint) {
            if (this.type !== Body.DYNAMIC) return;
            var rotForce = Body_applyForce_rotForce;
            relativePoint.cross(force, rotForce);
            this.force.vadd(force, this.force);
            this.torque.vadd(rotForce, this.torque);
          };
          var Body_applyLocalForce_worldForce = new Vec3();
          var Body_applyLocalForce_relativePointWorld = new Vec3();
          Body.prototype.applyLocalForce = function(localForce, localPoint) {
            if (this.type !== Body.DYNAMIC) return;
            var worldForce = Body_applyLocalForce_worldForce;
            var relativePointWorld = Body_applyLocalForce_relativePointWorld;
            this.vectorToWorldFrame(localForce, worldForce);
            this.vectorToWorldFrame(localPoint, relativePointWorld);
            this.applyForce(worldForce, relativePointWorld);
          };
          var Body_applyImpulse_r = new Vec3();
          var Body_applyImpulse_velo = new Vec3();
          var Body_applyImpulse_rotVelo = new Vec3();
          Body.prototype.applyImpulse = function(impulse, relativePoint) {
            if (this.type !== Body.DYNAMIC) return;
            var r = relativePoint;
            var velo = Body_applyImpulse_velo;
            velo.copy(impulse);
            velo.mult(this.invMass, velo);
            this.velocity.vadd(velo, this.velocity);
            var rotVelo = Body_applyImpulse_rotVelo;
            r.cross(impulse, rotVelo);
            this.invInertiaWorld.vmult(rotVelo, rotVelo);
            this.angularVelocity.vadd(rotVelo, this.angularVelocity);
          };
          var Body_applyLocalImpulse_worldImpulse = new Vec3();
          var Body_applyLocalImpulse_relativePoint = new Vec3();
          Body.prototype.applyLocalImpulse = function(localImpulse, localPoint) {
            if (this.type !== Body.DYNAMIC) return;
            var worldImpulse = Body_applyLocalImpulse_worldImpulse;
            var relativePointWorld = Body_applyLocalImpulse_relativePoint;
            this.vectorToWorldFrame(localImpulse, worldImpulse);
            this.vectorToWorldFrame(localPoint, relativePointWorld);
            this.applyImpulse(worldImpulse, relativePointWorld);
          };
          var Body_updateMassProperties_halfExtents = new Vec3();
          Body.prototype.updateMassProperties = function() {
            var halfExtents = Body_updateMassProperties_halfExtents;
            this.invMass = this.mass > 0 ? 1 / this.mass : 0;
            var I = this.inertia;
            var fixed = this.fixedRotation;
            this.computeAABB();
            halfExtents.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2);
            Box.calculateInertia(halfExtents, this.mass, I);
            this.invInertia.set(I.x > 0 && !fixed ? 1 / I.x : 0, I.y > 0 && !fixed ? 1 / I.y : 0, I.z > 0 && !fixed ? 1 / I.z : 0);
            this.updateInertiaWorld(true);
          };
          Body.prototype.getVelocityAtWorldPoint = function(worldPoint, result) {
            var r = new Vec3();
            worldPoint.vsub(this.position, r);
            this.angularVelocity.cross(r, result);
            this.velocity.vadd(result, result);
            return result;
          };
          var torque = new Vec3();
          var invI_tau_dt = new Vec3();
          var w = new Quaternion();
          var wq = new Quaternion();
          Body.prototype.integrate = function(dt, quatNormalize, quatNormalizeFast) {
            this.previousPosition.copy(this.position);
            this.previousQuaternion.copy(this.quaternion);
            if (!(this.type === Body.DYNAMIC || this.type === Body.KINEMATIC) || this.sleepState === Body.SLEEPING) return;
            var velo = this.velocity, angularVelo = this.angularVelocity, pos = this.position, force = this.force, torque = this.torque, quat = this.quaternion, invMass = this.invMass, invInertia = this.invInertiaWorld, linearFactor = this.linearFactor;
            var iMdt = invMass * dt;
            velo.x += force.x * iMdt * linearFactor.x;
            velo.y += force.y * iMdt * linearFactor.y;
            velo.z += force.z * iMdt * linearFactor.z;
            var e = invInertia.elements;
            var angularFactor = this.angularFactor;
            var tx = torque.x * angularFactor.x;
            var ty = torque.y * angularFactor.y;
            var tz = torque.z * angularFactor.z;
            angularVelo.x += dt * (e[0] * tx + e[1] * ty + e[2] * tz);
            angularVelo.y += dt * (e[3] * tx + e[4] * ty + e[5] * tz);
            angularVelo.z += dt * (e[6] * tx + e[7] * ty + e[8] * tz);
            pos.x += velo.x * dt;
            pos.y += velo.y * dt;
            pos.z += velo.z * dt;
            quat.integrate(this.angularVelocity, dt, this.angularFactor, quat);
            quatNormalize && (quatNormalizeFast ? quat.normalizeFast() : quat.normalize());
            this.aabbNeedsUpdate = true;
            this.updateInertiaWorld();
          };
          Body.prototype.isSleeping = function() {
            return this.sleepState === Body.SLEEPING;
          };
          Body.prototype.isSleepy = function() {
            return this.sleepState === Body.SLEEPY;
          };
          Body.prototype.isAwake = function() {
            return this.sleepState === Body.AWAKE;
          };
          Body.prototype.updateHasTrigger = function() {
            for (var i = this.shapes.length; i--; ) {
              this.hasTrigger = !this.shapes[i].collisionResponse;
              if (this.hasTrigger) break;
            }
          };
        }), {
          "../collision/AABB": 3,
          "../material/Material": 26,
          "../math/Mat3": 29,
          "../math/Quaternion": 30,
          "../math/Vec3": 32,
          "../shapes/Box": 39,
          "../shapes/Shape": 45,
          "../utils/EventTarget": 51,
          "../world/World": 58
        } ],
        34: [ (function(_dereq_, module, exports) {
          var Body = _dereq_("./Body");
          var Vec3 = _dereq_("../math/Vec3");
          var Quaternion = _dereq_("../math/Quaternion");
          var RaycastResult = _dereq_("../collision/RaycastResult");
          var Ray = _dereq_("../collision/Ray");
          var WheelInfo = _dereq_("../objects/WheelInfo");
          module.exports = RaycastVehicle;
          function RaycastVehicle(options) {
            this.chassisBody = options.chassisBody;
            this.wheelInfos = [];
            this.sliding = false;
            this.world = null;
            this.indexRightAxis = "undefined" !== typeof options.indexRightAxis ? options.indexRightAxis : 1;
            this.indexForwardAxis = "undefined" !== typeof options.indexForwardAxis ? options.indexForwardAxis : 0;
            this.indexUpAxis = "undefined" !== typeof options.indexUpAxis ? options.indexUpAxis : 2;
          }
          var tmpVec1 = new Vec3();
          var tmpVec2 = new Vec3();
          var tmpVec3 = new Vec3();
          var tmpVec4 = new Vec3();
          var tmpVec5 = new Vec3();
          var tmpVec6 = new Vec3();
          var tmpRay = new Ray();
          RaycastVehicle.prototype.addWheel = function(options) {
            options = options || {};
            var info = new WheelInfo(options);
            var index = this.wheelInfos.length;
            this.wheelInfos.push(info);
            return index;
          };
          RaycastVehicle.prototype.setSteeringValue = function(value, wheelIndex) {
            var wheel = this.wheelInfos[wheelIndex];
            wheel.steering = value;
          };
          var torque = new Vec3();
          RaycastVehicle.prototype.applyEngineForce = function(value, wheelIndex) {
            this.wheelInfos[wheelIndex].engineForce = value;
          };
          RaycastVehicle.prototype.setBrake = function(brake, wheelIndex) {
            this.wheelInfos[wheelIndex].brake = brake;
          };
          RaycastVehicle.prototype.addToWorld = function(world) {
            var constraints = this.constraints;
            world.addBody(this.chassisBody);
            var that = this;
            this.preStepCallback = function() {
              that.updateVehicle(world.dt);
            };
            world.addEventListener("preStep", this.preStepCallback);
            this.world = world;
          };
          RaycastVehicle.prototype.getVehicleAxisWorld = function(axisIndex, result) {
            result.set(0 === axisIndex ? 1 : 0, 1 === axisIndex ? 1 : 0, 2 === axisIndex ? 1 : 0);
            this.chassisBody.vectorToWorldFrame(result, result);
          };
          RaycastVehicle.prototype.updateVehicle = function(timeStep) {
            var wheelInfos = this.wheelInfos;
            var numWheels = wheelInfos.length;
            var chassisBody = this.chassisBody;
            for (var i = 0; i < numWheels; i++) this.updateWheelTransform(i);
            this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();
            var forwardWorld = new Vec3();
            this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);
            forwardWorld.dot(chassisBody.velocity) < 0 && (this.currentVehicleSpeedKmHour *= -1);
            for (var i = 0; i < numWheels; i++) this.castRay(wheelInfos[i]);
            this.updateSuspension(timeStep);
            var impulse = new Vec3();
            var relpos = new Vec3();
            for (var i = 0; i < numWheels; i++) {
              var wheel = wheelInfos[i];
              var suspensionForce = wheel.suspensionForce;
              suspensionForce > wheel.maxSuspensionForce && (suspensionForce = wheel.maxSuspensionForce);
              wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);
              wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
              chassisBody.applyImpulse(impulse, relpos);
            }
            this.updateFriction(timeStep);
            var hitNormalWorldScaledWithProj = new Vec3();
            var fwd = new Vec3();
            var vel = new Vec3();
            for (i = 0; i < numWheels; i++) {
              var wheel = wheelInfos[i];
              chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);
              var m = 1;
              switch (this.indexUpAxis) {
               case 1:
                m = -1;
              }
              if (wheel.isInContact) {
                this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
                var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
                wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);
                fwd.vsub(hitNormalWorldScaledWithProj, fwd);
                var proj2 = fwd.dot(vel);
                wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
              }
              !wheel.sliding && wheel.isInContact || 0 === wheel.engineForce || !wheel.useCustomSlidingRotationalSpeed || (wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep);
              Math.abs(wheel.brake) > Math.abs(wheel.engineForce) && (wheel.deltaRotation = 0);
              wheel.rotation += wheel.deltaRotation;
              wheel.deltaRotation *= .99;
            }
          };
          RaycastVehicle.prototype.updateSuspension = function(deltaTime) {
            var chassisBody = this.chassisBody;
            var chassisMass = chassisBody.mass;
            var wheelInfos = this.wheelInfos;
            var numWheels = wheelInfos.length;
            for (var w_it = 0; w_it < numWheels; w_it++) {
              var wheel = wheelInfos[w_it];
              if (wheel.isInContact) {
                var force;
                var susp_length = wheel.suspensionRestLength;
                var current_length = wheel.suspensionLength;
                var length_diff = susp_length - current_length;
                force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;
                var projected_rel_vel = wheel.suspensionRelativeVelocity;
                var susp_damping;
                susp_damping = projected_rel_vel < 0 ? wheel.dampingCompression : wheel.dampingRelaxation;
                force -= susp_damping * projected_rel_vel;
                wheel.suspensionForce = force * chassisMass;
                wheel.suspensionForce < 0 && (wheel.suspensionForce = 0);
              } else wheel.suspensionForce = 0;
            }
          };
          RaycastVehicle.prototype.removeFromWorld = function(world) {
            var constraints = this.constraints;
            world.remove(this.chassisBody);
            world.removeEventListener("preStep", this.preStepCallback);
            this.world = null;
          };
          var castRay_rayvector = new Vec3();
          var castRay_target = new Vec3();
          RaycastVehicle.prototype.castRay = function(wheel) {
            var rayvector = castRay_rayvector;
            var target = castRay_target;
            this.updateWheelTransformWorld(wheel);
            var chassisBody = this.chassisBody;
            var depth = -1;
            var raylen = wheel.suspensionRestLength + wheel.radius;
            wheel.directionWorld.scale(raylen, rayvector);
            var source = wheel.chassisConnectionPointWorld;
            source.vadd(rayvector, target);
            var raycastResult = wheel.raycastResult;
            var param = 0;
            raycastResult.reset();
            var oldState = chassisBody.collisionResponse;
            chassisBody.collisionResponse = false;
            this.world.rayTest(source, target, raycastResult);
            chassisBody.collisionResponse = oldState;
            var object = raycastResult.body;
            wheel.raycastResult.groundObject = 0;
            if (object) {
              depth = raycastResult.distance;
              wheel.raycastResult.hitNormalWorld = raycastResult.hitNormalWorld;
              wheel.isInContact = true;
              var hitDistance = raycastResult.distance;
              wheel.suspensionLength = hitDistance - wheel.radius;
              var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
              var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;
              wheel.suspensionLength < minSuspensionLength && (wheel.suspensionLength = minSuspensionLength);
              if (wheel.suspensionLength > maxSuspensionLength) {
                wheel.suspensionLength = maxSuspensionLength;
                wheel.raycastResult.reset();
              }
              var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);
              var chassis_velocity_at_contactPoint = new Vec3();
              chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);
              var projVel = wheel.raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);
              if (denominator >= -.1) {
                wheel.suspensionRelativeVelocity = 0;
                wheel.clippedInvContactDotSuspension = 10;
              } else {
                var inv = -1 / denominator;
                wheel.suspensionRelativeVelocity = projVel * inv;
                wheel.clippedInvContactDotSuspension = inv;
              }
            } else {
              wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
              wheel.suspensionRelativeVelocity = 0;
              wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
              wheel.clippedInvContactDotSuspension = 1;
            }
            return depth;
          };
          RaycastVehicle.prototype.updateWheelTransformWorld = function(wheel) {
            wheel.isInContact = false;
            var chassisBody = this.chassisBody;
            chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
            chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
            chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
          };
          RaycastVehicle.prototype.updateWheelTransform = function(wheelIndex) {
            var up = tmpVec4;
            var right = tmpVec5;
            var fwd = tmpVec6;
            var wheel = this.wheelInfos[wheelIndex];
            this.updateWheelTransformWorld(wheel);
            wheel.directionLocal.scale(-1, up);
            right.copy(wheel.axleLocal);
            up.cross(right, fwd);
            fwd.normalize();
            right.normalize();
            var steering = wheel.steering;
            var steeringOrn = new Quaternion();
            steeringOrn.setFromAxisAngle(up, steering);
            var rotatingOrn = new Quaternion();
            rotatingOrn.setFromAxisAngle(right, wheel.rotation);
            var q = wheel.worldTransform.quaternion;
            this.chassisBody.quaternion.mult(steeringOrn, q);
            q.mult(rotatingOrn, q);
            q.normalize();
            var p = wheel.worldTransform.position;
            p.copy(wheel.directionWorld);
            p.scale(wheel.suspensionLength, p);
            p.vadd(wheel.chassisConnectionPointWorld, p);
          };
          var directions = [ new Vec3(1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, 0, 1) ];
          RaycastVehicle.prototype.getWheelTransformWorld = function(wheelIndex) {
            return this.wheelInfos[wheelIndex].worldTransform;
          };
          var updateFriction_surfNormalWS_scaled_proj = new Vec3();
          var updateFriction_axle = [];
          var updateFriction_forwardWS = [];
          var sideFrictionStiffness2 = 1;
          RaycastVehicle.prototype.updateFriction = function(timeStep) {
            var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;
            var wheelInfos = this.wheelInfos;
            var numWheels = wheelInfos.length;
            var chassisBody = this.chassisBody;
            var forwardWS = updateFriction_forwardWS;
            var axle = updateFriction_axle;
            var numWheelsOnGround = 0;
            for (var i = 0; i < numWheels; i++) {
              var wheel = wheelInfos[i];
              var groundObject = wheel.raycastResult.body;
              groundObject && numWheelsOnGround++;
              wheel.sideImpulse = 0;
              wheel.forwardImpulse = 0;
              forwardWS[i] || (forwardWS[i] = new Vec3());
              axle[i] || (axle[i] = new Vec3());
            }
            for (var i = 0; i < numWheels; i++) {
              var wheel = wheelInfos[i];
              var groundObject = wheel.raycastResult.body;
              if (groundObject) {
                var axlei = axle[i];
                var wheelTrans = this.getWheelTransformWorld(i);
                wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);
                var surfNormalWS = wheel.raycastResult.hitNormalWorld;
                var proj = axlei.dot(surfNormalWS);
                surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
                axlei.vsub(surfNormalWS_scaled_proj, axlei);
                axlei.normalize();
                surfNormalWS.cross(axlei, forwardWS[i]);
                forwardWS[i].normalize();
                wheel.sideImpulse = resolveSingleBilateral(chassisBody, wheel.raycastResult.hitPointWorld, groundObject, wheel.raycastResult.hitPointWorld, axlei);
                wheel.sideImpulse *= sideFrictionStiffness2;
              }
            }
            var sideFactor = 1;
            var fwdFactor = .5;
            this.sliding = false;
            for (var i = 0; i < numWheels; i++) {
              var wheel = wheelInfos[i];
              var groundObject = wheel.raycastResult.body;
              var rollingFriction = 0;
              wheel.slipInfo = 1;
              if (groundObject) {
                var defaultRollingFrictionImpulse = 0;
                var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;
                rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);
                rollingFriction += wheel.engineForce * timeStep;
                var factor = maxImpulse / rollingFriction;
                wheel.slipInfo *= factor;
              }
              wheel.forwardImpulse = 0;
              wheel.skidInfo = 1;
              if (groundObject) {
                wheel.skidInfo = 1;
                var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
                var maximpSide = maximp;
                var maximpSquared = maximp * maximpSide;
                wheel.forwardImpulse = rollingFriction;
                var x = wheel.forwardImpulse * fwdFactor;
                var y = wheel.sideImpulse * sideFactor;
                var impulseSquared = x * x + y * y;
                wheel.sliding = false;
                if (impulseSquared > maximpSquared) {
                  this.sliding = true;
                  wheel.sliding = true;
                  var factor = maximp / Math.sqrt(impulseSquared);
                  wheel.skidInfo *= factor;
                }
              }
            }
            if (this.sliding) for (var i = 0; i < numWheels; i++) {
              var wheel = wheelInfos[i];
              if (0 !== wheel.sideImpulse && wheel.skidInfo < 1) {
                wheel.forwardImpulse *= wheel.skidInfo;
                wheel.sideImpulse *= wheel.skidInfo;
              }
            }
            for (var i = 0; i < numWheels; i++) {
              var wheel = wheelInfos[i];
              var rel_pos = new Vec3();
              wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos);
              if (0 !== wheel.forwardImpulse) {
                var impulse = new Vec3();
                forwardWS[i].scale(wheel.forwardImpulse, impulse);
                chassisBody.applyImpulse(impulse, rel_pos);
              }
              if (0 !== wheel.sideImpulse) {
                var groundObject = wheel.raycastResult.body;
                var rel_pos2 = new Vec3();
                wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2);
                var sideImp = new Vec3();
                axle[i].scale(wheel.sideImpulse, sideImp);
                chassisBody.vectorToLocalFrame(rel_pos, rel_pos);
                rel_pos["xyz"[this.indexUpAxis]] *= wheel.rollInfluence;
                chassisBody.vectorToWorldFrame(rel_pos, rel_pos);
                chassisBody.applyImpulse(sideImp, rel_pos);
                sideImp.scale(-1, sideImp);
                groundObject.applyImpulse(sideImp, rel_pos2);
              }
            }
          };
          var calcRollingFriction_vel1 = new Vec3();
          var calcRollingFriction_vel2 = new Vec3();
          var calcRollingFriction_vel = new Vec3();
          function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
            var j1 = 0;
            var contactPosWorld = frictionPosWorld;
            var vel1 = calcRollingFriction_vel1;
            var vel2 = calcRollingFriction_vel2;
            var vel = calcRollingFriction_vel;
            body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
            body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
            vel1.vsub(vel2, vel);
            var vrel = frictionDirectionWorld.dot(vel);
            var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
            var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
            var relaxation = 1;
            var jacDiagABInv = relaxation / (denom0 + denom1);
            j1 = -vrel * jacDiagABInv;
            maxImpulse < j1 && (j1 = maxImpulse);
            j1 < -maxImpulse && (j1 = -maxImpulse);
            return j1;
          }
          var computeImpulseDenominator_r0 = new Vec3();
          var computeImpulseDenominator_c0 = new Vec3();
          var computeImpulseDenominator_vec = new Vec3();
          var computeImpulseDenominator_m = new Vec3();
          function computeImpulseDenominator(body, pos, normal) {
            var r0 = computeImpulseDenominator_r0;
            var c0 = computeImpulseDenominator_c0;
            var vec = computeImpulseDenominator_vec;
            var m = computeImpulseDenominator_m;
            pos.vsub(body.position, r0);
            r0.cross(normal, c0);
            body.invInertiaWorld.vmult(c0, m);
            m.cross(r0, vec);
            return body.invMass + normal.dot(vec);
          }
          var resolveSingleBilateral_vel1 = new Vec3();
          var resolveSingleBilateral_vel2 = new Vec3();
          var resolveSingleBilateral_vel = new Vec3();
          function resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse) {
            var normalLenSqr = normal.norm2();
            if (normalLenSqr > 1.1) return 0;
            var vel1 = resolveSingleBilateral_vel1;
            var vel2 = resolveSingleBilateral_vel2;
            var vel = resolveSingleBilateral_vel;
            body1.getVelocityAtWorldPoint(pos1, vel1);
            body2.getVelocityAtWorldPoint(pos2, vel2);
            vel1.vsub(vel2, vel);
            var rel_vel = normal.dot(vel);
            var contactDamping = .2;
            var massTerm = 1 / (body1.invMass + body2.invMass);
            var impulse = -contactDamping * rel_vel * massTerm;
            return impulse;
          }
        }), {
          "../collision/Ray": 10,
          "../collision/RaycastResult": 11,
          "../math/Quaternion": 30,
          "../math/Vec3": 32,
          "../objects/WheelInfo": 38,
          "./Body": 33
        } ],
        35: [ (function(_dereq_, module, exports) {
          var Body = _dereq_("./Body");
          var Sphere = _dereq_("../shapes/Sphere");
          var Box = _dereq_("../shapes/Box");
          var Vec3 = _dereq_("../math/Vec3");
          var HingeConstraint = _dereq_("../constraints/HingeConstraint");
          var CMath = _dereq_("../math/CMath");
          module.exports = RigidVehicle;
          function RigidVehicle(options) {
            this.wheelBodies = [];
            this.coordinateSystem = "undefined" === typeof options.coordinateSystem ? new Vec3(1, 2, 3) : options.coordinateSystem.clone();
            this.chassisBody = options.chassisBody;
            if (!this.chassisBody) {
              var chassisShape = new Box(new Vec3(5, 2, .5));
              this.chassisBody = new Body(1, chassisShape);
            }
            this.constraints = [];
            this.wheelAxes = [];
            this.wheelForces = [];
          }
          RigidVehicle.prototype.addWheel = function(options) {
            options = options || {};
            var wheelBody = options.body;
            wheelBody || (wheelBody = new Body(1, new Sphere(1.2)));
            this.wheelBodies.push(wheelBody);
            this.wheelForces.push(0);
            var zero = new Vec3();
            var position = "undefined" !== typeof options.position ? options.position.clone() : new Vec3();
            var worldPosition = new Vec3();
            this.chassisBody.pointToWorldFrame(position, worldPosition);
            wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z);
            var axis = "undefined" !== typeof options.axis ? options.axis.clone() : new Vec3(0, 1, 0);
            this.wheelAxes.push(axis);
            var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
              pivotA: position,
              axisA: axis,
              pivotB: Vec3.ZERO,
              axisB: axis,
              collideConnected: false
            });
            this.constraints.push(hingeConstraint);
            return this.wheelBodies.length - 1;
          };
          RigidVehicle.prototype.setSteeringValue = function(value, wheelIndex) {
            var axis = this.wheelAxes[wheelIndex];
            var c = CMath.cos(value), s = CMath.sin(value), x = axis.x, y = axis.y;
            this.constraints[wheelIndex].axisA.set(c * x - s * y, s * x + c * y, 0);
          };
          RigidVehicle.prototype.setMotorSpeed = function(value, wheelIndex) {
            var hingeConstraint = this.constraints[wheelIndex];
            hingeConstraint.enableMotor();
            hingeConstraint.motorTargetVelocity = value;
          };
          RigidVehicle.prototype.disableMotor = function(wheelIndex) {
            var hingeConstraint = this.constraints[wheelIndex];
            hingeConstraint.disableMotor();
          };
          var torque = new Vec3();
          RigidVehicle.prototype.setWheelForce = function(value, wheelIndex) {
            this.wheelForces[wheelIndex] = value;
          };
          RigidVehicle.prototype.applyWheelForce = function(value, wheelIndex) {
            var axis = this.wheelAxes[wheelIndex];
            var wheelBody = this.wheelBodies[wheelIndex];
            var bodyTorque = wheelBody.torque;
            axis.scale(value, torque);
            wheelBody.vectorToWorldFrame(torque, torque);
            bodyTorque.vadd(torque, bodyTorque);
          };
          RigidVehicle.prototype.addToWorld = function(world) {
            var constraints = this.constraints;
            var bodies = this.wheelBodies.concat([ this.chassisBody ]);
            for (var i = 0; i < bodies.length; i++) world.addBody(bodies[i]);
            for (var i = 0; i < constraints.length; i++) world.addConstraint(constraints[i]);
            world.addEventListener("preStep", this._update.bind(this));
          };
          RigidVehicle.prototype._update = function() {
            var wheelForces = this.wheelForces;
            for (var i = 0; i < wheelForces.length; i++) this.applyWheelForce(wheelForces[i], i);
          };
          RigidVehicle.prototype.removeFromWorld = function(world) {
            var constraints = this.constraints;
            var bodies = this.wheelBodies.concat([ this.chassisBody ]);
            for (var i = 0; i < bodies.length; i++) world.remove(bodies[i]);
            for (var i = 0; i < constraints.length; i++) world.removeConstraint(constraints[i]);
          };
          var worldAxis = new Vec3();
          RigidVehicle.prototype.getWheelSpeed = function(wheelIndex) {
            var axis = this.wheelAxes[wheelIndex];
            var wheelBody = this.wheelBodies[wheelIndex];
            var w = wheelBody.angularVelocity;
            this.chassisBody.vectorToWorldFrame(axis, worldAxis);
            return w.dot(worldAxis);
          };
        }), {
          "../constraints/HingeConstraint": 16,
          "../math/CMath": 27,
          "../math/Vec3": 32,
          "../shapes/Box": 39,
          "../shapes/Sphere": 46,
          "./Body": 33
        } ],
        36: [ (function(_dereq_, module, exports) {
          module.exports = SPHSystem;
          var Shape = _dereq_("../shapes/Shape");
          var Vec3 = _dereq_("../math/Vec3");
          var Quaternion = _dereq_("../math/Quaternion");
          var Particle = _dereq_("../shapes/Particle");
          var Body = _dereq_("../objects/Body");
          var Material = _dereq_("../material/Material");
          function SPHSystem() {
            this.particles = [];
            this.density = 1;
            this.smoothingRadius = 1;
            this.speedOfSound = 1;
            this.viscosity = .01;
            this.eps = 1e-6;
            this.pressures = [];
            this.densities = [];
            this.neighbors = [];
          }
          SPHSystem.prototype.add = function(particle) {
            this.particles.push(particle);
            this.neighbors.length < this.particles.length && this.neighbors.push([]);
          };
          SPHSystem.prototype.remove = function(particle) {
            var idx = this.particles.indexOf(particle);
            if (-1 !== idx) {
              this.particles.splice(idx, 1);
              this.neighbors.length > this.particles.length && this.neighbors.pop();
            }
          };
          var SPHSystem_getNeighbors_dist = new Vec3();
          SPHSystem.prototype.getNeighbors = function(particle, neighbors) {
            var N = this.particles.length, id = particle.id, R2 = this.smoothingRadius * this.smoothingRadius, dist = SPHSystem_getNeighbors_dist;
            for (var i = 0; i !== N; i++) {
              var p = this.particles[i];
              p.position.vsub(particle.position, dist);
              id !== p.id && dist.norm2() < R2 && neighbors.push(p);
            }
          };
          var SPHSystem_update_dist = new Vec3(), SPHSystem_update_a_pressure = new Vec3(), SPHSystem_update_a_visc = new Vec3(), SPHSystem_update_gradW = new Vec3(), SPHSystem_update_r_vec = new Vec3(), SPHSystem_update_u = new Vec3();
          SPHSystem.prototype.update = function() {
            var N = this.particles.length, dist = SPHSystem_update_dist, cs = this.speedOfSound, eps = this.eps;
            for (var i = 0; i !== N; i++) {
              var p = this.particles[i];
              var neighbors = this.neighbors[i];
              neighbors.length = 0;
              this.getNeighbors(p, neighbors);
              neighbors.push(this.particles[i]);
              var numNeighbors = neighbors.length;
              var sum = 0;
              for (var j = 0; j !== numNeighbors; j++) {
                p.position.vsub(neighbors[j].position, dist);
                var len = dist.norm();
                var weight = this.w(len);
                sum += neighbors[j].mass * weight;
              }
              this.densities[i] = sum;
              this.pressures[i] = cs * cs * (this.densities[i] - this.density);
            }
            var a_pressure = SPHSystem_update_a_pressure;
            var a_visc = SPHSystem_update_a_visc;
            var gradW = SPHSystem_update_gradW;
            var r_vec = SPHSystem_update_r_vec;
            var u = SPHSystem_update_u;
            for (var i = 0; i !== N; i++) {
              var particle = this.particles[i];
              a_pressure.set(0, 0, 0);
              a_visc.set(0, 0, 0);
              var Pij;
              var nabla;
              var Vij;
              var neighbors = this.neighbors[i];
              var numNeighbors = neighbors.length;
              for (var j = 0; j !== numNeighbors; j++) {
                var neighbor = neighbors[j];
                particle.position.vsub(neighbor.position, r_vec);
                var r = r_vec.norm();
                Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i] * this.densities[i] + eps) + this.pressures[j] / (this.densities[j] * this.densities[j] + eps));
                this.gradw(r_vec, gradW);
                gradW.mult(Pij, gradW);
                a_pressure.vadd(gradW, a_pressure);
                neighbor.velocity.vsub(particle.velocity, u);
                u.mult(1 / (1e-4 + this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass, u);
                nabla = this.nablaw(r);
                u.mult(nabla, u);
                a_visc.vadd(u, a_visc);
              }
              a_visc.mult(particle.mass, a_visc);
              a_pressure.mult(particle.mass, a_pressure);
              particle.force.vadd(a_visc, particle.force);
              particle.force.vadd(a_pressure, particle.force);
            }
          };
          SPHSystem.prototype.w = function(r) {
            var h = this.smoothingRadius;
            return 315 / (64 * Math.PI * Math.pow(h, 9)) * Math.pow(h * h - r * r, 3);
          };
          SPHSystem.prototype.gradw = function(rVec, resultVec) {
            var r = rVec.norm(), h = this.smoothingRadius;
            rVec.mult(945 / (32 * Math.PI * Math.pow(h, 9)) * Math.pow(h * h - r * r, 2), resultVec);
          };
          SPHSystem.prototype.nablaw = function(r) {
            var h = this.smoothingRadius;
            var nabla = 945 / (32 * Math.PI * Math.pow(h, 9)) * (h * h - r * r) * (7 * r * r - 3 * h * h);
            return nabla;
          };
        }), {
          "../material/Material": 26,
          "../math/Quaternion": 30,
          "../math/Vec3": 32,
          "../objects/Body": 33,
          "../shapes/Particle": 43,
          "../shapes/Shape": 45
        } ],
        37: [ (function(_dereq_, module, exports) {
          var Vec3 = _dereq_("../math/Vec3");
          module.exports = Spring;
          function Spring(bodyA, bodyB, options) {
            options = options || {};
            this.restLength = "number" === typeof options.restLength ? options.restLength : 1;
            this.stiffness = options.stiffness || 100;
            this.damping = options.damping || 1;
            this.bodyA = bodyA;
            this.bodyB = bodyB;
            this.localAnchorA = new Vec3();
            this.localAnchorB = new Vec3();
            options.localAnchorA && this.localAnchorA.copy(options.localAnchorA);
            options.localAnchorB && this.localAnchorB.copy(options.localAnchorB);
            options.worldAnchorA && this.setWorldAnchorA(options.worldAnchorA);
            options.worldAnchorB && this.setWorldAnchorB(options.worldAnchorB);
          }
          Spring.prototype.setWorldAnchorA = function(worldAnchorA) {
            this.bodyA.pointToLocalFrame(worldAnchorA, this.localAnchorA);
          };
          Spring.prototype.setWorldAnchorB = function(worldAnchorB) {
            this.bodyB.pointToLocalFrame(worldAnchorB, this.localAnchorB);
          };
          Spring.prototype.getWorldAnchorA = function(result) {
            this.bodyA.pointToWorldFrame(this.localAnchorA, result);
          };
          Spring.prototype.getWorldAnchorB = function(result) {
            this.bodyB.pointToWorldFrame(this.localAnchorB, result);
          };
          var applyForce_r = new Vec3(), applyForce_r_unit = new Vec3(), applyForce_u = new Vec3(), applyForce_f = new Vec3(), applyForce_worldAnchorA = new Vec3(), applyForce_worldAnchorB = new Vec3(), applyForce_ri = new Vec3(), applyForce_rj = new Vec3(), applyForce_ri_x_f = new Vec3(), applyForce_rj_x_f = new Vec3(), applyForce_tmp = new Vec3();
          Spring.prototype.applyForce = function() {
            var k = this.stiffness, d = this.damping, l = this.restLength, bodyA = this.bodyA, bodyB = this.bodyB, r = applyForce_r, r_unit = applyForce_r_unit, u = applyForce_u, f = applyForce_f, tmp = applyForce_tmp;
            var worldAnchorA = applyForce_worldAnchorA, worldAnchorB = applyForce_worldAnchorB, ri = applyForce_ri, rj = applyForce_rj, ri_x_f = applyForce_ri_x_f, rj_x_f = applyForce_rj_x_f;
            this.getWorldAnchorA(worldAnchorA);
            this.getWorldAnchorB(worldAnchorB);
            worldAnchorA.vsub(bodyA.position, ri);
            worldAnchorB.vsub(bodyB.position, rj);
            worldAnchorB.vsub(worldAnchorA, r);
            var rlen = r.norm();
            r_unit.copy(r);
            r_unit.normalize();
            bodyB.velocity.vsub(bodyA.velocity, u);
            bodyB.angularVelocity.cross(rj, tmp);
            u.vadd(tmp, u);
            bodyA.angularVelocity.cross(ri, tmp);
            u.vsub(tmp, u);
            r_unit.mult(-k * (rlen - l) - d * u.dot(r_unit), f);
            bodyA.force.vsub(f, bodyA.force);
            bodyB.force.vadd(f, bodyB.force);
            ri.cross(f, ri_x_f);
            rj.cross(f, rj_x_f);
            bodyA.torque.vsub(ri_x_f, bodyA.torque);
            bodyB.torque.vadd(rj_x_f, bodyB.torque);
          };
        }), {
          "../math/Vec3": 32
        } ],
        38: [ (function(_dereq_, module, exports) {
          var Vec3 = _dereq_("../math/Vec3");
          var Transform = _dereq_("../math/Transform");
          var RaycastResult = _dereq_("../collision/RaycastResult");
          var Utils = _dereq_("../utils/Utils");
          module.exports = WheelInfo;
          function WheelInfo(options) {
            options = Utils.defaults(options, {
              chassisConnectionPointLocal: new Vec3(),
              chassisConnectionPointWorld: new Vec3(),
              directionLocal: new Vec3(),
              directionWorld: new Vec3(),
              axleLocal: new Vec3(),
              axleWorld: new Vec3(),
              suspensionRestLength: 1,
              suspensionMaxLength: 2,
              radius: 1,
              suspensionStiffness: 100,
              dampingCompression: 10,
              dampingRelaxation: 10,
              frictionSlip: 1e4,
              steering: 0,
              rotation: 0,
              deltaRotation: 0,
              rollInfluence: .01,
              maxSuspensionForce: Number.MAX_VALUE,
              isFrontWheel: true,
              clippedInvContactDotSuspension: 1,
              suspensionRelativeVelocity: 0,
              suspensionForce: 0,
              skidInfo: 0,
              suspensionLength: 0,
              maxSuspensionTravel: 1,
              useCustomSlidingRotationalSpeed: false,
              customSlidingRotationalSpeed: -.1
            });
            this.maxSuspensionTravel = options.maxSuspensionTravel;
            this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;
            this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;
            this.sliding = false;
            this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();
            this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();
            this.directionLocal = options.directionLocal.clone();
            this.directionWorld = options.directionWorld.clone();
            this.axleLocal = options.axleLocal.clone();
            this.axleWorld = options.axleWorld.clone();
            this.suspensionRestLength = options.suspensionRestLength;
            this.suspensionMaxLength = options.suspensionMaxLength;
            this.radius = options.radius;
            this.suspensionStiffness = options.suspensionStiffness;
            this.dampingCompression = options.dampingCompression;
            this.dampingRelaxation = options.dampingRelaxation;
            this.frictionSlip = options.frictionSlip;
            this.steering = 0;
            this.rotation = 0;
            this.deltaRotation = 0;
            this.rollInfluence = options.rollInfluence;
            this.maxSuspensionForce = options.maxSuspensionForce;
            this.engineForce = 0;
            this.brake = 0;
            this.isFrontWheel = options.isFrontWheel;
            this.clippedInvContactDotSuspension = 1;
            this.suspensionRelativeVelocity = 0;
            this.suspensionForce = 0;
            this.skidInfo = 0;
            this.suspensionLength = 0;
            this.sideImpulse = 0;
            this.forwardImpulse = 0;
            this.raycastResult = new RaycastResult();
            this.worldTransform = new Transform();
            this.isInContact = false;
          }
          var chassis_velocity_at_contactPoint = new Vec3();
          var relpos = new Vec3();
          var chassis_velocity_at_contactPoint = new Vec3();
          WheelInfo.prototype.updateWheel = function(chassis) {
            var raycastResult = this.raycastResult;
            if (this.isInContact) {
              var project = raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
              raycastResult.hitPointWorld.vsub(chassis.position, relpos);
              chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
              var projVel = raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);
              if (project >= -.1) {
                this.suspensionRelativeVelocity = 0;
                this.clippedInvContactDotSuspension = 10;
              } else {
                var inv = -1 / project;
                this.suspensionRelativeVelocity = projVel * inv;
                this.clippedInvContactDotSuspension = inv;
              }
            } else {
              raycastResult.suspensionLength = this.suspensionRestLength;
              this.suspensionRelativeVelocity = 0;
              raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
              this.clippedInvContactDotSuspension = 1;
            }
          };
        }), {
          "../collision/RaycastResult": 11,
          "../math/Transform": 31,
          "../math/Vec3": 32,
          "../utils/Utils": 55
        } ],
        39: [ (function(_dereq_, module, exports) {
          module.exports = Box;
          var Shape = _dereq_("./Shape");
          var Vec3 = _dereq_("../math/Vec3");
          var ConvexPolyhedron = _dereq_("./ConvexPolyhedron");
          function Box(halfExtents) {
            Shape.call(this, {
              type: Shape.types.BOX
            });
            this.halfExtents = halfExtents;
            this.convexPolyhedronRepresentation = null;
            this.updateConvexPolyhedronRepresentation();
            this.updateBoundingSphereRadius();
          }
          Box.prototype = new Shape();
          Box.prototype.constructor = Box;
          Box.prototype.updateConvexPolyhedronRepresentation = function() {
            var sx = this.halfExtents.x;
            var sy = this.halfExtents.y;
            var sz = this.halfExtents.z;
            var V = Vec3;
            var vertices = [ new V(-sx, -sy, -sz), new V(sx, -sy, -sz), new V(sx, sy, -sz), new V(-sx, sy, -sz), new V(-sx, -sy, sz), new V(sx, -sy, sz), new V(sx, sy, sz), new V(-sx, sy, sz) ];
            var indices = [ [ 3, 2, 1, 0 ], [ 4, 5, 6, 7 ], [ 5, 4, 0, 1 ], [ 2, 3, 7, 6 ], [ 0, 4, 7, 3 ], [ 1, 2, 6, 5 ] ];
            var axes = [ new V(0, 0, 1), new V(0, 1, 0), new V(1, 0, 0) ];
            var h = new ConvexPolyhedron(vertices, indices);
            this.convexPolyhedronRepresentation = h;
            h.material = this.material;
          };
          Box.prototype.calculateLocalInertia = function(mass, target) {
            target = target || new Vec3();
            Box.calculateInertia(this.halfExtents, mass, target);
            return target;
          };
          Box.calculateInertia = function(halfExtents, mass, target) {
            var e = halfExtents;
            if (e.isZero()) {
              target.x = 2 / 12 * mass;
              target.y = 2 / 12 * mass;
              target.z = 2 / 12 * mass;
            } else {
              target.x = 1 / 12 * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z);
              target.y = 1 / 12 * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z);
              target.z = 1 / 12 * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);
            }
          };
          Box.prototype.getSideNormals = function(sixTargetVectors, quat) {
            var sides = sixTargetVectors;
            var ex = this.halfExtents;
            sides[0].set(ex.x, 0, 0);
            sides[1].set(0, ex.y, 0);
            sides[2].set(0, 0, ex.z);
            sides[3].set(-ex.x, 0, 0);
            sides[4].set(0, -ex.y, 0);
            sides[5].set(0, 0, -ex.z);
            if (void 0 !== quat) for (var i = 0; i !== sides.length; i++) quat.vmult(sides[i], sides[i]);
            return sides;
          };
          Box.prototype.volume = function() {
            return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
          };
          Box.prototype.updateBoundingSphereRadius = function() {
            this.boundingSphereRadius = this.halfExtents.norm();
          };
          var worldCornerTempPos = new Vec3();
          var worldCornerTempNeg = new Vec3();
          Box.prototype.forEachWorldCorner = function(pos, quat, callback) {
            var e = this.halfExtents;
            var corners = [ [ e.x, e.y, e.z ], [ -e.x, e.y, e.z ], [ -e.x, -e.y, e.z ], [ -e.x, -e.y, -e.z ], [ e.x, -e.y, -e.z ], [ e.x, e.y, -e.z ], [ -e.x, e.y, -e.z ], [ e.x, -e.y, e.z ] ];
            for (var i = 0; i < corners.length; i++) {
              worldCornerTempPos.set(corners[i][0], corners[i][1], corners[i][2]);
              quat.vmult(worldCornerTempPos, worldCornerTempPos);
              pos.vadd(worldCornerTempPos, worldCornerTempPos);
              callback(worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z);
            }
          };
          var worldCornersTemp = [ new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3() ];
          Box.prototype.calculateWorldAABB = function(pos, quat, min, max) {
            var e = this.halfExtents;
            worldCornersTemp[0].set(e.x, e.y, e.z);
            worldCornersTemp[1].set(-e.x, e.y, e.z);
            worldCornersTemp[2].set(-e.x, -e.y, e.z);
            worldCornersTemp[3].set(-e.x, -e.y, -e.z);
            worldCornersTemp[4].set(e.x, -e.y, -e.z);
            worldCornersTemp[5].set(e.x, e.y, -e.z);
            worldCornersTemp[6].set(-e.x, e.y, -e.z);
            worldCornersTemp[7].set(e.x, -e.y, e.z);
            var wc = worldCornersTemp[0];
            quat.vmult(wc, wc);
            pos.vadd(wc, wc);
            max.copy(wc);
            min.copy(wc);
            for (var i = 1; i < 8; i++) {
              var wc = worldCornersTemp[i];
              quat.vmult(wc, wc);
              pos.vadd(wc, wc);
              var x = wc.x;
              var y = wc.y;
              var z = wc.z;
              x > max.x && (max.x = x);
              y > max.y && (max.y = y);
              z > max.z && (max.z = z);
              x < min.x && (min.x = x);
              y < min.y && (min.y = y);
              z < min.z && (min.z = z);
            }
          };
        }), {
          "../math/Vec3": 32,
          "./ConvexPolyhedron": 40,
          "./Shape": 45
        } ],
        40: [ (function(_dereq_, module, exports) {
          module.exports = ConvexPolyhedron;
          var Shape = _dereq_("./Shape");
          var Vec3 = _dereq_("../math/Vec3");
          var Quaternion = _dereq_("../math/Quaternion");
          var Transform = _dereq_("../math/Transform");
          function ConvexPolyhedron(points, faces, uniqueAxes) {
            Shape.call(this, {
              type: Shape.types.CONVEXPOLYHEDRON
            });
            this.vertices = points || [];
            this.worldVertices = [];
            this.worldVerticesNeedsUpdate = true;
            this.faces = faces || [];
            this.faceNormals = [];
            this.computeNormals();
            this.worldFaceNormalsNeedsUpdate = true;
            this.worldFaceNormals = [];
            this.uniqueEdges = [];
            this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;
            this.computeEdges();
            this.updateBoundingSphereRadius();
          }
          ConvexPolyhedron.prototype = new Shape();
          ConvexPolyhedron.prototype.constructor = ConvexPolyhedron;
          var computeEdges_tmpEdge = new Vec3();
          ConvexPolyhedron.prototype.computeEdges = function() {
            var faces = this.faces;
            var vertices = this.vertices;
            var nv = vertices.length;
            var edges = this.uniqueEdges;
            edges.length = 0;
            var edge = computeEdges_tmpEdge;
            for (var i = 0; i !== faces.length; i++) {
              var face = faces[i];
              var numVertices = face.length;
              for (var j = 0; j !== numVertices; j++) {
                var k = (j + 1) % numVertices;
                vertices[face[j]].vsub(vertices[face[k]], edge);
                edge.normalize();
                var found = false;
                for (var p = 0; p !== edges.length; p++) if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {
                  found = true;
                  break;
                }
                found || edges.push(edge.clone());
              }
            }
          };
          ConvexPolyhedron.prototype.computeNormals = function() {
            this.faceNormals.length = this.faces.length;
            for (var i = 0; i < this.faces.length; i++) {
              for (var j = 0; j < this.faces[i].length; j++) if (!this.vertices[this.faces[i][j]]) throw new Error("Vertex " + this.faces[i][j] + " not found!");
              var n = this.faceNormals[i] || new Vec3();
              this.getFaceNormal(i, n);
              n.negate(n);
              this.faceNormals[i] = n;
              var vertex = this.vertices[this.faces[i][0]];
              if (n.dot(vertex) < 0) {
                console.error(".faceNormals[" + i + "] = Vec3(" + n.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");
                for (var j = 0; j < this.faces[i].length; j++) console.warn(".vertices[" + this.faces[i][j] + "] = Vec3(" + this.vertices[this.faces[i][j]].toString() + ")");
              }
            }
          };
          var cb = new Vec3();
          var ab = new Vec3();
          ConvexPolyhedron.computeNormal = function(va, vb, vc, target) {
            vb.vsub(va, ab);
            vc.vsub(vb, cb);
            cb.cross(ab, target);
            target.isZero() || target.normalize();
          };
          ConvexPolyhedron.prototype.getFaceNormal = function(i, target) {
            var f = this.faces[i];
            var va = this.vertices[f[0]];
            var vb = this.vertices[f[1]];
            var vc = this.vertices[f[2]];
            return ConvexPolyhedron.computeNormal(va, vb, vc, target);
          };
          var cah_WorldNormal = new Vec3();
          ConvexPolyhedron.prototype.clipAgainstHull = function(posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {
            var WorldNormal = cah_WorldNormal;
            var hullA = this;
            var curMaxDist = maxDist;
            var closestFaceB = -1;
            var dmax = -Number.MAX_VALUE;
            for (var face = 0; face < hullB.faces.length; face++) {
              WorldNormal.copy(hullB.faceNormals[face]);
              quatB.vmult(WorldNormal, WorldNormal);
              var d = WorldNormal.dot(separatingNormal);
              if (d > dmax) {
                dmax = d;
                closestFaceB = face;
              }
            }
            var worldVertsB1 = [];
            var polyB = hullB.faces[closestFaceB];
            var numVertices = polyB.length;
            for (var e0 = 0; e0 < numVertices; e0++) {
              var b = hullB.vertices[polyB[e0]];
              var worldb = new Vec3();
              worldb.copy(b);
              quatB.vmult(worldb, worldb);
              posB.vadd(worldb, worldb);
              worldVertsB1.push(worldb);
            }
            closestFaceB >= 0 && this.clipFaceAgainstHull(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result);
          };
          var fsa_faceANormalWS3 = new Vec3(), fsa_Worldnormal1 = new Vec3(), fsa_deltaC = new Vec3(), fsa_worldEdge0 = new Vec3(), fsa_worldEdge1 = new Vec3(), fsa_Cross = new Vec3();
          ConvexPolyhedron.prototype.findSeparatingAxis = function(hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {
            var faceANormalWS3 = fsa_faceANormalWS3, Worldnormal1 = fsa_Worldnormal1, deltaC = fsa_deltaC, worldEdge0 = fsa_worldEdge0, worldEdge1 = fsa_worldEdge1, Cross = fsa_Cross;
            var dmin = Number.MAX_VALUE;
            var hullA = this;
            var curPlaneTests = 0;
            if (hullA.uniqueAxes) for (var i = 0; i !== hullA.uniqueAxes.length; i++) {
              quatA.vmult(hullA.uniqueAxes[i], faceANormalWS3);
              var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
              if (false === d) return false;
              if (d < dmin) {
                dmin = d;
                target.copy(faceANormalWS3);
              }
            } else {
              var numFacesA = faceListA ? faceListA.length : hullA.faces.length;
              for (var i = 0; i < numFacesA; i++) {
                var fi = faceListA ? faceListA[i] : i;
                faceANormalWS3.copy(hullA.faceNormals[fi]);
                quatA.vmult(faceANormalWS3, faceANormalWS3);
                var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
                if (false === d) return false;
                if (d < dmin) {
                  dmin = d;
                  target.copy(faceANormalWS3);
                }
              }
            }
            if (hullB.uniqueAxes) for (var i = 0; i !== hullB.uniqueAxes.length; i++) {
              quatB.vmult(hullB.uniqueAxes[i], Worldnormal1);
              curPlaneTests++;
              var d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);
              if (false === d) return false;
              if (d < dmin) {
                dmin = d;
                target.copy(Worldnormal1);
              }
            } else {
              var numFacesB = faceListB ? faceListB.length : hullB.faces.length;
              for (var i = 0; i < numFacesB; i++) {
                var fi = faceListB ? faceListB[i] : i;
                Worldnormal1.copy(hullB.faceNormals[fi]);
                quatB.vmult(Worldnormal1, Worldnormal1);
                curPlaneTests++;
                var d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);
                if (false === d) return false;
                if (d < dmin) {
                  dmin = d;
                  target.copy(Worldnormal1);
                }
              }
            }
            for (var e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {
              quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);
              for (var e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {
                quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
                worldEdge0.cross(worldEdge1, Cross);
                if (!Cross.almostZero()) {
                  Cross.normalize();
                  var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);
                  if (false === dist) return false;
                  if (dist < dmin) {
                    dmin = dist;
                    target.copy(Cross);
                  }
                }
              }
            }
            posB.vsub(posA, deltaC);
            deltaC.dot(target) > 0 && target.negate(target);
            return true;
          };
          var maxminA = [], maxminB = [];
          ConvexPolyhedron.prototype.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB) {
            var hullA = this;
            ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
            ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
            var maxA = maxminA[0];
            var minA = maxminA[1];
            var maxB = maxminB[0];
            var minB = maxminB[1];
            if (maxA < minB || maxB < minA) return false;
            var d0 = maxA - minB;
            var d1 = maxB - minA;
            var depth = d0 < d1 ? d0 : d1;
            return depth;
          };
          var cli_aabbmin = new Vec3(), cli_aabbmax = new Vec3();
          ConvexPolyhedron.prototype.calculateLocalInertia = function(mass, target) {
            this.computeLocalAABB(cli_aabbmin, cli_aabbmax);
            var x = cli_aabbmax.x - cli_aabbmin.x, y = cli_aabbmax.y - cli_aabbmin.y, z = cli_aabbmax.z - cli_aabbmin.z;
            target.x = 1 / 12 * mass * (2 * y * 2 * y + 2 * z * 2 * z);
            target.y = 1 / 12 * mass * (2 * x * 2 * x + 2 * z * 2 * z);
            target.z = 1 / 12 * mass * (2 * y * 2 * y + 2 * x * 2 * x);
          };
          ConvexPolyhedron.prototype.getPlaneConstantOfFace = function(face_i) {
            var f = this.faces[face_i];
            var n = this.faceNormals[face_i];
            var v = this.vertices[f[0]];
            var c = -n.dot(v);
            return c;
          };
          var cfah_faceANormalWS = new Vec3(), cfah_edge0 = new Vec3(), cfah_WorldEdge0 = new Vec3(), cfah_worldPlaneAnormal1 = new Vec3(), cfah_planeNormalWS1 = new Vec3(), cfah_worldA1 = new Vec3(), cfah_localPlaneNormal = new Vec3(), cfah_planeNormalWS = new Vec3();
          ConvexPolyhedron.prototype.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {
            var faceANormalWS = cfah_faceANormalWS, edge0 = cfah_edge0, WorldEdge0 = cfah_WorldEdge0, worldPlaneAnormal1 = cfah_worldPlaneAnormal1, planeNormalWS1 = cfah_planeNormalWS1, worldA1 = cfah_worldA1, localPlaneNormal = cfah_localPlaneNormal, planeNormalWS = cfah_planeNormalWS;
            var hullA = this;
            var worldVertsB2 = [];
            var pVtxIn = worldVertsB1;
            var pVtxOut = worldVertsB2;
            var closestFaceA = -1;
            var dmin = Number.MAX_VALUE;
            for (var face = 0; face < hullA.faces.length; face++) {
              faceANormalWS.copy(hullA.faceNormals[face]);
              quatA.vmult(faceANormalWS, faceANormalWS);
              var d = faceANormalWS.dot(separatingNormal);
              if (d < dmin) {
                dmin = d;
                closestFaceA = face;
              }
            }
            if (closestFaceA < 0) return;
            var polyA = hullA.faces[closestFaceA];
            polyA.connectedFaces = [];
            for (var i = 0; i < hullA.faces.length; i++) for (var j = 0; j < hullA.faces[i].length; j++) -1 !== polyA.indexOf(hullA.faces[i][j]) && i !== closestFaceA && -1 === polyA.connectedFaces.indexOf(i) && polyA.connectedFaces.push(i);
            var numContacts = pVtxIn.length;
            var numVerticesA = polyA.length;
            var res = [];
            for (var e0 = 0; e0 < numVerticesA; e0++) {
              var a = hullA.vertices[polyA[e0]];
              var b = hullA.vertices[polyA[(e0 + 1) % numVerticesA]];
              a.vsub(b, edge0);
              WorldEdge0.copy(edge0);
              quatA.vmult(WorldEdge0, WorldEdge0);
              posA.vadd(WorldEdge0, WorldEdge0);
              worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);
              quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);
              posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);
              WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);
              planeNormalWS1.negate(planeNormalWS1);
              worldA1.copy(a);
              quatA.vmult(worldA1, worldA1);
              posA.vadd(worldA1, worldA1);
              var planeEqWS1 = -worldA1.dot(planeNormalWS1);
              var planeEqWS;
              true;
              var otherFace = polyA.connectedFaces[e0];
              localPlaneNormal.copy(this.faceNormals[otherFace]);
              var localPlaneEq = this.getPlaneConstantOfFace(otherFace);
              planeNormalWS.copy(localPlaneNormal);
              quatA.vmult(planeNormalWS, planeNormalWS);
              var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
              this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);
              while (pVtxIn.length) pVtxIn.shift();
              while (pVtxOut.length) pVtxIn.push(pVtxOut.shift());
            }
            localPlaneNormal.copy(this.faceNormals[closestFaceA]);
            var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
            planeNormalWS.copy(localPlaneNormal);
            quatA.vmult(planeNormalWS, planeNormalWS);
            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
            for (var i = 0; i < pVtxIn.length; i++) {
              var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS;
              depth <= minDist && (depth = minDist);
              if (depth <= maxDist) {
                var point = pVtxIn[i];
                if (depth <= 0) {
                  var p = {
                    point: point,
                    normal: planeNormalWS,
                    depth: depth
                  };
                  result.push(p);
                }
              }
            }
          };
          ConvexPolyhedron.prototype.clipFaceAgainstPlane = function(inVertices, outVertices, planeNormal, planeConstant) {
            var n_dot_first, n_dot_last;
            var numVerts = inVertices.length;
            if (numVerts < 2) return outVertices;
            var firstVertex = inVertices[inVertices.length - 1], lastVertex = inVertices[0];
            n_dot_first = planeNormal.dot(firstVertex) + planeConstant;
            for (var vi = 0; vi < numVerts; vi++) {
              lastVertex = inVertices[vi];
              n_dot_last = planeNormal.dot(lastVertex) + planeConstant;
              if (n_dot_first < 0) if (n_dot_last < 0) {
                var newv = new Vec3();
                newv.copy(lastVertex);
                outVertices.push(newv);
              } else {
                var newv = new Vec3();
                firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
                outVertices.push(newv);
              } else if (n_dot_last < 0) {
                var newv = new Vec3();
                firstVertex.lerp(lastVertex, n_dot_first / (n_dot_first - n_dot_last), newv);
                outVertices.push(newv);
                outVertices.push(lastVertex);
              }
              firstVertex = lastVertex;
              n_dot_first = n_dot_last;
            }
            return outVertices;
          };
          ConvexPolyhedron.prototype.computeWorldVertices = function(position, quat) {
            var N = this.vertices.length;
            while (this.worldVertices.length < N) this.worldVertices.push(new Vec3());
            var verts = this.vertices, worldVerts = this.worldVertices;
            for (var i = 0; i !== N; i++) {
              quat.vmult(verts[i], worldVerts[i]);
              position.vadd(worldVerts[i], worldVerts[i]);
            }
            this.worldVerticesNeedsUpdate = false;
          };
          var computeLocalAABB_worldVert = new Vec3();
          ConvexPolyhedron.prototype.computeLocalAABB = function(aabbmin, aabbmax) {
            var n = this.vertices.length, vertices = this.vertices, worldVert = computeLocalAABB_worldVert;
            aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            for (var i = 0; i < n; i++) {
              var v = vertices[i];
              v.x < aabbmin.x ? aabbmin.x = v.x : v.x > aabbmax.x && (aabbmax.x = v.x);
              v.y < aabbmin.y ? aabbmin.y = v.y : v.y > aabbmax.y && (aabbmax.y = v.y);
              v.z < aabbmin.z ? aabbmin.z = v.z : v.z > aabbmax.z && (aabbmax.z = v.z);
            }
          };
          ConvexPolyhedron.prototype.computeWorldFaceNormals = function(quat) {
            var N = this.faceNormals.length;
            while (this.worldFaceNormals.length < N) this.worldFaceNormals.push(new Vec3());
            var normals = this.faceNormals, worldNormals = this.worldFaceNormals;
            for (var i = 0; i !== N; i++) quat.vmult(normals[i], worldNormals[i]);
            this.worldFaceNormalsNeedsUpdate = false;
          };
          ConvexPolyhedron.prototype.updateBoundingSphereRadius = function() {
            var max2 = 0;
            var verts = this.vertices;
            for (var i = 0, N = verts.length; i !== N; i++) {
              var norm2 = verts[i].norm2();
              norm2 > max2 && (max2 = norm2);
            }
            this.boundingSphereRadius = Math.sqrt(max2);
          };
          var tempWorldVertex = new Vec3();
          ConvexPolyhedron.prototype.calculateWorldAABB = function(pos, quat, min, max) {
            var n = this.vertices.length, verts = this.vertices;
            var minx, miny, minz, maxx, maxy, maxz;
            for (var i = 0; i < n; i++) {
              tempWorldVertex.copy(verts[i]);
              quat.vmult(tempWorldVertex, tempWorldVertex);
              pos.vadd(tempWorldVertex, tempWorldVertex);
              var v = tempWorldVertex;
              (v.x < minx || void 0 === minx) && (minx = v.x);
              (v.x > maxx || void 0 === maxx) && (maxx = v.x);
              (v.y < miny || void 0 === miny) && (miny = v.y);
              (v.y > maxy || void 0 === maxy) && (maxy = v.y);
              (v.z < minz || void 0 === minz) && (minz = v.z);
              (v.z > maxz || void 0 === maxz) && (maxz = v.z);
            }
            min.set(minx, miny, minz);
            max.set(maxx, maxy, maxz);
          };
          ConvexPolyhedron.prototype.volume = function() {
            return 4 * Math.PI * this.boundingSphereRadius / 3;
          };
          ConvexPolyhedron.prototype.getAveragePointLocal = function(target) {
            target = target || new Vec3();
            var n = this.vertices.length, verts = this.vertices;
            for (var i = 0; i < n; i++) target.vadd(verts[i], target);
            target.mult(1 / n, target);
            return target;
          };
          ConvexPolyhedron.prototype.transformAllPoints = function(offset, quat) {
            var n = this.vertices.length, verts = this.vertices;
            if (quat) {
              for (var i = 0; i < n; i++) {
                var v = verts[i];
                quat.vmult(v, v);
              }
              for (var i = 0; i < this.faceNormals.length; i++) {
                var v = this.faceNormals[i];
                quat.vmult(v, v);
              }
            }
            if (offset) for (var i = 0; i < n; i++) {
              var v = verts[i];
              v.vadd(offset, v);
            }
          };
          var ConvexPolyhedron_pointIsInside = new Vec3();
          var ConvexPolyhedron_vToP = new Vec3();
          var ConvexPolyhedron_vToPointInside = new Vec3();
          ConvexPolyhedron.prototype.pointIsInside = function(p) {
            var n = this.vertices.length, verts = this.vertices, faces = this.faces, normals = this.faceNormals;
            var positiveResult = null;
            var N = this.faces.length;
            var pointInside = ConvexPolyhedron_pointIsInside;
            this.getAveragePointLocal(pointInside);
            for (var i = 0; i < N; i++) {
              var numVertices = this.faces[i].length;
              var n = normals[i];
              var v = verts[faces[i][0]];
              var vToP = ConvexPolyhedron_vToP;
              p.vsub(v, vToP);
              var r1 = n.dot(vToP);
              var vToPointInside = ConvexPolyhedron_vToPointInside;
              pointInside.vsub(v, vToPointInside);
              var r2 = n.dot(vToPointInside);
              if (r1 < 0 && r2 > 0 || r1 > 0 && r2 < 0) return false;
            }
            return positiveResult ? 1 : -1;
          };
          var project_worldVertex = new Vec3();
          var project_localAxis = new Vec3();
          var project_localOrigin = new Vec3();
          ConvexPolyhedron.project = function(hull, axis, pos, quat, result) {
            var n = hull.vertices.length, worldVertex = project_worldVertex, localAxis = project_localAxis, max = 0, min = 0, localOrigin = project_localOrigin, vs = hull.vertices;
            localOrigin.setZero();
            Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
            Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
            var add = localOrigin.dot(localAxis);
            min = max = vs[0].dot(localAxis);
            for (var i = 1; i < n; i++) {
              var val = vs[i].dot(localAxis);
              val > max && (max = val);
              val < min && (min = val);
            }
            min -= add;
            max -= add;
            if (min > max) {
              var temp = min;
              min = max;
              max = temp;
            }
            result[0] = max;
            result[1] = min;
          };
        }), {
          "../math/Quaternion": 30,
          "../math/Transform": 31,
          "../math/Vec3": 32,
          "./Shape": 45
        } ],
        41: [ (function(_dereq_, module, exports) {
          module.exports = Cylinder;
          var Shape = _dereq_("./Shape");
          var Vec3 = _dereq_("../math/Vec3");
          var Quaternion = _dereq_("../math/Quaternion");
          var ConvexPolyhedron = _dereq_("./ConvexPolyhedron");
          var CMath = _dereq_("../math/CMath");
          function Cylinder(radiusTop, radiusBottom, height, numSegments, isDirY) {
            if (isDirY) {
              var N = numSegments, cos = CMath.cos, sin = CMath.sin;
              var halfH = height / 2;
              var vertices = [];
              var indices = [];
              var tf = [ 0 ];
              var bf = [ 1 ];
              var axes = [];
              var theta = 2 * Math.PI / N;
              for (var i = 0; i < N; i++) {
                vertices.push(new Vec3(radiusTop * cos(theta * i), halfH, radiusTop * sin(theta * i)));
                vertices.push(new Vec3(radiusTop * cos(theta * i), -halfH, radiusTop * sin(theta * i)));
                if (i < N - 1) {
                  indices.push([ 2 * i + 2, 2 * i + 3, 2 * i + 1, 2 * i ]);
                  tf.push(2 * i + 2);
                  bf.push(2 * i + 3);
                } else indices.push([ 0, 1, 2 * i + 1, 2 * i ]);
                (N % 2 === 1 || i < N / 2) && axes.push(new Vec3(cos(theta * (i + .5)), 0, sin(theta * (i + .5))));
              }
              indices.push(bf);
              var temp = [];
              for (var i = 0; i < tf.length; i++) temp.push(tf[tf.length - i - 1]);
              indices.push(temp);
              axes.push(new Vec3(0, 1, 0));
              ConvexPolyhedron.call(this, vertices, indices, axes);
              return;
            }
            var N = numSegments, verts = [], axes = [], faces = [], bottomface = [], topface = [], cos = CMath.cos, sin = CMath.sin;
            verts.push(new Vec3(radiusBottom * cos(0), radiusBottom * sin(0), .5 * -height));
            bottomface.push(0);
            verts.push(new Vec3(radiusTop * cos(0), radiusTop * sin(0), .5 * height));
            topface.push(1);
            for (var i = 0; i < N; i++) {
              var theta = 2 * Math.PI / N * (i + 1);
              var thetaN = 2 * Math.PI / N * (i + .5);
              if (i < N - 1) {
                verts.push(new Vec3(radiusBottom * cos(theta), radiusBottom * sin(theta), .5 * -height));
                bottomface.push(2 * i + 2);
                verts.push(new Vec3(radiusTop * cos(theta), radiusTop * sin(theta), .5 * height));
                topface.push(2 * i + 3);
                faces.push([ 2 * i + 2, 2 * i + 3, 2 * i + 1, 2 * i ]);
              } else faces.push([ 0, 1, 2 * i + 1, 2 * i ]);
              (N % 2 === 1 || i < N / 2) && axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));
            }
            faces.push(topface);
            axes.push(new Vec3(0, 0, 1));
            var temp = [];
            for (var i = 0; i < bottomface.length; i++) temp.push(bottomface[bottomface.length - i - 1]);
            faces.push(temp);
            ConvexPolyhedron.call(this, verts, faces, axes);
          }
          Cylinder.prototype = new ConvexPolyhedron();
        }), {
          "../math/CMath": 27,
          "../math/Quaternion": 30,
          "../math/Vec3": 32,
          "./ConvexPolyhedron": 40,
          "./Shape": 45
        } ],
        42: [ (function(_dereq_, module, exports) {
          var Shape = _dereq_("./Shape");
          var ConvexPolyhedron = _dereq_("./ConvexPolyhedron");
          var Vec3 = _dereq_("../math/Vec3");
          var Utils = _dereq_("../utils/Utils");
          module.exports = Heightfield;
          function Heightfield(data, options) {
            options = Utils.defaults(options, {
              maxValue: null,
              minValue: null,
              elementSize: 1
            });
            this.data = data;
            this.maxValue = options.maxValue;
            this.minValue = options.minValue;
            this.elementSize = options.elementSize;
            null === options.minValue && this.updateMinValue();
            null === options.maxValue && this.updateMaxValue();
            this.cacheEnabled = true;
            Shape.call(this, {
              type: Shape.types.HEIGHTFIELD
            });
            this.pillarConvex = new ConvexPolyhedron();
            this.pillarOffset = new Vec3();
            this.updateBoundingSphereRadius();
            this._cachedPillars = {};
          }
          Heightfield.prototype = new Shape();
          Heightfield.prototype.update = function() {
            this._cachedPillars = {};
          };
          Heightfield.prototype.updateMinValue = function() {
            var data = this.data;
            var minValue = data[0][0];
            for (var i = 0; i !== data.length; i++) for (var j = 0; j !== data[i].length; j++) {
              var v = data[i][j];
              v < minValue && (minValue = v);
            }
            this.minValue = minValue;
          };
          Heightfield.prototype.updateMaxValue = function() {
            var data = this.data;
            var maxValue = data[0][0];
            for (var i = 0; i !== data.length; i++) for (var j = 0; j !== data[i].length; j++) {
              var v = data[i][j];
              v > maxValue && (maxValue = v);
            }
            this.maxValue = maxValue;
          };
          Heightfield.prototype.setHeightValueAtIndex = function(xi, yi, value) {
            var data = this.data;
            data[xi][yi] = value;
            this.clearCachedConvexTrianglePillar(xi, yi, false);
            if (xi > 0) {
              this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
              this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
            }
            if (yi > 0) {
              this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
              this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
            }
            yi > 0 && xi > 0 && this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
          };
          Heightfield.prototype.getRectMinMax = function(iMinX, iMinY, iMaxX, iMaxY, result) {
            result = result || [];
            var data = this.data, max = this.minValue;
            for (var i = iMinX; i <= iMaxX; i++) for (var j = iMinY; j <= iMaxY; j++) {
              var height = data[i][j];
              height > max && (max = height);
            }
            result[0] = this.minValue;
            result[1] = max;
          };
          Heightfield.prototype.getIndexOfPosition = function(x, y, result, clamp) {
            var w = this.elementSize;
            var data = this.data;
            var xi = Math.floor(x / w);
            var yi = Math.floor(y / w);
            result[0] = xi;
            result[1] = yi;
            if (clamp) {
              xi < 0 && (xi = 0);
              yi < 0 && (yi = 0);
              xi >= data.length - 1 && (xi = data.length - 1);
              yi >= data[0].length - 1 && (yi = data[0].length - 1);
            }
            if (xi < 0 || yi < 0 || xi >= data.length - 1 || yi >= data[0].length - 1) return false;
            return true;
          };
          var getHeightAt_idx = [];
          var getHeightAt_weights = new Vec3();
          var getHeightAt_a = new Vec3();
          var getHeightAt_b = new Vec3();
          var getHeightAt_c = new Vec3();
          Heightfield.prototype.getTriangleAt = function(x, y, edgeClamp, a, b, c) {
            var idx = getHeightAt_idx;
            this.getIndexOfPosition(x, y, idx, edgeClamp);
            var xi = idx[0];
            var yi = idx[1];
            var data = this.data;
            if (edgeClamp) {
              xi = Math.min(data.length - 2, Math.max(0, xi));
              yi = Math.min(data[0].length - 2, Math.max(0, yi));
            }
            var elementSize = this.elementSize;
            var lowerDist2 = Math.pow(x / elementSize - xi, 2) + Math.pow(y / elementSize - yi, 2);
            var upperDist2 = Math.pow(x / elementSize - (xi + 1), 2) + Math.pow(y / elementSize - (yi + 1), 2);
            var upper = lowerDist2 > upperDist2;
            this.getTriangle(xi, yi, upper, a, b, c);
            return upper;
          };
          var getNormalAt_a = new Vec3();
          var getNormalAt_b = new Vec3();
          var getNormalAt_c = new Vec3();
          var getNormalAt_e0 = new Vec3();
          var getNormalAt_e1 = new Vec3();
          Heightfield.prototype.getNormalAt = function(x, y, edgeClamp, result) {
            var a = getNormalAt_a;
            var b = getNormalAt_b;
            var c = getNormalAt_c;
            var e0 = getNormalAt_e0;
            var e1 = getNormalAt_e1;
            this.getTriangleAt(x, y, edgeClamp, a, b, c);
            b.vsub(a, e0);
            c.vsub(a, e1);
            e0.cross(e1, result);
            result.normalize();
          };
          Heightfield.prototype.getAabbAtIndex = function(xi, yi, result) {
            var data = this.data;
            var elementSize = this.elementSize;
            result.lowerBound.set(xi * elementSize, yi * elementSize, data[xi][yi]);
            result.upperBound.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
          };
          Heightfield.prototype.getHeightAt = function(x, y, edgeClamp) {
            var data = this.data;
            var a = getHeightAt_a;
            var b = getHeightAt_b;
            var c = getHeightAt_c;
            var idx = getHeightAt_idx;
            this.getIndexOfPosition(x, y, idx, edgeClamp);
            var xi = idx[0];
            var yi = idx[1];
            if (edgeClamp) {
              xi = Math.min(data.length - 2, Math.max(0, xi));
              yi = Math.min(data[0].length - 2, Math.max(0, yi));
            }
            var upper = this.getTriangleAt(x, y, edgeClamp, a, b, c);
            barycentricWeights(x, y, a.x, a.y, b.x, b.y, c.x, c.y, getHeightAt_weights);
            var w = getHeightAt_weights;
            return upper ? data[xi + 1][yi + 1] * w.x + data[xi][yi + 1] * w.y + data[xi + 1][yi] * w.z : data[xi][yi] * w.x + data[xi + 1][yi] * w.y + data[xi][yi + 1] * w.z;
          };
          function barycentricWeights(x, y, ax, ay, bx, by, cx, cy, result) {
            result.x = ((by - cy) * (x - cx) + (cx - bx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
            result.y = ((cy - ay) * (x - cx) + (ax - cx) * (y - cy)) / ((by - cy) * (ax - cx) + (cx - bx) * (ay - cy));
            result.z = 1 - result.x - result.y;
          }
          Heightfield.prototype.getCacheConvexTrianglePillarKey = function(xi, yi, getUpperTriangle) {
            return xi + "_" + yi + "_" + (getUpperTriangle ? 1 : 0);
          };
          Heightfield.prototype.getCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle) {
            return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
          };
          Heightfield.prototype.setCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle, convex, offset) {
            this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
              convex: convex,
              offset: offset
            };
          };
          Heightfield.prototype.clearCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle) {
            delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
          };
          Heightfield.prototype.getTriangle = function(xi, yi, upper, a, b, c) {
            var data = this.data;
            var elementSize = this.elementSize;
            if (upper) {
              a.set((xi + 1) * elementSize, (yi + 1) * elementSize, data[xi + 1][yi + 1]);
              b.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
              c.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
            } else {
              a.set(xi * elementSize, yi * elementSize, data[xi][yi]);
              b.set((xi + 1) * elementSize, yi * elementSize, data[xi + 1][yi]);
              c.set(xi * elementSize, (yi + 1) * elementSize, data[xi][yi + 1]);
            }
          };
          Heightfield.prototype.getConvexTrianglePillar = function(xi, yi, getUpperTriangle) {
            var result = this.pillarConvex;
            var offsetResult = this.pillarOffset;
            if (this.cacheEnabled) {
              var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);
              if (data) {
                this.pillarConvex = data.convex;
                this.pillarOffset = data.offset;
                return;
              }
              result = new ConvexPolyhedron();
              offsetResult = new Vec3();
              this.pillarConvex = result;
              this.pillarOffset = offsetResult;
            }
            var data = this.data;
            var elementSize = this.elementSize;
            var faces = result.faces;
            result.vertices.length = 6;
            for (var i = 0; i < 6; i++) result.vertices[i] || (result.vertices[i] = new Vec3());
            faces.length = 5;
            for (var i = 0; i < 5; i++) faces[i] || (faces[i] = []);
            var verts = result.vertices;
            var h = (Math.min(data[xi][yi], data[xi + 1][yi], data[xi][yi + 1], data[xi + 1][yi + 1]) - this.minValue) / 2 + this.minValue;
            if (getUpperTriangle) {
              offsetResult.set((xi + .75) * elementSize, (yi + .75) * elementSize, h);
              verts[0].set(.25 * elementSize, .25 * elementSize, data[xi + 1][yi + 1] - h);
              verts[1].set(-.75 * elementSize, .25 * elementSize, data[xi][yi + 1] - h);
              verts[2].set(.25 * elementSize, -.75 * elementSize, data[xi + 1][yi] - h);
              verts[3].set(.25 * elementSize, .25 * elementSize, -h - 1);
              verts[4].set(-.75 * elementSize, .25 * elementSize, -h - 1);
              verts[5].set(.25 * elementSize, -.75 * elementSize, -h - 1);
              faces[0][0] = 0;
              faces[0][1] = 1;
              faces[0][2] = 2;
              faces[1][0] = 5;
              faces[1][1] = 4;
              faces[1][2] = 3;
              faces[2][0] = 2;
              faces[2][1] = 5;
              faces[2][2] = 3;
              faces[2][3] = 0;
              faces[3][0] = 3;
              faces[3][1] = 4;
              faces[3][2] = 1;
              faces[3][3] = 0;
              faces[4][0] = 1;
              faces[4][1] = 4;
              faces[4][2] = 5;
              faces[4][3] = 2;
            } else {
              offsetResult.set((xi + .25) * elementSize, (yi + .25) * elementSize, h);
              verts[0].set(-.25 * elementSize, -.25 * elementSize, data[xi][yi] - h);
              verts[1].set(.75 * elementSize, -.25 * elementSize, data[xi + 1][yi] - h);
              verts[2].set(-.25 * elementSize, .75 * elementSize, data[xi][yi + 1] - h);
              verts[3].set(-.25 * elementSize, -.25 * elementSize, -h - 1);
              verts[4].set(.75 * elementSize, -.25 * elementSize, -h - 1);
              verts[5].set(-.25 * elementSize, .75 * elementSize, -h - 1);
              faces[0][0] = 0;
              faces[0][1] = 1;
              faces[0][2] = 2;
              faces[1][0] = 5;
              faces[1][1] = 4;
              faces[1][2] = 3;
              faces[2][0] = 0;
              faces[2][1] = 2;
              faces[2][2] = 5;
              faces[2][3] = 3;
              faces[3][0] = 1;
              faces[3][1] = 0;
              faces[3][2] = 3;
              faces[3][3] = 4;
              faces[4][0] = 4;
              faces[4][1] = 5;
              faces[4][2] = 2;
              faces[4][3] = 1;
            }
            result.computeNormals();
            result.computeEdges();
            result.updateBoundingSphereRadius();
            this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
          };
          Heightfield.prototype.calculateLocalInertia = function(mass, target) {
            target = target || new Vec3();
            target.set(0, 0, 0);
            return target;
          };
          Heightfield.prototype.volume = function() {
            return Number.MAX_VALUE;
          };
          Heightfield.prototype.calculateWorldAABB = function(pos, quat, min, max) {
            min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
          };
          Heightfield.prototype.updateBoundingSphereRadius = function() {
            var data = this.data, s = this.elementSize;
            this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
          };
          Heightfield.prototype.setHeightsFromImage = function(image, scale) {
            var canvas = document.createElement("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            var context = canvas.getContext("2d");
            context.drawImage(image, 0, 0);
            var imageData = context.getImageData(0, 0, image.width, image.height);
            var matrix = this.data;
            matrix.length = 0;
            this.elementSize = Math.abs(scale.x) / imageData.width;
            for (var i = 0; i < imageData.height; i++) {
              var row = [];
              for (var j = 0; j < imageData.width; j++) {
                var a = imageData.data[4 * (i * imageData.height + j)];
                var b = imageData.data[4 * (i * imageData.height + j) + 1];
                var c = imageData.data[4 * (i * imageData.height + j) + 2];
                var height = (a + b + c) / 4 / 255 * scale.z;
                scale.x < 0 ? row.push(height) : row.unshift(height);
              }
              scale.y < 0 ? matrix.unshift(row) : matrix.push(row);
            }
            this.updateMaxValue();
            this.updateMinValue();
            this.update();
          };
        }), {
          "../math/Vec3": 32,
          "../utils/Utils": 55,
          "./ConvexPolyhedron": 40,
          "./Shape": 45
        } ],
        43: [ (function(_dereq_, module, exports) {
          module.exports = Particle;
          var Shape = _dereq_("./Shape");
          var Vec3 = _dereq_("../math/Vec3");
          function Particle() {
            Shape.call(this, {
              type: Shape.types.PARTICLE
            });
          }
          Particle.prototype = new Shape();
          Particle.prototype.constructor = Particle;
          Particle.prototype.calculateLocalInertia = function(mass, target) {
            target = target || new Vec3();
            target.set(0, 0, 0);
            return target;
          };
          Particle.prototype.volume = function() {
            return 0;
          };
          Particle.prototype.updateBoundingSphereRadius = function() {
            this.boundingSphereRadius = 0;
          };
          Particle.prototype.calculateWorldAABB = function(pos, quat, min, max) {
            min.copy(pos);
            max.copy(pos);
          };
        }), {
          "../math/Vec3": 32,
          "./Shape": 45
        } ],
        44: [ (function(_dereq_, module, exports) {
          module.exports = Plane;
          var Shape = _dereq_("./Shape");
          var Vec3 = _dereq_("../math/Vec3");
          function Plane() {
            Shape.call(this, {
              type: Shape.types.PLANE
            });
            this.worldNormal = new Vec3();
            this.worldNormalNeedsUpdate = true;
            this.boundingSphereRadius = Number.MAX_VALUE;
          }
          Plane.prototype = new Shape();
          Plane.prototype.constructor = Plane;
          Plane.prototype.computeWorldNormal = function(quat) {
            var n = this.worldNormal;
            n.set(0, 0, 1);
            quat.vmult(n, n);
            this.worldNormalNeedsUpdate = false;
          };
          Plane.prototype.calculateLocalInertia = function(mass, target) {
            target = target || new Vec3();
            return target;
          };
          Plane.prototype.volume = function() {
            return Number.MAX_VALUE;
          };
          var tempNormal = new Vec3();
          Plane.prototype.calculateWorldAABB = function(pos, quat, min, max) {
            tempNormal.set(0, 0, 1);
            quat.vmult(tempNormal, tempNormal);
            var maxVal = Number.MAX_VALUE;
            min.set(-maxVal, -maxVal, -maxVal);
            max.set(maxVal, maxVal, maxVal);
            1 === tempNormal.x && (max.x = pos.x);
            1 === tempNormal.y && (max.y = pos.y);
            1 === tempNormal.z && (max.z = pos.z);
            -1 === tempNormal.x && (min.x = pos.x);
            -1 === tempNormal.y && (min.y = pos.y);
            -1 === tempNormal.z && (min.z = pos.z);
          };
          Plane.prototype.updateBoundingSphereRadius = function() {
            this.boundingSphereRadius = Number.MAX_VALUE;
          };
        }), {
          "../math/Vec3": 32,
          "./Shape": 45
        } ],
        45: [ (function(_dereq_, module, exports) {
          module.exports = Shape;
          var EventTarget = _dereq_("../utils/EventTarget");
          var Shape = _dereq_("./Shape");
          var Vec3 = _dereq_("../math/Vec3");
          var Quaternion = _dereq_("../math/Quaternion");
          var Material = _dereq_("../material/Material");
          function Shape(options) {
            options = options || {};
            EventTarget.apply(this);
            this.id = Shape.idCounter++;
            this.type = options.type || 0;
            this.boundingSphereRadius = 0;
            this.collisionResponse = !options.collisionResponse || options.collisionResponse;
            this.collisionFilterGroup = void 0 !== options.collisionFilterGroup ? options.collisionFilterGroup : 1;
            this.collisionFilterMask = void 0 !== options.collisionFilterMask ? options.collisionFilterMask : -1;
            this.material = options.material ? options.material : null;
            this.body = null;
          }
          Shape.prototype = new EventTarget();
          Shape.prototype.constructor = Shape;
          Shape.prototype.updateBoundingSphereRadius = function() {
            throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
          };
          Shape.prototype.volume = function() {
            throw "volume() not implemented for shape type " + this.type;
          };
          Shape.prototype.calculateLocalInertia = function(mass, target) {
            throw "calculateLocalInertia() not implemented for shape type " + this.type;
          };
          Shape.idCounter = 0;
          Shape.types = {
            SPHERE: 1,
            PLANE: 2,
            BOX: 4,
            COMPOUND: 8,
            CONVEXPOLYHEDRON: 16,
            HEIGHTFIELD: 32,
            PARTICLE: 64,
            CYLINDER: 128,
            TRIMESH: 256
          };
        }), {
          "../material/Material": 26,
          "../math/Quaternion": 30,
          "../math/Vec3": 32,
          "../utils/EventTarget": 51,
          "./Shape": 45
        } ],
        46: [ (function(_dereq_, module, exports) {
          module.exports = Sphere;
          var Shape = _dereq_("./Shape");
          var Vec3 = _dereq_("../math/Vec3");
          function Sphere(radius) {
            Shape.call(this, {
              type: Shape.types.SPHERE
            });
            this.radius = void 0 !== radius ? radius : 1;
            if (this.radius < 0) throw new Error("The sphere radius cannot be negative.");
            this.updateBoundingSphereRadius();
          }
          Sphere.prototype = new Shape();
          Sphere.prototype.constructor = Sphere;
          Sphere.prototype.calculateLocalInertia = function(mass, target) {
            target = target || new Vec3();
            var I = 2 * mass * this.radius * this.radius / 5;
            target.x = I;
            target.y = I;
            target.z = I;
            return target;
          };
          Sphere.prototype.volume = function() {
            return 4 * Math.PI * this.radius / 3;
          };
          Sphere.prototype.updateBoundingSphereRadius = function() {
            this.boundingSphereRadius = this.radius;
          };
          Sphere.prototype.calculateWorldAABB = function(pos, quat, min, max) {
            var r = this.radius;
            var axes = [ "x", "y", "z" ];
            for (var i = 0; i < axes.length; i++) {
              var ax = axes[i];
              min[ax] = pos[ax] - r;
              max[ax] = pos[ax] + r;
            }
          };
        }), {
          "../math/Vec3": 32,
          "./Shape": 45
        } ],
        47: [ (function(_dereq_, module, exports) {
          module.exports = Trimesh;
          var Shape = _dereq_("./Shape");
          var Vec3 = _dereq_("../math/Vec3");
          var Quaternion = _dereq_("../math/Quaternion");
          var Transform = _dereq_("../math/Transform");
          var AABB = _dereq_("../collision/AABB");
          var Octree = _dereq_("../utils/Octree");
          var CMath = _dereq_("../math/CMath");
          function Trimesh(vertices, indices) {
            Shape.call(this, {
              type: Shape.types.TRIMESH
            });
            this.vertices = new Float32Array(vertices);
            this.indices = new Int16Array(indices);
            this.normals = new Float32Array(indices.length);
            this.aabb = new AABB();
            this.edges = null;
            this.scale = new Vec3(1, 1, 1);
            this.tree = new Octree();
            this.updateEdges();
            this.updateNormals();
            this.updateAABB();
            this.updateBoundingSphereRadius();
            this.updateTree();
          }
          Trimesh.prototype = new Shape();
          Trimesh.prototype.constructor = Trimesh;
          var computeNormals_n = new Vec3();
          Trimesh.prototype.updateTree = function() {
            var tree = this.tree;
            tree.reset();
            tree.aabb.copy(this.aabb);
            var scale = this.scale;
            tree.aabb.lowerBound.x *= 1 / scale.x;
            tree.aabb.lowerBound.y *= 1 / scale.y;
            tree.aabb.lowerBound.z *= 1 / scale.z;
            tree.aabb.upperBound.x *= 1 / scale.x;
            tree.aabb.upperBound.y *= 1 / scale.y;
            tree.aabb.upperBound.z *= 1 / scale.z;
            var triangleAABB = new AABB();
            var a = new Vec3();
            var b = new Vec3();
            var c = new Vec3();
            var points = [ a, b, c ];
            for (var i = 0; i < this.indices.length / 3; i++) {
              var i3 = 3 * i;
              this._getUnscaledVertex(this.indices[i3], a);
              this._getUnscaledVertex(this.indices[i3 + 1], b);
              this._getUnscaledVertex(this.indices[i3 + 2], c);
              triangleAABB.setFromPoints(points);
              tree.insert(triangleAABB, i);
            }
            tree.removeEmptyNodes();
          };
          var unscaledAABB = new AABB();
          Trimesh.prototype.getTrianglesInAABB = function(aabb, result) {
            unscaledAABB.copy(aabb);
            var scale = this.scale;
            var isx = scale.x;
            var isy = scale.y;
            var isz = scale.z;
            var l = unscaledAABB.lowerBound;
            var u = unscaledAABB.upperBound;
            l.x /= isx;
            l.y /= isy;
            l.z /= isz;
            u.x /= isx;
            u.y /= isy;
            u.z /= isz;
            return this.tree.aabbQuery(unscaledAABB, result);
          };
          Trimesh.prototype.setScale = function(scale) {
            var wasUniform = this.scale.x === this.scale.y === this.scale.z;
            var isUniform = scale.x === scale.y === scale.z;
            wasUniform && isUniform || this.updateNormals();
            this.scale.copy(scale);
            this.updateAABB();
            this.updateBoundingSphereRadius();
          };
          Trimesh.prototype.updateNormals = function() {
            var n = computeNormals_n;
            var normals = this.normals;
            for (var i = 0; i < this.indices.length / 3; i++) {
              var i3 = 3 * i;
              var a = this.indices[i3], b = this.indices[i3 + 1], c = this.indices[i3 + 2];
              this.getVertex(a, va);
              this.getVertex(b, vb);
              this.getVertex(c, vc);
              Trimesh.computeNormal(vb, va, vc, n);
              normals[i3] = n.x;
              normals[i3 + 1] = n.y;
              normals[i3 + 2] = n.z;
            }
          };
          Trimesh.prototype.updateEdges = function() {
            var edges = {};
            var add = function add(indexA, indexB) {
              var key = a < b ? a + "_" + b : b + "_" + a;
              edges[key] = true;
            };
            for (var i = 0; i < this.indices.length / 3; i++) {
              var i3 = 3 * i;
              var a = this.indices[i3], b = this.indices[i3 + 1], c = this.indices[i3 + 2];
              add(a, b);
              add(b, c);
              add(c, a);
            }
            var keys = Object.keys(edges);
            this.edges = new Int16Array(2 * keys.length);
            for (var i = 0; i < keys.length; i++) {
              var indices = keys[i].split("_");
              this.edges[2 * i] = parseInt(indices[0], 10);
              this.edges[2 * i + 1] = parseInt(indices[1], 10);
            }
          };
          Trimesh.prototype.getEdgeVertex = function(edgeIndex, firstOrSecond, vertexStore) {
            var vertexIndex = this.edges[2 * edgeIndex + (firstOrSecond ? 1 : 0)];
            this.getVertex(vertexIndex, vertexStore);
          };
          var getEdgeVector_va = new Vec3();
          var getEdgeVector_vb = new Vec3();
          Trimesh.prototype.getEdgeVector = function(edgeIndex, vectorStore) {
            var va = getEdgeVector_va;
            var vb = getEdgeVector_vb;
            this.getEdgeVertex(edgeIndex, 0, va);
            this.getEdgeVertex(edgeIndex, 1, vb);
            vb.vsub(va, vectorStore);
          };
          var cb = new Vec3();
          var ab = new Vec3();
          Trimesh.computeNormal = function(va, vb, vc, target) {
            vb.vsub(va, ab);
            vc.vsub(vb, cb);
            cb.cross(ab, target);
            target.isZero() || target.normalize();
          };
          var va = new Vec3();
          var vb = new Vec3();
          var vc = new Vec3();
          Trimesh.prototype.getVertex = function(i, out) {
            var scale = this.scale;
            this._getUnscaledVertex(i, out);
            out.x *= scale.x;
            out.y *= scale.y;
            out.z *= scale.z;
            return out;
          };
          Trimesh.prototype._getUnscaledVertex = function(i, out) {
            var i3 = 3 * i;
            var vertices = this.vertices;
            return out.set(vertices[i3], vertices[i3 + 1], vertices[i3 + 2]);
          };
          Trimesh.prototype.getWorldVertex = function(i, pos, quat, out) {
            this.getVertex(i, out);
            Transform.pointToWorldFrame(pos, quat, out, out);
            return out;
          };
          Trimesh.prototype.getTriangleVertices = function(i, a, b, c) {
            var i3 = 3 * i;
            this.getVertex(this.indices[i3], a);
            this.getVertex(this.indices[i3 + 1], b);
            this.getVertex(this.indices[i3 + 2], c);
          };
          Trimesh.prototype.getNormal = function(i, target) {
            var i3 = 3 * i;
            return target.set(this.normals[i3], this.normals[i3 + 1], this.normals[i3 + 2]);
          };
          var cli_aabb = new AABB();
          Trimesh.prototype.calculateLocalInertia = function(mass, target) {
            this.computeLocalAABB(cli_aabb);
            var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x, y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y, z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
            return target.set(1 / 12 * mass * (2 * y * 2 * y + 2 * z * 2 * z), 1 / 12 * mass * (2 * x * 2 * x + 2 * z * 2 * z), 1 / 12 * mass * (2 * y * 2 * y + 2 * x * 2 * x));
          };
          var computeLocalAABB_worldVert = new Vec3();
          Trimesh.prototype.computeLocalAABB = function(aabb) {
            var l = aabb.lowerBound, u = aabb.upperBound, n = this.vertices.length, vertices = this.vertices, v = computeLocalAABB_worldVert;
            this.getVertex(0, v);
            l.copy(v);
            u.copy(v);
            for (var i = 0; i !== n; i++) {
              this.getVertex(i, v);
              v.x < l.x ? l.x = v.x : v.x > u.x && (u.x = v.x);
              v.y < l.y ? l.y = v.y : v.y > u.y && (u.y = v.y);
              v.z < l.z ? l.z = v.z : v.z > u.z && (u.z = v.z);
            }
          };
          Trimesh.prototype.updateAABB = function() {
            this.computeLocalAABB(this.aabb);
          };
          Trimesh.prototype.updateBoundingSphereRadius = function() {
            var max2 = 0;
            var vertices = this.vertices;
            var v = new Vec3();
            for (var i = 0, N = vertices.length / 3; i !== N; i++) {
              this.getVertex(i, v);
              var norm2 = v.norm2();
              norm2 > max2 && (max2 = norm2);
            }
            this.boundingSphereRadius = Math.sqrt(max2);
          };
          var tempWorldVertex = new Vec3();
          var calculateWorldAABB_frame = new Transform();
          var calculateWorldAABB_aabb = new AABB();
          Trimesh.prototype.calculateWorldAABB = function(pos, quat, min, max) {
            var frame = calculateWorldAABB_frame;
            var result = calculateWorldAABB_aabb;
            frame.position = pos;
            frame.quaternion = quat;
            this.aabb.toWorldFrame(frame, result);
            min.copy(result.lowerBound);
            max.copy(result.upperBound);
          };
          Trimesh.prototype.volume = function() {
            return 4 * Math.PI * this.boundingSphereRadius / 3;
          };
          Trimesh.createTorus = function(radius, tube, radialSegments, tubularSegments, arc) {
            radius = radius || 1;
            tube = tube || .5;
            radialSegments = radialSegments || 8;
            tubularSegments = tubularSegments || 6;
            arc = arc || 2 * Math.PI;
            var vertices = [];
            var indices = [];
            for (var j = 0; j <= radialSegments; j++) for (var i = 0; i <= tubularSegments; i++) {
              var u = i / tubularSegments * arc;
              var v = j / radialSegments * Math.PI * 2;
              var x = (radius + tube * CMath.cos(v)) * CMath.cos(u);
              var y = (radius + tube * CMath.cos(v)) * CMath.sin(u);
              var z = tube * CMath.sin(v);
              vertices.push(x, y, z);
            }
            for (var j = 1; j <= radialSegments; j++) for (var i = 1; i <= tubularSegments; i++) {
              var a = (tubularSegments + 1) * j + i - 1;
              var b = (tubularSegments + 1) * (j - 1) + i - 1;
              var c = (tubularSegments + 1) * (j - 1) + i;
              var d = (tubularSegments + 1) * j + i;
              indices.push(a, b, d);
              indices.push(b, c, d);
            }
            return new Trimesh(vertices, indices);
          };
        }), {
          "../collision/AABB": 3,
          "../math/CMath": 27,
          "../math/Quaternion": 30,
          "../math/Transform": 31,
          "../math/Vec3": 32,
          "../utils/Octree": 52,
          "./Shape": 45
        } ],
        48: [ (function(_dereq_, module, exports) {
          module.exports = GSSolver;
          var Vec3 = _dereq_("../math/Vec3");
          var Quaternion = _dereq_("../math/Quaternion");
          var Solver = _dereq_("./Solver");
          function GSSolver() {
            Solver.call(this);
            this.iterations = 10;
            this.tolerance = 1e-7;
          }
          GSSolver.prototype = new Solver();
          var GSSolver_solve_lambda = [];
          var GSSolver_solve_invCs = [];
          var GSSolver_solve_Bs = [];
          GSSolver.prototype.solve = function(dt, world) {
            var iter = 0, maxIter = this.iterations, tolSquared = this.tolerance * this.tolerance, equations = this.equations, Neq = equations.length, bodies = world.bodies, Nbodies = bodies.length, h = dt, q, B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj;
            if (0 !== Neq) for (var i = 0; i !== Nbodies; i++) bodies[i].updateSolveMassProperties();
            var invCs = GSSolver_solve_invCs, Bs = GSSolver_solve_Bs, lambda = GSSolver_solve_lambda;
            invCs.length = Neq;
            Bs.length = Neq;
            lambda.length = Neq;
            for (var i = 0; i !== Neq; i++) {
              var c = equations[i];
              lambda[i] = 0;
              Bs[i] = c.computeB(h);
              invCs[i] = 1 / c.computeC();
            }
            if (0 !== Neq) {
              for (var i = 0; i !== Nbodies; i++) {
                var b = bodies[i], vlambda = b.vlambda, wlambda = b.wlambda;
                vlambda.set(0, 0, 0);
                wlambda.set(0, 0, 0);
              }
              for (iter = 0; iter !== maxIter; iter++) {
                deltalambdaTot = 0;
                for (var j = 0; j !== Neq; j++) {
                  var c = equations[j];
                  B = Bs[j];
                  invC = invCs[j];
                  lambdaj = lambda[j];
                  GWlambda = c.computeGWlambda();
                  deltalambda = invC * (B - GWlambda - c.eps * lambdaj);
                  lambdaj + deltalambda < c.minForce ? deltalambda = c.minForce - lambdaj : lambdaj + deltalambda > c.maxForce && (deltalambda = c.maxForce - lambdaj);
                  lambda[j] += deltalambda;
                  deltalambdaTot += deltalambda > 0 ? deltalambda : -deltalambda;
                  c.addToWlambda(deltalambda);
                }
                if (deltalambdaTot * deltalambdaTot < tolSquared) break;
              }
              for (var i = 0; i !== Nbodies; i++) {
                var b = bodies[i], v = b.velocity, w = b.angularVelocity;
                b.vlambda.vmul(b.linearFactor, b.vlambda);
                v.vadd(b.vlambda, v);
                b.wlambda.vmul(b.angularFactor, b.wlambda);
                w.vadd(b.wlambda, w);
              }
              var l = equations.length;
              var invDt = 1 / h;
              while (l--) equations[l].multiplier = lambda[l] * invDt;
            }
            return iter;
          };
        }), {
          "../math/Quaternion": 30,
          "../math/Vec3": 32,
          "./Solver": 49
        } ],
        49: [ (function(_dereq_, module, exports) {
          module.exports = Solver;
          function Solver() {
            this.equations = [];
          }
          Solver.prototype.solve = function(dt, world) {
            return 0;
          };
          Solver.prototype.addEquation = function(eq) {
            eq.enabled && this.equations.push(eq);
          };
          Solver.prototype.removeEquation = function(eq) {
            var eqs = this.equations;
            var i = eqs.indexOf(eq);
            -1 !== i && eqs.splice(i, 1);
          };
          Solver.prototype.removeAllEquations = function() {
            this.equations.length = 0;
          };
        }), {} ],
        50: [ (function(_dereq_, module, exports) {
          module.exports = SplitSolver;
          var Vec3 = _dereq_("../math/Vec3");
          var Quaternion = _dereq_("../math/Quaternion");
          var Solver = _dereq_("./Solver");
          var Body = _dereq_("../objects/Body");
          function SplitSolver(subsolver) {
            Solver.call(this);
            this.iterations = 10;
            this.tolerance = 1e-7;
            this.subsolver = subsolver;
            this.nodes = [];
            this.nodePool = [];
            while (this.nodePool.length < 128) this.nodePool.push(this.createNode());
          }
          SplitSolver.prototype = new Solver();
          var SplitSolver_solve_nodes = [];
          var SplitSolver_solve_nodePool = [];
          var SplitSolver_solve_eqs = [];
          var SplitSolver_solve_bds = [];
          var SplitSolver_solve_dummyWorld = {
            bodies: []
          };
          var STATIC = Body.STATIC;
          function getUnvisitedNode(nodes) {
            var Nnodes = nodes.length;
            for (var i = 0; i !== Nnodes; i++) {
              var node = nodes[i];
              if (!node.visited && !(node.body.type & STATIC)) return node;
            }
            return false;
          }
          var queue = [];
          function bfs(root, visitFunc, bds, eqs) {
            queue.push(root);
            root.visited = true;
            visitFunc(root, bds, eqs);
            while (queue.length) {
              var node = queue.pop();
              var child;
              while (child = getUnvisitedNode(node.children)) {
                child.visited = true;
                visitFunc(child, bds, eqs);
                queue.push(child);
              }
            }
          }
          function visitFunc(node, bds, eqs) {
            bds.push(node.body);
            var Neqs = node.eqs.length;
            for (var i = 0; i !== Neqs; i++) {
              var eq = node.eqs[i];
              -1 === eqs.indexOf(eq) && eqs.push(eq);
            }
          }
          SplitSolver.prototype.createNode = function() {
            return {
              body: null,
              children: [],
              eqs: [],
              visited: false
            };
          };
          SplitSolver.prototype.solve = function(dt, world) {
            var nodes = SplitSolver_solve_nodes, nodePool = this.nodePool, bodies = world.bodies, equations = this.equations, Neq = equations.length, Nbodies = bodies.length, subsolver = this.subsolver;
            while (nodePool.length < Nbodies) nodePool.push(this.createNode());
            nodes.length = Nbodies;
            for (var i = 0; i < Nbodies; i++) nodes[i] = nodePool[i];
            for (var i = 0; i !== Nbodies; i++) {
              var node = nodes[i];
              node.body = bodies[i];
              node.children.length = 0;
              node.eqs.length = 0;
              node.visited = false;
            }
            for (var k = 0; k !== Neq; k++) {
              var eq = equations[k], i = bodies.indexOf(eq.bi), j = bodies.indexOf(eq.bj), ni = nodes[i], nj = nodes[j];
              ni.children.push(nj);
              ni.eqs.push(eq);
              nj.children.push(ni);
              nj.eqs.push(eq);
            }
            var child, n = 0, eqs = SplitSolver_solve_eqs;
            subsolver.tolerance = this.tolerance;
            subsolver.iterations = this.iterations;
            var dummyWorld = SplitSolver_solve_dummyWorld;
            while (child = getUnvisitedNode(nodes)) {
              eqs.length = 0;
              dummyWorld.bodies.length = 0;
              bfs(child, visitFunc, dummyWorld.bodies, eqs);
              var Neqs = eqs.length;
              eqs = eqs.sort(sortById);
              for (var i = 0; i !== Neqs; i++) subsolver.addEquation(eqs[i]);
              var iter = subsolver.solve(dt, dummyWorld);
              subsolver.removeAllEquations();
              n++;
            }
            return n;
          };
          function sortById(a, b) {
            return b.id - a.id;
          }
        }), {
          "../math/Quaternion": 30,
          "../math/Vec3": 32,
          "../objects/Body": 33,
          "./Solver": 49
        } ],
        51: [ (function(_dereq_, module, exports) {
          var EventTarget = function EventTarget() {};
          module.exports = EventTarget;
          EventTarget.prototype = {
            constructor: EventTarget,
            addEventListener: function addEventListener(type, listener) {
              void 0 === this._listeners && (this._listeners = {});
              var listeners = this._listeners;
              void 0 === listeners[type] && (listeners[type] = []);
              -1 === listeners[type].indexOf(listener) && listeners[type].push(listener);
              return this;
            },
            hasEventListener: function hasEventListener(type, listener) {
              if (void 0 === this._listeners) return false;
              var listeners = this._listeners;
              if (void 0 !== listeners[type] && -1 !== listeners[type].indexOf(listener)) return true;
              return false;
            },
            hasAnyEventListener: function hasAnyEventListener(type) {
              if (void 0 === this._listeners) return false;
              var listeners = this._listeners;
              return void 0 !== listeners[type];
            },
            removeEventListener: function removeEventListener(type, listener) {
              if (void 0 === this._listeners) return this;
              var listeners = this._listeners;
              if (void 0 === listeners[type]) return this;
              var index = listeners[type].indexOf(listener);
              -1 !== index && listeners[type].splice(index, 1);
              return this;
            },
            dispatchEvent: function dispatchEvent(event) {
              if (void 0 === this._listeners) return this;
              var listeners = this._listeners;
              var listenerArray = listeners[event.type];
              if (void 0 !== listenerArray) {
                event.target = this;
                for (var i = 0, l = listenerArray.length; i < l; i++) listenerArray[i].call(this, event);
              }
              return this;
            }
          };
        }), {} ],
        52: [ (function(_dereq_, module, exports) {
          var AABB = _dereq_("../collision/AABB");
          var Vec3 = _dereq_("../math/Vec3");
          module.exports = Octree;
          function OctreeNode(options) {
            options = options || {};
            this.root = options.root || null;
            this.aabb = options.aabb ? options.aabb.clone() : new AABB();
            this.data = [];
            this.children = [];
          }
          function Octree(aabb, options) {
            options = options || {};
            options.root = null;
            options.aabb = aabb;
            OctreeNode.call(this, options);
            this.maxDepth = "undefined" !== typeof options.maxDepth ? options.maxDepth : 8;
          }
          Octree.prototype = new OctreeNode();
          OctreeNode.prototype.reset = function(aabb, options) {
            this.children.length = this.data.length = 0;
          };
          OctreeNode.prototype.insert = function(aabb, elementData, level) {
            var nodeData = this.data;
            level = level || 0;
            if (!this.aabb.contains(aabb)) return false;
            var children = this.children;
            if (level < (this.maxDepth || this.root.maxDepth)) {
              var subdivided = false;
              if (!children.length) {
                this.subdivide();
                subdivided = true;
              }
              for (var i = 0; 8 !== i; i++) if (children[i].insert(aabb, elementData, level + 1)) return true;
              subdivided && (children.length = 0);
            }
            nodeData.push(elementData);
            return true;
          };
          var halfDiagonal = new Vec3();
          OctreeNode.prototype.subdivide = function() {
            var aabb = this.aabb;
            var l = aabb.lowerBound;
            var u = aabb.upperBound;
            var children = this.children;
            children.push(new OctreeNode({
              aabb: new AABB({
                lowerBound: new Vec3(0, 0, 0)
              })
            }), new OctreeNode({
              aabb: new AABB({
                lowerBound: new Vec3(1, 0, 0)
              })
            }), new OctreeNode({
              aabb: new AABB({
                lowerBound: new Vec3(1, 1, 0)
              })
            }), new OctreeNode({
              aabb: new AABB({
                lowerBound: new Vec3(1, 1, 1)
              })
            }), new OctreeNode({
              aabb: new AABB({
                lowerBound: new Vec3(0, 1, 1)
              })
            }), new OctreeNode({
              aabb: new AABB({
                lowerBound: new Vec3(0, 0, 1)
              })
            }), new OctreeNode({
              aabb: new AABB({
                lowerBound: new Vec3(1, 0, 1)
              })
            }), new OctreeNode({
              aabb: new AABB({
                lowerBound: new Vec3(0, 1, 0)
              })
            }));
            u.vsub(l, halfDiagonal);
            halfDiagonal.scale(.5, halfDiagonal);
            var root = this.root || this;
            for (var i = 0; 8 !== i; i++) {
              var child = children[i];
              child.root = root;
              var lowerBound = child.aabb.lowerBound;
              lowerBound.x *= halfDiagonal.x;
              lowerBound.y *= halfDiagonal.y;
              lowerBound.z *= halfDiagonal.z;
              lowerBound.vadd(l, lowerBound);
              lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
            }
          };
          OctreeNode.prototype.aabbQuery = function(aabb, result) {
            var nodeData = this.data;
            var children = this.children;
            var queue = [ this ];
            while (queue.length) {
              var node = queue.pop();
              node.aabb.overlaps(aabb) && Array.prototype.push.apply(result, node.data);
              Array.prototype.push.apply(queue, node.children);
            }
            return result;
          };
          var tmpAABB = new AABB();
          OctreeNode.prototype.rayQuery = function(ray, treeTransform, result) {
            ray.getAABB(tmpAABB);
            tmpAABB.toLocalFrame(treeTransform, tmpAABB);
            this.aabbQuery(tmpAABB, result);
            return result;
          };
          OctreeNode.prototype.removeEmptyNodes = function() {
            for (var i = this.children.length - 1; i >= 0; i--) {
              this.children[i].removeEmptyNodes();
              this.children[i].children.length || this.children[i].data.length || this.children.splice(i, 1);
            }
          };
        }), {
          "../collision/AABB": 3,
          "../math/Vec3": 32
        } ],
        53: [ (function(_dereq_, module, exports) {
          module.exports = Pool;
          function Pool() {
            this.objects = [];
            this.type = Object;
          }
          Pool.prototype.release = function() {
            var Nargs = arguments.length;
            for (var i = 0; i !== Nargs; i++) this.objects.push(arguments[i]);
            return this;
          };
          Pool.prototype.get = function() {
            return 0 === this.objects.length ? this.constructObject() : this.objects.pop();
          };
          Pool.prototype.constructObject = function() {
            throw new Error("constructObject() not implemented in this Pool subclass yet!");
          };
          Pool.prototype.resize = function(size) {
            var objects = this.objects;
            while (objects.length > size) objects.pop();
            while (objects.length < size) objects.push(this.constructObject());
            return this;
          };
        }), {} ],
        54: [ (function(_dereq_, module, exports) {
          module.exports = TupleDictionary;
          function TupleDictionary() {
            this.data = {
              keys: []
            };
          }
          TupleDictionary.prototype.get = function(i, j) {
            if (i > j) {
              var temp = j;
              j = i;
              i = temp;
            }
            return this.data[i + "-" + j];
          };
          TupleDictionary.prototype.set = function(i, j, value) {
            if (i > j) {
              var temp = j;
              j = i;
              i = temp;
            }
            var key = i + "-" + j;
            this.get(i, j) || this.data.keys.push(key);
            this.data[key] = value;
            return this.data[key];
          };
          TupleDictionary.prototype.del = function(i, j) {
            if (i > j) {
              var temp = j;
              j = i;
              i = temp;
            }
            var key = i + "-" + j;
            var index = this.data.keys.indexOf(key);
            if (index >= 0) {
              this.data.keys.splice(index, 1);
              delete this.data[key];
              return true;
            }
            return false;
          };
          TupleDictionary.prototype.reset = function() {
            this.data = {
              keys: []
            };
          };
          TupleDictionary.prototype.getLength = function() {
            return this.data.keys.length;
          };
          TupleDictionary.prototype.getKeyByIndex = function(index) {
            return this.data.keys[index];
          };
          TupleDictionary.prototype.getDataByKey = function(Key) {
            return this.data[Key];
          };
        }), {} ],
        55: [ (function(_dereq_, module, exports) {
          function Utils() {}
          module.exports = Utils;
          Utils.defaults = function(options, defaults) {
            options = options || {};
            for (var key in defaults) key in options || (options[key] = defaults[key]);
            return options;
          };
        }), {} ],
        56: [ (function(_dereq_, module, exports) {
          module.exports = Vec3Pool;
          var Vec3 = _dereq_("../math/Vec3");
          var Pool = _dereq_("./Pool");
          function Vec3Pool() {
            Pool.call(this);
            this.type = Vec3;
          }
          Vec3Pool.prototype = new Pool();
          Vec3Pool.prototype.constructObject = function() {
            return new Vec3();
          };
        }), {
          "../math/Vec3": 32,
          "./Pool": 53
        } ],
        57: [ (function(_dereq_, module, exports) {
          module.exports = Narrowphase;
          var AABB = _dereq_("../collision/AABB");
          var Body = _dereq_("../objects/Body");
          var Shape = _dereq_("../shapes/Shape");
          var Ray = _dereq_("../collision/Ray");
          var Vec3 = _dereq_("../math/Vec3");
          var Transform = _dereq_("../math/Transform");
          var ConvexPolyhedron = _dereq_("../shapes/ConvexPolyhedron");
          var Quaternion = _dereq_("../math/Quaternion");
          var Solver = _dereq_("../solver/Solver");
          var Vec3Pool = _dereq_("../utils/Vec3Pool");
          var ContactEquation = _dereq_("../equations/ContactEquation");
          var FrictionEquation = _dereq_("../equations/FrictionEquation");
          function Narrowphase(world) {
            this.contactPointPool = [];
            this.frictionEquationPool = [];
            this.result = [];
            this.frictionResult = [];
            this.v3pool = new Vec3Pool();
            this.world = world;
            this.currentContactMaterial = null;
            this.enableFrictionReduction = false;
          }
          Narrowphase.prototype.createContactEquation = function(bi, bj, si, sj, overrideShapeA, overrideShapeB) {
            var c;
            if (this.contactPointPool.length) {
              c = this.contactPointPool.pop();
              c.bi = bi;
              c.bj = bj;
            } else c = new ContactEquation(bi, bj);
            c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;
            var cm = this.currentContactMaterial;
            c.restitution = cm.restitution;
            c.setSpookParams(cm.contactEquationStiffness, cm.contactEquationRelaxation, this.world.dt);
            var matA = si.material || bi.material;
            var matB = sj.material || bj.material;
            matA && matB && matA.restitution >= 0 && matB.restitution >= 0 && (c.restitution = matA.restitution * matB.restitution);
            c.si = overrideShapeA || si;
            c.sj = overrideShapeB || sj;
            return c;
          };
          Narrowphase.prototype.createFrictionEquationsFromContact = function(contactEquation, outArray) {
            var bodyA = contactEquation.bi;
            var bodyB = contactEquation.bj;
            var shapeA = contactEquation.si;
            var shapeB = contactEquation.sj;
            var world = this.world;
            var cm = this.currentContactMaterial;
            var friction = cm.friction;
            var matA = shapeA.material || bodyA.material;
            var matB = shapeB.material || bodyB.material;
            matA && matB && matA.friction >= 0 && matB.friction >= 0 && (friction = matA.friction * matB.friction);
            if (friction > 0) {
              var mug = friction * world.gravity.length();
              var reducedMass = bodyA.invMass + bodyB.invMass;
              reducedMass > 0 && (reducedMass = 1 / reducedMass);
              var pool = this.frictionEquationPool;
              var c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
              var c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
              c1.bi = c2.bi = bodyA;
              c1.bj = c2.bj = bodyB;
              c1.minForce = c2.minForce = -mug * reducedMass;
              c1.maxForce = c2.maxForce = mug * reducedMass;
              c1.ri.copy(contactEquation.ri);
              c1.rj.copy(contactEquation.rj);
              c2.ri.copy(contactEquation.ri);
              c2.rj.copy(contactEquation.rj);
              contactEquation.ni.tangents(c1.t, c2.t);
              c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
              c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
              c1.enabled = c2.enabled = contactEquation.enabled;
              outArray.push(c1, c2);
              return true;
            }
            return false;
          };
          var averageNormal = new Vec3();
          var averageContactPointA = new Vec3();
          var averageContactPointB = new Vec3();
          Narrowphase.prototype.createFrictionFromAverage = function(numContacts) {
            var c = this.result[this.result.length - 1];
            if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || 1 === numContacts) return;
            var f1 = this.frictionResult[this.frictionResult.length - 2];
            var f2 = this.frictionResult[this.frictionResult.length - 1];
            averageNormal.setZero();
            averageContactPointA.setZero();
            averageContactPointB.setZero();
            var bodyA = c.bi;
            var bodyB = c.bj;
            for (var i = 0; i !== numContacts; i++) {
              c = this.result[this.result.length - 1 - i];
              if (c.bodyA !== bodyA) {
                averageNormal.vadd(c.ni, averageNormal);
                averageContactPointA.vadd(c.ri, averageContactPointA);
                averageContactPointB.vadd(c.rj, averageContactPointB);
              } else {
                averageNormal.vsub(c.ni, averageNormal);
                averageContactPointA.vadd(c.rj, averageContactPointA);
                averageContactPointB.vadd(c.ri, averageContactPointB);
              }
            }
            var invNumContacts = 1 / numContacts;
            averageContactPointA.scale(invNumContacts, f1.ri);
            averageContactPointB.scale(invNumContacts, f1.rj);
            f2.ri.copy(f1.ri);
            f2.rj.copy(f1.rj);
            averageNormal.normalize();
            averageNormal.tangents(f1.t, f2.t);
          };
          var tmpVec1 = new Vec3();
          var tmpVec2 = new Vec3();
          var tmpQuat1 = new Quaternion();
          var tmpQuat2 = new Quaternion();
          Narrowphase.prototype.getContacts = function(p1, p2, world, result, oldcontacts, frictionResult, frictionPool) {
            this.contactPointPool = oldcontacts;
            this.frictionEquationPool = frictionPool;
            this.result = result;
            this.frictionResult = frictionResult;
            var qi = tmpQuat1;
            var qj = tmpQuat2;
            var xi = tmpVec1;
            var xj = tmpVec2;
            for (var k = 0, N = p1.length; k !== N; k++) {
              var bi = p1[k], bj = p2[k];
              var bodyContactMaterial = null;
              bi.material && bj.material && (bodyContactMaterial = world.getContactMaterial(bi.material, bj.material) || null);
              var justTest = false == bi.collisionResponse || false == bj.collisionResponse || bi.type & Body.KINEMATIC && bj.type & Body.STATIC || bi.type & Body.STATIC && bj.type & Body.KINEMATIC || bi.type & Body.KINEMATIC && bj.type & Body.KINEMATIC;
              for (var i = 0; i < bi.shapes.length; i++) {
                bi.quaternion.mult(bi.shapeOrientations[i], qi);
                bi.quaternion.vmult(bi.shapeOffsets[i], xi);
                xi.vadd(bi.position, xi);
                var si = bi.shapes[i];
                for (var j = 0; j < bj.shapes.length; j++) {
                  bj.quaternion.mult(bj.shapeOrientations[j], qj);
                  bj.quaternion.vmult(bj.shapeOffsets[j], xj);
                  xj.vadd(bj.position, xj);
                  var sj = bj.shapes[j];
                  if (!(si.collisionFilterMask & sj.collisionFilterGroup && sj.collisionFilterMask & si.collisionFilterGroup)) continue;
                  if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) continue;
                  justTest |= false == si.collisionResponse || false == sj.collisionResponse;
                  var shapeContactMaterial = null;
                  si.material && sj.material && (shapeContactMaterial = world.getContactMaterial(si.material, sj.material) || null);
                  this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial;
                  var resolver = this[si.type | sj.type];
                  if (resolver) {
                    var retval = false;
                    retval = si.type < sj.type ? resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest) : resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj, justTest);
                    if (retval && justTest) {
                      world.shapeOverlapKeeper.set(si.id, sj.id);
                      world.bodyOverlapKeeper.set(bi.id, bj.id);
                      var data = {
                        si: si,
                        sj: sj
                      };
                      world.triggerDic.set(si.id, sj.id, data);
                      world.oldTriggerDic.set(si.id, sj.id, data);
                    }
                  }
                }
              }
            }
          };
          var numWarnings = 0;
          var maxWarnings = 10;
          function warn(msg) {
            if (numWarnings > maxWarnings) return;
            numWarnings++;
            console.warn(msg);
          }
          Narrowphase.prototype[Shape.types.BOX | Shape.types.BOX] = Narrowphase.prototype.boxBox = function(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            si.convexPolyhedronRepresentation.material = si.material;
            sj.convexPolyhedronRepresentation.material = sj.material;
            si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
            sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
            return this.convexConvex(si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
          };
          Narrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.boxConvex = function(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            si.convexPolyhedronRepresentation.material = si.material;
            si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
            return this.convexConvex(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
          };
          Narrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] = Narrowphase.prototype.boxParticle = function(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            si.convexPolyhedronRepresentation.material = si.material;
            si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
            return this.convexParticle(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
          };
          Narrowphase.prototype[Shape.types.SPHERE] = Narrowphase.prototype.sphereSphere = function(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            if (justTest) return xi.distanceSquared(xj) < Math.pow(si.radius + sj.radius, 2);
            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
            xj.vsub(xi, r.ni);
            r.ni.normalize();
            r.ri.copy(r.ni);
            r.rj.copy(r.ni);
            r.ri.mult(si.radius, r.ri);
            r.rj.mult(-sj.radius, r.rj);
            r.ri.vadd(xi, r.ri);
            r.ri.vsub(bi.position, r.ri);
            r.rj.vadd(xj, r.rj);
            r.rj.vsub(bj.position, r.rj);
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
          };
          var planeTrimesh_normal = new Vec3();
          var planeTrimesh_relpos = new Vec3();
          var planeTrimesh_projected = new Vec3();
          Narrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] = Narrowphase.prototype.planeTrimesh = function(planeShape, trimeshShape, planePos, trimeshPos, planeQuat, trimeshQuat, planeBody, trimeshBody, rsi, rsj, justTest) {
            var v = new Vec3();
            var normal = planeTrimesh_normal;
            normal.set(0, 0, 1);
            planeQuat.vmult(normal, normal);
            for (var i = 0; i < trimeshShape.vertices.length / 3; i++) {
              trimeshShape.getVertex(i, v);
              var v2 = new Vec3();
              v2.copy(v);
              Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);
              var relpos = planeTrimesh_relpos;
              v.vsub(planePos, relpos);
              var dot = normal.dot(relpos);
              if (dot <= 0) {
                if (justTest) return true;
                var r = this.createContactEquation(planeBody, trimeshBody, planeShape, trimeshShape, rsi, rsj);
                r.ni.copy(normal);
                var projected = planeTrimesh_projected;
                normal.scale(relpos.dot(normal), projected);
                v.vsub(projected, projected);
                r.ri.copy(projected);
                r.ri.vsub(planeBody.position, r.ri);
                r.rj.copy(v);
                r.rj.vsub(trimeshBody.position, r.rj);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
              }
            }
          };
          var sphereTrimesh_normal = new Vec3();
          var sphereTrimesh_relpos = new Vec3();
          var sphereTrimesh_projected = new Vec3();
          var sphereTrimesh_v = new Vec3();
          var sphereTrimesh_v2 = new Vec3();
          var sphereTrimesh_edgeVertexA = new Vec3();
          var sphereTrimesh_edgeVertexB = new Vec3();
          var sphereTrimesh_edgeVector = new Vec3();
          var sphereTrimesh_edgeVectorUnit = new Vec3();
          var sphereTrimesh_localSpherePos = new Vec3();
          var sphereTrimesh_tmp = new Vec3();
          var sphereTrimesh_va = new Vec3();
          var sphereTrimesh_vb = new Vec3();
          var sphereTrimesh_vc = new Vec3();
          var sphereTrimesh_localSphereAABB = new AABB();
          var sphereTrimesh_triangles = [];
          Narrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] = Narrowphase.prototype.sphereTrimesh = function(sphereShape, trimeshShape, spherePos, trimeshPos, sphereQuat, trimeshQuat, sphereBody, trimeshBody, rsi, rsj, justTest) {
            var edgeVertexA = sphereTrimesh_edgeVertexA;
            var edgeVertexB = sphereTrimesh_edgeVertexB;
            var edgeVector = sphereTrimesh_edgeVector;
            var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
            var localSpherePos = sphereTrimesh_localSpherePos;
            var tmp = sphereTrimesh_tmp;
            var localSphereAABB = sphereTrimesh_localSphereAABB;
            var v2 = sphereTrimesh_v2;
            var relpos = sphereTrimesh_relpos;
            var triangles = sphereTrimesh_triangles;
            Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos);
            var sphereRadius = sphereShape.radius;
            localSphereAABB.lowerBound.set(localSpherePos.x - sphereRadius, localSpherePos.y - sphereRadius, localSpherePos.z - sphereRadius);
            localSphereAABB.upperBound.set(localSpherePos.x + sphereRadius, localSpherePos.y + sphereRadius, localSpherePos.z + sphereRadius);
            trimeshShape.getTrianglesInAABB(localSphereAABB, triangles);
            var v = sphereTrimesh_v;
            var radiusSquared = sphereShape.radius * sphereShape.radius;
            for (var i = 0; i < triangles.length; i++) for (var j = 0; j < 3; j++) {
              trimeshShape.getVertex(trimeshShape.indices[3 * triangles[i] + j], v);
              v.vsub(localSpherePos, relpos);
              if (relpos.norm2() <= radiusSquared) {
                v2.copy(v);
                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);
                v.vsub(spherePos, relpos);
                if (justTest) return true;
                var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
                r.ni.copy(relpos);
                r.ni.normalize();
                r.ri.copy(r.ni);
                r.ri.scale(sphereShape.radius, r.ri);
                r.ri.vadd(spherePos, r.ri);
                r.ri.vsub(sphereBody.position, r.ri);
                r.rj.copy(v);
                r.rj.vsub(trimeshBody.position, r.rj);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
              }
            }
            for (var i = 0; i < triangles.length; i++) for (var j = 0; j < 3; j++) {
              trimeshShape.getVertex(trimeshShape.indices[3 * triangles[i] + j], edgeVertexA);
              trimeshShape.getVertex(trimeshShape.indices[3 * triangles[i] + (j + 1) % 3], edgeVertexB);
              edgeVertexB.vsub(edgeVertexA, edgeVector);
              localSpherePos.vsub(edgeVertexB, tmp);
              var positionAlongEdgeB = tmp.dot(edgeVector);
              localSpherePos.vsub(edgeVertexA, tmp);
              var positionAlongEdgeA = tmp.dot(edgeVector);
              if (positionAlongEdgeA > 0 && positionAlongEdgeB < 0) {
                localSpherePos.vsub(edgeVertexA, tmp);
                edgeVectorUnit.copy(edgeVector);
                edgeVectorUnit.normalize();
                positionAlongEdgeA = tmp.dot(edgeVectorUnit);
                edgeVectorUnit.scale(positionAlongEdgeA, tmp);
                tmp.vadd(edgeVertexA, tmp);
                var dist = tmp.distanceTo(localSpherePos);
                if (dist < sphereShape.radius) {
                  if (justTest) return true;
                  var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
                  tmp.vsub(localSpherePos, r.ni);
                  r.ni.normalize();
                  r.ni.scale(sphereShape.radius, r.ri);
                  Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
                  tmp.vsub(trimeshBody.position, r.rj);
                  Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                  Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
                  this.result.push(r);
                  this.createFrictionEquationsFromContact(r, this.frictionResult);
                }
              }
            }
            var va = sphereTrimesh_va;
            var vb = sphereTrimesh_vb;
            var vc = sphereTrimesh_vc;
            var normal = sphereTrimesh_normal;
            for (var i = 0, N = triangles.length; i !== N; i++) {
              trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
              trimeshShape.getNormal(triangles[i], normal);
              localSpherePos.vsub(va, tmp);
              var dist = tmp.dot(normal);
              normal.scale(dist, tmp);
              localSpherePos.vsub(tmp, tmp);
              dist = tmp.distanceTo(localSpherePos);
              if (Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius) {
                if (justTest) return true;
                var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape, rsi, rsj);
                tmp.vsub(localSpherePos, r.ni);
                r.ni.normalize();
                r.ni.scale(sphereShape.radius, r.ri);
                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
                tmp.vsub(trimeshBody.position, r.rj);
                Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
              }
            }
            triangles.length = 0;
          };
          var point_on_plane_to_sphere = new Vec3();
          var plane_to_sphere_ortho = new Vec3();
          var p_s_ni = new Vec3();
          var p_s_ri = new Vec3();
          var p_s_rj = new Vec3();
          Narrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] = Narrowphase.prototype.spherePlane = function(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            p_s_ni.set(0, 0, 1);
            qj.vmult(p_s_ni, p_s_ni);
            p_s_ni.negate(p_s_ni);
            p_s_ni.normalize();
            p_s_ni.mult(si.radius, p_s_ri);
            xi.vsub(xj, point_on_plane_to_sphere);
            p_s_ni.mult(p_s_ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
            point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, p_s_rj);
            if (-point_on_plane_to_sphere.dot(p_s_ni) <= si.radius) {
              if (justTest) return true;
              var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
              r.ni.copy(p_s_ni);
              r.ri.copy(p_s_ri);
              r.rj.copy(p_s_rj);
              var ri = r.ri;
              var rj = r.rj;
              ri.vadd(xi, ri);
              ri.vsub(bi.position, ri);
              rj.vadd(xj, rj);
              rj.vsub(bj.position, rj);
              this.result.push(r);
              this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
            return false;
          };
          var pointInPolygon_edge = new Vec3();
          var pointInPolygon_edge_x_normal = new Vec3();
          var pointInPolygon_vtp = new Vec3();
          function pointInPolygon(verts, normal, p) {
            var positiveResult = null;
            var N = verts.length;
            for (var i = 0; i !== N; i++) {
              var v = verts[i];
              var edge = pointInPolygon_edge;
              verts[(i + 1) % N].vsub(v, edge);
              var edge_x_normal = pointInPolygon_edge_x_normal;
              edge.cross(normal, edge_x_normal);
              var vertex_to_p = pointInPolygon_vtp;
              p.vsub(v, vertex_to_p);
              var r = edge_x_normal.dot(vertex_to_p);
              if (null === positiveResult || r > 0 && true === positiveResult || r <= 0 && false === positiveResult) {
                null === positiveResult && (positiveResult = r > 0);
                continue;
              }
              return false;
            }
            return true;
          }
          var box_to_sphere = new Vec3();
          var sphereBox_ns = new Vec3();
          var sphereBox_ns1 = new Vec3();
          var sphereBox_ns2 = new Vec3();
          var sphereBox_sides = [ new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3() ];
          var sphereBox_sphere_to_corner = new Vec3();
          var sphereBox_side_ns = new Vec3();
          var sphereBox_side_ns1 = new Vec3();
          var sphereBox_side_ns2 = new Vec3();
          Narrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] = Narrowphase.prototype.sphereBox = function(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            var v3pool = this.v3pool;
            var sides = sphereBox_sides;
            xi.vsub(xj, box_to_sphere);
            sj.getSideNormals(sides, qj);
            var R = si.radius;
            var penetrating_sides = [];
            var found = false;
            var side_ns = sphereBox_side_ns;
            var side_ns1 = sphereBox_side_ns1;
            var side_ns2 = sphereBox_side_ns2;
            var side_h = null;
            var side_penetrations = 0;
            var side_dot1 = 0;
            var side_dot2 = 0;
            var side_distance = null;
            for (var idx = 0, nsides = sides.length; idx !== nsides && false === found; idx++) {
              var ns = sphereBox_ns;
              ns.copy(sides[idx]);
              var h = ns.norm();
              ns.normalize();
              var dot = box_to_sphere.dot(ns);
              if (dot < h + R && dot > 0) {
                var ns1 = sphereBox_ns1;
                var ns2 = sphereBox_ns2;
                ns1.copy(sides[(idx + 1) % 3]);
                ns2.copy(sides[(idx + 2) % 3]);
                var h1 = ns1.norm();
                var h2 = ns2.norm();
                ns1.normalize();
                ns2.normalize();
                var dot1 = box_to_sphere.dot(ns1);
                var dot2 = box_to_sphere.dot(ns2);
                if (dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2) {
                  var dist = Math.abs(dot - h - R);
                  if (null === side_distance || dist < side_distance) {
                    side_distance = dist;
                    side_dot1 = dot1;
                    side_dot2 = dot2;
                    side_h = h;
                    side_ns.copy(ns);
                    side_ns1.copy(ns1);
                    side_ns2.copy(ns2);
                    side_penetrations++;
                    if (justTest) return true;
                  }
                }
              }
            }
            if (side_penetrations) {
              found = true;
              var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
              side_ns.mult(-R, r.ri);
              r.ni.copy(side_ns);
              r.ni.negate(r.ni);
              side_ns.mult(side_h, side_ns);
              side_ns1.mult(side_dot1, side_ns1);
              side_ns.vadd(side_ns1, side_ns);
              side_ns2.mult(side_dot2, side_ns2);
              side_ns.vadd(side_ns2, r.rj);
              r.ri.vadd(xi, r.ri);
              r.ri.vsub(bi.position, r.ri);
              r.rj.vadd(xj, r.rj);
              r.rj.vsub(bj.position, r.rj);
              this.result.push(r);
              this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
            var rj = v3pool.get();
            var sphere_to_corner = sphereBox_sphere_to_corner;
            for (var j = 0; 2 !== j && !found; j++) for (var k = 0; 2 !== k && !found; k++) for (var l = 0; 2 !== l && !found; l++) {
              rj.set(0, 0, 0);
              j ? rj.vadd(sides[0], rj) : rj.vsub(sides[0], rj);
              k ? rj.vadd(sides[1], rj) : rj.vsub(sides[1], rj);
              l ? rj.vadd(sides[2], rj) : rj.vsub(sides[2], rj);
              xj.vadd(rj, sphere_to_corner);
              sphere_to_corner.vsub(xi, sphere_to_corner);
              if (sphere_to_corner.norm2() < R * R) {
                if (justTest) return true;
                found = true;
                var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                r.ri.copy(sphere_to_corner);
                r.ri.normalize();
                r.ni.copy(r.ri);
                r.ri.mult(R, r.ri);
                r.rj.copy(rj);
                r.ri.vadd(xi, r.ri);
                r.ri.vsub(bi.position, r.ri);
                r.rj.vadd(xj, r.rj);
                r.rj.vsub(bj.position, r.rj);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
              }
            }
            v3pool.release(rj);
            rj = null;
            var edgeTangent = v3pool.get();
            var edgeCenter = v3pool.get();
            var r = v3pool.get();
            var orthogonal = v3pool.get();
            var dist = v3pool.get();
            var Nsides = sides.length;
            for (var j = 0; j !== Nsides && !found; j++) for (var k = 0; k !== Nsides && !found; k++) if (j % 3 !== k % 3) {
              sides[k].cross(sides[j], edgeTangent);
              edgeTangent.normalize();
              sides[j].vadd(sides[k], edgeCenter);
              r.copy(xi);
              r.vsub(edgeCenter, r);
              r.vsub(xj, r);
              var orthonorm = r.dot(edgeTangent);
              edgeTangent.mult(orthonorm, orthogonal);
              var l = 0;
              while (l === j % 3 || l === k % 3) l++;
              dist.copy(xi);
              dist.vsub(orthogonal, dist);
              dist.vsub(edgeCenter, dist);
              dist.vsub(xj, dist);
              var tdist = Math.abs(orthonorm);
              var ndist = dist.norm();
              if (tdist < sides[l].norm() && ndist < R) {
                if (justTest) return true;
                found = true;
                var res = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                edgeCenter.vadd(orthogonal, res.rj);
                res.rj.copy(res.rj);
                dist.negate(res.ni);
                res.ni.normalize();
                res.ri.copy(res.rj);
                res.ri.vadd(xj, res.ri);
                res.ri.vsub(xi, res.ri);
                res.ri.normalize();
                res.ri.mult(R, res.ri);
                res.ri.vadd(xi, res.ri);
                res.ri.vsub(bi.position, res.ri);
                res.rj.vadd(xj, res.rj);
                res.rj.vsub(bj.position, res.rj);
                this.result.push(res);
                this.createFrictionEquationsFromContact(res, this.frictionResult);
              }
            }
            v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist);
          };
          var convex_to_sphere = new Vec3();
          var sphereConvex_edge = new Vec3();
          var sphereConvex_edgeUnit = new Vec3();
          var sphereConvex_sphereToCorner = new Vec3();
          var sphereConvex_worldCorner = new Vec3();
          var sphereConvex_worldNormal = new Vec3();
          var sphereConvex_worldPoint = new Vec3();
          var sphereConvex_worldSpherePointClosestToPlane = new Vec3();
          var sphereConvex_penetrationVec = new Vec3();
          var sphereConvex_sphereToWorldPoint = new Vec3();
          Narrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.sphereConvex = function(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            var v3pool = this.v3pool;
            xi.vsub(xj, convex_to_sphere);
            var normals = sj.faceNormals;
            var faces = sj.faces;
            var verts = sj.vertices;
            var R = si.radius;
            var penetrating_sides = [];
            for (var i = 0; i !== verts.length; i++) {
              var v = verts[i];
              var worldCorner = sphereConvex_worldCorner;
              qj.vmult(v, worldCorner);
              xj.vadd(worldCorner, worldCorner);
              var sphere_to_corner = sphereConvex_sphereToCorner;
              worldCorner.vsub(xi, sphere_to_corner);
              if (sphere_to_corner.norm2() < R * R) {
                if (justTest) return true;
                found = true;
                var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                r.ri.copy(sphere_to_corner);
                r.ri.normalize();
                r.ni.copy(r.ri);
                r.ri.mult(R, r.ri);
                worldCorner.vsub(xj, r.rj);
                r.ri.vadd(xi, r.ri);
                r.ri.vsub(bi.position, r.ri);
                r.rj.vadd(xj, r.rj);
                r.rj.vsub(bj.position, r.rj);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
                return;
              }
            }
            var found = false;
            for (var i = 0, nfaces = faces.length; i !== nfaces && false === found; i++) {
              var normal = normals[i];
              var face = faces[i];
              var worldNormal = sphereConvex_worldNormal;
              qj.vmult(normal, worldNormal);
              var worldPoint = sphereConvex_worldPoint;
              qj.vmult(verts[face[0]], worldPoint);
              worldPoint.vadd(xj, worldPoint);
              var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
              worldNormal.mult(-R, worldSpherePointClosestToPlane);
              xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);
              var penetrationVec = sphereConvex_penetrationVec;
              worldSpherePointClosestToPlane.vsub(worldPoint, penetrationVec);
              var penetration = penetrationVec.dot(worldNormal);
              var worldPointToSphere = sphereConvex_sphereToWorldPoint;
              xi.vsub(worldPoint, worldPointToSphere);
              if (penetration < 0 && worldPointToSphere.dot(worldNormal) > 0) {
                var faceVerts = [];
                for (var j = 0, Nverts = face.length; j !== Nverts; j++) {
                  var worldVertex = v3pool.get();
                  qj.vmult(verts[face[j]], worldVertex);
                  xj.vadd(worldVertex, worldVertex);
                  faceVerts.push(worldVertex);
                }
                if (pointInPolygon(faceVerts, worldNormal, xi)) {
                  if (justTest) return true;
                  found = true;
                  var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                  worldNormal.mult(-R, r.ri);
                  worldNormal.negate(r.ni);
                  var penetrationVec2 = v3pool.get();
                  worldNormal.mult(-penetration, penetrationVec2);
                  var penetrationSpherePoint = v3pool.get();
                  worldNormal.mult(-R, penetrationSpherePoint);
                  xi.vsub(xj, r.rj);
                  r.rj.vadd(penetrationSpherePoint, r.rj);
                  r.rj.vadd(penetrationVec2, r.rj);
                  r.rj.vadd(xj, r.rj);
                  r.rj.vsub(bj.position, r.rj);
                  r.ri.vadd(xi, r.ri);
                  r.ri.vsub(bi.position, r.ri);
                  v3pool.release(penetrationVec2);
                  v3pool.release(penetrationSpherePoint);
                  this.result.push(r);
                  this.createFrictionEquationsFromContact(r, this.frictionResult);
                  for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) v3pool.release(faceVerts[j]);
                  return;
                }
                for (var j = 0; j !== face.length; j++) {
                  var v1 = v3pool.get();
                  var v2 = v3pool.get();
                  qj.vmult(verts[face[(j + 1) % face.length]], v1);
                  qj.vmult(verts[face[(j + 2) % face.length]], v2);
                  xj.vadd(v1, v1);
                  xj.vadd(v2, v2);
                  var edge = sphereConvex_edge;
                  v2.vsub(v1, edge);
                  var edgeUnit = sphereConvex_edgeUnit;
                  edge.unit(edgeUnit);
                  var p = v3pool.get();
                  var v1_to_xi = v3pool.get();
                  xi.vsub(v1, v1_to_xi);
                  var dot = v1_to_xi.dot(edgeUnit);
                  edgeUnit.mult(dot, p);
                  p.vadd(v1, p);
                  var xi_to_p = v3pool.get();
                  p.vsub(xi, xi_to_p);
                  if (dot > 0 && dot * dot < edge.norm2() && xi_to_p.norm2() < R * R) {
                    if (justTest) return true;
                    var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                    p.vsub(xj, r.rj);
                    p.vsub(xi, r.ni);
                    r.ni.normalize();
                    r.ni.mult(R, r.ri);
                    r.rj.vadd(xj, r.rj);
                    r.rj.vsub(bj.position, r.rj);
                    r.ri.vadd(xi, r.ri);
                    r.ri.vsub(bi.position, r.ri);
                    this.result.push(r);
                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                    for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) v3pool.release(faceVerts[j]);
                    v3pool.release(v1);
                    v3pool.release(v2);
                    v3pool.release(p);
                    v3pool.release(xi_to_p);
                    v3pool.release(v1_to_xi);
                    return;
                  }
                  v3pool.release(v1);
                  v3pool.release(v2);
                  v3pool.release(p);
                  v3pool.release(xi_to_p);
                  v3pool.release(v1_to_xi);
                }
                for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) v3pool.release(faceVerts[j]);
              }
            }
          };
          var planeBox_normal = new Vec3();
          var plane_to_corner = new Vec3();
          Narrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] = Narrowphase.prototype.planeBox = function(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            sj.convexPolyhedronRepresentation.material = sj.material;
            sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
            sj.convexPolyhedronRepresentation.id = sj.id;
            return this.planeConvex(si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj, justTest);
          };
          var planeConvex_v = new Vec3();
          var planeConvex_normal = new Vec3();
          var planeConvex_relpos = new Vec3();
          var planeConvex_projected = new Vec3();
          Narrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.planeConvex = function(planeShape, convexShape, planePosition, convexPosition, planeQuat, convexQuat, planeBody, convexBody, si, sj, justTest) {
            var worldVertex = planeConvex_v, worldNormal = planeConvex_normal;
            worldNormal.set(0, 0, 1);
            planeQuat.vmult(worldNormal, worldNormal);
            var numContacts = 0;
            var relpos = planeConvex_relpos;
            for (var i = 0; i !== convexShape.vertices.length; i++) {
              worldVertex.copy(convexShape.vertices[i]);
              convexQuat.vmult(worldVertex, worldVertex);
              convexPosition.vadd(worldVertex, worldVertex);
              worldVertex.vsub(planePosition, relpos);
              var dot = worldNormal.dot(relpos);
              if (dot <= 0) {
                if (justTest) return true;
                var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape, si, sj);
                var projected = planeConvex_projected;
                worldNormal.mult(worldNormal.dot(relpos), projected);
                worldVertex.vsub(projected, projected);
                projected.vsub(planePosition, r.ri);
                r.ni.copy(worldNormal);
                worldVertex.vsub(convexPosition, r.rj);
                r.ri.vadd(planePosition, r.ri);
                r.ri.vsub(planeBody.position, r.ri);
                r.rj.vadd(convexPosition, r.rj);
                r.rj.vsub(convexBody.position, r.rj);
                this.result.push(r);
                numContacts++;
                this.enableFrictionReduction || this.createFrictionEquationsFromContact(r, this.frictionResult);
              }
            }
            this.enableFrictionReduction && numContacts && this.createFrictionFromAverage(numContacts);
          };
          var convexConvex_sepAxis = new Vec3();
          var convexConvex_q = new Vec3();
          Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.convexConvex = function(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest, faceListA, faceListB) {
            var sepAxis = convexConvex_sepAxis;
            if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) return;
            if (si.findSeparatingAxis(sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB)) {
              var res = [];
              var q = convexConvex_q;
              si.clipAgainstHull(xi, qi, sj, xj, qj, sepAxis, -100, 100, res);
              var numContacts = 0;
              for (var j = 0; j !== res.length; j++) {
                if (justTest) return true;
                var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj), ri = r.ri, rj = r.rj;
                sepAxis.negate(r.ni);
                res[j].normal.negate(q);
                q.mult(res[j].depth, q);
                res[j].point.vadd(q, ri);
                rj.copy(res[j].point);
                ri.vsub(xi, ri);
                rj.vsub(xj, rj);
                ri.vadd(xi, ri);
                ri.vsub(bi.position, ri);
                rj.vadd(xj, rj);
                rj.vsub(bj.position, rj);
                this.result.push(r);
                numContacts++;
                this.enableFrictionReduction || this.createFrictionEquationsFromContact(r, this.frictionResult);
              }
              this.enableFrictionReduction && numContacts && this.createFrictionFromAverage(numContacts);
            }
          };
          var particlePlane_normal = new Vec3();
          var particlePlane_relpos = new Vec3();
          var particlePlane_projected = new Vec3();
          Narrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] = Narrowphase.prototype.planeParticle = function(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
            var normal = particlePlane_normal;
            normal.set(0, 0, 1);
            bj.quaternion.vmult(normal, normal);
            var relpos = particlePlane_relpos;
            xi.vsub(bj.position, relpos);
            var dot = normal.dot(relpos);
            if (dot <= 0) {
              if (justTest) return true;
              var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
              r.ni.copy(normal);
              r.ni.negate(r.ni);
              r.ri.set(0, 0, 0);
              var projected = particlePlane_projected;
              normal.mult(normal.dot(xi), projected);
              xi.vsub(projected, projected);
              r.rj.copy(projected);
              this.result.push(r);
              this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
          };
          var particleSphere_normal = new Vec3();
          Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] = Narrowphase.prototype.sphereParticle = function(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
            var normal = particleSphere_normal;
            normal.set(0, 0, 1);
            xi.vsub(xj, normal);
            var lengthSquared = normal.norm2();
            if (lengthSquared <= sj.radius * sj.radius) {
              if (justTest) return true;
              var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
              normal.normalize();
              r.rj.copy(normal);
              r.rj.mult(sj.radius, r.rj);
              r.ni.copy(normal);
              r.ni.negate(r.ni);
              r.ri.set(0, 0, 0);
              this.result.push(r);
              this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
          };
          var cqj = new Quaternion();
          var convexParticle_local = new Vec3();
          var convexParticle_normal = new Vec3();
          var convexParticle_penetratedFaceNormal = new Vec3();
          var convexParticle_vertexToParticle = new Vec3();
          var convexParticle_worldPenetrationVec = new Vec3();
          Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] = Narrowphase.prototype.convexParticle = function(sj, si, xj, xi, qj, qi, bj, bi, rsi, rsj, justTest) {
            var penetratedFaceIndex = -1;
            var penetratedFaceNormal = convexParticle_penetratedFaceNormal;
            var worldPenetrationVec = convexParticle_worldPenetrationVec;
            var minPenetration = null;
            var numDetectedFaces = 0;
            var local = convexParticle_local;
            local.copy(xi);
            local.vsub(xj, local);
            qj.conjugate(cqj);
            cqj.vmult(local, local);
            if (sj.pointIsInside(local)) {
              sj.worldVerticesNeedsUpdate && sj.computeWorldVertices(xj, qj);
              sj.worldFaceNormalsNeedsUpdate && sj.computeWorldFaceNormals(qj);
              for (var i = 0, nfaces = sj.faces.length; i !== nfaces; i++) {
                var verts = [ sj.worldVertices[sj.faces[i][0]] ];
                var normal = sj.worldFaceNormals[i];
                xi.vsub(verts[0], convexParticle_vertexToParticle);
                var penetration = -normal.dot(convexParticle_vertexToParticle);
                if (null === minPenetration || Math.abs(penetration) < Math.abs(minPenetration)) {
                  if (justTest) return true;
                  minPenetration = penetration;
                  penetratedFaceIndex = i;
                  penetratedFaceNormal.copy(normal);
                  numDetectedFaces++;
                }
              }
              if (-1 !== penetratedFaceIndex) {
                var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj);
                penetratedFaceNormal.mult(minPenetration, worldPenetrationVec);
                worldPenetrationVec.vadd(xi, worldPenetrationVec);
                worldPenetrationVec.vsub(xj, worldPenetrationVec);
                r.rj.copy(worldPenetrationVec);
                penetratedFaceNormal.negate(r.ni);
                r.ri.set(0, 0, 0);
                var ri = r.ri, rj = r.rj;
                ri.vadd(xi, ri);
                ri.vsub(bi.position, ri);
                rj.vadd(xj, rj);
                rj.vsub(bj.position, rj);
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
              } else console.warn("Point found inside convex, but did not find penetrating face!");
            }
          };
          Narrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.boxHeightfield = function(si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, justTest) {
            si.convexPolyhedronRepresentation.material = si.material;
            si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
            return this.convexHeightfield(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj, justTest);
          };
          var convexHeightfield_tmp1 = new Vec3();
          var convexHeightfield_tmp2 = new Vec3();
          var convexHeightfield_faceList = [ 0 ];
          Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.convexHeightfield = function(convexShape, hfShape, convexPos, hfPos, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest) {
            var data = hfShape.data, w = hfShape.elementSize, radius = convexShape.boundingSphereRadius, worldPillarOffset = convexHeightfield_tmp2, faceList = convexHeightfield_faceList;
            var localConvexPos = convexHeightfield_tmp1;
            Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);
            var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1, iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1, iMinY = Math.floor((localConvexPos.y - radius) / w) - 1, iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;
            if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) return;
            iMinX < 0 && (iMinX = 0);
            iMaxX < 0 && (iMaxX = 0);
            iMinY < 0 && (iMinY = 0);
            iMaxY < 0 && (iMaxY = 0);
            iMinX >= data.length && (iMinX = data.length - 1);
            iMaxX >= data.length && (iMaxX = data.length - 1);
            iMaxY >= data[0].length && (iMaxY = data[0].length - 1);
            iMinY >= data[0].length && (iMinY = data[0].length - 1);
            var minMax = [];
            hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
            var min = minMax[0];
            var max = minMax[1];
            if (localConvexPos.z - radius > max || localConvexPos.z + radius < min) return;
            for (var i = iMinX; i < iMaxX; i++) for (var j = iMinY; j < iMaxY; j++) {
              var intersecting = false;
              hfShape.getConvexTrianglePillar(i, j, false);
              Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
              convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius && (intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest, faceList, null));
              if (justTest && intersecting) return true;
              hfShape.getConvexTrianglePillar(i, j, true);
              Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
              convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius && (intersecting = this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, rsi, rsj, justTest, faceList, null));
              if (justTest && intersecting) return true;
            }
          };
          var sphereHeightfield_tmp1 = new Vec3();
          var sphereHeightfield_tmp2 = new Vec3();
          Narrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] = Narrowphase.prototype.sphereHeightfield = function(sphereShape, hfShape, spherePos, hfPos, sphereQuat, hfQuat, sphereBody, hfBody, rsi, rsj, justTest) {
            var data = hfShape.data, radius = sphereShape.radius, w = hfShape.elementSize, worldPillarOffset = sphereHeightfield_tmp2;
            var localSpherePos = sphereHeightfield_tmp1;
            Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);
            var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1, iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1, iMinY = Math.floor((localSpherePos.y - radius) / w) - 1, iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;
            if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) return;
            iMinX < 0 && (iMinX = 0);
            iMaxX < 0 && (iMaxX = 0);
            iMinY < 0 && (iMinY = 0);
            iMaxY < 0 && (iMaxY = 0);
            iMinX >= data.length && (iMinX = data.length - 1);
            iMaxX >= data.length && (iMaxX = data.length - 1);
            iMaxY >= data[0].length && (iMaxY = data[0].length - 1);
            iMinY >= data[0].length && (iMinY = data[0].length - 1);
            var minMax = [];
            hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
            var min = minMax[0];
            var max = minMax[1];
            if (localSpherePos.z - radius > max || localSpherePos.z + radius < min) return;
            var result = this.result;
            for (var i = iMinX; i < iMaxX; i++) for (var j = iMinY; j < iMaxY; j++) {
              var numContactsBefore = result.length;
              var intersecting = false;
              hfShape.getConvexTrianglePillar(i, j, false);
              Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
              spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius && (intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest));
              if (justTest && intersecting) return true;
              hfShape.getConvexTrianglePillar(i, j, true);
              Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
              spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius && (intersecting = this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody, sphereShape, hfShape, justTest));
              if (justTest && intersecting) return true;
              var numContacts = result.length - numContactsBefore;
              if (numContacts > 2) return;
            }
          };
        }), {
          "../collision/AABB": 3,
          "../collision/Ray": 10,
          "../equations/ContactEquation": 20,
          "../equations/FrictionEquation": 22,
          "../math/Quaternion": 30,
          "../math/Transform": 31,
          "../math/Vec3": 32,
          "../objects/Body": 33,
          "../shapes/ConvexPolyhedron": 40,
          "../shapes/Shape": 45,
          "../solver/Solver": 49,
          "../utils/Vec3Pool": 56
        } ],
        58: [ (function(_dereq_, module, exports) {
          module.exports = World;
          var Shape = _dereq_("../shapes/Shape");
          var Vec3 = _dereq_("../math/Vec3");
          var Quaternion = _dereq_("../math/Quaternion");
          var GSSolver = _dereq_("../solver/GSSolver");
          var ContactEquation = _dereq_("../equations/ContactEquation");
          var FrictionEquation = _dereq_("../equations/FrictionEquation");
          var Narrowphase = _dereq_("./Narrowphase");
          var EventTarget = _dereq_("../utils/EventTarget");
          var ArrayCollisionMatrix = _dereq_("../collision/ArrayCollisionMatrix");
          var ObjectCollisionMatrix = _dereq_("../collision/ObjectCollisionMatrix");
          var OverlapKeeper = _dereq_("../collision/OverlapKeeper");
          var Material = _dereq_("../material/Material");
          var ContactMaterial = _dereq_("../material/ContactMaterial");
          var Body = _dereq_("../objects/Body");
          var TupleDictionary = _dereq_("../utils/TupleDictionary");
          var RaycastResult = _dereq_("../collision/RaycastResult");
          var AABB = _dereq_("../collision/AABB");
          var Ray = _dereq_("../collision/Ray");
          var NaiveBroadphase = _dereq_("../collision/NaiveBroadphase");
          function World(options) {
            options = options || {};
            EventTarget.apply(this);
            this.dt = -1;
            this.allowSleep = !!options.allowSleep;
            this.contacts = [];
            this.frictionEquations = [];
            this.quatNormalizeSkip = void 0 !== options.quatNormalizeSkip ? options.quatNormalizeSkip : 0;
            this.quatNormalizeFast = void 0 !== options.quatNormalizeFast && options.quatNormalizeFast;
            this.time = 0;
            this.timeFixed = 0;
            this.stepnumber = 0;
            this.default_dt = 1 / 60;
            this.nextId = 0;
            this.gravity = new Vec3();
            options.gravity && this.gravity.copy(options.gravity);
            this.broadphase = void 0 !== options.broadphase ? options.broadphase : new NaiveBroadphase();
            this.bodies = [];
            this.solver = void 0 !== options.solver ? options.solver : new GSSolver();
            this.constraints = [];
            this.narrowphase = new Narrowphase(this);
            this.collisionMatrix = new ArrayCollisionMatrix();
            this.collisionMatrixPrevious = new ArrayCollisionMatrix();
            this.bodyOverlapKeeper = new OverlapKeeper();
            this.shapeOverlapKeeper = new OverlapKeeper();
            this.materials = [];
            this.contactmaterials = [];
            this.contactMaterialTable = new TupleDictionary();
            this.defaultMaterial = new Material("default");
            this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, {
              friction: .3,
              restitution: 0
            });
            this.doProfiling = false;
            this.profile = {
              solve: 0,
              makeContactConstraints: 0,
              broadphase: 0,
              integrate: 0,
              narrowphase: 0
            };
            this.accumulator = 0;
            this.subsystems = [];
            this.addBodyEvent = {
              type: "addBody",
              body: null
            };
            this.removeBodyEvent = {
              type: "removeBody",
              body: null
            };
            this.idToBodyMap = {};
            this.broadphase.setWorld(this);
            this.substeps = 0;
            this.cm = new ObjectCollisionMatrix();
            this.tm = new ObjectCollisionMatrix();
            this.triggerDic = new TupleDictionary();
            this.oldTriggerDic = new TupleDictionary();
            this.contactsDic = new TupleDictionary();
            this.oldContactsDic = new TupleDictionary();
          }
          World.idToBodyMap = {};
          World.idToShapeMap = {};
          World.prototype = new EventTarget();
          var tmpAABB1 = new AABB();
          var tmpArray1 = [];
          var tmpRay = new Ray();
          World.prototype.getContactMaterial = function(m1, m2) {
            return this.contactMaterialTable.get(m1.id, m2.id);
          };
          World.prototype.numObjects = function() {
            return this.bodies.length;
          };
          World.prototype.collisionMatrixTick = function() {
            var temp = this.collisionMatrixPrevious;
            this.collisionMatrixPrevious = this.collisionMatrix;
            this.collisionMatrix = temp;
            this.collisionMatrix.reset();
            this.bodyOverlapKeeper.tick();
            this.shapeOverlapKeeper.tick();
          };
          World.prototype.add = World.prototype.addBody = function(body) {
            World.SLEEPING = false;
            if (-1 !== this.bodies.indexOf(body)) return;
            body.index = this.bodies.length;
            this.bodies.push(body);
            body.world = this;
            body.initPosition.copy(body.position);
            body.initVelocity.copy(body.velocity);
            body.timeLastSleepy = this.time;
            if (body instanceof Body) {
              body.initAngularVelocity.copy(body.angularVelocity);
              body.initQuaternion.copy(body.quaternion);
            }
            this.collisionMatrix.setNumObjects(this.bodies.length);
            this.addBodyEvent.body = body;
            this.cm.setNumObjects(this.bodies.length);
            World.idToBodyMap[body.id] = body;
            this.dispatchEvent(this.addBodyEvent);
          };
          World.prototype.addConstraint = function(c) {
            World.SLEEPING = false;
            this.constraints.push(c);
          };
          World.prototype.removeConstraint = function(c) {
            World.SLEEPING = false;
            var idx = this.constraints.indexOf(c);
            -1 !== idx && this.constraints.splice(idx, 1);
          };
          World.prototype.rayTest = function(from, to, result) {
            result instanceof RaycastResult ? this.raycastClosest(from, to, {
              skipBackfaces: true
            }, result) : this.raycastAll(from, to, {
              skipBackfaces: true
            }, result);
          };
          World.prototype.raycastAll = function(from, to, options, callback) {
            options.mode = Ray.ALL;
            options.from = from;
            options.to = to;
            options.callback = callback;
            return tmpRay.intersectWorld(this, options);
          };
          World.prototype.raycastAny = function(from, to, options, result) {
            options.mode = Ray.ANY;
            options.from = from;
            options.to = to;
            options.result = result;
            return tmpRay.intersectWorld(this, options);
          };
          World.prototype.raycastClosest = function(from, to, options, result) {
            options.mode = Ray.CLOSEST;
            options.from = from;
            options.to = to;
            options.result = result;
            return tmpRay.intersectWorld(this, options);
          };
          World.prototype.remove = function(body) {
            World.SLEEPING = false;
            body.world = null;
            var n = this.bodies.length - 1, bodies = this.bodies, idx = bodies.indexOf(body);
            if (-1 !== idx) {
              bodies.splice(idx, 1);
              for (var i = 0; i !== bodies.length; i++) bodies[i].index = i;
              this.collisionMatrix.setNumObjects(n);
              this.removeBodyEvent.body = body;
              delete World.idToBodyMap[body.id];
              this.cm.setNumObjects(n);
              this.dispatchEvent(this.removeBodyEvent);
            }
          };
          World.prototype.removeBody = World.prototype.remove;
          World.prototype.getBodyById = function(id) {
            return World.idToBodyMap[id];
          };
          World.prototype.getShapeById = function(id) {
            return World.idToShapeMap[id];
          };
          World.prototype.addMaterial = function(m) {
            this.materials.push(m);
          };
          World.prototype.addContactMaterial = function(cmat) {
            this.contactmaterials.push(cmat);
            this.contactMaterialTable.set(cmat.materials[0].id, cmat.materials[1].id, cmat);
          };
          "undefined" === typeof performance && (performance = {});
          if (!performance.now) {
            var nowOffset = Date.now();
            performance.timing && performance.timing.navigationStart && (nowOffset = performance.timing.navigationStart);
            performance.now = function() {
              return Date.now() - nowOffset;
            };
          }
          var step_tmp1 = new Vec3();
          World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps) {
            maxSubSteps = maxSubSteps || 10;
            timeSinceLastCalled = timeSinceLastCalled || 0;
            if (0 === timeSinceLastCalled) {
              this.internalStep(dt);
              this.time += dt;
              this.substeps = 1;
            } else {
              this.accumulator += timeSinceLastCalled;
              this.substeps = 0;
              while (this.accumulator >= dt && this.substeps < maxSubSteps) {
                this.internalStep(dt);
                this.accumulator -= dt;
                this.substeps++;
              }
              var t = this.accumulator % dt / dt;
              for (var j = 0; j !== this.bodies.length; j++) {
                var b = this.bodies[j];
                b.previousPosition.lerp(b.position, t, b.interpolatedPosition);
                b.previousQuaternion.slerp(b.quaternion, t, b.interpolatedQuaternion);
                b.previousQuaternion.normalize();
              }
              this.time += timeSinceLastCalled;
            }
          };
          var World_step_postStepEvent = {
            type: "postStep"
          }, World_step_preStepEvent = {
            type: "preStep"
          }, World_step_collideEvent = {
            type: "collide",
            body: null,
            contact: null
          }, World_step_oldContacts = [], World_step_frictionEquationPool = [], World_step_p1 = [], World_step_p2 = [], World_step_gvec = new Vec3(), World_step_vi = new Vec3(), World_step_vj = new Vec3(), World_step_wi = new Vec3(), World_step_wj = new Vec3(), World_step_t1 = new Vec3(), World_step_t2 = new Vec3(), World_step_rixn = new Vec3(), World_step_rjxn = new Vec3(), World_step_step_q = new Quaternion(), World_step_step_w = new Quaternion(), World_step_step_wq = new Quaternion(), invI_tau_dt = new Vec3();
          World.prototype.internalStep = function(dt) {
            this.dt = dt;
            var world = this, that = this, contacts = this.contacts, p1 = World_step_p1, p2 = World_step_p2, N = this.numObjects(), bodies = this.bodies, solver = this.solver, gravity = this.gravity, doProfiling = this.doProfiling, profile = this.profile, DYNAMIC = Body.DYNAMIC, profilingStart, constraints = this.constraints, frictionEquationPool = World_step_frictionEquationPool, gnorm = gravity.norm(), gx = gravity.x, gy = gravity.y, gz = gravity.z, i = 0;
            doProfiling && (profilingStart = performance.now());
            for (i = 0; i !== N; i++) {
              var bi = bodies[i];
              if (bi.useGravity && bi.type === DYNAMIC) {
                var f = bi.force, m = bi.mass;
                f.x += m * gx;
                f.y += m * gy;
                f.z += m * gz;
              }
            }
            for (var i = 0, Nsubsystems = this.subsystems.length; i !== Nsubsystems; i++) this.subsystems[i].update();
            doProfiling && (profilingStart = performance.now());
            p1.length = 0;
            p2.length = 0;
            this.broadphase.collisionPairs(this, p1, p2);
            doProfiling && (profile.broadphase = performance.now() - profilingStart);
            var Nconstraints = constraints.length;
            for (i = 0; i !== Nconstraints; i++) {
              var c = constraints[i];
              if (!c.collideConnected) for (var j = p1.length - 1; j >= 0; j -= 1) if (c.bodyA === p1[j] && c.bodyB === p2[j] || c.bodyB === p1[j] && c.bodyA === p2[j]) {
                p1.splice(j, 1);
                p2.splice(j, 1);
              }
            }
            this.collisionMatrixTick();
            doProfiling && (profilingStart = performance.now());
            var oldcontacts = World_step_oldContacts;
            var NoldContacts = contacts.length;
            for (i = 0; i !== NoldContacts; i++) oldcontacts.push(contacts[i]);
            contacts.length = 0;
            var NoldFrictionEquations = this.frictionEquations.length;
            for (i = 0; i !== NoldFrictionEquations; i++) frictionEquationPool.push(this.frictionEquations[i]);
            this.frictionEquations.length = 0;
            this.narrowphase.getContacts(p1, p2, this, contacts, oldcontacts, this.frictionEquations, frictionEquationPool);
            if (0 == contacts.length && World.SLEEPING) return;
            doProfiling && (profile.narrowphase = performance.now() - profilingStart);
            doProfiling && (profilingStart = performance.now());
            for (var i = 0; i < this.frictionEquations.length; i++) solver.addEquation(this.frictionEquations[i]);
            var ncontacts = contacts.length;
            for (var k = 0; k !== ncontacts; k++) {
              var c = contacts[k];
              var bi = c.bi, bj = c.bj, si = c.si, sj = c.sj;
              si.material && sj.material ? si.material.restitution >= 0 && sj.material.restitution >= 0 && (c.restitution = si.material.restitution * sj.material.restitution) : bi.material && bj.material && bi.material.restitution >= 0 && bj.material.restitution >= 0 && (c.restitution = bi.material.restitution * bj.material.restitution);
              solver.addEquation(c);
              if (bi.allowSleep && bi.type === Body.DYNAMIC && bi.sleepState === Body.SLEEPING && bj.sleepState === Body.AWAKE && bj.type !== Body.STATIC) {
                var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();
                var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);
                speedSquaredB >= 2 * speedLimitSquaredB && (bi._wakeUpAfterNarrowphase = true);
              }
              if (bj.allowSleep && bj.type === Body.DYNAMIC && bj.sleepState === Body.SLEEPING && bi.sleepState === Body.AWAKE && bi.type !== Body.STATIC) {
                var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();
                var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);
                speedSquaredA >= 2 * speedLimitSquaredA && (bj._wakeUpAfterNarrowphase = true);
              }
              this.collisionMatrix.set(bi, bj, true);
              if (!this.collisionMatrixPrevious.get(bi, bj)) {
                World_step_collideEvent.body = bj;
                World_step_collideEvent.contact = c;
                bi.dispatchEvent(World_step_collideEvent);
                World_step_collideEvent.body = bi;
                bj.dispatchEvent(World_step_collideEvent);
              }
              this.bodyOverlapKeeper.set(bi.id, bj.id);
              this.shapeOverlapKeeper.set(si.id, sj.id);
            }
            this.emitContactEvents();
            if (doProfiling) {
              profile.makeContactConstraints = performance.now() - profilingStart;
              profilingStart = performance.now();
            }
            for (i = 0; i !== N; i++) {
              var bi = bodies[i];
              if (bi._wakeUpAfterNarrowphase) {
                bi.wakeUp();
                bi._wakeUpAfterNarrowphase = false;
              }
            }
            var Nconstraints = constraints.length;
            for (i = 0; i !== Nconstraints; i++) {
              var c = constraints[i];
              c.update();
              for (var j = 0, Neq = c.equations.length; j !== Neq; j++) {
                var eq = c.equations[j];
                solver.addEquation(eq);
              }
            }
            solver.solve(dt, this);
            doProfiling && (profile.solve = performance.now() - profilingStart);
            solver.removeAllEquations();
            var pow = Math.pow;
            for (i = 0; i !== N; i++) {
              var bi = bodies[i];
              if (bi.type & DYNAMIC) {
                var ld = pow(1 - bi.linearDamping, dt);
                var v = bi.velocity;
                v.mult(ld, v);
                var av = bi.angularVelocity;
                if (av) {
                  var ad = pow(1 - bi.angularDamping, dt);
                  av.mult(ad, av);
                }
              }
            }
            this.dispatchEvent(World_step_preStepEvent);
            for (i = 0; i !== N; i++) {
              var bi = bodies[i];
              bi.preStep && bi.preStep.call(bi);
            }
            doProfiling && (profilingStart = performance.now());
            var stepnumber = this.stepnumber;
            var quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;
            var quatNormalizeFast = this.quatNormalizeFast;
            for (i = 0; i !== N; i++) bodies[i].integrate(dt, quatNormalize, quatNormalizeFast);
            this.clearForces();
            this.broadphase.dirty = true;
            doProfiling && (profile.integrate = performance.now() - profilingStart);
            this.time += dt;
            this.timeFixed += dt;
            this.stepnumber += 1;
            this.dispatchEvent(World_step_postStepEvent);
            for (i = 0; i !== N; i++) {
              var bi = bodies[i];
              var postStep = bi.postStep;
              postStep && postStep.call(bi);
            }
            if (this.allowSleep) {
              for (i = 0; i !== N; i++) bodies[i].sleepTick(this.time);
              World.SLEEPING = true;
              for (i = 0; i !== N; i++) {
                var bi = bodies[i];
                if (bi.type != Body.STATIC && !bi.isSleeping()) {
                  World.SLEEPING = false;
                  break;
                }
              }
            } else World.SLEEPING = false;
          };
          World.prototype.emitContactEvents = (function() {
            var additions = [];
            var removals = [];
            var beginContactEvent = {
              type: "beginContact",
              bodyA: null,
              bodyB: null
            };
            var endContactEvent = {
              type: "endContact",
              bodyA: null,
              bodyB: null
            };
            var beginShapeContactEvent = {
              type: "beginShapeContact",
              bodyA: null,
              bodyB: null,
              shapeA: null,
              shapeB: null
            };
            var endShapeContactEvent = {
              type: "endShapeContact",
              bodyA: null,
              bodyB: null,
              shapeA: null,
              shapeB: null
            };
            return function() {
              var hasBeginContact = this.hasAnyEventListener("beginContact");
              var hasEndContact = this.hasAnyEventListener("endContact");
              (hasBeginContact || hasEndContact) && this.bodyOverlapKeeper.getDiff(additions, removals);
              if (hasBeginContact) {
                for (var i = 0, l = additions.length; i < l; i += 2) {
                  beginContactEvent.bodyA = this.getBodyById(additions[i]);
                  beginContactEvent.bodyB = this.getBodyById(additions[i + 1]);
                  this.dispatchEvent(beginContactEvent);
                }
                beginContactEvent.bodyA = beginContactEvent.bodyB = null;
              }
              if (hasEndContact) {
                for (var i = 0, l = removals.length; i < l; i += 2) {
                  endContactEvent.bodyA = this.getBodyById(removals[i]);
                  endContactEvent.bodyB = this.getBodyById(removals[i + 1]);
                  this.dispatchEvent(endContactEvent);
                }
                endContactEvent.bodyA = endContactEvent.bodyB = null;
              }
              additions.length = removals.length = 0;
              var hasBeginShapeContact = this.hasAnyEventListener("beginShapeContact");
              var hasEndShapeContact = this.hasAnyEventListener("endShapeContact");
              (hasBeginShapeContact || hasEndShapeContact) && this.shapeOverlapKeeper.getDiff(additions, removals);
              if (hasBeginShapeContact) {
                for (var i = 0, l = additions.length; i < l; i += 2) {
                  var shapeA = this.getShapeById(additions[i]);
                  var shapeB = this.getShapeById(additions[i + 1]);
                  beginShapeContactEvent.shapeA = shapeA;
                  beginShapeContactEvent.shapeB = shapeB;
                  beginShapeContactEvent.bodyA = shapeA.body;
                  beginShapeContactEvent.bodyB = shapeB.body;
                  this.dispatchEvent(beginShapeContactEvent);
                }
                beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null;
              }
              if (hasEndShapeContact) {
                for (var i = 0, l = removals.length; i < l; i += 2) {
                  var shapeA = this.getShapeById(removals[i]);
                  var shapeB = this.getShapeById(removals[i + 1]);
                  endShapeContactEvent.shapeA = shapeA;
                  endShapeContactEvent.shapeB = shapeB;
                  endShapeContactEvent.bodyA = shapeA.body;
                  endShapeContactEvent.bodyB = shapeB.body;
                  this.dispatchEvent(endShapeContactEvent);
                }
                endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null;
              }
            };
          })();
          World.prototype.clearForces = function() {
            var bodies = this.bodies;
            var N = bodies.length;
            for (var i = 0; i !== N; i++) {
              var b = bodies[i], force = b.force, tau = b.torque;
              b.force.set(0, 0, 0);
              b.torque.set(0, 0, 0);
            }
          };
          var cc_trigger = {
            type: "cc-trigger",
            event: "",
            selfBody: null,
            otherBody: null,
            selfShape: null,
            otherShape: null
          };
          var cc_collide = {
            type: "cc-collide",
            event: "",
            body: null,
            selfShape: null,
            otherShape: null,
            contacts: null
          };
          var cc_oldContacts = [];
          World.prototype.emitTriggeredEvents = function() {
            if (0 == this.substeps) return;
            var key;
            var data;
            var i = this.triggerDic.getLength();
            while (i--) {
              key = this.triggerDic.getKeyByIndex(i);
              data = this.triggerDic.getDataByKey(key);
              if (null == data) continue;
              var shapeA = data.si;
              var shapeB = data.sj;
              if (this.tm.get(shapeA, shapeB)) cc_trigger.event = "onTriggerStay"; else {
                this.tm.set(shapeA, shapeB, true);
                cc_trigger.event = "onTriggerEnter";
              }
              cc_trigger.selfShape = shapeA;
              cc_trigger.otherShape = shapeB;
              cc_trigger.selfBody = shapeA.body;
              cc_trigger.otherBody = shapeB.body;
              shapeA.dispatchEvent(cc_trigger);
              cc_trigger.selfShape = shapeB;
              cc_trigger.otherShape = shapeA;
              cc_trigger.selfBody = shapeB.body;
              cc_trigger.otherBody = shapeA.body;
              shapeB.dispatchEvent(cc_trigger);
            }
            i = this.oldTriggerDic.getLength();
            while (i > 0) {
              i--;
              key = this.oldTriggerDic.getKeyByIndex(i);
              if (null != this.triggerDic.getDataByKey(key)) continue;
              data = this.oldTriggerDic.getDataByKey(key);
              if (null == data) continue;
              var shapeA = data.si;
              var shapeB = data.sj;
              this.tm.set(shapeA, shapeB, false);
              this.oldTriggerDic.del(shapeA.id, shapeB.id) && i--;
              cc_trigger.event = "onTriggerExit";
              cc_trigger.selfShape = shapeA;
              cc_trigger.otherShape = shapeB;
              cc_trigger.selfBody = shapeA.body;
              cc_trigger.otherBody = shapeB.body;
              shapeA.dispatchEvent(cc_trigger);
              cc_trigger.selfShape = shapeB;
              cc_trigger.otherShape = shapeA;
              cc_trigger.selfBody = shapeB.body;
              cc_trigger.otherBody = shapeA.body;
              shapeB.dispatchEvent(cc_trigger);
            }
            this.triggerDic.reset();
          };
          World.prototype.emitCollisionEvents = function() {
            if (0 == this.substeps) return;
            var contacts = this.contacts;
            var i = this.contacts.length;
            while (i--) {
              var c = contacts[i];
              var si = c.si;
              var sj = c.sj;
              var item = this.contactsDic.get(si.id, sj.id);
              null == item && (item = this.contactsDic.set(si.id, sj.id, []));
              item.push(c);
            }
            var key;
            var data;
            var i = this.contactsDic.getLength();
            while (i--) {
              key = this.contactsDic.getKeyByIndex(i);
              data = this.contactsDic.getDataByKey(key);
              if (null == data) continue;
              var si = data[0].si;
              var sj = data[0].sj;
              var bi = si.body;
              var bj = sj.body;
              if (this.cm.get(bi, bj)) cc_collide.event = "onCollisionStay"; else {
                this.cm.set(bi, bj, true);
                cc_collide.event = "onCollisionEnter";
              }
              cc_collide.bi = bi;
              cc_collide.contact = data[0];
              cc_collide.contacts = data;
              cc_collide.body = bj;
              cc_collide.selfShape = si;
              cc_collide.otherShape = sj;
              bi.dispatchEvent(cc_collide);
              cc_collide.body = bi;
              cc_collide.selfShape = sj;
              cc_collide.otherShape = si;
              bj.dispatchEvent(cc_collide);
            }
            var oldcontacts = cc_oldContacts;
            for (i = oldcontacts.length; i--; ) {
              var c = oldcontacts[i];
              var si = c.si;
              var sj = c.sj;
              null == this.oldContactsDic.get(si.id, sj.id) && this.oldContactsDic.set(si.id, sj.id, c);
            }
            i = this.oldContactsDic.getLength();
            while (i--) {
              key = this.oldContactsDic.getKeyByIndex(i);
              if (null == this.contactsDic.getDataByKey(key)) {
                data = this.oldContactsDic.getDataByKey(key);
                var si = data.si;
                var sj = data.sj;
                var bi = si.body;
                var bj = sj.body;
                if (this.cm.get(bi, bj) && (!bi.isSleeping() || !bj.isSleeping())) {
                  this.cm.set(bi, bj, false);
                  cc_collide.bi = bi;
                  cc_collide.contact = data;
                  cc_collide.event = "onCollisionExit";
                  cc_collide.body = bj;
                  cc_collide.selfShape = si;
                  cc_collide.otherShape = sj;
                  cc_collide.contacts.length = 0;
                  cc_collide.contacts.push(data);
                  bi.dispatchEvent(cc_collide);
                  cc_collide.body = bi;
                  cc_collide.selfShape = sj;
                  cc_collide.otherShape = si;
                  bj.dispatchEvent(cc_collide);
                }
              }
            }
            this.contactsDic.reset();
            this.oldContactsDic.reset();
            World_step_oldContacts = cc_oldContacts;
            cc_oldContacts = this.contacts.slice();
            this.contacts.length = 0;
          };
        }), {
          "../collision/AABB": 3,
          "../collision/ArrayCollisionMatrix": 4,
          "../collision/NaiveBroadphase": 7,
          "../collision/ObjectCollisionMatrix": 8,
          "../collision/OverlapKeeper": 9,
          "../collision/Ray": 10,
          "../collision/RaycastResult": 11,
          "../equations/ContactEquation": 20,
          "../equations/FrictionEquation": 22,
          "../material/ContactMaterial": 25,
          "../material/Material": 26,
          "../math/Quaternion": 30,
          "../math/Vec3": 32,
          "../objects/Body": 33,
          "../shapes/Shape": 45,
          "../solver/GSSolver": 48,
          "../utils/EventTarget": 51,
          "../utils/TupleDictionary": 54,
          "./Narrowphase": 57
        } ]
      }, {}, [ 2 ])(2);
    }));
  }), {} ],
  464: [ (function(require, module, exports) {
    "use strict";
    var _global = "undefined" === typeof window ? global : window;
    _global.cc = _global.cc || {};
    cc.internal = cc.internal || {};
    require("./predefine");
    require("./polyfill/string");
    require("./polyfill/misc");
    require("./polyfill/array");
    require("./polyfill/object");
    require("./polyfill/array-buffer");
    require("./polyfill/number");
    true;
    require("./polyfill/typescript");
    require("./cocos2d/core/predefine");
    true;
    require("./cocos2d");
    require("./extends");
    false;
    module.exports = _global.cc;
  }), {
    "./cocos2d": 414,
    "./cocos2d/core/predefine": 298,
    "./extends": 447,
    "./package": void 0,
    "./polyfill/array": 466,
    "./polyfill/array-buffer": 465,
    "./polyfill/misc": 467,
    "./polyfill/number": 468,
    "./polyfill/object": 469,
    "./polyfill/string": 470,
    "./polyfill/typescript": 471,
    "./predefine": 472
  } ],
  465: [ (function(require, module, exports) {
    "use strict";
    if (!ArrayBuffer.isView) {
      var TypedArray = Object.getPrototypeOf(Int8Array);
      ArrayBuffer.isView = "function" === typeof TypedArray ? function(obj) {
        return obj instanceof TypedArray;
      } : function(obj) {
        if ("object" !== typeof obj) return false;
        var ctor = obj.constructor;
        return ctor === Float64Array || ctor === Float32Array || ctor === Uint8Array || ctor === Uint32Array || ctor === Int8Array;
      };
    }
  }), {} ],
  466: [ (function(require, module, exports) {
    "use strict";
    Array.isArray || (Array.isArray = function(arg) {
      return "[object Array]" === Object.prototype.toString.call(arg);
    });
    Array.prototype.find || (Array.prototype.find = function(callback) {
      var length = this.length;
      for (var i = 0; i < length; i++) {
        var element = this[i];
        if (callback.call(this, element, i, this)) return element;
      }
      return;
    });
    Array.prototype.includes || (Array.prototype.includes = function(value) {
      return -1 !== this.indexOf(value);
    });
  }), {} ],
  467: [ (function(require, module, exports) {
    "use strict";
    Math.sign || (Math.sign = function(x) {
      x = +x;
      if (0 === x || isNaN(x)) return x;
      return x > 0 ? 1 : -1;
    });
    Math.log2 || (Math.log2 = function(x) {
      return Math.log(x) * Math.LOG2E;
    });
    Number.isInteger || (Number.isInteger = function(value) {
      return "number" === typeof value && isFinite(value) && Math.floor(value) === value;
    });
    true;
    var Timer = window.performance || Date;
    var _timerTable = Object.create(null);
    console.time = function(label) {
      _timerTable[label] = Timer.now();
    };
    console.timeEnd = function(label) {
      var startTime = _timerTable[label];
      var duration = Timer.now() - startTime;
      console.log(label + ": " + duration + "ms");
    };
  }), {} ],
  468: [ (function(require, module, exports) {
    "use strict";
    Number.parseFloat = Number.parseFloat || parseFloat;
    Number.parseInt = Number.parseInt || parseInt;
  }), {} ],
  469: [ (function(require, module, exports) {
    "use strict";
    Object.assign || (Object.assign = function(target, source) {
      return cc.js.mixin(target, source);
    });
    Object.getOwnPropertyDescriptors || (Object.getOwnPropertyDescriptors = function(obj) {
      var descriptors = {};
      var ownKeys = Object.getOwnPropertyNames(obj);
      Object.getOwnPropertySymbols && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(obj)));
      for (var i = 0; i < ownKeys.length; ++i) {
        var key = ownKeys[i];
        descriptors[key] = Object.getOwnPropertyDescriptor(obj, key);
      }
      return descriptors;
    });
  }), {} ],
  470: [ (function(require, module, exports) {
    "use strict";
    String.prototype.startsWith || (String.prototype.startsWith = function(searchString, position) {
      position = position || 0;
      return this.lastIndexOf(searchString, position) === position;
    });
    String.prototype.endsWith || (String.prototype.endsWith = function(searchString, position) {
      ("undefined" === typeof position || position > this.length) && (position = this.length);
      position -= searchString.length;
      var lastIndex = this.indexOf(searchString, position);
      return -1 !== lastIndex && lastIndex === position;
    });
    String.prototype.trimLeft || (String.prototype.trimLeft = function() {
      return this.replace(/^\s+/, "");
    });
  }), {} ],
  471: [ (function(require, module, exports) {
    "use strict";
    var extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
    };
    window.__extends = function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    window.__assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
      }
      return t;
    };
    window.__rest = function(s, e) {
      var t = {};
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
      if (null != s && "function" === typeof Object.getOwnPropertySymbols) for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
      return t;
    };
    window.__decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    window.__param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    window.__metadata = function(metadataKey, metadataValue) {
      if ("object" === typeof Reflect && "function" === typeof Reflect.metadata) return Reflect.metadata(metadataKey, metadataValue);
    };
    window.__awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    window.__generator = function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function sent() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    window.__exportStar = function(m, o) {
      for (var p in m) "default" === p || Object.prototype.hasOwnProperty.call(o, p) || __createBinding(o, m, p);
    };
    window.__createBinding = Object.create ? function(o, m, k, k2) {
      void 0 === k2 && (k2 = k);
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function(o, m, k, k2) {
      void 0 === k2 && (k2 = k);
      o[k2] = m[k];
    };
    window.__values = function(o) {
      var s = "function" === typeof Symbol && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && "number" === typeof o.length) return {
        next: function next() {
          o && i >= o.length && (o = void 0);
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    window.__read = function(o, n) {
      var m = "function" === typeof Symbol && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((void 0 === n || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          r && !r.done && (m = i["return"]) && m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    window.__spread = function() {
      for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    window.__spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
      k++) r[k] = a[j];
      return r;
    };
    window.__await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    window.__asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        g[n] && (i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([ n, v, a, b ]) > 1 || resume(n, v);
          });
        });
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        (f(v), q.shift(), q.length) && resume(q[0][0], q[0][1]);
      }
    };
    window.__asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", (function(e) {
        throw e;
      })), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? {
            value: __await(o[n](v)),
            done: "return" === n
          } : f ? f(v) : v;
        } : f;
      }
    };
    window.__asyncValues = function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = "function" === typeof __values ? __values(o) : o[Symbol.iterator](), 
      i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then((function(v) {
          resolve({
            value: v,
            done: d
          });
        }), reject);
      }
    };
    window.__makeTemplateObject = function(cooked, raw) {
      Object.defineProperty ? Object.defineProperty(cooked, "raw", {
        value: raw
      }) : cooked.raw = raw;
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
      });
    } : function(o, v) {
      o["default"] = v;
    };
    window.__importStar = function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (null != mod) for (var k in mod) "default" !== k && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
    };
    window.__importDefault = function(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    };
    window.__classPrivateFieldGet = function(receiver, privateMap) {
      if (!privateMap.has(receiver)) throw new TypeError("attempted to get private field on non-instance");
      return privateMap.get(receiver);
    };
    window.__classPrivateFieldSet = function(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) throw new TypeError("attempted to set private field on non-instance");
      privateMap.set(receiver, value);
      return value;
    };
  }), {} ],
  472: [ (function(require, module, exports) {
    "use strict";
    var _global = "undefined" === typeof window ? global : window;
    function defineMacro(name, defaultValue) {
      "undefined" === typeof _global[name] && (_global[name] = defaultValue);
    }
    function defineDeprecatedMacroGetter(name, defaultValue) {
      "undefined" === typeof _global[name] && Object.defineProperty(_global, name, {
        get: function get() {
          var recommandedUsage;
          "CC_WECHATGAMESUB" === name ? recommandedUsage = "cc.sys.platform === cc.sys.WECHAT_GAME_SUB" : "CC_WECHATGAME" === name ? recommandedUsage = "cc.sys.platform === cc.sys.WECHAT_GAME" : "CC_QQPLAY" === name && (recommandedUsage = "cc.sys.platform === cc.sys.QQ_PLAY");
          cc.warnID(1400, name, recommandedUsage);
          return defaultValue;
        }
      });
    }
    function defined(name) {
      return "object" === typeof _global[name];
    }
    defineMacro("CC_BUILD", false);
    false;
    defineMacro("CC_DEV", true);
    defineMacro("CC_DEBUG", true);
    defineMacro("CC_JSB", defined("jsb"));
    defineMacro("CC_NATIVERENDERER", defined("jsb"));
    defineMacro("CC_SUPPORT_JIT", true);
    defineMacro("CC_PHYSICS_BUILTIN", false);
    defineMacro("CC_PHYSICS_CANNON", true);
    defineMacro("CC_EDITOR", defined("Editor") && defined("process") && "electron" in process.versions);
    defineMacro("CC_PREVIEW", true);
    defineMacro("CC_TEST", defined("tap") || defined("QUnit"));
    defineMacro("CC_RUNTIME", "function" === typeof loadRuntime);
    defineMacro("CC_JSB", defined("jsb") && true);
    var WECHATGAMESUB = !!(defined("wx") && wx.getSharedCanvas);
    var WECHATGAME = !!(defined("wx") && (wx.getSystemInfoSync || wx.getSharedCanvas));
    var QQPLAY = defined("bk");
    defineDeprecatedMacroGetter("CC_WECHATGAMESUB", WECHATGAMESUB);
    defineDeprecatedMacroGetter("CC_WECHATGAME", WECHATGAME);
    defineDeprecatedMacroGetter("CC_QQPLAY", QQPLAY);
    true;
    cc._Test = {};
    var engineVersion = "2.4.9";
    _global["CocosEngine"] = cc.ENGINE_VERSION = engineVersion;
  }), {} ]
}, {}, [ 464 ]);